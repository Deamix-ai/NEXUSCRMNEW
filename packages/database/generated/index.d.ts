
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model Lead
 * 
 */
export type Lead = $Result.DefaultSelection<Prisma.$LeadPayload>
/**
 * Model Deal
 * 
 */
export type Deal = $Result.DefaultSelection<Prisma.$DealPayload>
/**
 * Model PipelineStage
 * 
 */
export type PipelineStage = $Result.DefaultSelection<Prisma.$PipelineStagePayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model Room
 * 
 */
export type Room = $Result.DefaultSelection<Prisma.$RoomPayload>
/**
 * Model Job
 * 
 */
export type Job = $Result.DefaultSelection<Prisma.$JobPayload>
/**
 * Model JobDayLog
 * 
 */
export type JobDayLog = $Result.DefaultSelection<Prisma.$JobDayLogPayload>
/**
 * Model InstallerCompany
 * 
 */
export type InstallerCompany = $Result.DefaultSelection<Prisma.$InstallerCompanyPayload>
/**
 * Model InstallerTeamMember
 * 
 */
export type InstallerTeamMember = $Result.DefaultSelection<Prisma.$InstallerTeamMemberPayload>
/**
 * Model DesignVersion
 * 
 */
export type DesignVersion = $Result.DefaultSelection<Prisma.$DesignVersionPayload>
/**
 * Model DesignClashTicket
 * 
 */
export type DesignClashTicket = $Result.DefaultSelection<Prisma.$DesignClashTicketPayload>
/**
 * Model Moodboard
 * 
 */
export type Moodboard = $Result.DefaultSelection<Prisma.$MoodboardPayload>
/**
 * Model MoodboardItem
 * 
 */
export type MoodboardItem = $Result.DefaultSelection<Prisma.$MoodboardItemPayload>
/**
 * Model MoodboardComment
 * 
 */
export type MoodboardComment = $Result.DefaultSelection<Prisma.$MoodboardCommentPayload>
/**
 * Model ParsedSpecItem
 * 
 */
export type ParsedSpecItem = $Result.DefaultSelection<Prisma.$ParsedSpecItemPayload>
/**
 * Model Snag
 * 
 */
export type Snag = $Result.DefaultSelection<Prisma.$SnagPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model FormTemplate
 * 
 */
export type FormTemplate = $Result.DefaultSelection<Prisma.$FormTemplatePayload>
/**
 * Model FormSubmission
 * 
 */
export type FormSubmission = $Result.DefaultSelection<Prisma.$FormSubmissionPayload>
/**
 * Model HandoverPack
 * 
 */
export type HandoverPack = $Result.DefaultSelection<Prisma.$HandoverPackPayload>
/**
 * Model Guide
 * 
 */
export type Guide = $Result.DefaultSelection<Prisma.$GuidePayload>
/**
 * Model EmailJourney
 * 
 */
export type EmailJourney = $Result.DefaultSelection<Prisma.$EmailJourneyPayload>
/**
 * Model EmailSequenceStep
 * 
 */
export type EmailSequenceStep = $Result.DefaultSelection<Prisma.$EmailSequenceStepPayload>
/**
 * Model Webhook
 * 
 */
export type Webhook = $Result.DefaultSelection<Prisma.$WebhookPayload>
/**
 * Model WebhookDelivery
 * 
 */
export type WebhookDelivery = $Result.DefaultSelection<Prisma.$WebhookDeliveryPayload>
/**
 * Model EventLog
 * 
 */
export type EventLog = $Result.DefaultSelection<Prisma.$EventLogPayload>
/**
 * Model Integration
 * 
 */
export type Integration = $Result.DefaultSelection<Prisma.$IntegrationPayload>
/**
 * Model MergeQueue
 * 
 */
export type MergeQueue = $Result.DefaultSelection<Prisma.$MergeQueuePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  SALES: 'SALES',
  DESIGNER: 'DESIGNER',
  FIELD: 'FIELD',
  INSTALLER_COMPANY_OWNER: 'INSTALLER_COMPANY_OWNER',
  READ_ONLY: 'READ_ONLY'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ClientType: {
  RESIDENTIAL: 'RESIDENTIAL',
  COMMERCIAL: 'COMMERCIAL',
  TRADE: 'TRADE'
};

export type ClientType = (typeof ClientType)[keyof typeof ClientType]


export const LeadStatus: {
  NEW: 'NEW',
  CONTACTED: 'CONTACTED',
  QUALIFIED: 'QUALIFIED',
  PROPOSAL_SENT: 'PROPOSAL_SENT',
  NEGOTIATING: 'NEGOTIATING',
  WON: 'WON',
  LOST: 'LOST',
  NURTURING: 'NURTURING'
};

export type LeadStatus = (typeof LeadStatus)[keyof typeof LeadStatus]


export const Priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const ActivityType: {
  CALL: 'CALL',
  EMAIL: 'EMAIL',
  SMS: 'SMS',
  MEETING: 'MEETING',
  NOTE: 'NOTE',
  TASK: 'TASK',
  DOCUMENT_UPLOAD: 'DOCUMENT_UPLOAD',
  PORTAL_ACCESS: 'PORTAL_ACCESS',
  SURVEY_SUBMITTED: 'SURVEY_SUBMITTED',
  DESIGN_VIEWED: 'DESIGN_VIEWED',
  PAYMENT_RECEIVED: 'PAYMENT_RECEIVED'
};

export type ActivityType = (typeof ActivityType)[keyof typeof ActivityType]


export const Direction: {
  INBOUND: 'INBOUND',
  OUTBOUND: 'OUTBOUND'
};

export type Direction = (typeof Direction)[keyof typeof Direction]


export const TaskStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const AppointmentStatus: {
  SCHEDULED: 'SCHEDULED',
  CONFIRMED: 'CONFIRMED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  NO_SHOW: 'NO_SHOW'
};

export type AppointmentStatus = (typeof AppointmentStatus)[keyof typeof AppointmentStatus]


export const RoomType: {
  BATHROOM: 'BATHROOM',
  EN_SUITE: 'EN_SUITE',
  WC: 'WC',
  WETROOM: 'WETROOM',
  SHOWER_ROOM: 'SHOWER_ROOM',
  UTILITY: 'UTILITY'
};

export type RoomType = (typeof RoomType)[keyof typeof RoomType]


export const JobStatus: {
  QUOTED: 'QUOTED',
  SURVEY_BOOKED: 'SURVEY_BOOKED',
  SURVEYED: 'SURVEYED',
  DESIGNING: 'DESIGNING',
  DESIGN_APPROVED: 'DESIGN_APPROVED',
  MATERIALS_ORDERED: 'MATERIALS_ORDERED',
  SCHEDULED: 'SCHEDULED',
  IN_PROGRESS: 'IN_PROGRESS',
  SNAGGING: 'SNAGGING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type JobStatus = (typeof JobStatus)[keyof typeof JobStatus]


export const SyncStatus: {
  QUEUED: 'QUEUED',
  UPLOADING: 'UPLOADING',
  RETRYING: 'RETRYING',
  SYNCED: 'SYNCED',
  ERROR: 'ERROR'
};

export type SyncStatus = (typeof SyncStatus)[keyof typeof SyncStatus]


export const DesignStatus: {
  DRAFT: 'DRAFT',
  REVIEW: 'REVIEW',
  CLIENT_REVIEW: 'CLIENT_REVIEW',
  APPROVED: 'APPROVED',
  FINAL: 'FINAL',
  ARCHIVED: 'ARCHIVED'
};

export type DesignStatus = (typeof DesignStatus)[keyof typeof DesignStatus]


export const ClashStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED'
};

export type ClashStatus = (typeof ClashStatus)[keyof typeof ClashStatus]


export const MoodboardStatus: {
  ACTIVE: 'ACTIVE',
  ARCHIVED: 'ARCHIVED'
};

export type MoodboardStatus = (typeof MoodboardStatus)[keyof typeof MoodboardStatus]


export const SpecItemStatus: {
  PENDING: 'PENDING',
  ORDERED: 'ORDERED',
  DELIVERED: 'DELIVERED',
  INSTALLED: 'INSTALLED',
  SUBSTITUTED: 'SUBSTITUTED',
  CANCELLED: 'CANCELLED'
};

export type SpecItemStatus = (typeof SpecItemStatus)[keyof typeof SpecItemStatus]


export const SnagCategory: {
  PLUMBING: 'PLUMBING',
  ELECTRICAL: 'ELECTRICAL',
  TILING: 'TILING',
  DECORATION: 'DECORATION',
  FITTING: 'FITTING',
  CLEANING: 'CLEANING',
  OTHER: 'OTHER'
};

export type SnagCategory = (typeof SnagCategory)[keyof typeof SnagCategory]


export const SnagStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED',
  DEFERRED: 'DEFERRED'
};

export type SnagStatus = (typeof SnagStatus)[keyof typeof SnagStatus]


export const DocumentCategory: {
  CONTRACT: 'CONTRACT',
  INVOICE: 'INVOICE',
  QUOTE: 'QUOTE',
  DESIGN: 'DESIGN',
  PHOTO: 'PHOTO',
  SPECIFICATION: 'SPECIFICATION',
  COMPLIANCE: 'COMPLIANCE',
  HANDOVER: 'HANDOVER',
  OTHER: 'OTHER'
};

export type DocumentCategory = (typeof DocumentCategory)[keyof typeof DocumentCategory]


export const VirusScanStatus: {
  PENDING: 'PENDING',
  CLEAN: 'CLEAN',
  INFECTED: 'INFECTED',
  ERROR: 'ERROR'
};

export type VirusScanStatus = (typeof VirusScanStatus)[keyof typeof VirusScanStatus]


export const FormCategory: {
  SURVEY: 'SURVEY',
  DAILY_LOG: 'DAILY_LOG',
  START_WORK: 'START_WORK',
  END_WORK: 'END_WORK',
  DESIGN_BRIEF: 'DESIGN_BRIEF',
  CLIENT_FEEDBACK: 'CLIENT_FEEDBACK',
  COMPLIANCE_CHECK: 'COMPLIANCE_CHECK'
};

export type FormCategory = (typeof FormCategory)[keyof typeof FormCategory]


export const SubmissionSource: {
  WEB: 'WEB',
  MOBILE: 'MOBILE',
  API: 'API'
};

export type SubmissionSource = (typeof SubmissionSource)[keyof typeof SubmissionSource]


export const GuideCategory: {
  CARE_MAINTENANCE: 'CARE_MAINTENANCE',
  TROUBLESHOOTING: 'TROUBLESHOOTING',
  WARRANTY: 'WARRANTY',
  SAFETY: 'SAFETY',
  INSTALLATION: 'INSTALLATION',
  DESIGN_TIPS: 'DESIGN_TIPS'
};

export type GuideCategory = (typeof GuideCategory)[keyof typeof GuideCategory]


export const EmailTrigger: {
  STAGE_CHANGE: 'STAGE_CHANGE',
  TASK_OVERDUE: 'TASK_OVERDUE',
  APPOINTMENT_REMINDER: 'APPOINTMENT_REMINDER',
  SURVEY_COMPLETED: 'SURVEY_COMPLETED',
  DESIGN_READY: 'DESIGN_READY',
  JOB_COMPLETED: 'JOB_COMPLETED',
  PAYMENT_DUE: 'PAYMENT_DUE'
};

export type EmailTrigger = (typeof EmailTrigger)[keyof typeof EmailTrigger]


export const WebhookEvent: {
  LEAD_CREATED: 'LEAD_CREATED',
  DEAL_STAGE_CHANGED: 'DEAL_STAGE_CHANGED',
  JOB_STATUS_CHANGED: 'JOB_STATUS_CHANGED',
  TASK_COMPLETED: 'TASK_COMPLETED',
  APPOINTMENT_SCHEDULED: 'APPOINTMENT_SCHEDULED',
  DOCUMENT_UPLOADED: 'DOCUMENT_UPLOADED',
  FORM_SUBMITTED: 'FORM_SUBMITTED',
  DESIGN_APPROVED: 'DESIGN_APPROVED',
  PAYMENT_RECEIVED: 'PAYMENT_RECEIVED'
};

export type WebhookEvent = (typeof WebhookEvent)[keyof typeof WebhookEvent]


export const IntegrationType: {
  TWILIO: 'TWILIO',
  DOCUSIGN: 'DOCUSIGN',
  XERO: 'XERO',
  OUTLOOK: 'OUTLOOK',
  GOOGLE_CALENDAR: 'GOOGLE_CALENDAR',
  MAILCHIMP: 'MAILCHIMP',
  ZAPIER: 'ZAPIER'
};

export type IntegrationType = (typeof IntegrationType)[keyof typeof IntegrationType]


export const MergeStatus: {
  PENDING: 'PENDING',
  REVIEWED: 'REVIEWED',
  MERGED: 'MERGED',
  REJECTED: 'REJECTED'
};

export type MergeStatus = (typeof MergeStatus)[keyof typeof MergeStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ClientType = $Enums.ClientType

export const ClientType: typeof $Enums.ClientType

export type LeadStatus = $Enums.LeadStatus

export const LeadStatus: typeof $Enums.LeadStatus

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type ActivityType = $Enums.ActivityType

export const ActivityType: typeof $Enums.ActivityType

export type Direction = $Enums.Direction

export const Direction: typeof $Enums.Direction

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type AppointmentStatus = $Enums.AppointmentStatus

export const AppointmentStatus: typeof $Enums.AppointmentStatus

export type RoomType = $Enums.RoomType

export const RoomType: typeof $Enums.RoomType

export type JobStatus = $Enums.JobStatus

export const JobStatus: typeof $Enums.JobStatus

export type SyncStatus = $Enums.SyncStatus

export const SyncStatus: typeof $Enums.SyncStatus

export type DesignStatus = $Enums.DesignStatus

export const DesignStatus: typeof $Enums.DesignStatus

export type ClashStatus = $Enums.ClashStatus

export const ClashStatus: typeof $Enums.ClashStatus

export type MoodboardStatus = $Enums.MoodboardStatus

export const MoodboardStatus: typeof $Enums.MoodboardStatus

export type SpecItemStatus = $Enums.SpecItemStatus

export const SpecItemStatus: typeof $Enums.SpecItemStatus

export type SnagCategory = $Enums.SnagCategory

export const SnagCategory: typeof $Enums.SnagCategory

export type SnagStatus = $Enums.SnagStatus

export const SnagStatus: typeof $Enums.SnagStatus

export type DocumentCategory = $Enums.DocumentCategory

export const DocumentCategory: typeof $Enums.DocumentCategory

export type VirusScanStatus = $Enums.VirusScanStatus

export const VirusScanStatus: typeof $Enums.VirusScanStatus

export type FormCategory = $Enums.FormCategory

export const FormCategory: typeof $Enums.FormCategory

export type SubmissionSource = $Enums.SubmissionSource

export const SubmissionSource: typeof $Enums.SubmissionSource

export type GuideCategory = $Enums.GuideCategory

export const GuideCategory: typeof $Enums.GuideCategory

export type EmailTrigger = $Enums.EmailTrigger

export const EmailTrigger: typeof $Enums.EmailTrigger

export type WebhookEvent = $Enums.WebhookEvent

export const WebhookEvent: typeof $Enums.WebhookEvent

export type IntegrationType = $Enums.IntegrationType

export const IntegrationType: typeof $Enums.IntegrationType

export type MergeStatus = $Enums.MergeStatus

export const MergeStatus: typeof $Enums.MergeStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs>;

  /**
   * `prisma.lead`: Exposes CRUD operations for the **Lead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leads
    * const leads = await prisma.lead.findMany()
    * ```
    */
  get lead(): Prisma.LeadDelegate<ExtArgs>;

  /**
   * `prisma.deal`: Exposes CRUD operations for the **Deal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deals
    * const deals = await prisma.deal.findMany()
    * ```
    */
  get deal(): Prisma.DealDelegate<ExtArgs>;

  /**
   * `prisma.pipelineStage`: Exposes CRUD operations for the **PipelineStage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PipelineStages
    * const pipelineStages = await prisma.pipelineStage.findMany()
    * ```
    */
  get pipelineStage(): Prisma.PipelineStageDelegate<ExtArgs>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **Room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.RoomDelegate<ExtArgs>;

  /**
   * `prisma.job`: Exposes CRUD operations for the **Job** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.job.findMany()
    * ```
    */
  get job(): Prisma.JobDelegate<ExtArgs>;

  /**
   * `prisma.jobDayLog`: Exposes CRUD operations for the **JobDayLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobDayLogs
    * const jobDayLogs = await prisma.jobDayLog.findMany()
    * ```
    */
  get jobDayLog(): Prisma.JobDayLogDelegate<ExtArgs>;

  /**
   * `prisma.installerCompany`: Exposes CRUD operations for the **InstallerCompany** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstallerCompanies
    * const installerCompanies = await prisma.installerCompany.findMany()
    * ```
    */
  get installerCompany(): Prisma.InstallerCompanyDelegate<ExtArgs>;

  /**
   * `prisma.installerTeamMember`: Exposes CRUD operations for the **InstallerTeamMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstallerTeamMembers
    * const installerTeamMembers = await prisma.installerTeamMember.findMany()
    * ```
    */
  get installerTeamMember(): Prisma.InstallerTeamMemberDelegate<ExtArgs>;

  /**
   * `prisma.designVersion`: Exposes CRUD operations for the **DesignVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DesignVersions
    * const designVersions = await prisma.designVersion.findMany()
    * ```
    */
  get designVersion(): Prisma.DesignVersionDelegate<ExtArgs>;

  /**
   * `prisma.designClashTicket`: Exposes CRUD operations for the **DesignClashTicket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DesignClashTickets
    * const designClashTickets = await prisma.designClashTicket.findMany()
    * ```
    */
  get designClashTicket(): Prisma.DesignClashTicketDelegate<ExtArgs>;

  /**
   * `prisma.moodboard`: Exposes CRUD operations for the **Moodboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Moodboards
    * const moodboards = await prisma.moodboard.findMany()
    * ```
    */
  get moodboard(): Prisma.MoodboardDelegate<ExtArgs>;

  /**
   * `prisma.moodboardItem`: Exposes CRUD operations for the **MoodboardItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MoodboardItems
    * const moodboardItems = await prisma.moodboardItem.findMany()
    * ```
    */
  get moodboardItem(): Prisma.MoodboardItemDelegate<ExtArgs>;

  /**
   * `prisma.moodboardComment`: Exposes CRUD operations for the **MoodboardComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MoodboardComments
    * const moodboardComments = await prisma.moodboardComment.findMany()
    * ```
    */
  get moodboardComment(): Prisma.MoodboardCommentDelegate<ExtArgs>;

  /**
   * `prisma.parsedSpecItem`: Exposes CRUD operations for the **ParsedSpecItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParsedSpecItems
    * const parsedSpecItems = await prisma.parsedSpecItem.findMany()
    * ```
    */
  get parsedSpecItem(): Prisma.ParsedSpecItemDelegate<ExtArgs>;

  /**
   * `prisma.snag`: Exposes CRUD operations for the **Snag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Snags
    * const snags = await prisma.snag.findMany()
    * ```
    */
  get snag(): Prisma.SnagDelegate<ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs>;

  /**
   * `prisma.formTemplate`: Exposes CRUD operations for the **FormTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormTemplates
    * const formTemplates = await prisma.formTemplate.findMany()
    * ```
    */
  get formTemplate(): Prisma.FormTemplateDelegate<ExtArgs>;

  /**
   * `prisma.formSubmission`: Exposes CRUD operations for the **FormSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormSubmissions
    * const formSubmissions = await prisma.formSubmission.findMany()
    * ```
    */
  get formSubmission(): Prisma.FormSubmissionDelegate<ExtArgs>;

  /**
   * `prisma.handoverPack`: Exposes CRUD operations for the **HandoverPack** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HandoverPacks
    * const handoverPacks = await prisma.handoverPack.findMany()
    * ```
    */
  get handoverPack(): Prisma.HandoverPackDelegate<ExtArgs>;

  /**
   * `prisma.guide`: Exposes CRUD operations for the **Guide** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guides
    * const guides = await prisma.guide.findMany()
    * ```
    */
  get guide(): Prisma.GuideDelegate<ExtArgs>;

  /**
   * `prisma.emailJourney`: Exposes CRUD operations for the **EmailJourney** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailJourneys
    * const emailJourneys = await prisma.emailJourney.findMany()
    * ```
    */
  get emailJourney(): Prisma.EmailJourneyDelegate<ExtArgs>;

  /**
   * `prisma.emailSequenceStep`: Exposes CRUD operations for the **EmailSequenceStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailSequenceSteps
    * const emailSequenceSteps = await prisma.emailSequenceStep.findMany()
    * ```
    */
  get emailSequenceStep(): Prisma.EmailSequenceStepDelegate<ExtArgs>;

  /**
   * `prisma.webhook`: Exposes CRUD operations for the **Webhook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Webhooks
    * const webhooks = await prisma.webhook.findMany()
    * ```
    */
  get webhook(): Prisma.WebhookDelegate<ExtArgs>;

  /**
   * `prisma.webhookDelivery`: Exposes CRUD operations for the **WebhookDelivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookDeliveries
    * const webhookDeliveries = await prisma.webhookDelivery.findMany()
    * ```
    */
  get webhookDelivery(): Prisma.WebhookDeliveryDelegate<ExtArgs>;

  /**
   * `prisma.eventLog`: Exposes CRUD operations for the **EventLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventLogs
    * const eventLogs = await prisma.eventLog.findMany()
    * ```
    */
  get eventLog(): Prisma.EventLogDelegate<ExtArgs>;

  /**
   * `prisma.integration`: Exposes CRUD operations for the **Integration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Integrations
    * const integrations = await prisma.integration.findMany()
    * ```
    */
  get integration(): Prisma.IntegrationDelegate<ExtArgs>;

  /**
   * `prisma.mergeQueue`: Exposes CRUD operations for the **MergeQueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MergeQueues
    * const mergeQueues = await prisma.mergeQueue.findMany()
    * ```
    */
  get mergeQueue(): Prisma.MergeQueueDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Client: 'Client',
    Contact: 'Contact',
    Lead: 'Lead',
    Deal: 'Deal',
    PipelineStage: 'PipelineStage',
    Activity: 'Activity',
    Task: 'Task',
    Appointment: 'Appointment',
    Room: 'Room',
    Job: 'Job',
    JobDayLog: 'JobDayLog',
    InstallerCompany: 'InstallerCompany',
    InstallerTeamMember: 'InstallerTeamMember',
    DesignVersion: 'DesignVersion',
    DesignClashTicket: 'DesignClashTicket',
    Moodboard: 'Moodboard',
    MoodboardItem: 'MoodboardItem',
    MoodboardComment: 'MoodboardComment',
    ParsedSpecItem: 'ParsedSpecItem',
    Snag: 'Snag',
    Document: 'Document',
    FormTemplate: 'FormTemplate',
    FormSubmission: 'FormSubmission',
    HandoverPack: 'HandoverPack',
    Guide: 'Guide',
    EmailJourney: 'EmailJourney',
    EmailSequenceStep: 'EmailSequenceStep',
    Webhook: 'Webhook',
    WebhookDelivery: 'WebhookDelivery',
    EventLog: 'EventLog',
    Integration: 'Integration',
    MergeQueue: 'MergeQueue'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "client" | "contact" | "lead" | "deal" | "pipelineStage" | "activity" | "task" | "appointment" | "room" | "job" | "jobDayLog" | "installerCompany" | "installerTeamMember" | "designVersion" | "designClashTicket" | "moodboard" | "moodboardItem" | "moodboardComment" | "parsedSpecItem" | "snag" | "document" | "formTemplate" | "formSubmission" | "handoverPack" | "guide" | "emailJourney" | "emailSequenceStep" | "webhook" | "webhookDelivery" | "eventLog" | "integration" | "mergeQueue"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      Lead: {
        payload: Prisma.$LeadPayload<ExtArgs>
        fields: Prisma.LeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findFirst: {
            args: Prisma.LeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findMany: {
            args: Prisma.LeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          create: {
            args: Prisma.LeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          createMany: {
            args: Prisma.LeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          delete: {
            args: Prisma.LeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          update: {
            args: Prisma.LeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          deleteMany: {
            args: Prisma.LeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          aggregate: {
            args: Prisma.LeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLead>
          }
          groupBy: {
            args: Prisma.LeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadCountArgs<ExtArgs>
            result: $Utils.Optional<LeadCountAggregateOutputType> | number
          }
        }
      }
      Deal: {
        payload: Prisma.$DealPayload<ExtArgs>
        fields: Prisma.DealFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DealFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DealFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          findFirst: {
            args: Prisma.DealFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DealFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          findMany: {
            args: Prisma.DealFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>[]
          }
          create: {
            args: Prisma.DealCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          createMany: {
            args: Prisma.DealCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DealCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>[]
          }
          delete: {
            args: Prisma.DealDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          update: {
            args: Prisma.DealUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          deleteMany: {
            args: Prisma.DealDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DealUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DealUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          aggregate: {
            args: Prisma.DealAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeal>
          }
          groupBy: {
            args: Prisma.DealGroupByArgs<ExtArgs>
            result: $Utils.Optional<DealGroupByOutputType>[]
          }
          count: {
            args: Prisma.DealCountArgs<ExtArgs>
            result: $Utils.Optional<DealCountAggregateOutputType> | number
          }
        }
      }
      PipelineStage: {
        payload: Prisma.$PipelineStagePayload<ExtArgs>
        fields: Prisma.PipelineStageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PipelineStageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineStagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PipelineStageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineStagePayload>
          }
          findFirst: {
            args: Prisma.PipelineStageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineStagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PipelineStageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineStagePayload>
          }
          findMany: {
            args: Prisma.PipelineStageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineStagePayload>[]
          }
          create: {
            args: Prisma.PipelineStageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineStagePayload>
          }
          createMany: {
            args: Prisma.PipelineStageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PipelineStageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineStagePayload>[]
          }
          delete: {
            args: Prisma.PipelineStageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineStagePayload>
          }
          update: {
            args: Prisma.PipelineStageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineStagePayload>
          }
          deleteMany: {
            args: Prisma.PipelineStageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PipelineStageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PipelineStageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineStagePayload>
          }
          aggregate: {
            args: Prisma.PipelineStageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePipelineStage>
          }
          groupBy: {
            args: Prisma.PipelineStageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PipelineStageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PipelineStageCountArgs<ExtArgs>
            result: $Utils.Optional<PipelineStageCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      Room: {
        payload: Prisma.$RoomPayload<ExtArgs>
        fields: Prisma.RoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findFirst: {
            args: Prisma.RoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findMany: {
            args: Prisma.RoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          create: {
            args: Prisma.RoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          createMany: {
            args: Prisma.RoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          delete: {
            args: Prisma.RoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          update: {
            args: Prisma.RoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          deleteMany: {
            args: Prisma.RoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          aggregate: {
            args: Prisma.RoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoom>
          }
          groupBy: {
            args: Prisma.RoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomCountArgs<ExtArgs>
            result: $Utils.Optional<RoomCountAggregateOutputType> | number
          }
        }
      }
      Job: {
        payload: Prisma.$JobPayload<ExtArgs>
        fields: Prisma.JobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          findFirst: {
            args: Prisma.JobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          findMany: {
            args: Prisma.JobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          create: {
            args: Prisma.JobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          createMany: {
            args: Prisma.JobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          delete: {
            args: Prisma.JobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          update: {
            args: Prisma.JobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          deleteMany: {
            args: Prisma.JobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          aggregate: {
            args: Prisma.JobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob>
          }
          groupBy: {
            args: Prisma.JobGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobCountArgs<ExtArgs>
            result: $Utils.Optional<JobCountAggregateOutputType> | number
          }
        }
      }
      JobDayLog: {
        payload: Prisma.$JobDayLogPayload<ExtArgs>
        fields: Prisma.JobDayLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobDayLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobDayLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobDayLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobDayLogPayload>
          }
          findFirst: {
            args: Prisma.JobDayLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobDayLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobDayLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobDayLogPayload>
          }
          findMany: {
            args: Prisma.JobDayLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobDayLogPayload>[]
          }
          create: {
            args: Prisma.JobDayLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobDayLogPayload>
          }
          createMany: {
            args: Prisma.JobDayLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobDayLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobDayLogPayload>[]
          }
          delete: {
            args: Prisma.JobDayLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobDayLogPayload>
          }
          update: {
            args: Prisma.JobDayLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobDayLogPayload>
          }
          deleteMany: {
            args: Prisma.JobDayLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobDayLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JobDayLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobDayLogPayload>
          }
          aggregate: {
            args: Prisma.JobDayLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobDayLog>
          }
          groupBy: {
            args: Prisma.JobDayLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobDayLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobDayLogCountArgs<ExtArgs>
            result: $Utils.Optional<JobDayLogCountAggregateOutputType> | number
          }
        }
      }
      InstallerCompany: {
        payload: Prisma.$InstallerCompanyPayload<ExtArgs>
        fields: Prisma.InstallerCompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstallerCompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallerCompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstallerCompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallerCompanyPayload>
          }
          findFirst: {
            args: Prisma.InstallerCompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallerCompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstallerCompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallerCompanyPayload>
          }
          findMany: {
            args: Prisma.InstallerCompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallerCompanyPayload>[]
          }
          create: {
            args: Prisma.InstallerCompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallerCompanyPayload>
          }
          createMany: {
            args: Prisma.InstallerCompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstallerCompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallerCompanyPayload>[]
          }
          delete: {
            args: Prisma.InstallerCompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallerCompanyPayload>
          }
          update: {
            args: Prisma.InstallerCompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallerCompanyPayload>
          }
          deleteMany: {
            args: Prisma.InstallerCompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstallerCompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InstallerCompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallerCompanyPayload>
          }
          aggregate: {
            args: Prisma.InstallerCompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstallerCompany>
          }
          groupBy: {
            args: Prisma.InstallerCompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstallerCompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstallerCompanyCountArgs<ExtArgs>
            result: $Utils.Optional<InstallerCompanyCountAggregateOutputType> | number
          }
        }
      }
      InstallerTeamMember: {
        payload: Prisma.$InstallerTeamMemberPayload<ExtArgs>
        fields: Prisma.InstallerTeamMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstallerTeamMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallerTeamMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstallerTeamMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallerTeamMemberPayload>
          }
          findFirst: {
            args: Prisma.InstallerTeamMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallerTeamMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstallerTeamMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallerTeamMemberPayload>
          }
          findMany: {
            args: Prisma.InstallerTeamMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallerTeamMemberPayload>[]
          }
          create: {
            args: Prisma.InstallerTeamMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallerTeamMemberPayload>
          }
          createMany: {
            args: Prisma.InstallerTeamMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstallerTeamMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallerTeamMemberPayload>[]
          }
          delete: {
            args: Prisma.InstallerTeamMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallerTeamMemberPayload>
          }
          update: {
            args: Prisma.InstallerTeamMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallerTeamMemberPayload>
          }
          deleteMany: {
            args: Prisma.InstallerTeamMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstallerTeamMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InstallerTeamMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallerTeamMemberPayload>
          }
          aggregate: {
            args: Prisma.InstallerTeamMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstallerTeamMember>
          }
          groupBy: {
            args: Prisma.InstallerTeamMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstallerTeamMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstallerTeamMemberCountArgs<ExtArgs>
            result: $Utils.Optional<InstallerTeamMemberCountAggregateOutputType> | number
          }
        }
      }
      DesignVersion: {
        payload: Prisma.$DesignVersionPayload<ExtArgs>
        fields: Prisma.DesignVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DesignVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DesignVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignVersionPayload>
          }
          findFirst: {
            args: Prisma.DesignVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DesignVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignVersionPayload>
          }
          findMany: {
            args: Prisma.DesignVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignVersionPayload>[]
          }
          create: {
            args: Prisma.DesignVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignVersionPayload>
          }
          createMany: {
            args: Prisma.DesignVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DesignVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignVersionPayload>[]
          }
          delete: {
            args: Prisma.DesignVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignVersionPayload>
          }
          update: {
            args: Prisma.DesignVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignVersionPayload>
          }
          deleteMany: {
            args: Prisma.DesignVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DesignVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DesignVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignVersionPayload>
          }
          aggregate: {
            args: Prisma.DesignVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDesignVersion>
          }
          groupBy: {
            args: Prisma.DesignVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DesignVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DesignVersionCountArgs<ExtArgs>
            result: $Utils.Optional<DesignVersionCountAggregateOutputType> | number
          }
        }
      }
      DesignClashTicket: {
        payload: Prisma.$DesignClashTicketPayload<ExtArgs>
        fields: Prisma.DesignClashTicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DesignClashTicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignClashTicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DesignClashTicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignClashTicketPayload>
          }
          findFirst: {
            args: Prisma.DesignClashTicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignClashTicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DesignClashTicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignClashTicketPayload>
          }
          findMany: {
            args: Prisma.DesignClashTicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignClashTicketPayload>[]
          }
          create: {
            args: Prisma.DesignClashTicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignClashTicketPayload>
          }
          createMany: {
            args: Prisma.DesignClashTicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DesignClashTicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignClashTicketPayload>[]
          }
          delete: {
            args: Prisma.DesignClashTicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignClashTicketPayload>
          }
          update: {
            args: Prisma.DesignClashTicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignClashTicketPayload>
          }
          deleteMany: {
            args: Prisma.DesignClashTicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DesignClashTicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DesignClashTicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignClashTicketPayload>
          }
          aggregate: {
            args: Prisma.DesignClashTicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDesignClashTicket>
          }
          groupBy: {
            args: Prisma.DesignClashTicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<DesignClashTicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.DesignClashTicketCountArgs<ExtArgs>
            result: $Utils.Optional<DesignClashTicketCountAggregateOutputType> | number
          }
        }
      }
      Moodboard: {
        payload: Prisma.$MoodboardPayload<ExtArgs>
        fields: Prisma.MoodboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MoodboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MoodboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardPayload>
          }
          findFirst: {
            args: Prisma.MoodboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MoodboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardPayload>
          }
          findMany: {
            args: Prisma.MoodboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardPayload>[]
          }
          create: {
            args: Prisma.MoodboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardPayload>
          }
          createMany: {
            args: Prisma.MoodboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MoodboardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardPayload>[]
          }
          delete: {
            args: Prisma.MoodboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardPayload>
          }
          update: {
            args: Prisma.MoodboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardPayload>
          }
          deleteMany: {
            args: Prisma.MoodboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MoodboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MoodboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardPayload>
          }
          aggregate: {
            args: Prisma.MoodboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMoodboard>
          }
          groupBy: {
            args: Prisma.MoodboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<MoodboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.MoodboardCountArgs<ExtArgs>
            result: $Utils.Optional<MoodboardCountAggregateOutputType> | number
          }
        }
      }
      MoodboardItem: {
        payload: Prisma.$MoodboardItemPayload<ExtArgs>
        fields: Prisma.MoodboardItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MoodboardItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MoodboardItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardItemPayload>
          }
          findFirst: {
            args: Prisma.MoodboardItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MoodboardItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardItemPayload>
          }
          findMany: {
            args: Prisma.MoodboardItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardItemPayload>[]
          }
          create: {
            args: Prisma.MoodboardItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardItemPayload>
          }
          createMany: {
            args: Prisma.MoodboardItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MoodboardItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardItemPayload>[]
          }
          delete: {
            args: Prisma.MoodboardItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardItemPayload>
          }
          update: {
            args: Prisma.MoodboardItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardItemPayload>
          }
          deleteMany: {
            args: Prisma.MoodboardItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MoodboardItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MoodboardItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardItemPayload>
          }
          aggregate: {
            args: Prisma.MoodboardItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMoodboardItem>
          }
          groupBy: {
            args: Prisma.MoodboardItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<MoodboardItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.MoodboardItemCountArgs<ExtArgs>
            result: $Utils.Optional<MoodboardItemCountAggregateOutputType> | number
          }
        }
      }
      MoodboardComment: {
        payload: Prisma.$MoodboardCommentPayload<ExtArgs>
        fields: Prisma.MoodboardCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MoodboardCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MoodboardCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardCommentPayload>
          }
          findFirst: {
            args: Prisma.MoodboardCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MoodboardCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardCommentPayload>
          }
          findMany: {
            args: Prisma.MoodboardCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardCommentPayload>[]
          }
          create: {
            args: Prisma.MoodboardCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardCommentPayload>
          }
          createMany: {
            args: Prisma.MoodboardCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MoodboardCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardCommentPayload>[]
          }
          delete: {
            args: Prisma.MoodboardCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardCommentPayload>
          }
          update: {
            args: Prisma.MoodboardCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardCommentPayload>
          }
          deleteMany: {
            args: Prisma.MoodboardCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MoodboardCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MoodboardCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodboardCommentPayload>
          }
          aggregate: {
            args: Prisma.MoodboardCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMoodboardComment>
          }
          groupBy: {
            args: Prisma.MoodboardCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<MoodboardCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.MoodboardCommentCountArgs<ExtArgs>
            result: $Utils.Optional<MoodboardCommentCountAggregateOutputType> | number
          }
        }
      }
      ParsedSpecItem: {
        payload: Prisma.$ParsedSpecItemPayload<ExtArgs>
        fields: Prisma.ParsedSpecItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParsedSpecItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedSpecItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParsedSpecItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedSpecItemPayload>
          }
          findFirst: {
            args: Prisma.ParsedSpecItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedSpecItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParsedSpecItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedSpecItemPayload>
          }
          findMany: {
            args: Prisma.ParsedSpecItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedSpecItemPayload>[]
          }
          create: {
            args: Prisma.ParsedSpecItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedSpecItemPayload>
          }
          createMany: {
            args: Prisma.ParsedSpecItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParsedSpecItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedSpecItemPayload>[]
          }
          delete: {
            args: Prisma.ParsedSpecItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedSpecItemPayload>
          }
          update: {
            args: Prisma.ParsedSpecItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedSpecItemPayload>
          }
          deleteMany: {
            args: Prisma.ParsedSpecItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParsedSpecItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ParsedSpecItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedSpecItemPayload>
          }
          aggregate: {
            args: Prisma.ParsedSpecItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParsedSpecItem>
          }
          groupBy: {
            args: Prisma.ParsedSpecItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParsedSpecItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParsedSpecItemCountArgs<ExtArgs>
            result: $Utils.Optional<ParsedSpecItemCountAggregateOutputType> | number
          }
        }
      }
      Snag: {
        payload: Prisma.$SnagPayload<ExtArgs>
        fields: Prisma.SnagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SnagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SnagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnagPayload>
          }
          findFirst: {
            args: Prisma.SnagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SnagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnagPayload>
          }
          findMany: {
            args: Prisma.SnagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnagPayload>[]
          }
          create: {
            args: Prisma.SnagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnagPayload>
          }
          createMany: {
            args: Prisma.SnagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SnagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnagPayload>[]
          }
          delete: {
            args: Prisma.SnagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnagPayload>
          }
          update: {
            args: Prisma.SnagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnagPayload>
          }
          deleteMany: {
            args: Prisma.SnagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SnagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SnagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnagPayload>
          }
          aggregate: {
            args: Prisma.SnagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSnag>
          }
          groupBy: {
            args: Prisma.SnagGroupByArgs<ExtArgs>
            result: $Utils.Optional<SnagGroupByOutputType>[]
          }
          count: {
            args: Prisma.SnagCountArgs<ExtArgs>
            result: $Utils.Optional<SnagCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      FormTemplate: {
        payload: Prisma.$FormTemplatePayload<ExtArgs>
        fields: Prisma.FormTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>
          }
          findFirst: {
            args: Prisma.FormTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>
          }
          findMany: {
            args: Prisma.FormTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>[]
          }
          create: {
            args: Prisma.FormTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>
          }
          createMany: {
            args: Prisma.FormTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>[]
          }
          delete: {
            args: Prisma.FormTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>
          }
          update: {
            args: Prisma.FormTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>
          }
          deleteMany: {
            args: Prisma.FormTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FormTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>
          }
          aggregate: {
            args: Prisma.FormTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormTemplate>
          }
          groupBy: {
            args: Prisma.FormTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<FormTemplateCountAggregateOutputType> | number
          }
        }
      }
      FormSubmission: {
        payload: Prisma.$FormSubmissionPayload<ExtArgs>
        fields: Prisma.FormSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormSubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormSubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          findFirst: {
            args: Prisma.FormSubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormSubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          findMany: {
            args: Prisma.FormSubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>[]
          }
          create: {
            args: Prisma.FormSubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          createMany: {
            args: Prisma.FormSubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormSubmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>[]
          }
          delete: {
            args: Prisma.FormSubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          update: {
            args: Prisma.FormSubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.FormSubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormSubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FormSubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          aggregate: {
            args: Prisma.FormSubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormSubmission>
          }
          groupBy: {
            args: Prisma.FormSubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormSubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<FormSubmissionCountAggregateOutputType> | number
          }
        }
      }
      HandoverPack: {
        payload: Prisma.$HandoverPackPayload<ExtArgs>
        fields: Prisma.HandoverPackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HandoverPackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandoverPackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HandoverPackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandoverPackPayload>
          }
          findFirst: {
            args: Prisma.HandoverPackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandoverPackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HandoverPackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandoverPackPayload>
          }
          findMany: {
            args: Prisma.HandoverPackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandoverPackPayload>[]
          }
          create: {
            args: Prisma.HandoverPackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandoverPackPayload>
          }
          createMany: {
            args: Prisma.HandoverPackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HandoverPackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandoverPackPayload>[]
          }
          delete: {
            args: Prisma.HandoverPackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandoverPackPayload>
          }
          update: {
            args: Prisma.HandoverPackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandoverPackPayload>
          }
          deleteMany: {
            args: Prisma.HandoverPackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HandoverPackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HandoverPackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandoverPackPayload>
          }
          aggregate: {
            args: Prisma.HandoverPackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHandoverPack>
          }
          groupBy: {
            args: Prisma.HandoverPackGroupByArgs<ExtArgs>
            result: $Utils.Optional<HandoverPackGroupByOutputType>[]
          }
          count: {
            args: Prisma.HandoverPackCountArgs<ExtArgs>
            result: $Utils.Optional<HandoverPackCountAggregateOutputType> | number
          }
        }
      }
      Guide: {
        payload: Prisma.$GuidePayload<ExtArgs>
        fields: Prisma.GuideFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuideFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuideFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>
          }
          findFirst: {
            args: Prisma.GuideFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuideFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>
          }
          findMany: {
            args: Prisma.GuideFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>[]
          }
          create: {
            args: Prisma.GuideCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>
          }
          createMany: {
            args: Prisma.GuideCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GuideCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>[]
          }
          delete: {
            args: Prisma.GuideDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>
          }
          update: {
            args: Prisma.GuideUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>
          }
          deleteMany: {
            args: Prisma.GuideDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuideUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GuideUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>
          }
          aggregate: {
            args: Prisma.GuideAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuide>
          }
          groupBy: {
            args: Prisma.GuideGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuideGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuideCountArgs<ExtArgs>
            result: $Utils.Optional<GuideCountAggregateOutputType> | number
          }
        }
      }
      EmailJourney: {
        payload: Prisma.$EmailJourneyPayload<ExtArgs>
        fields: Prisma.EmailJourneyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailJourneyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJourneyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailJourneyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJourneyPayload>
          }
          findFirst: {
            args: Prisma.EmailJourneyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJourneyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailJourneyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJourneyPayload>
          }
          findMany: {
            args: Prisma.EmailJourneyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJourneyPayload>[]
          }
          create: {
            args: Prisma.EmailJourneyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJourneyPayload>
          }
          createMany: {
            args: Prisma.EmailJourneyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailJourneyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJourneyPayload>[]
          }
          delete: {
            args: Prisma.EmailJourneyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJourneyPayload>
          }
          update: {
            args: Prisma.EmailJourneyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJourneyPayload>
          }
          deleteMany: {
            args: Prisma.EmailJourneyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailJourneyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailJourneyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJourneyPayload>
          }
          aggregate: {
            args: Prisma.EmailJourneyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailJourney>
          }
          groupBy: {
            args: Prisma.EmailJourneyGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailJourneyGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailJourneyCountArgs<ExtArgs>
            result: $Utils.Optional<EmailJourneyCountAggregateOutputType> | number
          }
        }
      }
      EmailSequenceStep: {
        payload: Prisma.$EmailSequenceStepPayload<ExtArgs>
        fields: Prisma.EmailSequenceStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailSequenceStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSequenceStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailSequenceStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSequenceStepPayload>
          }
          findFirst: {
            args: Prisma.EmailSequenceStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSequenceStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailSequenceStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSequenceStepPayload>
          }
          findMany: {
            args: Prisma.EmailSequenceStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSequenceStepPayload>[]
          }
          create: {
            args: Prisma.EmailSequenceStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSequenceStepPayload>
          }
          createMany: {
            args: Prisma.EmailSequenceStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailSequenceStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSequenceStepPayload>[]
          }
          delete: {
            args: Prisma.EmailSequenceStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSequenceStepPayload>
          }
          update: {
            args: Prisma.EmailSequenceStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSequenceStepPayload>
          }
          deleteMany: {
            args: Prisma.EmailSequenceStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailSequenceStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailSequenceStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSequenceStepPayload>
          }
          aggregate: {
            args: Prisma.EmailSequenceStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailSequenceStep>
          }
          groupBy: {
            args: Prisma.EmailSequenceStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailSequenceStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailSequenceStepCountArgs<ExtArgs>
            result: $Utils.Optional<EmailSequenceStepCountAggregateOutputType> | number
          }
        }
      }
      Webhook: {
        payload: Prisma.$WebhookPayload<ExtArgs>
        fields: Prisma.WebhookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findFirst: {
            args: Prisma.WebhookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findMany: {
            args: Prisma.WebhookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          create: {
            args: Prisma.WebhookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          createMany: {
            args: Prisma.WebhookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          delete: {
            args: Prisma.WebhookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          update: {
            args: Prisma.WebhookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          deleteMany: {
            args: Prisma.WebhookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebhookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          aggregate: {
            args: Prisma.WebhookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhook>
          }
          groupBy: {
            args: Prisma.WebhookGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookCountAggregateOutputType> | number
          }
        }
      }
      WebhookDelivery: {
        payload: Prisma.$WebhookDeliveryPayload<ExtArgs>
        fields: Prisma.WebhookDeliveryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookDeliveryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          findFirst: {
            args: Prisma.WebhookDeliveryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookDeliveryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          findMany: {
            args: Prisma.WebhookDeliveryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
          }
          create: {
            args: Prisma.WebhookDeliveryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          createMany: {
            args: Prisma.WebhookDeliveryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookDeliveryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
          }
          delete: {
            args: Prisma.WebhookDeliveryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          update: {
            args: Prisma.WebhookDeliveryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          deleteMany: {
            args: Prisma.WebhookDeliveryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookDeliveryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebhookDeliveryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          aggregate: {
            args: Prisma.WebhookDeliveryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookDelivery>
          }
          groupBy: {
            args: Prisma.WebhookDeliveryGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookDeliveryGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookDeliveryCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookDeliveryCountAggregateOutputType> | number
          }
        }
      }
      EventLog: {
        payload: Prisma.$EventLogPayload<ExtArgs>
        fields: Prisma.EventLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload>
          }
          findFirst: {
            args: Prisma.EventLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload>
          }
          findMany: {
            args: Prisma.EventLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload>[]
          }
          create: {
            args: Prisma.EventLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload>
          }
          createMany: {
            args: Prisma.EventLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload>[]
          }
          delete: {
            args: Prisma.EventLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload>
          }
          update: {
            args: Prisma.EventLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload>
          }
          deleteMany: {
            args: Prisma.EventLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload>
          }
          aggregate: {
            args: Prisma.EventLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventLog>
          }
          groupBy: {
            args: Prisma.EventLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventLogCountArgs<ExtArgs>
            result: $Utils.Optional<EventLogCountAggregateOutputType> | number
          }
        }
      }
      Integration: {
        payload: Prisma.$IntegrationPayload<ExtArgs>
        fields: Prisma.IntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          findFirst: {
            args: Prisma.IntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          findMany: {
            args: Prisma.IntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          create: {
            args: Prisma.IntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          createMany: {
            args: Prisma.IntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          delete: {
            args: Prisma.IntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          update: {
            args: Prisma.IntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          deleteMany: {
            args: Prisma.IntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          aggregate: {
            args: Prisma.IntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntegration>
          }
          groupBy: {
            args: Prisma.IntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<IntegrationCountAggregateOutputType> | number
          }
        }
      }
      MergeQueue: {
        payload: Prisma.$MergeQueuePayload<ExtArgs>
        fields: Prisma.MergeQueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MergeQueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MergeQueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MergeQueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MergeQueuePayload>
          }
          findFirst: {
            args: Prisma.MergeQueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MergeQueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MergeQueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MergeQueuePayload>
          }
          findMany: {
            args: Prisma.MergeQueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MergeQueuePayload>[]
          }
          create: {
            args: Prisma.MergeQueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MergeQueuePayload>
          }
          createMany: {
            args: Prisma.MergeQueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MergeQueueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MergeQueuePayload>[]
          }
          delete: {
            args: Prisma.MergeQueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MergeQueuePayload>
          }
          update: {
            args: Prisma.MergeQueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MergeQueuePayload>
          }
          deleteMany: {
            args: Prisma.MergeQueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MergeQueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MergeQueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MergeQueuePayload>
          }
          aggregate: {
            args: Prisma.MergeQueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMergeQueue>
          }
          groupBy: {
            args: Prisma.MergeQueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<MergeQueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.MergeQueueCountArgs<ExtArgs>
            result: $Utils.Optional<MergeQueueCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdUsers: number
    updatedUsers: number
    ownedClients: number
    ownedLeads: number
    ownedDeals: number
    assignedTasks: number
    createdTasks: number
    activities: number
    appointments: number
    jobDayLogs: number
    designVersions: number
    createdClients: number
    updatedClients: number
    designerJobs: number
    installerCompanies: number
    clashReports: number
    clashAssignments: number
    moodboardComments: number
    snagReports: number
    snagAssignments: number
    uploadedDocuments: number
    formSubmissions: number
    eventLogs: number
    mergeReviews: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdUsers?: boolean | UserCountOutputTypeCountCreatedUsersArgs
    updatedUsers?: boolean | UserCountOutputTypeCountUpdatedUsersArgs
    ownedClients?: boolean | UserCountOutputTypeCountOwnedClientsArgs
    ownedLeads?: boolean | UserCountOutputTypeCountOwnedLeadsArgs
    ownedDeals?: boolean | UserCountOutputTypeCountOwnedDealsArgs
    assignedTasks?: boolean | UserCountOutputTypeCountAssignedTasksArgs
    createdTasks?: boolean | UserCountOutputTypeCountCreatedTasksArgs
    activities?: boolean | UserCountOutputTypeCountActivitiesArgs
    appointments?: boolean | UserCountOutputTypeCountAppointmentsArgs
    jobDayLogs?: boolean | UserCountOutputTypeCountJobDayLogsArgs
    designVersions?: boolean | UserCountOutputTypeCountDesignVersionsArgs
    createdClients?: boolean | UserCountOutputTypeCountCreatedClientsArgs
    updatedClients?: boolean | UserCountOutputTypeCountUpdatedClientsArgs
    designerJobs?: boolean | UserCountOutputTypeCountDesignerJobsArgs
    installerCompanies?: boolean | UserCountOutputTypeCountInstallerCompaniesArgs
    clashReports?: boolean | UserCountOutputTypeCountClashReportsArgs
    clashAssignments?: boolean | UserCountOutputTypeCountClashAssignmentsArgs
    moodboardComments?: boolean | UserCountOutputTypeCountMoodboardCommentsArgs
    snagReports?: boolean | UserCountOutputTypeCountSnagReportsArgs
    snagAssignments?: boolean | UserCountOutputTypeCountSnagAssignmentsArgs
    uploadedDocuments?: boolean | UserCountOutputTypeCountUploadedDocumentsArgs
    formSubmissions?: boolean | UserCountOutputTypeCountFormSubmissionsArgs
    eventLogs?: boolean | UserCountOutputTypeCountEventLogsArgs
    mergeReviews?: boolean | UserCountOutputTypeCountMergeReviewsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedDealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountJobDayLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobDayLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDesignVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignVersionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDesignerJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInstallerCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstallerCompanyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClashReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignClashTicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClashAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignClashTicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMoodboardCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoodboardCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSnagReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SnagWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSnagAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SnagWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFormSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormSubmissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMergeReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MergeQueueWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    contacts: number
    leads: number
    deals: number
    rooms: number
    jobs: number
    activities: number
    documents: number
    appointments: number
    moodboards: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | ClientCountOutputTypeCountContactsArgs
    leads?: boolean | ClientCountOutputTypeCountLeadsArgs
    deals?: boolean | ClientCountOutputTypeCountDealsArgs
    rooms?: boolean | ClientCountOutputTypeCountRoomsArgs
    jobs?: boolean | ClientCountOutputTypeCountJobsArgs
    activities?: boolean | ClientCountOutputTypeCountActivitiesArgs
    documents?: boolean | ClientCountOutputTypeCountDocumentsArgs
    appointments?: boolean | ClientCountOutputTypeCountAppointmentsArgs
    moodboards?: boolean | ClientCountOutputTypeCountMoodboardsArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountDealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountMoodboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoodboardWhereInput
  }


  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    activities: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | ContactCountOutputTypeCountActivitiesArgs
  }

  // Custom InputTypes
  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }


  /**
   * Count Type LeadCountOutputType
   */

  export type LeadCountOutputType = {
    activities: number
    tasks: number
  }

  export type LeadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | LeadCountOutputTypeCountActivitiesArgs
    tasks?: boolean | LeadCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCountOutputType
     */
    select?: LeadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type DealCountOutputType
   */

  export type DealCountOutputType = {
    activities: number
    tasks: number
    documents: number
  }

  export type DealCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | DealCountOutputTypeCountActivitiesArgs
    tasks?: boolean | DealCountOutputTypeCountTasksArgs
    documents?: boolean | DealCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealCountOutputType
     */
    select?: DealCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * Count Type PipelineStageCountOutputType
   */

  export type PipelineStageCountOutputType = {
    deals: number
  }

  export type PipelineStageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deals?: boolean | PipelineStageCountOutputTypeCountDealsArgs
  }

  // Custom InputTypes
  /**
   * PipelineStageCountOutputType without action
   */
  export type PipelineStageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineStageCountOutputType
     */
    select?: PipelineStageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PipelineStageCountOutputType without action
   */
  export type PipelineStageCountOutputTypeCountDealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
  }


  /**
   * Count Type RoomCountOutputType
   */

  export type RoomCountOutputType = {
    jobs: number
  }

  export type RoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | RoomCountOutputTypeCountJobsArgs
  }

  // Custom InputTypes
  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomCountOutputType
     */
    select?: RoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
  }


  /**
   * Count Type JobCountOutputType
   */

  export type JobCountOutputType = {
    tasks: number
    appointments: number
    jobDayLogs: number
    designVersions: number
    snags: number
    documents: number
    parsedSpecItems: number
    moodboards: number
    handoverPacks: number
  }

  export type JobCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | JobCountOutputTypeCountTasksArgs
    appointments?: boolean | JobCountOutputTypeCountAppointmentsArgs
    jobDayLogs?: boolean | JobCountOutputTypeCountJobDayLogsArgs
    designVersions?: boolean | JobCountOutputTypeCountDesignVersionsArgs
    snags?: boolean | JobCountOutputTypeCountSnagsArgs
    documents?: boolean | JobCountOutputTypeCountDocumentsArgs
    parsedSpecItems?: boolean | JobCountOutputTypeCountParsedSpecItemsArgs
    moodboards?: boolean | JobCountOutputTypeCountMoodboardsArgs
    handoverPacks?: boolean | JobCountOutputTypeCountHandoverPacksArgs
  }

  // Custom InputTypes
  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobCountOutputType
     */
    select?: JobCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountJobDayLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobDayLogWhereInput
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountDesignVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignVersionWhereInput
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountSnagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SnagWhereInput
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountParsedSpecItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParsedSpecItemWhereInput
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountMoodboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoodboardWhereInput
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountHandoverPacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HandoverPackWhereInput
  }


  /**
   * Count Type InstallerCompanyCountOutputType
   */

  export type InstallerCompanyCountOutputType = {
    teamMembers: number
    jobs: number
  }

  export type InstallerCompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teamMembers?: boolean | InstallerCompanyCountOutputTypeCountTeamMembersArgs
    jobs?: boolean | InstallerCompanyCountOutputTypeCountJobsArgs
  }

  // Custom InputTypes
  /**
   * InstallerCompanyCountOutputType without action
   */
  export type InstallerCompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallerCompanyCountOutputType
     */
    select?: InstallerCompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstallerCompanyCountOutputType without action
   */
  export type InstallerCompanyCountOutputTypeCountTeamMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstallerTeamMemberWhereInput
  }

  /**
   * InstallerCompanyCountOutputType without action
   */
  export type InstallerCompanyCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
  }


  /**
   * Count Type DesignVersionCountOutputType
   */

  export type DesignVersionCountOutputType = {
    clashTickets: number
  }

  export type DesignVersionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clashTickets?: boolean | DesignVersionCountOutputTypeCountClashTicketsArgs
  }

  // Custom InputTypes
  /**
   * DesignVersionCountOutputType without action
   */
  export type DesignVersionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignVersionCountOutputType
     */
    select?: DesignVersionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DesignVersionCountOutputType without action
   */
  export type DesignVersionCountOutputTypeCountClashTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignClashTicketWhereInput
  }


  /**
   * Count Type MoodboardCountOutputType
   */

  export type MoodboardCountOutputType = {
    items: number
  }

  export type MoodboardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | MoodboardCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * MoodboardCountOutputType without action
   */
  export type MoodboardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardCountOutputType
     */
    select?: MoodboardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MoodboardCountOutputType without action
   */
  export type MoodboardCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoodboardItemWhereInput
  }


  /**
   * Count Type MoodboardItemCountOutputType
   */

  export type MoodboardItemCountOutputType = {
    clientComments: number
  }

  export type MoodboardItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientComments?: boolean | MoodboardItemCountOutputTypeCountClientCommentsArgs
  }

  // Custom InputTypes
  /**
   * MoodboardItemCountOutputType without action
   */
  export type MoodboardItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardItemCountOutputType
     */
    select?: MoodboardItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MoodboardItemCountOutputType without action
   */
  export type MoodboardItemCountOutputTypeCountClientCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoodboardCommentWhereInput
  }


  /**
   * Count Type FormTemplateCountOutputType
   */

  export type FormTemplateCountOutputType = {
    submissions: number
  }

  export type FormTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submissions?: boolean | FormTemplateCountOutputTypeCountSubmissionsArgs
  }

  // Custom InputTypes
  /**
   * FormTemplateCountOutputType without action
   */
  export type FormTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplateCountOutputType
     */
    select?: FormTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FormTemplateCountOutputType without action
   */
  export type FormTemplateCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormSubmissionWhereInput
  }


  /**
   * Count Type EmailJourneyCountOutputType
   */

  export type EmailJourneyCountOutputType = {
    emailSequence: number
  }

  export type EmailJourneyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailSequence?: boolean | EmailJourneyCountOutputTypeCountEmailSequenceArgs
  }

  // Custom InputTypes
  /**
   * EmailJourneyCountOutputType without action
   */
  export type EmailJourneyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJourneyCountOutputType
     */
    select?: EmailJourneyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmailJourneyCountOutputType without action
   */
  export type EmailJourneyCountOutputTypeCountEmailSequenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailSequenceStepWhereInput
  }


  /**
   * Count Type WebhookCountOutputType
   */

  export type WebhookCountOutputType = {
    deliveries: number
  }

  export type WebhookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveries?: boolean | WebhookCountOutputTypeCountDeliveriesArgs
  }

  // Custom InputTypes
  /**
   * WebhookCountOutputType without action
   */
  export type WebhookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookCountOutputType
     */
    select?: WebhookCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WebhookCountOutputType without action
   */
  export type WebhookCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookDeliveryWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    lastLoginAt: Date | null
    emailVerifiedAt: Date | null
    twoFactorSecret: string | null
    twoFactorEnabled: boolean | null
    avatarUrl: string | null
    timezone: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    lastLoginAt: Date | null
    emailVerifiedAt: Date | null
    twoFactorSecret: string | null
    twoFactorEnabled: boolean | null
    avatarUrl: string | null
    timezone: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    firstName: number
    lastName: number
    phone: number
    role: number
    isActive: number
    lastLoginAt: number
    emailVerifiedAt: number
    twoFactorSecret: number
    twoFactorEnabled: number
    avatarUrl: number
    timezone: number
    preferences: number
    createdAt: number
    updatedAt: number
    createdById: number
    updatedById: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    phone?: true
    role?: true
    isActive?: true
    lastLoginAt?: true
    emailVerifiedAt?: true
    twoFactorSecret?: true
    twoFactorEnabled?: true
    avatarUrl?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    phone?: true
    role?: true
    isActive?: true
    lastLoginAt?: true
    emailVerifiedAt?: true
    twoFactorSecret?: true
    twoFactorEnabled?: true
    avatarUrl?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    phone?: true
    role?: true
    isActive?: true
    lastLoginAt?: true
    emailVerifiedAt?: true
    twoFactorSecret?: true
    twoFactorEnabled?: true
    avatarUrl?: true
    timezone?: true
    preferences?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string | null
    firstName: string
    lastName: string
    phone: string | null
    role: $Enums.UserRole
    isActive: boolean
    lastLoginAt: Date | null
    emailVerifiedAt: Date | null
    twoFactorSecret: string | null
    twoFactorEnabled: boolean
    avatarUrl: string | null
    timezone: string
    preferences: JsonValue
    createdAt: Date
    updatedAt: Date
    createdById: string | null
    updatedById: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    role?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    emailVerifiedAt?: boolean
    twoFactorSecret?: boolean
    twoFactorEnabled?: boolean
    avatarUrl?: boolean
    timezone?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    updatedBy?: boolean | User$updatedByArgs<ExtArgs>
    createdUsers?: boolean | User$createdUsersArgs<ExtArgs>
    updatedUsers?: boolean | User$updatedUsersArgs<ExtArgs>
    ownedClients?: boolean | User$ownedClientsArgs<ExtArgs>
    ownedLeads?: boolean | User$ownedLeadsArgs<ExtArgs>
    ownedDeals?: boolean | User$ownedDealsArgs<ExtArgs>
    assignedTasks?: boolean | User$assignedTasksArgs<ExtArgs>
    createdTasks?: boolean | User$createdTasksArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    appointments?: boolean | User$appointmentsArgs<ExtArgs>
    jobDayLogs?: boolean | User$jobDayLogsArgs<ExtArgs>
    designVersions?: boolean | User$designVersionsArgs<ExtArgs>
    createdClients?: boolean | User$createdClientsArgs<ExtArgs>
    updatedClients?: boolean | User$updatedClientsArgs<ExtArgs>
    designerJobs?: boolean | User$designerJobsArgs<ExtArgs>
    installerCompanies?: boolean | User$installerCompaniesArgs<ExtArgs>
    clashReports?: boolean | User$clashReportsArgs<ExtArgs>
    clashAssignments?: boolean | User$clashAssignmentsArgs<ExtArgs>
    moodboardComments?: boolean | User$moodboardCommentsArgs<ExtArgs>
    snagReports?: boolean | User$snagReportsArgs<ExtArgs>
    snagAssignments?: boolean | User$snagAssignmentsArgs<ExtArgs>
    uploadedDocuments?: boolean | User$uploadedDocumentsArgs<ExtArgs>
    formSubmissions?: boolean | User$formSubmissionsArgs<ExtArgs>
    eventLogs?: boolean | User$eventLogsArgs<ExtArgs>
    mergeReviews?: boolean | User$mergeReviewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    role?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    emailVerifiedAt?: boolean
    twoFactorSecret?: boolean
    twoFactorEnabled?: boolean
    avatarUrl?: boolean
    timezone?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    updatedBy?: boolean | User$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    role?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    emailVerifiedAt?: boolean
    twoFactorSecret?: boolean
    twoFactorEnabled?: boolean
    avatarUrl?: boolean
    timezone?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    updatedBy?: boolean | User$updatedByArgs<ExtArgs>
    createdUsers?: boolean | User$createdUsersArgs<ExtArgs>
    updatedUsers?: boolean | User$updatedUsersArgs<ExtArgs>
    ownedClients?: boolean | User$ownedClientsArgs<ExtArgs>
    ownedLeads?: boolean | User$ownedLeadsArgs<ExtArgs>
    ownedDeals?: boolean | User$ownedDealsArgs<ExtArgs>
    assignedTasks?: boolean | User$assignedTasksArgs<ExtArgs>
    createdTasks?: boolean | User$createdTasksArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    appointments?: boolean | User$appointmentsArgs<ExtArgs>
    jobDayLogs?: boolean | User$jobDayLogsArgs<ExtArgs>
    designVersions?: boolean | User$designVersionsArgs<ExtArgs>
    createdClients?: boolean | User$createdClientsArgs<ExtArgs>
    updatedClients?: boolean | User$updatedClientsArgs<ExtArgs>
    designerJobs?: boolean | User$designerJobsArgs<ExtArgs>
    installerCompanies?: boolean | User$installerCompaniesArgs<ExtArgs>
    clashReports?: boolean | User$clashReportsArgs<ExtArgs>
    clashAssignments?: boolean | User$clashAssignmentsArgs<ExtArgs>
    moodboardComments?: boolean | User$moodboardCommentsArgs<ExtArgs>
    snagReports?: boolean | User$snagReportsArgs<ExtArgs>
    snagAssignments?: boolean | User$snagAssignmentsArgs<ExtArgs>
    uploadedDocuments?: boolean | User$uploadedDocumentsArgs<ExtArgs>
    formSubmissions?: boolean | User$formSubmissionsArgs<ExtArgs>
    eventLogs?: boolean | User$eventLogsArgs<ExtArgs>
    mergeReviews?: boolean | User$mergeReviewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    updatedBy?: boolean | User$updatedByArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
      createdUsers: Prisma.$UserPayload<ExtArgs>[]
      updatedUsers: Prisma.$UserPayload<ExtArgs>[]
      ownedClients: Prisma.$ClientPayload<ExtArgs>[]
      ownedLeads: Prisma.$LeadPayload<ExtArgs>[]
      ownedDeals: Prisma.$DealPayload<ExtArgs>[]
      assignedTasks: Prisma.$TaskPayload<ExtArgs>[]
      createdTasks: Prisma.$TaskPayload<ExtArgs>[]
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      jobDayLogs: Prisma.$JobDayLogPayload<ExtArgs>[]
      designVersions: Prisma.$DesignVersionPayload<ExtArgs>[]
      createdClients: Prisma.$ClientPayload<ExtArgs>[]
      updatedClients: Prisma.$ClientPayload<ExtArgs>[]
      designerJobs: Prisma.$JobPayload<ExtArgs>[]
      installerCompanies: Prisma.$InstallerCompanyPayload<ExtArgs>[]
      clashReports: Prisma.$DesignClashTicketPayload<ExtArgs>[]
      clashAssignments: Prisma.$DesignClashTicketPayload<ExtArgs>[]
      moodboardComments: Prisma.$MoodboardCommentPayload<ExtArgs>[]
      snagReports: Prisma.$SnagPayload<ExtArgs>[]
      snagAssignments: Prisma.$SnagPayload<ExtArgs>[]
      uploadedDocuments: Prisma.$DocumentPayload<ExtArgs>[]
      formSubmissions: Prisma.$FormSubmissionPayload<ExtArgs>[]
      eventLogs: Prisma.$EventLogPayload<ExtArgs>[]
      mergeReviews: Prisma.$MergeQueuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string | null
      firstName: string
      lastName: string
      phone: string | null
      role: $Enums.UserRole
      isActive: boolean
      lastLoginAt: Date | null
      emailVerifiedAt: Date | null
      twoFactorSecret: string | null
      twoFactorEnabled: boolean
      avatarUrl: string | null
      timezone: string
      preferences: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
      createdById: string | null
      updatedById: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends User$createdByArgs<ExtArgs> = {}>(args?: Subset<T, User$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    updatedBy<T extends User$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    createdUsers<T extends User$createdUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$createdUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    updatedUsers<T extends User$updatedUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    ownedClients<T extends User$ownedClientsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedClientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany"> | Null>
    ownedLeads<T extends User$ownedLeadsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedLeadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany"> | Null>
    ownedDeals<T extends User$ownedDealsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedDealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findMany"> | Null>
    assignedTasks<T extends User$assignedTasksArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    createdTasks<T extends User$createdTasksArgs<ExtArgs> = {}>(args?: Subset<T, User$createdTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    activities<T extends User$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany"> | Null>
    appointments<T extends User$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany"> | Null>
    jobDayLogs<T extends User$jobDayLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$jobDayLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobDayLogPayload<ExtArgs>, T, "findMany"> | Null>
    designVersions<T extends User$designVersionsArgs<ExtArgs> = {}>(args?: Subset<T, User$designVersionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignVersionPayload<ExtArgs>, T, "findMany"> | Null>
    createdClients<T extends User$createdClientsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdClientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany"> | Null>
    updatedClients<T extends User$updatedClientsArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedClientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany"> | Null>
    designerJobs<T extends User$designerJobsArgs<ExtArgs> = {}>(args?: Subset<T, User$designerJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany"> | Null>
    installerCompanies<T extends User$installerCompaniesArgs<ExtArgs> = {}>(args?: Subset<T, User$installerCompaniesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallerCompanyPayload<ExtArgs>, T, "findMany"> | Null>
    clashReports<T extends User$clashReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$clashReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignClashTicketPayload<ExtArgs>, T, "findMany"> | Null>
    clashAssignments<T extends User$clashAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$clashAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignClashTicketPayload<ExtArgs>, T, "findMany"> | Null>
    moodboardComments<T extends User$moodboardCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$moodboardCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoodboardCommentPayload<ExtArgs>, T, "findMany"> | Null>
    snagReports<T extends User$snagReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$snagReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnagPayload<ExtArgs>, T, "findMany"> | Null>
    snagAssignments<T extends User$snagAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$snagAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnagPayload<ExtArgs>, T, "findMany"> | Null>
    uploadedDocuments<T extends User$uploadedDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany"> | Null>
    formSubmissions<T extends User$formSubmissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$formSubmissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findMany"> | Null>
    eventLogs<T extends User$eventLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$eventLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "findMany"> | Null>
    mergeReviews<T extends User$mergeReviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$mergeReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MergeQueuePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly emailVerifiedAt: FieldRef<"User", 'DateTime'>
    readonly twoFactorSecret: FieldRef<"User", 'String'>
    readonly twoFactorEnabled: FieldRef<"User", 'Boolean'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly timezone: FieldRef<"User", 'String'>
    readonly preferences: FieldRef<"User", 'Json'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly createdById: FieldRef<"User", 'String'>
    readonly updatedById: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.createdBy
   */
  export type User$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.updatedBy
   */
  export type User$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.createdUsers
   */
  export type User$createdUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.updatedUsers
   */
  export type User$updatedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.ownedClients
   */
  export type User$ownedClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    cursor?: ClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * User.ownedLeads
   */
  export type User$ownedLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * User.ownedDeals
   */
  export type User$ownedDealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    cursor?: DealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * User.assignedTasks
   */
  export type User$assignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * User.createdTasks
   */
  export type User$createdTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * User.activities
   */
  export type User$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * User.appointments
   */
  export type User$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * User.jobDayLogs
   */
  export type User$jobDayLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobDayLog
     */
    select?: JobDayLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobDayLogInclude<ExtArgs> | null
    where?: JobDayLogWhereInput
    orderBy?: JobDayLogOrderByWithRelationInput | JobDayLogOrderByWithRelationInput[]
    cursor?: JobDayLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobDayLogScalarFieldEnum | JobDayLogScalarFieldEnum[]
  }

  /**
   * User.designVersions
   */
  export type User$designVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignVersion
     */
    select?: DesignVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignVersionInclude<ExtArgs> | null
    where?: DesignVersionWhereInput
    orderBy?: DesignVersionOrderByWithRelationInput | DesignVersionOrderByWithRelationInput[]
    cursor?: DesignVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DesignVersionScalarFieldEnum | DesignVersionScalarFieldEnum[]
  }

  /**
   * User.createdClients
   */
  export type User$createdClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    cursor?: ClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * User.updatedClients
   */
  export type User$updatedClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    cursor?: ClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * User.designerJobs
   */
  export type User$designerJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    cursor?: JobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * User.installerCompanies
   */
  export type User$installerCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallerCompany
     */
    select?: InstallerCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallerCompanyInclude<ExtArgs> | null
    where?: InstallerCompanyWhereInput
    orderBy?: InstallerCompanyOrderByWithRelationInput | InstallerCompanyOrderByWithRelationInput[]
    cursor?: InstallerCompanyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstallerCompanyScalarFieldEnum | InstallerCompanyScalarFieldEnum[]
  }

  /**
   * User.clashReports
   */
  export type User$clashReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignClashTicket
     */
    select?: DesignClashTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignClashTicketInclude<ExtArgs> | null
    where?: DesignClashTicketWhereInput
    orderBy?: DesignClashTicketOrderByWithRelationInput | DesignClashTicketOrderByWithRelationInput[]
    cursor?: DesignClashTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DesignClashTicketScalarFieldEnum | DesignClashTicketScalarFieldEnum[]
  }

  /**
   * User.clashAssignments
   */
  export type User$clashAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignClashTicket
     */
    select?: DesignClashTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignClashTicketInclude<ExtArgs> | null
    where?: DesignClashTicketWhereInput
    orderBy?: DesignClashTicketOrderByWithRelationInput | DesignClashTicketOrderByWithRelationInput[]
    cursor?: DesignClashTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DesignClashTicketScalarFieldEnum | DesignClashTicketScalarFieldEnum[]
  }

  /**
   * User.moodboardComments
   */
  export type User$moodboardCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardComment
     */
    select?: MoodboardCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardCommentInclude<ExtArgs> | null
    where?: MoodboardCommentWhereInput
    orderBy?: MoodboardCommentOrderByWithRelationInput | MoodboardCommentOrderByWithRelationInput[]
    cursor?: MoodboardCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MoodboardCommentScalarFieldEnum | MoodboardCommentScalarFieldEnum[]
  }

  /**
   * User.snagReports
   */
  export type User$snagReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagInclude<ExtArgs> | null
    where?: SnagWhereInput
    orderBy?: SnagOrderByWithRelationInput | SnagOrderByWithRelationInput[]
    cursor?: SnagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SnagScalarFieldEnum | SnagScalarFieldEnum[]
  }

  /**
   * User.snagAssignments
   */
  export type User$snagAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagInclude<ExtArgs> | null
    where?: SnagWhereInput
    orderBy?: SnagOrderByWithRelationInput | SnagOrderByWithRelationInput[]
    cursor?: SnagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SnagScalarFieldEnum | SnagScalarFieldEnum[]
  }

  /**
   * User.uploadedDocuments
   */
  export type User$uploadedDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * User.formSubmissions
   */
  export type User$formSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    where?: FormSubmissionWhereInput
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    cursor?: FormSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * User.eventLogs
   */
  export type User$eventLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventLogInclude<ExtArgs> | null
    where?: EventLogWhereInput
    orderBy?: EventLogOrderByWithRelationInput | EventLogOrderByWithRelationInput[]
    cursor?: EventLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventLogScalarFieldEnum | EventLogScalarFieldEnum[]
  }

  /**
   * User.mergeReviews
   */
  export type User$mergeReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MergeQueue
     */
    select?: MergeQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MergeQueueInclude<ExtArgs> | null
    where?: MergeQueueWhereInput
    orderBy?: MergeQueueOrderByWithRelationInput | MergeQueueOrderByWithRelationInput[]
    cursor?: MergeQueueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MergeQueueScalarFieldEnum | MergeQueueScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    companyName: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    mobile: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    county: string | null
    postcode: string | null
    country: string | null
    clientType: $Enums.ClientType | null
    leadSource: string | null
    referralSource: string | null
    portalKey: string | null
    portalLastAccessAt: Date | null
    marketingConsent: boolean | null
    marketingConsentDate: Date | null
    emailConsent: boolean | null
    smsConsent: boolean | null
    callRecordingConsent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
    ownerId: string | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    companyName: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    mobile: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    county: string | null
    postcode: string | null
    country: string | null
    clientType: $Enums.ClientType | null
    leadSource: string | null
    referralSource: string | null
    portalKey: string | null
    portalLastAccessAt: Date | null
    marketingConsent: boolean | null
    marketingConsentDate: Date | null
    emailConsent: boolean | null
    smsConsent: boolean | null
    callRecordingConsent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
    ownerId: string | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    companyName: number
    firstName: number
    lastName: number
    email: number
    phone: number
    mobile: number
    addressLine1: number
    addressLine2: number
    city: number
    county: number
    postcode: number
    country: number
    clientType: number
    leadSource: number
    referralSource: number
    portalKey: number
    portalLastAccessAt: number
    marketingConsent: number
    marketingConsentDate: number
    emailConsent: number
    smsConsent: number
    callRecordingConsent: number
    createdAt: number
    updatedAt: number
    createdById: number
    updatedById: number
    ownerId: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    companyName?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    mobile?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    county?: true
    postcode?: true
    country?: true
    clientType?: true
    leadSource?: true
    referralSource?: true
    portalKey?: true
    portalLastAccessAt?: true
    marketingConsent?: true
    marketingConsentDate?: true
    emailConsent?: true
    smsConsent?: true
    callRecordingConsent?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    ownerId?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    companyName?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    mobile?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    county?: true
    postcode?: true
    country?: true
    clientType?: true
    leadSource?: true
    referralSource?: true
    portalKey?: true
    portalLastAccessAt?: true
    marketingConsent?: true
    marketingConsentDate?: true
    emailConsent?: true
    smsConsent?: true
    callRecordingConsent?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    ownerId?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    companyName?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    mobile?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    county?: true
    postcode?: true
    country?: true
    clientType?: true
    leadSource?: true
    referralSource?: true
    portalKey?: true
    portalLastAccessAt?: true
    marketingConsent?: true
    marketingConsentDate?: true
    emailConsent?: true
    smsConsent?: true
    callRecordingConsent?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    ownerId?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    companyName: string | null
    firstName: string
    lastName: string
    email: string | null
    phone: string | null
    mobile: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    county: string | null
    postcode: string | null
    country: string
    clientType: $Enums.ClientType
    leadSource: string | null
    referralSource: string | null
    portalKey: string | null
    portalLastAccessAt: Date | null
    marketingConsent: boolean
    marketingConsentDate: Date | null
    emailConsent: boolean
    smsConsent: boolean
    callRecordingConsent: boolean
    createdAt: Date
    updatedAt: Date
    createdById: string | null
    updatedById: string | null
    ownerId: string
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    mobile?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    county?: boolean
    postcode?: boolean
    country?: boolean
    clientType?: boolean
    leadSource?: boolean
    referralSource?: boolean
    portalKey?: boolean
    portalLastAccessAt?: boolean
    marketingConsent?: boolean
    marketingConsentDate?: boolean
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    ownerId?: boolean
    createdBy?: boolean | Client$createdByArgs<ExtArgs>
    updatedBy?: boolean | Client$updatedByArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    contacts?: boolean | Client$contactsArgs<ExtArgs>
    leads?: boolean | Client$leadsArgs<ExtArgs>
    deals?: boolean | Client$dealsArgs<ExtArgs>
    rooms?: boolean | Client$roomsArgs<ExtArgs>
    jobs?: boolean | Client$jobsArgs<ExtArgs>
    activities?: boolean | Client$activitiesArgs<ExtArgs>
    documents?: boolean | Client$documentsArgs<ExtArgs>
    appointments?: boolean | Client$appointmentsArgs<ExtArgs>
    moodboards?: boolean | Client$moodboardsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    mobile?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    county?: boolean
    postcode?: boolean
    country?: boolean
    clientType?: boolean
    leadSource?: boolean
    referralSource?: boolean
    portalKey?: boolean
    portalLastAccessAt?: boolean
    marketingConsent?: boolean
    marketingConsentDate?: boolean
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    ownerId?: boolean
    createdBy?: boolean | Client$createdByArgs<ExtArgs>
    updatedBy?: boolean | Client$updatedByArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    companyName?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    mobile?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    county?: boolean
    postcode?: boolean
    country?: boolean
    clientType?: boolean
    leadSource?: boolean
    referralSource?: boolean
    portalKey?: boolean
    portalLastAccessAt?: boolean
    marketingConsent?: boolean
    marketingConsentDate?: boolean
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    ownerId?: boolean
  }

  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Client$createdByArgs<ExtArgs>
    updatedBy?: boolean | Client$updatedByArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    contacts?: boolean | Client$contactsArgs<ExtArgs>
    leads?: boolean | Client$leadsArgs<ExtArgs>
    deals?: boolean | Client$dealsArgs<ExtArgs>
    rooms?: boolean | Client$roomsArgs<ExtArgs>
    jobs?: boolean | Client$jobsArgs<ExtArgs>
    activities?: boolean | Client$activitiesArgs<ExtArgs>
    documents?: boolean | Client$documentsArgs<ExtArgs>
    appointments?: boolean | Client$appointmentsArgs<ExtArgs>
    moodboards?: boolean | Client$moodboardsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Client$createdByArgs<ExtArgs>
    updatedBy?: boolean | Client$updatedByArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
      owner: Prisma.$UserPayload<ExtArgs>
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      leads: Prisma.$LeadPayload<ExtArgs>[]
      deals: Prisma.$DealPayload<ExtArgs>[]
      rooms: Prisma.$RoomPayload<ExtArgs>[]
      jobs: Prisma.$JobPayload<ExtArgs>[]
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      moodboards: Prisma.$MoodboardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyName: string | null
      firstName: string
      lastName: string
      email: string | null
      phone: string | null
      mobile: string | null
      addressLine1: string | null
      addressLine2: string | null
      city: string | null
      county: string | null
      postcode: string | null
      country: string
      clientType: $Enums.ClientType
      leadSource: string | null
      referralSource: string | null
      portalKey: string | null
      portalLastAccessAt: Date | null
      marketingConsent: boolean
      marketingConsentDate: Date | null
      emailConsent: boolean
      smsConsent: boolean
      callRecordingConsent: boolean
      createdAt: Date
      updatedAt: Date
      createdById: string | null
      updatedById: string | null
      ownerId: string
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends Client$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Client$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    updatedBy<T extends Client$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, Client$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    contacts<T extends Client$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Client$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany"> | Null>
    leads<T extends Client$leadsArgs<ExtArgs> = {}>(args?: Subset<T, Client$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany"> | Null>
    deals<T extends Client$dealsArgs<ExtArgs> = {}>(args?: Subset<T, Client$dealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findMany"> | Null>
    rooms<T extends Client$roomsArgs<ExtArgs> = {}>(args?: Subset<T, Client$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany"> | Null>
    jobs<T extends Client$jobsArgs<ExtArgs> = {}>(args?: Subset<T, Client$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany"> | Null>
    activities<T extends Client$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Client$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany"> | Null>
    documents<T extends Client$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Client$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany"> | Null>
    appointments<T extends Client$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Client$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany"> | Null>
    moodboards<T extends Client$moodboardsArgs<ExtArgs> = {}>(args?: Subset<T, Client$moodboardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoodboardPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */ 
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly companyName: FieldRef<"Client", 'String'>
    readonly firstName: FieldRef<"Client", 'String'>
    readonly lastName: FieldRef<"Client", 'String'>
    readonly email: FieldRef<"Client", 'String'>
    readonly phone: FieldRef<"Client", 'String'>
    readonly mobile: FieldRef<"Client", 'String'>
    readonly addressLine1: FieldRef<"Client", 'String'>
    readonly addressLine2: FieldRef<"Client", 'String'>
    readonly city: FieldRef<"Client", 'String'>
    readonly county: FieldRef<"Client", 'String'>
    readonly postcode: FieldRef<"Client", 'String'>
    readonly country: FieldRef<"Client", 'String'>
    readonly clientType: FieldRef<"Client", 'ClientType'>
    readonly leadSource: FieldRef<"Client", 'String'>
    readonly referralSource: FieldRef<"Client", 'String'>
    readonly portalKey: FieldRef<"Client", 'String'>
    readonly portalLastAccessAt: FieldRef<"Client", 'DateTime'>
    readonly marketingConsent: FieldRef<"Client", 'Boolean'>
    readonly marketingConsentDate: FieldRef<"Client", 'DateTime'>
    readonly emailConsent: FieldRef<"Client", 'Boolean'>
    readonly smsConsent: FieldRef<"Client", 'Boolean'>
    readonly callRecordingConsent: FieldRef<"Client", 'Boolean'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
    readonly createdById: FieldRef<"Client", 'String'>
    readonly updatedById: FieldRef<"Client", 'String'>
    readonly ownerId: FieldRef<"Client", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
  }

  /**
   * Client.createdBy
   */
  export type Client$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Client.updatedBy
   */
  export type Client$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Client.contacts
   */
  export type Client$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Client.leads
   */
  export type Client$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Client.deals
   */
  export type Client$dealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    cursor?: DealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Client.rooms
   */
  export type Client$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Client.jobs
   */
  export type Client$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    cursor?: JobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Client.activities
   */
  export type Client$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Client.documents
   */
  export type Client$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Client.appointments
   */
  export type Client$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Client.moodboards
   */
  export type Client$moodboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Moodboard
     */
    select?: MoodboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardInclude<ExtArgs> | null
    where?: MoodboardWhereInput
    orderBy?: MoodboardOrderByWithRelationInput | MoodboardOrderByWithRelationInput[]
    cursor?: MoodboardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MoodboardScalarFieldEnum | MoodboardScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    mobile: string | null
    jobTitle: string | null
    isPrimary: boolean | null
    clientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    mobile: string | null
    jobTitle: string | null
    isPrimary: boolean | null
    clientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    phone: number
    mobile: number
    jobTitle: number
    isPrimary: number
    clientId: number
    createdAt: number
    updatedAt: number
    createdById: number
    updatedById: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    mobile?: true
    jobTitle?: true
    isPrimary?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    mobile?: true
    jobTitle?: true
    isPrimary?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    mobile?: true
    jobTitle?: true
    isPrimary?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    email: string | null
    phone: string | null
    mobile: string | null
    jobTitle: string | null
    isPrimary: boolean
    clientId: string
    createdAt: Date
    updatedAt: Date
    createdById: string | null
    updatedById: string | null
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    mobile?: boolean
    jobTitle?: boolean
    isPrimary?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    activities?: boolean | Contact$activitiesArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    mobile?: boolean
    jobTitle?: boolean
    isPrimary?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    mobile?: boolean
    jobTitle?: boolean
    isPrimary?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
  }

  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    activities?: boolean | Contact$activitiesArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      activities: Prisma.$ActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      email: string | null
      phone: string | null
      mobile: string | null
      jobTitle: string | null
      isPrimary: boolean
      clientId: string
      createdAt: Date
      updatedAt: Date
      createdById: string | null
      updatedById: string | null
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    activities<T extends Contact$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */ 
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly firstName: FieldRef<"Contact", 'String'>
    readonly lastName: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly phone: FieldRef<"Contact", 'String'>
    readonly mobile: FieldRef<"Contact", 'String'>
    readonly jobTitle: FieldRef<"Contact", 'String'>
    readonly isPrimary: FieldRef<"Contact", 'Boolean'>
    readonly clientId: FieldRef<"Contact", 'String'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
    readonly createdById: FieldRef<"Contact", 'String'>
    readonly updatedById: FieldRef<"Contact", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
  }

  /**
   * Contact.activities
   */
  export type Contact$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model Lead
   */

  export type AggregateLead = {
    _count: LeadCountAggregateOutputType | null
    _avg: LeadAvgAggregateOutputType | null
    _sum: LeadSumAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  export type LeadAvgAggregateOutputType = {
    estimatedValue: Decimal | null
    probability: number | null
    responseTime: number | null
  }

  export type LeadSumAggregateOutputType = {
    estimatedValue: Decimal | null
    probability: number | null
    responseTime: number | null
  }

  export type LeadMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.LeadStatus | null
    priority: $Enums.Priority | null
    estimatedValue: Decimal | null
    probability: number | null
    expectedCloseDate: Date | null
    source: string | null
    campaign: string | null
    medium: string | null
    firstResponseAt: Date | null
    responseTime: number | null
    clientId: string | null
    ownerId: string | null
    dealId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
  }

  export type LeadMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.LeadStatus | null
    priority: $Enums.Priority | null
    estimatedValue: Decimal | null
    probability: number | null
    expectedCloseDate: Date | null
    source: string | null
    campaign: string | null
    medium: string | null
    firstResponseAt: Date | null
    responseTime: number | null
    clientId: string | null
    ownerId: string | null
    dealId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
  }

  export type LeadCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    priority: number
    estimatedValue: number
    probability: number
    expectedCloseDate: number
    source: number
    campaign: number
    medium: number
    firstResponseAt: number
    responseTime: number
    clientId: number
    ownerId: number
    dealId: number
    createdAt: number
    updatedAt: number
    createdById: number
    updatedById: number
    _all: number
  }


  export type LeadAvgAggregateInputType = {
    estimatedValue?: true
    probability?: true
    responseTime?: true
  }

  export type LeadSumAggregateInputType = {
    estimatedValue?: true
    probability?: true
    responseTime?: true
  }

  export type LeadMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    estimatedValue?: true
    probability?: true
    expectedCloseDate?: true
    source?: true
    campaign?: true
    medium?: true
    firstResponseAt?: true
    responseTime?: true
    clientId?: true
    ownerId?: true
    dealId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type LeadMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    estimatedValue?: true
    probability?: true
    expectedCloseDate?: true
    source?: true
    campaign?: true
    medium?: true
    firstResponseAt?: true
    responseTime?: true
    clientId?: true
    ownerId?: true
    dealId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type LeadCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    estimatedValue?: true
    probability?: true
    expectedCloseDate?: true
    source?: true
    campaign?: true
    medium?: true
    firstResponseAt?: true
    responseTime?: true
    clientId?: true
    ownerId?: true
    dealId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    _all?: true
  }

  export type LeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lead to aggregate.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leads
    **/
    _count?: true | LeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadMaxAggregateInputType
  }

  export type GetLeadAggregateType<T extends LeadAggregateArgs> = {
        [P in keyof T & keyof AggregateLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLead[P]>
      : GetScalarType<T[P], AggregateLead[P]>
  }




  export type LeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithAggregationInput | LeadOrderByWithAggregationInput[]
    by: LeadScalarFieldEnum[] | LeadScalarFieldEnum
    having?: LeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadCountAggregateInputType | true
    _avg?: LeadAvgAggregateInputType
    _sum?: LeadSumAggregateInputType
    _min?: LeadMinAggregateInputType
    _max?: LeadMaxAggregateInputType
  }

  export type LeadGroupByOutputType = {
    id: string
    title: string
    description: string | null
    status: $Enums.LeadStatus
    priority: $Enums.Priority
    estimatedValue: Decimal | null
    probability: number
    expectedCloseDate: Date | null
    source: string | null
    campaign: string | null
    medium: string | null
    firstResponseAt: Date | null
    responseTime: number | null
    clientId: string
    ownerId: string
    dealId: string | null
    createdAt: Date
    updatedAt: Date
    createdById: string | null
    updatedById: string | null
    _count: LeadCountAggregateOutputType | null
    _avg: LeadAvgAggregateOutputType | null
    _sum: LeadSumAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  type GetLeadGroupByPayload<T extends LeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadGroupByOutputType[P]>
            : GetScalarType<T[P], LeadGroupByOutputType[P]>
        }
      >
    >


  export type LeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    estimatedValue?: boolean
    probability?: boolean
    expectedCloseDate?: boolean
    source?: boolean
    campaign?: boolean
    medium?: boolean
    firstResponseAt?: boolean
    responseTime?: boolean
    clientId?: boolean
    ownerId?: boolean
    dealId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Lead$dealArgs<ExtArgs>
    activities?: boolean | Lead$activitiesArgs<ExtArgs>
    tasks?: boolean | Lead$tasksArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    estimatedValue?: boolean
    probability?: boolean
    expectedCloseDate?: boolean
    source?: boolean
    campaign?: boolean
    medium?: boolean
    firstResponseAt?: boolean
    responseTime?: boolean
    clientId?: boolean
    ownerId?: boolean
    dealId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Lead$dealArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    estimatedValue?: boolean
    probability?: boolean
    expectedCloseDate?: boolean
    source?: boolean
    campaign?: boolean
    medium?: boolean
    firstResponseAt?: boolean
    responseTime?: boolean
    clientId?: boolean
    ownerId?: boolean
    dealId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
  }

  export type LeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Lead$dealArgs<ExtArgs>
    activities?: boolean | Lead$activitiesArgs<ExtArgs>
    tasks?: boolean | Lead$tasksArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Lead$dealArgs<ExtArgs>
  }

  export type $LeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lead"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs>
      deal: Prisma.$DealPayload<ExtArgs> | null
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      status: $Enums.LeadStatus
      priority: $Enums.Priority
      estimatedValue: Prisma.Decimal | null
      probability: number
      expectedCloseDate: Date | null
      source: string | null
      campaign: string | null
      medium: string | null
      firstResponseAt: Date | null
      responseTime: number | null
      clientId: string
      ownerId: string
      dealId: string | null
      createdAt: Date
      updatedAt: Date
      createdById: string | null
      updatedById: string | null
    }, ExtArgs["result"]["lead"]>
    composites: {}
  }

  type LeadGetPayload<S extends boolean | null | undefined | LeadDefaultArgs> = $Result.GetResult<Prisma.$LeadPayload, S>

  type LeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeadCountAggregateInputType | true
    }

  export interface LeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lead'], meta: { name: 'Lead' } }
    /**
     * Find zero or one Lead that matches the filter.
     * @param {LeadFindUniqueArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadFindUniqueArgs>(args: SelectSubset<T, LeadFindUniqueArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lead that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeadFindUniqueOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadFindFirstArgs>(args?: SelectSubset<T, LeadFindFirstArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Leads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leads
     * const leads = await prisma.lead.findMany()
     * 
     * // Get first 10 Leads
     * const leads = await prisma.lead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadWithIdOnly = await prisma.lead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadFindManyArgs>(args?: SelectSubset<T, LeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lead.
     * @param {LeadCreateArgs} args - Arguments to create a Lead.
     * @example
     * // Create one Lead
     * const Lead = await prisma.lead.create({
     *   data: {
     *     // ... data to create a Lead
     *   }
     * })
     * 
     */
    create<T extends LeadCreateArgs>(args: SelectSubset<T, LeadCreateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Leads.
     * @param {LeadCreateManyArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadCreateManyArgs>(args?: SelectSubset<T, LeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leads and returns the data saved in the database.
     * @param {LeadCreateManyAndReturnArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Lead.
     * @param {LeadDeleteArgs} args - Arguments to delete one Lead.
     * @example
     * // Delete one Lead
     * const Lead = await prisma.lead.delete({
     *   where: {
     *     // ... filter to delete one Lead
     *   }
     * })
     * 
     */
    delete<T extends LeadDeleteArgs>(args: SelectSubset<T, LeadDeleteArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lead.
     * @param {LeadUpdateArgs} args - Arguments to update one Lead.
     * @example
     * // Update one Lead
     * const lead = await prisma.lead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadUpdateArgs>(args: SelectSubset<T, LeadUpdateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Leads.
     * @param {LeadDeleteManyArgs} args - Arguments to filter Leads to delete.
     * @example
     * // Delete a few Leads
     * const { count } = await prisma.lead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadDeleteManyArgs>(args?: SelectSubset<T, LeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadUpdateManyArgs>(args: SelectSubset<T, LeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lead.
     * @param {LeadUpsertArgs} args - Arguments to update or create a Lead.
     * @example
     * // Update or create a Lead
     * const lead = await prisma.lead.upsert({
     *   create: {
     *     // ... data to create a Lead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lead we want to update
     *   }
     * })
     */
    upsert<T extends LeadUpsertArgs>(args: SelectSubset<T, LeadUpsertArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCountArgs} args - Arguments to filter Leads to count.
     * @example
     * // Count the number of Leads
     * const count = await prisma.lead.count({
     *   where: {
     *     // ... the filter for the Leads we want to count
     *   }
     * })
    **/
    count<T extends LeadCountArgs>(
      args?: Subset<T, LeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadAggregateArgs>(args: Subset<T, LeadAggregateArgs>): Prisma.PrismaPromise<GetLeadAggregateType<T>>

    /**
     * Group by Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadGroupByArgs['orderBy'] }
        : { orderBy?: LeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lead model
   */
  readonly fields: LeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    deal<T extends Lead$dealArgs<ExtArgs> = {}>(args?: Subset<T, Lead$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    activities<T extends Lead$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Lead$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany"> | Null>
    tasks<T extends Lead$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Lead$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lead model
   */ 
  interface LeadFieldRefs {
    readonly id: FieldRef<"Lead", 'String'>
    readonly title: FieldRef<"Lead", 'String'>
    readonly description: FieldRef<"Lead", 'String'>
    readonly status: FieldRef<"Lead", 'LeadStatus'>
    readonly priority: FieldRef<"Lead", 'Priority'>
    readonly estimatedValue: FieldRef<"Lead", 'Decimal'>
    readonly probability: FieldRef<"Lead", 'Int'>
    readonly expectedCloseDate: FieldRef<"Lead", 'DateTime'>
    readonly source: FieldRef<"Lead", 'String'>
    readonly campaign: FieldRef<"Lead", 'String'>
    readonly medium: FieldRef<"Lead", 'String'>
    readonly firstResponseAt: FieldRef<"Lead", 'DateTime'>
    readonly responseTime: FieldRef<"Lead", 'Int'>
    readonly clientId: FieldRef<"Lead", 'String'>
    readonly ownerId: FieldRef<"Lead", 'String'>
    readonly dealId: FieldRef<"Lead", 'String'>
    readonly createdAt: FieldRef<"Lead", 'DateTime'>
    readonly updatedAt: FieldRef<"Lead", 'DateTime'>
    readonly createdById: FieldRef<"Lead", 'String'>
    readonly updatedById: FieldRef<"Lead", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lead findUnique
   */
  export type LeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findUniqueOrThrow
   */
  export type LeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findFirst
   */
  export type LeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findFirstOrThrow
   */
  export type LeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findMany
   */
  export type LeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Leads to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead create
   */
  export type LeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to create a Lead.
     */
    data: XOR<LeadCreateInput, LeadUncheckedCreateInput>
  }

  /**
   * Lead createMany
   */
  export type LeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lead createManyAndReturn
   */
  export type LeadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lead update
   */
  export type LeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to update a Lead.
     */
    data: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
    /**
     * Choose, which Lead to update.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead updateMany
   */
  export type LeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
  }

  /**
   * Lead upsert
   */
  export type LeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The filter to search for the Lead to update in case it exists.
     */
    where: LeadWhereUniqueInput
    /**
     * In case the Lead found by the `where` argument doesn't exist, create a new Lead with this data.
     */
    create: XOR<LeadCreateInput, LeadUncheckedCreateInput>
    /**
     * In case the Lead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
  }

  /**
   * Lead delete
   */
  export type LeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter which Lead to delete.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead deleteMany
   */
  export type LeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leads to delete
     */
    where?: LeadWhereInput
  }

  /**
   * Lead.deal
   */
  export type Lead$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }

  /**
   * Lead.activities
   */
  export type Lead$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Lead.tasks
   */
  export type Lead$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Lead without action
   */
  export type LeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
  }


  /**
   * Model Deal
   */

  export type AggregateDeal = {
    _count: DealCountAggregateOutputType | null
    _avg: DealAvgAggregateOutputType | null
    _sum: DealSumAggregateOutputType | null
    _min: DealMinAggregateOutputType | null
    _max: DealMaxAggregateOutputType | null
  }

  export type DealAvgAggregateOutputType = {
    value: Decimal | null
    probability: number | null
  }

  export type DealSumAggregateOutputType = {
    value: Decimal | null
    probability: number | null
  }

  export type DealMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    value: Decimal | null
    probability: number | null
    expectedCloseDate: Date | null
    actualCloseDate: Date | null
    stageId: string | null
    clientId: string | null
    ownerId: string | null
    jobId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
  }

  export type DealMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    value: Decimal | null
    probability: number | null
    expectedCloseDate: Date | null
    actualCloseDate: Date | null
    stageId: string | null
    clientId: string | null
    ownerId: string | null
    jobId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
  }

  export type DealCountAggregateOutputType = {
    id: number
    title: number
    description: number
    value: number
    probability: number
    expectedCloseDate: number
    actualCloseDate: number
    stageId: number
    clientId: number
    ownerId: number
    jobId: number
    createdAt: number
    updatedAt: number
    createdById: number
    updatedById: number
    _all: number
  }


  export type DealAvgAggregateInputType = {
    value?: true
    probability?: true
  }

  export type DealSumAggregateInputType = {
    value?: true
    probability?: true
  }

  export type DealMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    value?: true
    probability?: true
    expectedCloseDate?: true
    actualCloseDate?: true
    stageId?: true
    clientId?: true
    ownerId?: true
    jobId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type DealMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    value?: true
    probability?: true
    expectedCloseDate?: true
    actualCloseDate?: true
    stageId?: true
    clientId?: true
    ownerId?: true
    jobId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type DealCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    value?: true
    probability?: true
    expectedCloseDate?: true
    actualCloseDate?: true
    stageId?: true
    clientId?: true
    ownerId?: true
    jobId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    _all?: true
  }

  export type DealAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deal to aggregate.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deals
    **/
    _count?: true | DealCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DealAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DealSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DealMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DealMaxAggregateInputType
  }

  export type GetDealAggregateType<T extends DealAggregateArgs> = {
        [P in keyof T & keyof AggregateDeal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeal[P]>
      : GetScalarType<T[P], AggregateDeal[P]>
  }




  export type DealGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
    orderBy?: DealOrderByWithAggregationInput | DealOrderByWithAggregationInput[]
    by: DealScalarFieldEnum[] | DealScalarFieldEnum
    having?: DealScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DealCountAggregateInputType | true
    _avg?: DealAvgAggregateInputType
    _sum?: DealSumAggregateInputType
    _min?: DealMinAggregateInputType
    _max?: DealMaxAggregateInputType
  }

  export type DealGroupByOutputType = {
    id: string
    title: string
    description: string | null
    value: Decimal
    probability: number
    expectedCloseDate: Date | null
    actualCloseDate: Date | null
    stageId: string
    clientId: string
    ownerId: string
    jobId: string | null
    createdAt: Date
    updatedAt: Date
    createdById: string | null
    updatedById: string | null
    _count: DealCountAggregateOutputType | null
    _avg: DealAvgAggregateOutputType | null
    _sum: DealSumAggregateOutputType | null
    _min: DealMinAggregateOutputType | null
    _max: DealMaxAggregateOutputType | null
  }

  type GetDealGroupByPayload<T extends DealGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DealGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DealGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DealGroupByOutputType[P]>
            : GetScalarType<T[P], DealGroupByOutputType[P]>
        }
      >
    >


  export type DealSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    value?: boolean
    probability?: boolean
    expectedCloseDate?: boolean
    actualCloseDate?: boolean
    stageId?: boolean
    clientId?: boolean
    ownerId?: boolean
    jobId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    stage?: boolean | PipelineStageDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    lead?: boolean | Deal$leadArgs<ExtArgs>
    job?: boolean | Deal$jobArgs<ExtArgs>
    activities?: boolean | Deal$activitiesArgs<ExtArgs>
    tasks?: boolean | Deal$tasksArgs<ExtArgs>
    documents?: boolean | Deal$documentsArgs<ExtArgs>
    _count?: boolean | DealCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deal"]>

  export type DealSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    value?: boolean
    probability?: boolean
    expectedCloseDate?: boolean
    actualCloseDate?: boolean
    stageId?: boolean
    clientId?: boolean
    ownerId?: boolean
    jobId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    stage?: boolean | PipelineStageDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    job?: boolean | Deal$jobArgs<ExtArgs>
  }, ExtArgs["result"]["deal"]>

  export type DealSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    value?: boolean
    probability?: boolean
    expectedCloseDate?: boolean
    actualCloseDate?: boolean
    stageId?: boolean
    clientId?: boolean
    ownerId?: boolean
    jobId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
  }

  export type DealInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stage?: boolean | PipelineStageDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    lead?: boolean | Deal$leadArgs<ExtArgs>
    job?: boolean | Deal$jobArgs<ExtArgs>
    activities?: boolean | Deal$activitiesArgs<ExtArgs>
    tasks?: boolean | Deal$tasksArgs<ExtArgs>
    documents?: boolean | Deal$documentsArgs<ExtArgs>
    _count?: boolean | DealCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DealIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stage?: boolean | PipelineStageDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    job?: boolean | Deal$jobArgs<ExtArgs>
  }

  export type $DealPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Deal"
    objects: {
      stage: Prisma.$PipelineStagePayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs>
      lead: Prisma.$LeadPayload<ExtArgs> | null
      job: Prisma.$JobPayload<ExtArgs> | null
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      value: Prisma.Decimal
      probability: number
      expectedCloseDate: Date | null
      actualCloseDate: Date | null
      stageId: string
      clientId: string
      ownerId: string
      jobId: string | null
      createdAt: Date
      updatedAt: Date
      createdById: string | null
      updatedById: string | null
    }, ExtArgs["result"]["deal"]>
    composites: {}
  }

  type DealGetPayload<S extends boolean | null | undefined | DealDefaultArgs> = $Result.GetResult<Prisma.$DealPayload, S>

  type DealCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DealFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DealCountAggregateInputType | true
    }

  export interface DealDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Deal'], meta: { name: 'Deal' } }
    /**
     * Find zero or one Deal that matches the filter.
     * @param {DealFindUniqueArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DealFindUniqueArgs>(args: SelectSubset<T, DealFindUniqueArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Deal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DealFindUniqueOrThrowArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DealFindUniqueOrThrowArgs>(args: SelectSubset<T, DealFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Deal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindFirstArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DealFindFirstArgs>(args?: SelectSubset<T, DealFindFirstArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Deal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindFirstOrThrowArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DealFindFirstOrThrowArgs>(args?: SelectSubset<T, DealFindFirstOrThrowArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Deals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deals
     * const deals = await prisma.deal.findMany()
     * 
     * // Get first 10 Deals
     * const deals = await prisma.deal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dealWithIdOnly = await prisma.deal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DealFindManyArgs>(args?: SelectSubset<T, DealFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Deal.
     * @param {DealCreateArgs} args - Arguments to create a Deal.
     * @example
     * // Create one Deal
     * const Deal = await prisma.deal.create({
     *   data: {
     *     // ... data to create a Deal
     *   }
     * })
     * 
     */
    create<T extends DealCreateArgs>(args: SelectSubset<T, DealCreateArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Deals.
     * @param {DealCreateManyArgs} args - Arguments to create many Deals.
     * @example
     * // Create many Deals
     * const deal = await prisma.deal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DealCreateManyArgs>(args?: SelectSubset<T, DealCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deals and returns the data saved in the database.
     * @param {DealCreateManyAndReturnArgs} args - Arguments to create many Deals.
     * @example
     * // Create many Deals
     * const deal = await prisma.deal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deals and only return the `id`
     * const dealWithIdOnly = await prisma.deal.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DealCreateManyAndReturnArgs>(args?: SelectSubset<T, DealCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Deal.
     * @param {DealDeleteArgs} args - Arguments to delete one Deal.
     * @example
     * // Delete one Deal
     * const Deal = await prisma.deal.delete({
     *   where: {
     *     // ... filter to delete one Deal
     *   }
     * })
     * 
     */
    delete<T extends DealDeleteArgs>(args: SelectSubset<T, DealDeleteArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Deal.
     * @param {DealUpdateArgs} args - Arguments to update one Deal.
     * @example
     * // Update one Deal
     * const deal = await prisma.deal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DealUpdateArgs>(args: SelectSubset<T, DealUpdateArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Deals.
     * @param {DealDeleteManyArgs} args - Arguments to filter Deals to delete.
     * @example
     * // Delete a few Deals
     * const { count } = await prisma.deal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DealDeleteManyArgs>(args?: SelectSubset<T, DealDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deals
     * const deal = await prisma.deal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DealUpdateManyArgs>(args: SelectSubset<T, DealUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Deal.
     * @param {DealUpsertArgs} args - Arguments to update or create a Deal.
     * @example
     * // Update or create a Deal
     * const deal = await prisma.deal.upsert({
     *   create: {
     *     // ... data to create a Deal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deal we want to update
     *   }
     * })
     */
    upsert<T extends DealUpsertArgs>(args: SelectSubset<T, DealUpsertArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Deals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealCountArgs} args - Arguments to filter Deals to count.
     * @example
     * // Count the number of Deals
     * const count = await prisma.deal.count({
     *   where: {
     *     // ... the filter for the Deals we want to count
     *   }
     * })
    **/
    count<T extends DealCountArgs>(
      args?: Subset<T, DealCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DealCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DealAggregateArgs>(args: Subset<T, DealAggregateArgs>): Prisma.PrismaPromise<GetDealAggregateType<T>>

    /**
     * Group by Deal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DealGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DealGroupByArgs['orderBy'] }
        : { orderBy?: DealGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DealGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDealGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Deal model
   */
  readonly fields: DealFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Deal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DealClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stage<T extends PipelineStageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PipelineStageDefaultArgs<ExtArgs>>): Prisma__PipelineStageClient<$Result.GetResult<Prisma.$PipelineStagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lead<T extends Deal$leadArgs<ExtArgs> = {}>(args?: Subset<T, Deal$leadArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    job<T extends Deal$jobArgs<ExtArgs> = {}>(args?: Subset<T, Deal$jobArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    activities<T extends Deal$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Deal$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany"> | Null>
    tasks<T extends Deal$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Deal$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    documents<T extends Deal$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Deal$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Deal model
   */ 
  interface DealFieldRefs {
    readonly id: FieldRef<"Deal", 'String'>
    readonly title: FieldRef<"Deal", 'String'>
    readonly description: FieldRef<"Deal", 'String'>
    readonly value: FieldRef<"Deal", 'Decimal'>
    readonly probability: FieldRef<"Deal", 'Int'>
    readonly expectedCloseDate: FieldRef<"Deal", 'DateTime'>
    readonly actualCloseDate: FieldRef<"Deal", 'DateTime'>
    readonly stageId: FieldRef<"Deal", 'String'>
    readonly clientId: FieldRef<"Deal", 'String'>
    readonly ownerId: FieldRef<"Deal", 'String'>
    readonly jobId: FieldRef<"Deal", 'String'>
    readonly createdAt: FieldRef<"Deal", 'DateTime'>
    readonly updatedAt: FieldRef<"Deal", 'DateTime'>
    readonly createdById: FieldRef<"Deal", 'String'>
    readonly updatedById: FieldRef<"Deal", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Deal findUnique
   */
  export type DealFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal findUniqueOrThrow
   */
  export type DealFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal findFirst
   */
  export type DealFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deals.
     */
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Deal findFirstOrThrow
   */
  export type DealFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deals.
     */
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Deal findMany
   */
  export type DealFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deals to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Deal create
   */
  export type DealCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The data needed to create a Deal.
     */
    data: XOR<DealCreateInput, DealUncheckedCreateInput>
  }

  /**
   * Deal createMany
   */
  export type DealCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deals.
     */
    data: DealCreateManyInput | DealCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Deal createManyAndReturn
   */
  export type DealCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Deals.
     */
    data: DealCreateManyInput | DealCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Deal update
   */
  export type DealUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The data needed to update a Deal.
     */
    data: XOR<DealUpdateInput, DealUncheckedUpdateInput>
    /**
     * Choose, which Deal to update.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal updateMany
   */
  export type DealUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deals.
     */
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyInput>
    /**
     * Filter which Deals to update
     */
    where?: DealWhereInput
  }

  /**
   * Deal upsert
   */
  export type DealUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The filter to search for the Deal to update in case it exists.
     */
    where: DealWhereUniqueInput
    /**
     * In case the Deal found by the `where` argument doesn't exist, create a new Deal with this data.
     */
    create: XOR<DealCreateInput, DealUncheckedCreateInput>
    /**
     * In case the Deal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DealUpdateInput, DealUncheckedUpdateInput>
  }

  /**
   * Deal delete
   */
  export type DealDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter which Deal to delete.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal deleteMany
   */
  export type DealDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deals to delete
     */
    where?: DealWhereInput
  }

  /**
   * Deal.lead
   */
  export type Deal$leadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
  }

  /**
   * Deal.job
   */
  export type Deal$jobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
  }

  /**
   * Deal.activities
   */
  export type Deal$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Deal.tasks
   */
  export type Deal$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Deal.documents
   */
  export type Deal$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Deal without action
   */
  export type DealDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
  }


  /**
   * Model PipelineStage
   */

  export type AggregatePipelineStage = {
    _count: PipelineStageCountAggregateOutputType | null
    _avg: PipelineStageAvgAggregateOutputType | null
    _sum: PipelineStageSumAggregateOutputType | null
    _min: PipelineStageMinAggregateOutputType | null
    _max: PipelineStageMaxAggregateOutputType | null
  }

  export type PipelineStageAvgAggregateOutputType = {
    order: number | null
    probability: number | null
  }

  export type PipelineStageSumAggregateOutputType = {
    order: number | null
    probability: number | null
  }

  export type PipelineStageMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    order: number | null
    probability: number | null
    isClosedWon: boolean | null
    isClosedLost: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PipelineStageMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    order: number | null
    probability: number | null
    isClosedWon: boolean | null
    isClosedLost: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PipelineStageCountAggregateOutputType = {
    id: number
    name: number
    description: number
    order: number
    probability: number
    isClosedWon: number
    isClosedLost: number
    autoTasks: number
    autoEmails: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PipelineStageAvgAggregateInputType = {
    order?: true
    probability?: true
  }

  export type PipelineStageSumAggregateInputType = {
    order?: true
    probability?: true
  }

  export type PipelineStageMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    probability?: true
    isClosedWon?: true
    isClosedLost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PipelineStageMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    probability?: true
    isClosedWon?: true
    isClosedLost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PipelineStageCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    probability?: true
    isClosedWon?: true
    isClosedLost?: true
    autoTasks?: true
    autoEmails?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PipelineStageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PipelineStage to aggregate.
     */
    where?: PipelineStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PipelineStages to fetch.
     */
    orderBy?: PipelineStageOrderByWithRelationInput | PipelineStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PipelineStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PipelineStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PipelineStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PipelineStages
    **/
    _count?: true | PipelineStageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PipelineStageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PipelineStageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PipelineStageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PipelineStageMaxAggregateInputType
  }

  export type GetPipelineStageAggregateType<T extends PipelineStageAggregateArgs> = {
        [P in keyof T & keyof AggregatePipelineStage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePipelineStage[P]>
      : GetScalarType<T[P], AggregatePipelineStage[P]>
  }




  export type PipelineStageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelineStageWhereInput
    orderBy?: PipelineStageOrderByWithAggregationInput | PipelineStageOrderByWithAggregationInput[]
    by: PipelineStageScalarFieldEnum[] | PipelineStageScalarFieldEnum
    having?: PipelineStageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PipelineStageCountAggregateInputType | true
    _avg?: PipelineStageAvgAggregateInputType
    _sum?: PipelineStageSumAggregateInputType
    _min?: PipelineStageMinAggregateInputType
    _max?: PipelineStageMaxAggregateInputType
  }

  export type PipelineStageGroupByOutputType = {
    id: string
    name: string
    description: string | null
    order: number
    probability: number
    isClosedWon: boolean
    isClosedLost: boolean
    autoTasks: JsonValue
    autoEmails: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: PipelineStageCountAggregateOutputType | null
    _avg: PipelineStageAvgAggregateOutputType | null
    _sum: PipelineStageSumAggregateOutputType | null
    _min: PipelineStageMinAggregateOutputType | null
    _max: PipelineStageMaxAggregateOutputType | null
  }

  type GetPipelineStageGroupByPayload<T extends PipelineStageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PipelineStageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PipelineStageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PipelineStageGroupByOutputType[P]>
            : GetScalarType<T[P], PipelineStageGroupByOutputType[P]>
        }
      >
    >


  export type PipelineStageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    probability?: boolean
    isClosedWon?: boolean
    isClosedLost?: boolean
    autoTasks?: boolean
    autoEmails?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deals?: boolean | PipelineStage$dealsArgs<ExtArgs>
    _count?: boolean | PipelineStageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pipelineStage"]>

  export type PipelineStageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    probability?: boolean
    isClosedWon?: boolean
    isClosedLost?: boolean
    autoTasks?: boolean
    autoEmails?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pipelineStage"]>

  export type PipelineStageSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    probability?: boolean
    isClosedWon?: boolean
    isClosedLost?: boolean
    autoTasks?: boolean
    autoEmails?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PipelineStageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deals?: boolean | PipelineStage$dealsArgs<ExtArgs>
    _count?: boolean | PipelineStageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PipelineStageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PipelineStagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PipelineStage"
    objects: {
      deals: Prisma.$DealPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      order: number
      probability: number
      isClosedWon: boolean
      isClosedLost: boolean
      autoTasks: Prisma.JsonValue
      autoEmails: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pipelineStage"]>
    composites: {}
  }

  type PipelineStageGetPayload<S extends boolean | null | undefined | PipelineStageDefaultArgs> = $Result.GetResult<Prisma.$PipelineStagePayload, S>

  type PipelineStageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PipelineStageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PipelineStageCountAggregateInputType | true
    }

  export interface PipelineStageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PipelineStage'], meta: { name: 'PipelineStage' } }
    /**
     * Find zero or one PipelineStage that matches the filter.
     * @param {PipelineStageFindUniqueArgs} args - Arguments to find a PipelineStage
     * @example
     * // Get one PipelineStage
     * const pipelineStage = await prisma.pipelineStage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PipelineStageFindUniqueArgs>(args: SelectSubset<T, PipelineStageFindUniqueArgs<ExtArgs>>): Prisma__PipelineStageClient<$Result.GetResult<Prisma.$PipelineStagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PipelineStage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PipelineStageFindUniqueOrThrowArgs} args - Arguments to find a PipelineStage
     * @example
     * // Get one PipelineStage
     * const pipelineStage = await prisma.pipelineStage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PipelineStageFindUniqueOrThrowArgs>(args: SelectSubset<T, PipelineStageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PipelineStageClient<$Result.GetResult<Prisma.$PipelineStagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PipelineStage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineStageFindFirstArgs} args - Arguments to find a PipelineStage
     * @example
     * // Get one PipelineStage
     * const pipelineStage = await prisma.pipelineStage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PipelineStageFindFirstArgs>(args?: SelectSubset<T, PipelineStageFindFirstArgs<ExtArgs>>): Prisma__PipelineStageClient<$Result.GetResult<Prisma.$PipelineStagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PipelineStage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineStageFindFirstOrThrowArgs} args - Arguments to find a PipelineStage
     * @example
     * // Get one PipelineStage
     * const pipelineStage = await prisma.pipelineStage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PipelineStageFindFirstOrThrowArgs>(args?: SelectSubset<T, PipelineStageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PipelineStageClient<$Result.GetResult<Prisma.$PipelineStagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PipelineStages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineStageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PipelineStages
     * const pipelineStages = await prisma.pipelineStage.findMany()
     * 
     * // Get first 10 PipelineStages
     * const pipelineStages = await prisma.pipelineStage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pipelineStageWithIdOnly = await prisma.pipelineStage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PipelineStageFindManyArgs>(args?: SelectSubset<T, PipelineStageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelineStagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PipelineStage.
     * @param {PipelineStageCreateArgs} args - Arguments to create a PipelineStage.
     * @example
     * // Create one PipelineStage
     * const PipelineStage = await prisma.pipelineStage.create({
     *   data: {
     *     // ... data to create a PipelineStage
     *   }
     * })
     * 
     */
    create<T extends PipelineStageCreateArgs>(args: SelectSubset<T, PipelineStageCreateArgs<ExtArgs>>): Prisma__PipelineStageClient<$Result.GetResult<Prisma.$PipelineStagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PipelineStages.
     * @param {PipelineStageCreateManyArgs} args - Arguments to create many PipelineStages.
     * @example
     * // Create many PipelineStages
     * const pipelineStage = await prisma.pipelineStage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PipelineStageCreateManyArgs>(args?: SelectSubset<T, PipelineStageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PipelineStages and returns the data saved in the database.
     * @param {PipelineStageCreateManyAndReturnArgs} args - Arguments to create many PipelineStages.
     * @example
     * // Create many PipelineStages
     * const pipelineStage = await prisma.pipelineStage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PipelineStages and only return the `id`
     * const pipelineStageWithIdOnly = await prisma.pipelineStage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PipelineStageCreateManyAndReturnArgs>(args?: SelectSubset<T, PipelineStageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelineStagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PipelineStage.
     * @param {PipelineStageDeleteArgs} args - Arguments to delete one PipelineStage.
     * @example
     * // Delete one PipelineStage
     * const PipelineStage = await prisma.pipelineStage.delete({
     *   where: {
     *     // ... filter to delete one PipelineStage
     *   }
     * })
     * 
     */
    delete<T extends PipelineStageDeleteArgs>(args: SelectSubset<T, PipelineStageDeleteArgs<ExtArgs>>): Prisma__PipelineStageClient<$Result.GetResult<Prisma.$PipelineStagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PipelineStage.
     * @param {PipelineStageUpdateArgs} args - Arguments to update one PipelineStage.
     * @example
     * // Update one PipelineStage
     * const pipelineStage = await prisma.pipelineStage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PipelineStageUpdateArgs>(args: SelectSubset<T, PipelineStageUpdateArgs<ExtArgs>>): Prisma__PipelineStageClient<$Result.GetResult<Prisma.$PipelineStagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PipelineStages.
     * @param {PipelineStageDeleteManyArgs} args - Arguments to filter PipelineStages to delete.
     * @example
     * // Delete a few PipelineStages
     * const { count } = await prisma.pipelineStage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PipelineStageDeleteManyArgs>(args?: SelectSubset<T, PipelineStageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PipelineStages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineStageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PipelineStages
     * const pipelineStage = await prisma.pipelineStage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PipelineStageUpdateManyArgs>(args: SelectSubset<T, PipelineStageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PipelineStage.
     * @param {PipelineStageUpsertArgs} args - Arguments to update or create a PipelineStage.
     * @example
     * // Update or create a PipelineStage
     * const pipelineStage = await prisma.pipelineStage.upsert({
     *   create: {
     *     // ... data to create a PipelineStage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PipelineStage we want to update
     *   }
     * })
     */
    upsert<T extends PipelineStageUpsertArgs>(args: SelectSubset<T, PipelineStageUpsertArgs<ExtArgs>>): Prisma__PipelineStageClient<$Result.GetResult<Prisma.$PipelineStagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PipelineStages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineStageCountArgs} args - Arguments to filter PipelineStages to count.
     * @example
     * // Count the number of PipelineStages
     * const count = await prisma.pipelineStage.count({
     *   where: {
     *     // ... the filter for the PipelineStages we want to count
     *   }
     * })
    **/
    count<T extends PipelineStageCountArgs>(
      args?: Subset<T, PipelineStageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PipelineStageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PipelineStage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineStageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PipelineStageAggregateArgs>(args: Subset<T, PipelineStageAggregateArgs>): Prisma.PrismaPromise<GetPipelineStageAggregateType<T>>

    /**
     * Group by PipelineStage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineStageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PipelineStageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PipelineStageGroupByArgs['orderBy'] }
        : { orderBy?: PipelineStageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PipelineStageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPipelineStageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PipelineStage model
   */
  readonly fields: PipelineStageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PipelineStage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PipelineStageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deals<T extends PipelineStage$dealsArgs<ExtArgs> = {}>(args?: Subset<T, PipelineStage$dealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PipelineStage model
   */ 
  interface PipelineStageFieldRefs {
    readonly id: FieldRef<"PipelineStage", 'String'>
    readonly name: FieldRef<"PipelineStage", 'String'>
    readonly description: FieldRef<"PipelineStage", 'String'>
    readonly order: FieldRef<"PipelineStage", 'Int'>
    readonly probability: FieldRef<"PipelineStage", 'Int'>
    readonly isClosedWon: FieldRef<"PipelineStage", 'Boolean'>
    readonly isClosedLost: FieldRef<"PipelineStage", 'Boolean'>
    readonly autoTasks: FieldRef<"PipelineStage", 'Json'>
    readonly autoEmails: FieldRef<"PipelineStage", 'Json'>
    readonly createdAt: FieldRef<"PipelineStage", 'DateTime'>
    readonly updatedAt: FieldRef<"PipelineStage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PipelineStage findUnique
   */
  export type PipelineStageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineStage
     */
    select?: PipelineStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineStageInclude<ExtArgs> | null
    /**
     * Filter, which PipelineStage to fetch.
     */
    where: PipelineStageWhereUniqueInput
  }

  /**
   * PipelineStage findUniqueOrThrow
   */
  export type PipelineStageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineStage
     */
    select?: PipelineStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineStageInclude<ExtArgs> | null
    /**
     * Filter, which PipelineStage to fetch.
     */
    where: PipelineStageWhereUniqueInput
  }

  /**
   * PipelineStage findFirst
   */
  export type PipelineStageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineStage
     */
    select?: PipelineStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineStageInclude<ExtArgs> | null
    /**
     * Filter, which PipelineStage to fetch.
     */
    where?: PipelineStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PipelineStages to fetch.
     */
    orderBy?: PipelineStageOrderByWithRelationInput | PipelineStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PipelineStages.
     */
    cursor?: PipelineStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PipelineStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PipelineStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PipelineStages.
     */
    distinct?: PipelineStageScalarFieldEnum | PipelineStageScalarFieldEnum[]
  }

  /**
   * PipelineStage findFirstOrThrow
   */
  export type PipelineStageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineStage
     */
    select?: PipelineStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineStageInclude<ExtArgs> | null
    /**
     * Filter, which PipelineStage to fetch.
     */
    where?: PipelineStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PipelineStages to fetch.
     */
    orderBy?: PipelineStageOrderByWithRelationInput | PipelineStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PipelineStages.
     */
    cursor?: PipelineStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PipelineStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PipelineStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PipelineStages.
     */
    distinct?: PipelineStageScalarFieldEnum | PipelineStageScalarFieldEnum[]
  }

  /**
   * PipelineStage findMany
   */
  export type PipelineStageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineStage
     */
    select?: PipelineStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineStageInclude<ExtArgs> | null
    /**
     * Filter, which PipelineStages to fetch.
     */
    where?: PipelineStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PipelineStages to fetch.
     */
    orderBy?: PipelineStageOrderByWithRelationInput | PipelineStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PipelineStages.
     */
    cursor?: PipelineStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PipelineStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PipelineStages.
     */
    skip?: number
    distinct?: PipelineStageScalarFieldEnum | PipelineStageScalarFieldEnum[]
  }

  /**
   * PipelineStage create
   */
  export type PipelineStageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineStage
     */
    select?: PipelineStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineStageInclude<ExtArgs> | null
    /**
     * The data needed to create a PipelineStage.
     */
    data: XOR<PipelineStageCreateInput, PipelineStageUncheckedCreateInput>
  }

  /**
   * PipelineStage createMany
   */
  export type PipelineStageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PipelineStages.
     */
    data: PipelineStageCreateManyInput | PipelineStageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PipelineStage createManyAndReturn
   */
  export type PipelineStageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineStage
     */
    select?: PipelineStageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PipelineStages.
     */
    data: PipelineStageCreateManyInput | PipelineStageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PipelineStage update
   */
  export type PipelineStageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineStage
     */
    select?: PipelineStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineStageInclude<ExtArgs> | null
    /**
     * The data needed to update a PipelineStage.
     */
    data: XOR<PipelineStageUpdateInput, PipelineStageUncheckedUpdateInput>
    /**
     * Choose, which PipelineStage to update.
     */
    where: PipelineStageWhereUniqueInput
  }

  /**
   * PipelineStage updateMany
   */
  export type PipelineStageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PipelineStages.
     */
    data: XOR<PipelineStageUpdateManyMutationInput, PipelineStageUncheckedUpdateManyInput>
    /**
     * Filter which PipelineStages to update
     */
    where?: PipelineStageWhereInput
  }

  /**
   * PipelineStage upsert
   */
  export type PipelineStageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineStage
     */
    select?: PipelineStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineStageInclude<ExtArgs> | null
    /**
     * The filter to search for the PipelineStage to update in case it exists.
     */
    where: PipelineStageWhereUniqueInput
    /**
     * In case the PipelineStage found by the `where` argument doesn't exist, create a new PipelineStage with this data.
     */
    create: XOR<PipelineStageCreateInput, PipelineStageUncheckedCreateInput>
    /**
     * In case the PipelineStage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PipelineStageUpdateInput, PipelineStageUncheckedUpdateInput>
  }

  /**
   * PipelineStage delete
   */
  export type PipelineStageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineStage
     */
    select?: PipelineStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineStageInclude<ExtArgs> | null
    /**
     * Filter which PipelineStage to delete.
     */
    where: PipelineStageWhereUniqueInput
  }

  /**
   * PipelineStage deleteMany
   */
  export type PipelineStageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PipelineStages to delete
     */
    where?: PipelineStageWhereInput
  }

  /**
   * PipelineStage.deals
   */
  export type PipelineStage$dealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    cursor?: DealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * PipelineStage without action
   */
  export type PipelineStageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineStage
     */
    select?: PipelineStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineStageInclude<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityAvgAggregateOutputType = {
    duration: number | null
  }

  export type ActivitySumAggregateOutputType = {
    duration: number | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    type: $Enums.ActivityType | null
    title: string | null
    description: string | null
    direction: $Enums.Direction | null
    duration: number | null
    outcome: string | null
    userId: string | null
    clientId: string | null
    contactId: string | null
    leadId: string | null
    dealId: string | null
    emailMessageId: string | null
    callRecordingUrl: string | null
    createdAt: Date | null
    scheduledAt: Date | null
    completedAt: Date | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    type: $Enums.ActivityType | null
    title: string | null
    description: string | null
    direction: $Enums.Direction | null
    duration: number | null
    outcome: string | null
    userId: string | null
    clientId: string | null
    contactId: string | null
    leadId: string | null
    dealId: string | null
    emailMessageId: string | null
    callRecordingUrl: string | null
    createdAt: Date | null
    scheduledAt: Date | null
    completedAt: Date | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    type: number
    title: number
    description: number
    direction: number
    duration: number
    outcome: number
    userId: number
    clientId: number
    contactId: number
    leadId: number
    dealId: number
    emailMessageId: number
    callRecordingUrl: number
    metadata: number
    createdAt: number
    scheduledAt: number
    completedAt: number
    _all: number
  }


  export type ActivityAvgAggregateInputType = {
    duration?: true
  }

  export type ActivitySumAggregateInputType = {
    duration?: true
  }

  export type ActivityMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    description?: true
    direction?: true
    duration?: true
    outcome?: true
    userId?: true
    clientId?: true
    contactId?: true
    leadId?: true
    dealId?: true
    emailMessageId?: true
    callRecordingUrl?: true
    createdAt?: true
    scheduledAt?: true
    completedAt?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    description?: true
    direction?: true
    duration?: true
    outcome?: true
    userId?: true
    clientId?: true
    contactId?: true
    leadId?: true
    dealId?: true
    emailMessageId?: true
    callRecordingUrl?: true
    createdAt?: true
    scheduledAt?: true
    completedAt?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    description?: true
    direction?: true
    duration?: true
    outcome?: true
    userId?: true
    clientId?: true
    contactId?: true
    leadId?: true
    dealId?: true
    emailMessageId?: true
    callRecordingUrl?: true
    metadata?: true
    createdAt?: true
    scheduledAt?: true
    completedAt?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _avg?: ActivityAvgAggregateInputType
    _sum?: ActivitySumAggregateInputType
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    type: $Enums.ActivityType
    title: string
    description: string | null
    direction: $Enums.Direction | null
    duration: number | null
    outcome: string | null
    userId: string
    clientId: string | null
    contactId: string | null
    leadId: string | null
    dealId: string | null
    emailMessageId: string | null
    callRecordingUrl: string | null
    metadata: JsonValue
    createdAt: Date
    scheduledAt: Date | null
    completedAt: Date | null
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    direction?: boolean
    duration?: boolean
    outcome?: boolean
    userId?: boolean
    clientId?: boolean
    contactId?: boolean
    leadId?: boolean
    dealId?: boolean
    emailMessageId?: boolean
    callRecordingUrl?: boolean
    metadata?: boolean
    createdAt?: boolean
    scheduledAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    client?: boolean | Activity$clientArgs<ExtArgs>
    contact?: boolean | Activity$contactArgs<ExtArgs>
    lead?: boolean | Activity$leadArgs<ExtArgs>
    deal?: boolean | Activity$dealArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    direction?: boolean
    duration?: boolean
    outcome?: boolean
    userId?: boolean
    clientId?: boolean
    contactId?: boolean
    leadId?: boolean
    dealId?: boolean
    emailMessageId?: boolean
    callRecordingUrl?: boolean
    metadata?: boolean
    createdAt?: boolean
    scheduledAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    client?: boolean | Activity$clientArgs<ExtArgs>
    contact?: boolean | Activity$contactArgs<ExtArgs>
    lead?: boolean | Activity$leadArgs<ExtArgs>
    deal?: boolean | Activity$dealArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    direction?: boolean
    duration?: boolean
    outcome?: boolean
    userId?: boolean
    clientId?: boolean
    contactId?: boolean
    leadId?: boolean
    dealId?: boolean
    emailMessageId?: boolean
    callRecordingUrl?: boolean
    metadata?: boolean
    createdAt?: boolean
    scheduledAt?: boolean
    completedAt?: boolean
  }

  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    client?: boolean | Activity$clientArgs<ExtArgs>
    contact?: boolean | Activity$contactArgs<ExtArgs>
    lead?: boolean | Activity$leadArgs<ExtArgs>
    deal?: boolean | Activity$dealArgs<ExtArgs>
  }
  export type ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    client?: boolean | Activity$clientArgs<ExtArgs>
    contact?: boolean | Activity$contactArgs<ExtArgs>
    lead?: boolean | Activity$leadArgs<ExtArgs>
    deal?: boolean | Activity$dealArgs<ExtArgs>
  }

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs> | null
      contact: Prisma.$ContactPayload<ExtArgs> | null
      lead: Prisma.$LeadPayload<ExtArgs> | null
      deal: Prisma.$DealPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.ActivityType
      title: string
      description: string | null
      direction: $Enums.Direction | null
      duration: number | null
      outcome: string | null
      userId: string
      clientId: string | null
      contactId: string | null
      leadId: string | null
      dealId: string | null
      emailMessageId: string | null
      callRecordingUrl: string | null
      metadata: Prisma.JsonValue
      createdAt: Date
      scheduledAt: Date | null
      completedAt: Date | null
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    client<T extends Activity$clientArgs<ExtArgs> = {}>(args?: Subset<T, Activity$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    contact<T extends Activity$contactArgs<ExtArgs> = {}>(args?: Subset<T, Activity$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    lead<T extends Activity$leadArgs<ExtArgs> = {}>(args?: Subset<T, Activity$leadArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    deal<T extends Activity$dealArgs<ExtArgs> = {}>(args?: Subset<T, Activity$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */ 
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'String'>
    readonly type: FieldRef<"Activity", 'ActivityType'>
    readonly title: FieldRef<"Activity", 'String'>
    readonly description: FieldRef<"Activity", 'String'>
    readonly direction: FieldRef<"Activity", 'Direction'>
    readonly duration: FieldRef<"Activity", 'Int'>
    readonly outcome: FieldRef<"Activity", 'String'>
    readonly userId: FieldRef<"Activity", 'String'>
    readonly clientId: FieldRef<"Activity", 'String'>
    readonly contactId: FieldRef<"Activity", 'String'>
    readonly leadId: FieldRef<"Activity", 'String'>
    readonly dealId: FieldRef<"Activity", 'String'>
    readonly emailMessageId: FieldRef<"Activity", 'String'>
    readonly callRecordingUrl: FieldRef<"Activity", 'String'>
    readonly metadata: FieldRef<"Activity", 'Json'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
    readonly scheduledAt: FieldRef<"Activity", 'DateTime'>
    readonly completedAt: FieldRef<"Activity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
  }

  /**
   * Activity.client
   */
  export type Activity$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Activity.contact
   */
  export type Activity$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Activity.lead
   */
  export type Activity$leadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
  }

  /**
   * Activity.deal
   */
  export type Activity$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.TaskStatus | null
    priority: $Enums.Priority | null
    dueDate: Date | null
    completedAt: Date | null
    assigneeId: string | null
    createdById: string | null
    clientId: string | null
    leadId: string | null
    dealId: string | null
    jobId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.TaskStatus | null
    priority: $Enums.Priority | null
    dueDate: Date | null
    completedAt: Date | null
    assigneeId: string | null
    createdById: string | null
    clientId: string | null
    leadId: string | null
    dealId: string | null
    jobId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    priority: number
    dueDate: number
    completedAt: number
    assigneeId: number
    createdById: number
    clientId: number
    leadId: number
    dealId: number
    jobId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaskMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    completedAt?: true
    assigneeId?: true
    createdById?: true
    clientId?: true
    leadId?: true
    dealId?: true
    jobId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    completedAt?: true
    assigneeId?: true
    createdById?: true
    clientId?: true
    leadId?: true
    dealId?: true
    jobId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    completedAt?: true
    assigneeId?: true
    createdById?: true
    clientId?: true
    leadId?: true
    dealId?: true
    jobId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    title: string
    description: string | null
    status: $Enums.TaskStatus
    priority: $Enums.Priority
    dueDate: Date | null
    completedAt: Date | null
    assigneeId: string
    createdById: string
    clientId: string | null
    leadId: string | null
    dealId: string | null
    jobId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    completedAt?: boolean
    assigneeId?: boolean
    createdById?: boolean
    clientId?: boolean
    leadId?: boolean
    dealId?: boolean
    jobId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignee?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    lead?: boolean | Task$leadArgs<ExtArgs>
    deal?: boolean | Task$dealArgs<ExtArgs>
    job?: boolean | Task$jobArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    completedAt?: boolean
    assigneeId?: boolean
    createdById?: boolean
    clientId?: boolean
    leadId?: boolean
    dealId?: boolean
    jobId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignee?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    lead?: boolean | Task$leadArgs<ExtArgs>
    deal?: boolean | Task$dealArgs<ExtArgs>
    job?: boolean | Task$jobArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    completedAt?: boolean
    assigneeId?: boolean
    createdById?: boolean
    clientId?: boolean
    leadId?: boolean
    dealId?: boolean
    jobId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignee?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    lead?: boolean | Task$leadArgs<ExtArgs>
    deal?: boolean | Task$dealArgs<ExtArgs>
    job?: boolean | Task$jobArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignee?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    lead?: boolean | Task$leadArgs<ExtArgs>
    deal?: boolean | Task$dealArgs<ExtArgs>
    job?: boolean | Task$jobArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      assignee: Prisma.$UserPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      lead: Prisma.$LeadPayload<ExtArgs> | null
      deal: Prisma.$DealPayload<ExtArgs> | null
      job: Prisma.$JobPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      status: $Enums.TaskStatus
      priority: $Enums.Priority
      dueDate: Date | null
      completedAt: Date | null
      assigneeId: string
      createdById: string
      clientId: string | null
      leadId: string | null
      dealId: string | null
      jobId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lead<T extends Task$leadArgs<ExtArgs> = {}>(args?: Subset<T, Task$leadArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    deal<T extends Task$dealArgs<ExtArgs> = {}>(args?: Subset<T, Task$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    job<T extends Task$jobArgs<ExtArgs> = {}>(args?: Subset<T, Task$jobArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */ 
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'TaskStatus'>
    readonly priority: FieldRef<"Task", 'Priority'>
    readonly dueDate: FieldRef<"Task", 'DateTime'>
    readonly completedAt: FieldRef<"Task", 'DateTime'>
    readonly assigneeId: FieldRef<"Task", 'String'>
    readonly createdById: FieldRef<"Task", 'String'>
    readonly clientId: FieldRef<"Task", 'String'>
    readonly leadId: FieldRef<"Task", 'String'>
    readonly dealId: FieldRef<"Task", 'String'>
    readonly jobId: FieldRef<"Task", 'String'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
  }

  /**
   * Task.lead
   */
  export type Task$leadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
  }

  /**
   * Task.deal
   */
  export type Task$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }

  /**
   * Task.job
   */
  export type Task$jobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    location: string | null
    meetingUrl: string | null
    status: $Enums.AppointmentStatus | null
    userId: string | null
    clientId: string | null
    jobId: string | null
    outlookEventId: string | null
    calendarSynced: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    location: string | null
    meetingUrl: string | null
    status: $Enums.AppointmentStatus | null
    userId: string | null
    clientId: string | null
    jobId: string | null
    outlookEventId: string | null
    calendarSynced: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    title: number
    description: number
    startTime: number
    endTime: number
    location: number
    meetingUrl: number
    status: number
    userId: number
    clientId: number
    jobId: number
    outlookEventId: number
    calendarSynced: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AppointmentMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    location?: true
    meetingUrl?: true
    status?: true
    userId?: true
    clientId?: true
    jobId?: true
    outlookEventId?: true
    calendarSynced?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    location?: true
    meetingUrl?: true
    status?: true
    userId?: true
    clientId?: true
    jobId?: true
    outlookEventId?: true
    calendarSynced?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    location?: true
    meetingUrl?: true
    status?: true
    userId?: true
    clientId?: true
    jobId?: true
    outlookEventId?: true
    calendarSynced?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: string
    title: string
    description: string | null
    startTime: Date
    endTime: Date
    location: string | null
    meetingUrl: string | null
    status: $Enums.AppointmentStatus
    userId: string
    clientId: string
    jobId: string | null
    outlookEventId: string | null
    calendarSynced: boolean
    createdAt: Date
    updatedAt: Date
    _count: AppointmentCountAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    location?: boolean
    meetingUrl?: boolean
    status?: boolean
    userId?: boolean
    clientId?: boolean
    jobId?: boolean
    outlookEventId?: boolean
    calendarSynced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    job?: boolean | Appointment$jobArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    location?: boolean
    meetingUrl?: boolean
    status?: boolean
    userId?: boolean
    clientId?: boolean
    jobId?: boolean
    outlookEventId?: boolean
    calendarSynced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    job?: boolean | Appointment$jobArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    location?: boolean
    meetingUrl?: boolean
    status?: boolean
    userId?: boolean
    clientId?: boolean
    jobId?: boolean
    outlookEventId?: boolean
    calendarSynced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    job?: boolean | Appointment$jobArgs<ExtArgs>
  }
  export type AppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    job?: boolean | Appointment$jobArgs<ExtArgs>
  }

  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs>
      job: Prisma.$JobPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      startTime: Date
      endTime: Date
      location: string | null
      meetingUrl: string | null
      status: $Enums.AppointmentStatus
      userId: string
      clientId: string
      jobId: string | null
      outlookEventId: string | null
      calendarSynced: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {AppointmentCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    job<T extends Appointment$jobArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$jobArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointment model
   */ 
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'String'>
    readonly title: FieldRef<"Appointment", 'String'>
    readonly description: FieldRef<"Appointment", 'String'>
    readonly startTime: FieldRef<"Appointment", 'DateTime'>
    readonly endTime: FieldRef<"Appointment", 'DateTime'>
    readonly location: FieldRef<"Appointment", 'String'>
    readonly meetingUrl: FieldRef<"Appointment", 'String'>
    readonly status: FieldRef<"Appointment", 'AppointmentStatus'>
    readonly userId: FieldRef<"Appointment", 'String'>
    readonly clientId: FieldRef<"Appointment", 'String'>
    readonly jobId: FieldRef<"Appointment", 'String'>
    readonly outlookEventId: FieldRef<"Appointment", 'String'>
    readonly calendarSynced: FieldRef<"Appointment", 'Boolean'>
    readonly createdAt: FieldRef<"Appointment", 'DateTime'>
    readonly updatedAt: FieldRef<"Appointment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Appointment createManyAndReturn
   */
  export type AppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
  }

  /**
   * Appointment.job
   */
  export type Appointment$jobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model Room
   */

  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomAvgAggregateOutputType = {
    length: number | null
    width: number | null
    height: number | null
  }

  export type RoomSumAggregateOutputType = {
    length: number | null
    width: number | null
    height: number | null
  }

  export type RoomMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.RoomType | null
    length: number | null
    width: number | null
    height: number | null
    currentCondition: string | null
    accessNotes: string | null
    clientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.RoomType | null
    length: number | null
    width: number | null
    height: number | null
    currentCondition: string | null
    accessNotes: string | null
    clientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomCountAggregateOutputType = {
    id: number
    name: number
    type: number
    length: number
    width: number
    height: number
    currentCondition: number
    accessNotes: number
    clientId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoomAvgAggregateInputType = {
    length?: true
    width?: true
    height?: true
  }

  export type RoomSumAggregateInputType = {
    length?: true
    width?: true
    height?: true
  }

  export type RoomMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    length?: true
    width?: true
    height?: true
    currentCondition?: true
    accessNotes?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    length?: true
    width?: true
    height?: true
    currentCondition?: true
    accessNotes?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    length?: true
    width?: true
    height?: true
    currentCondition?: true
    accessNotes?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Room to aggregate.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type RoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithAggregationInput | RoomOrderByWithAggregationInput[]
    by: RoomScalarFieldEnum[] | RoomScalarFieldEnum
    having?: RoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _avg?: RoomAvgAggregateInputType
    _sum?: RoomSumAggregateInputType
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }

  export type RoomGroupByOutputType = {
    id: string
    name: string
    type: $Enums.RoomType
    length: number | null
    width: number | null
    height: number | null
    currentCondition: string | null
    accessNotes: string | null
    clientId: string
    createdAt: Date
    updatedAt: Date
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends RoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type RoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    length?: boolean
    width?: boolean
    height?: boolean
    currentCondition?: boolean
    accessNotes?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    jobs?: boolean | Room$jobsArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    length?: boolean
    width?: boolean
    height?: boolean
    currentCondition?: boolean
    accessNotes?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    length?: boolean
    width?: boolean
    height?: boolean
    currentCondition?: boolean
    accessNotes?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    jobs?: boolean | Room$jobsArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $RoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Room"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      jobs: Prisma.$JobPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.RoomType
      length: number | null
      width: number | null
      height: number | null
      currentCondition: string | null
      accessNotes: string | null
      clientId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["room"]>
    composites: {}
  }

  type RoomGetPayload<S extends boolean | null | undefined | RoomDefaultArgs> = $Result.GetResult<Prisma.$RoomPayload, S>

  type RoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface RoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Room'], meta: { name: 'Room' } }
    /**
     * Find zero or one Room that matches the filter.
     * @param {RoomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomFindUniqueArgs>(args: SelectSubset<T, RoomFindUniqueArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Room that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomFindFirstArgs>(args?: SelectSubset<T, RoomFindFirstArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomWithIdOnly = await prisma.room.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomFindManyArgs>(args?: SelectSubset<T, RoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Room.
     * @param {RoomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
     */
    create<T extends RoomCreateArgs>(args: SelectSubset<T, RoomCreateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Rooms.
     * @param {RoomCreateManyArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomCreateManyArgs>(args?: SelectSubset<T, RoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rooms and returns the data saved in the database.
     * @param {RoomCreateManyAndReturnArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rooms and only return the `id`
     * const roomWithIdOnly = await prisma.room.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Room.
     * @param {RoomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
     */
    delete<T extends RoomDeleteArgs>(args: SelectSubset<T, RoomDeleteArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Room.
     * @param {RoomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomUpdateArgs>(args: SelectSubset<T, RoomUpdateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Rooms.
     * @param {RoomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomDeleteManyArgs>(args?: SelectSubset<T, RoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomUpdateManyArgs>(args: SelectSubset<T, RoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Room.
     * @param {RoomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
     */
    upsert<T extends RoomUpsertArgs>(args: SelectSubset<T, RoomUpsertArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends RoomCountArgs>(
      args?: Subset<T, RoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomGroupByArgs['orderBy'] }
        : { orderBy?: RoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Room model
   */
  readonly fields: RoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    jobs<T extends Room$jobsArgs<ExtArgs> = {}>(args?: Subset<T, Room$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Room model
   */ 
  interface RoomFieldRefs {
    readonly id: FieldRef<"Room", 'String'>
    readonly name: FieldRef<"Room", 'String'>
    readonly type: FieldRef<"Room", 'RoomType'>
    readonly length: FieldRef<"Room", 'Int'>
    readonly width: FieldRef<"Room", 'Int'>
    readonly height: FieldRef<"Room", 'Int'>
    readonly currentCondition: FieldRef<"Room", 'String'>
    readonly accessNotes: FieldRef<"Room", 'String'>
    readonly clientId: FieldRef<"Room", 'String'>
    readonly createdAt: FieldRef<"Room", 'DateTime'>
    readonly updatedAt: FieldRef<"Room", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Room findUnique
   */
  export type RoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findUniqueOrThrow
   */
  export type RoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findFirst
   */
  export type RoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findFirstOrThrow
   */
  export type RoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findMany
   */
  export type RoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room create
   */
  export type RoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to create a Room.
     */
    data: XOR<RoomCreateInput, RoomUncheckedCreateInput>
  }

  /**
   * Room createMany
   */
  export type RoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Room createManyAndReturn
   */
  export type RoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Room update
   */
  export type RoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to update a Room.
     */
    data: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
    /**
     * Choose, which Room to update.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room updateMany
   */
  export type RoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
  }

  /**
   * Room upsert
   */
  export type RoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The filter to search for the Room to update in case it exists.
     */
    where: RoomWhereUniqueInput
    /**
     * In case the Room found by the `where` argument doesn't exist, create a new Room with this data.
     */
    create: XOR<RoomCreateInput, RoomUncheckedCreateInput>
    /**
     * In case the Room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
  }

  /**
   * Room delete
   */
  export type RoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter which Room to delete.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room deleteMany
   */
  export type RoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rooms to delete
     */
    where?: RoomWhereInput
  }

  /**
   * Room.jobs
   */
  export type Room$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    cursor?: JobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Room without action
   */
  export type RoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
  }


  /**
   * Model Job
   */

  export type AggregateJob = {
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  export type JobAvgAggregateOutputType = {
    quotedValue: Decimal | null
    finalValue: Decimal | null
    depositAmount: Decimal | null
  }

  export type JobSumAggregateOutputType = {
    quotedValue: Decimal | null
    finalValue: Decimal | null
    depositAmount: Decimal | null
  }

  export type JobMinAggregateOutputType = {
    id: string | null
    jobNumber: string | null
    title: string | null
    description: string | null
    status: $Enums.JobStatus | null
    quotedDate: Date | null
    surveyDate: Date | null
    designDate: Date | null
    startDate: Date | null
    expectedEndDate: Date | null
    actualEndDate: Date | null
    quotedValue: Decimal | null
    finalValue: Decimal | null
    depositAmount: Decimal | null
    depositPaid: boolean | null
    designFeePaid: boolean | null
    balancePaid: boolean | null
    clientId: string | null
    roomId: string | null
    dealId: string | null
    installerCompanyId: string | null
    designerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobMaxAggregateOutputType = {
    id: string | null
    jobNumber: string | null
    title: string | null
    description: string | null
    status: $Enums.JobStatus | null
    quotedDate: Date | null
    surveyDate: Date | null
    designDate: Date | null
    startDate: Date | null
    expectedEndDate: Date | null
    actualEndDate: Date | null
    quotedValue: Decimal | null
    finalValue: Decimal | null
    depositAmount: Decimal | null
    depositPaid: boolean | null
    designFeePaid: boolean | null
    balancePaid: boolean | null
    clientId: string | null
    roomId: string | null
    dealId: string | null
    installerCompanyId: string | null
    designerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobCountAggregateOutputType = {
    id: number
    jobNumber: number
    title: number
    description: number
    status: number
    quotedDate: number
    surveyDate: number
    designDate: number
    startDate: number
    expectedEndDate: number
    actualEndDate: number
    quotedValue: number
    finalValue: number
    depositAmount: number
    depositPaid: number
    designFeePaid: number
    balancePaid: number
    clientId: number
    roomId: number
    dealId: number
    installerCompanyId: number
    designerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JobAvgAggregateInputType = {
    quotedValue?: true
    finalValue?: true
    depositAmount?: true
  }

  export type JobSumAggregateInputType = {
    quotedValue?: true
    finalValue?: true
    depositAmount?: true
  }

  export type JobMinAggregateInputType = {
    id?: true
    jobNumber?: true
    title?: true
    description?: true
    status?: true
    quotedDate?: true
    surveyDate?: true
    designDate?: true
    startDate?: true
    expectedEndDate?: true
    actualEndDate?: true
    quotedValue?: true
    finalValue?: true
    depositAmount?: true
    depositPaid?: true
    designFeePaid?: true
    balancePaid?: true
    clientId?: true
    roomId?: true
    dealId?: true
    installerCompanyId?: true
    designerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobMaxAggregateInputType = {
    id?: true
    jobNumber?: true
    title?: true
    description?: true
    status?: true
    quotedDate?: true
    surveyDate?: true
    designDate?: true
    startDate?: true
    expectedEndDate?: true
    actualEndDate?: true
    quotedValue?: true
    finalValue?: true
    depositAmount?: true
    depositPaid?: true
    designFeePaid?: true
    balancePaid?: true
    clientId?: true
    roomId?: true
    dealId?: true
    installerCompanyId?: true
    designerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobCountAggregateInputType = {
    id?: true
    jobNumber?: true
    title?: true
    description?: true
    status?: true
    quotedDate?: true
    surveyDate?: true
    designDate?: true
    startDate?: true
    expectedEndDate?: true
    actualEndDate?: true
    quotedValue?: true
    finalValue?: true
    depositAmount?: true
    depositPaid?: true
    designFeePaid?: true
    balancePaid?: true
    clientId?: true
    roomId?: true
    dealId?: true
    installerCompanyId?: true
    designerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Job to aggregate.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Jobs
    **/
    _count?: true | JobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobMaxAggregateInputType
  }

  export type GetJobAggregateType<T extends JobAggregateArgs> = {
        [P in keyof T & keyof AggregateJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob[P]>
      : GetScalarType<T[P], AggregateJob[P]>
  }




  export type JobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
    orderBy?: JobOrderByWithAggregationInput | JobOrderByWithAggregationInput[]
    by: JobScalarFieldEnum[] | JobScalarFieldEnum
    having?: JobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobCountAggregateInputType | true
    _avg?: JobAvgAggregateInputType
    _sum?: JobSumAggregateInputType
    _min?: JobMinAggregateInputType
    _max?: JobMaxAggregateInputType
  }

  export type JobGroupByOutputType = {
    id: string
    jobNumber: string
    title: string
    description: string | null
    status: $Enums.JobStatus
    quotedDate: Date | null
    surveyDate: Date | null
    designDate: Date | null
    startDate: Date | null
    expectedEndDate: Date | null
    actualEndDate: Date | null
    quotedValue: Decimal | null
    finalValue: Decimal | null
    depositAmount: Decimal | null
    depositPaid: boolean
    designFeePaid: boolean
    balancePaid: boolean
    clientId: string
    roomId: string
    dealId: string | null
    installerCompanyId: string | null
    designerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  type GetJobGroupByPayload<T extends JobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobGroupByOutputType[P]>
            : GetScalarType<T[P], JobGroupByOutputType[P]>
        }
      >
    >


  export type JobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobNumber?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    quotedDate?: boolean
    surveyDate?: boolean
    designDate?: boolean
    startDate?: boolean
    expectedEndDate?: boolean
    actualEndDate?: boolean
    quotedValue?: boolean
    finalValue?: boolean
    depositAmount?: boolean
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    clientId?: boolean
    roomId?: boolean
    dealId?: boolean
    installerCompanyId?: boolean
    designerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    deal?: boolean | Job$dealArgs<ExtArgs>
    installerCompany?: boolean | Job$installerCompanyArgs<ExtArgs>
    designer?: boolean | Job$designerArgs<ExtArgs>
    tasks?: boolean | Job$tasksArgs<ExtArgs>
    appointments?: boolean | Job$appointmentsArgs<ExtArgs>
    jobDayLogs?: boolean | Job$jobDayLogsArgs<ExtArgs>
    designVersions?: boolean | Job$designVersionsArgs<ExtArgs>
    snags?: boolean | Job$snagsArgs<ExtArgs>
    documents?: boolean | Job$documentsArgs<ExtArgs>
    parsedSpecItems?: boolean | Job$parsedSpecItemsArgs<ExtArgs>
    moodboards?: boolean | Job$moodboardsArgs<ExtArgs>
    handoverPacks?: boolean | Job$handoverPacksArgs<ExtArgs>
    _count?: boolean | JobCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type JobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobNumber?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    quotedDate?: boolean
    surveyDate?: boolean
    designDate?: boolean
    startDate?: boolean
    expectedEndDate?: boolean
    actualEndDate?: boolean
    quotedValue?: boolean
    finalValue?: boolean
    depositAmount?: boolean
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    clientId?: boolean
    roomId?: boolean
    dealId?: boolean
    installerCompanyId?: boolean
    designerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    installerCompany?: boolean | Job$installerCompanyArgs<ExtArgs>
    designer?: boolean | Job$designerArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type JobSelectScalar = {
    id?: boolean
    jobNumber?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    quotedDate?: boolean
    surveyDate?: boolean
    designDate?: boolean
    startDate?: boolean
    expectedEndDate?: boolean
    actualEndDate?: boolean
    quotedValue?: boolean
    finalValue?: boolean
    depositAmount?: boolean
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    clientId?: boolean
    roomId?: boolean
    dealId?: boolean
    installerCompanyId?: boolean
    designerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    deal?: boolean | Job$dealArgs<ExtArgs>
    installerCompany?: boolean | Job$installerCompanyArgs<ExtArgs>
    designer?: boolean | Job$designerArgs<ExtArgs>
    tasks?: boolean | Job$tasksArgs<ExtArgs>
    appointments?: boolean | Job$appointmentsArgs<ExtArgs>
    jobDayLogs?: boolean | Job$jobDayLogsArgs<ExtArgs>
    designVersions?: boolean | Job$designVersionsArgs<ExtArgs>
    snags?: boolean | Job$snagsArgs<ExtArgs>
    documents?: boolean | Job$documentsArgs<ExtArgs>
    parsedSpecItems?: boolean | Job$parsedSpecItemsArgs<ExtArgs>
    moodboards?: boolean | Job$moodboardsArgs<ExtArgs>
    handoverPacks?: boolean | Job$handoverPacksArgs<ExtArgs>
    _count?: boolean | JobCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    installerCompany?: boolean | Job$installerCompanyArgs<ExtArgs>
    designer?: boolean | Job$designerArgs<ExtArgs>
  }

  export type $JobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Job"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      room: Prisma.$RoomPayload<ExtArgs>
      deal: Prisma.$DealPayload<ExtArgs> | null
      installerCompany: Prisma.$InstallerCompanyPayload<ExtArgs> | null
      designer: Prisma.$UserPayload<ExtArgs> | null
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      jobDayLogs: Prisma.$JobDayLogPayload<ExtArgs>[]
      designVersions: Prisma.$DesignVersionPayload<ExtArgs>[]
      snags: Prisma.$SnagPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      parsedSpecItems: Prisma.$ParsedSpecItemPayload<ExtArgs>[]
      moodboards: Prisma.$MoodboardPayload<ExtArgs>[]
      handoverPacks: Prisma.$HandoverPackPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobNumber: string
      title: string
      description: string | null
      status: $Enums.JobStatus
      quotedDate: Date | null
      surveyDate: Date | null
      designDate: Date | null
      startDate: Date | null
      expectedEndDate: Date | null
      actualEndDate: Date | null
      quotedValue: Prisma.Decimal | null
      finalValue: Prisma.Decimal | null
      depositAmount: Prisma.Decimal | null
      depositPaid: boolean
      designFeePaid: boolean
      balancePaid: boolean
      clientId: string
      roomId: string
      dealId: string | null
      installerCompanyId: string | null
      designerId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["job"]>
    composites: {}
  }

  type JobGetPayload<S extends boolean | null | undefined | JobDefaultArgs> = $Result.GetResult<Prisma.$JobPayload, S>

  type JobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JobFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JobCountAggregateInputType | true
    }

  export interface JobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Job'], meta: { name: 'Job' } }
    /**
     * Find zero or one Job that matches the filter.
     * @param {JobFindUniqueArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobFindUniqueArgs>(args: SelectSubset<T, JobFindUniqueArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Job that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JobFindUniqueOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobFindUniqueOrThrowArgs>(args: SelectSubset<T, JobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Job that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindFirstArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobFindFirstArgs>(args?: SelectSubset<T, JobFindFirstArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Job that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindFirstOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobFindFirstOrThrowArgs>(args?: SelectSubset<T, JobFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.job.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.job.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobWithIdOnly = await prisma.job.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobFindManyArgs>(args?: SelectSubset<T, JobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Job.
     * @param {JobCreateArgs} args - Arguments to create a Job.
     * @example
     * // Create one Job
     * const Job = await prisma.job.create({
     *   data: {
     *     // ... data to create a Job
     *   }
     * })
     * 
     */
    create<T extends JobCreateArgs>(args: SelectSubset<T, JobCreateArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Jobs.
     * @param {JobCreateManyArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const job = await prisma.job.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobCreateManyArgs>(args?: SelectSubset<T, JobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Jobs and returns the data saved in the database.
     * @param {JobCreateManyAndReturnArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const job = await prisma.job.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Jobs and only return the `id`
     * const jobWithIdOnly = await prisma.job.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobCreateManyAndReturnArgs>(args?: SelectSubset<T, JobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Job.
     * @param {JobDeleteArgs} args - Arguments to delete one Job.
     * @example
     * // Delete one Job
     * const Job = await prisma.job.delete({
     *   where: {
     *     // ... filter to delete one Job
     *   }
     * })
     * 
     */
    delete<T extends JobDeleteArgs>(args: SelectSubset<T, JobDeleteArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Job.
     * @param {JobUpdateArgs} args - Arguments to update one Job.
     * @example
     * // Update one Job
     * const job = await prisma.job.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobUpdateArgs>(args: SelectSubset<T, JobUpdateArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Jobs.
     * @param {JobDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.job.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobDeleteManyArgs>(args?: SelectSubset<T, JobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const job = await prisma.job.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobUpdateManyArgs>(args: SelectSubset<T, JobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Job.
     * @param {JobUpsertArgs} args - Arguments to update or create a Job.
     * @example
     * // Update or create a Job
     * const job = await prisma.job.upsert({
     *   create: {
     *     // ... data to create a Job
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job we want to update
     *   }
     * })
     */
    upsert<T extends JobUpsertArgs>(args: SelectSubset<T, JobUpsertArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.job.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends JobCountArgs>(
      args?: Subset<T, JobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobAggregateArgs>(args: Subset<T, JobAggregateArgs>): Prisma.PrismaPromise<GetJobAggregateType<T>>

    /**
     * Group by Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobGroupByArgs['orderBy'] }
        : { orderBy?: JobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Job model
   */
  readonly fields: JobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Job.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    deal<T extends Job$dealArgs<ExtArgs> = {}>(args?: Subset<T, Job$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    installerCompany<T extends Job$installerCompanyArgs<ExtArgs> = {}>(args?: Subset<T, Job$installerCompanyArgs<ExtArgs>>): Prisma__InstallerCompanyClient<$Result.GetResult<Prisma.$InstallerCompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    designer<T extends Job$designerArgs<ExtArgs> = {}>(args?: Subset<T, Job$designerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tasks<T extends Job$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Job$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    appointments<T extends Job$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Job$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany"> | Null>
    jobDayLogs<T extends Job$jobDayLogsArgs<ExtArgs> = {}>(args?: Subset<T, Job$jobDayLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobDayLogPayload<ExtArgs>, T, "findMany"> | Null>
    designVersions<T extends Job$designVersionsArgs<ExtArgs> = {}>(args?: Subset<T, Job$designVersionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignVersionPayload<ExtArgs>, T, "findMany"> | Null>
    snags<T extends Job$snagsArgs<ExtArgs> = {}>(args?: Subset<T, Job$snagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnagPayload<ExtArgs>, T, "findMany"> | Null>
    documents<T extends Job$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Job$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany"> | Null>
    parsedSpecItems<T extends Job$parsedSpecItemsArgs<ExtArgs> = {}>(args?: Subset<T, Job$parsedSpecItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedSpecItemPayload<ExtArgs>, T, "findMany"> | Null>
    moodboards<T extends Job$moodboardsArgs<ExtArgs> = {}>(args?: Subset<T, Job$moodboardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoodboardPayload<ExtArgs>, T, "findMany"> | Null>
    handoverPacks<T extends Job$handoverPacksArgs<ExtArgs> = {}>(args?: Subset<T, Job$handoverPacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HandoverPackPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Job model
   */ 
  interface JobFieldRefs {
    readonly id: FieldRef<"Job", 'String'>
    readonly jobNumber: FieldRef<"Job", 'String'>
    readonly title: FieldRef<"Job", 'String'>
    readonly description: FieldRef<"Job", 'String'>
    readonly status: FieldRef<"Job", 'JobStatus'>
    readonly quotedDate: FieldRef<"Job", 'DateTime'>
    readonly surveyDate: FieldRef<"Job", 'DateTime'>
    readonly designDate: FieldRef<"Job", 'DateTime'>
    readonly startDate: FieldRef<"Job", 'DateTime'>
    readonly expectedEndDate: FieldRef<"Job", 'DateTime'>
    readonly actualEndDate: FieldRef<"Job", 'DateTime'>
    readonly quotedValue: FieldRef<"Job", 'Decimal'>
    readonly finalValue: FieldRef<"Job", 'Decimal'>
    readonly depositAmount: FieldRef<"Job", 'Decimal'>
    readonly depositPaid: FieldRef<"Job", 'Boolean'>
    readonly designFeePaid: FieldRef<"Job", 'Boolean'>
    readonly balancePaid: FieldRef<"Job", 'Boolean'>
    readonly clientId: FieldRef<"Job", 'String'>
    readonly roomId: FieldRef<"Job", 'String'>
    readonly dealId: FieldRef<"Job", 'String'>
    readonly installerCompanyId: FieldRef<"Job", 'String'>
    readonly designerId: FieldRef<"Job", 'String'>
    readonly createdAt: FieldRef<"Job", 'DateTime'>
    readonly updatedAt: FieldRef<"Job", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Job findUnique
   */
  export type JobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job findUniqueOrThrow
   */
  export type JobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job findFirst
   */
  export type JobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job findFirstOrThrow
   */
  export type JobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job findMany
   */
  export type JobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job create
   */
  export type JobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The data needed to create a Job.
     */
    data: XOR<JobCreateInput, JobUncheckedCreateInput>
  }

  /**
   * Job createMany
   */
  export type JobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Jobs.
     */
    data: JobCreateManyInput | JobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Job createManyAndReturn
   */
  export type JobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Jobs.
     */
    data: JobCreateManyInput | JobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Job update
   */
  export type JobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The data needed to update a Job.
     */
    data: XOR<JobUpdateInput, JobUncheckedUpdateInput>
    /**
     * Choose, which Job to update.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job updateMany
   */
  export type JobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Jobs.
     */
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     */
    where?: JobWhereInput
  }

  /**
   * Job upsert
   */
  export type JobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The filter to search for the Job to update in case it exists.
     */
    where: JobWhereUniqueInput
    /**
     * In case the Job found by the `where` argument doesn't exist, create a new Job with this data.
     */
    create: XOR<JobCreateInput, JobUncheckedCreateInput>
    /**
     * In case the Job was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobUpdateInput, JobUncheckedUpdateInput>
  }

  /**
   * Job delete
   */
  export type JobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter which Job to delete.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job deleteMany
   */
  export type JobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobs to delete
     */
    where?: JobWhereInput
  }

  /**
   * Job.deal
   */
  export type Job$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }

  /**
   * Job.installerCompany
   */
  export type Job$installerCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallerCompany
     */
    select?: InstallerCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallerCompanyInclude<ExtArgs> | null
    where?: InstallerCompanyWhereInput
  }

  /**
   * Job.designer
   */
  export type Job$designerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Job.tasks
   */
  export type Job$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Job.appointments
   */
  export type Job$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Job.jobDayLogs
   */
  export type Job$jobDayLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobDayLog
     */
    select?: JobDayLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobDayLogInclude<ExtArgs> | null
    where?: JobDayLogWhereInput
    orderBy?: JobDayLogOrderByWithRelationInput | JobDayLogOrderByWithRelationInput[]
    cursor?: JobDayLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobDayLogScalarFieldEnum | JobDayLogScalarFieldEnum[]
  }

  /**
   * Job.designVersions
   */
  export type Job$designVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignVersion
     */
    select?: DesignVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignVersionInclude<ExtArgs> | null
    where?: DesignVersionWhereInput
    orderBy?: DesignVersionOrderByWithRelationInput | DesignVersionOrderByWithRelationInput[]
    cursor?: DesignVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DesignVersionScalarFieldEnum | DesignVersionScalarFieldEnum[]
  }

  /**
   * Job.snags
   */
  export type Job$snagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagInclude<ExtArgs> | null
    where?: SnagWhereInput
    orderBy?: SnagOrderByWithRelationInput | SnagOrderByWithRelationInput[]
    cursor?: SnagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SnagScalarFieldEnum | SnagScalarFieldEnum[]
  }

  /**
   * Job.documents
   */
  export type Job$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Job.parsedSpecItems
   */
  export type Job$parsedSpecItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedSpecItem
     */
    select?: ParsedSpecItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedSpecItemInclude<ExtArgs> | null
    where?: ParsedSpecItemWhereInput
    orderBy?: ParsedSpecItemOrderByWithRelationInput | ParsedSpecItemOrderByWithRelationInput[]
    cursor?: ParsedSpecItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParsedSpecItemScalarFieldEnum | ParsedSpecItemScalarFieldEnum[]
  }

  /**
   * Job.moodboards
   */
  export type Job$moodboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Moodboard
     */
    select?: MoodboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardInclude<ExtArgs> | null
    where?: MoodboardWhereInput
    orderBy?: MoodboardOrderByWithRelationInput | MoodboardOrderByWithRelationInput[]
    cursor?: MoodboardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MoodboardScalarFieldEnum | MoodboardScalarFieldEnum[]
  }

  /**
   * Job.handoverPacks
   */
  export type Job$handoverPacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HandoverPack
     */
    select?: HandoverPackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandoverPackInclude<ExtArgs> | null
    where?: HandoverPackWhereInput
    orderBy?: HandoverPackOrderByWithRelationInput | HandoverPackOrderByWithRelationInput[]
    cursor?: HandoverPackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HandoverPackScalarFieldEnum | HandoverPackScalarFieldEnum[]
  }

  /**
   * Job without action
   */
  export type JobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
  }


  /**
   * Model JobDayLog
   */

  export type AggregateJobDayLog = {
    _count: JobDayLogCountAggregateOutputType | null
    _avg: JobDayLogAvgAggregateOutputType | null
    _sum: JobDayLogSumAggregateOutputType | null
    _min: JobDayLogMinAggregateOutputType | null
    _max: JobDayLogMaxAggregateOutputType | null
  }

  export type JobDayLogAvgAggregateOutputType = {
    checkInLatitude: Decimal | null
    checkInLongitude: Decimal | null
  }

  export type JobDayLogSumAggregateOutputType = {
    checkInLatitude: Decimal | null
    checkInLongitude: Decimal | null
  }

  export type JobDayLogMinAggregateOutputType = {
    id: string | null
    date: Date | null
    userId: string | null
    jobId: string | null
    startTime: Date | null
    endTime: Date | null
    lunchStart: Date | null
    lunchEnd: Date | null
    checkInLatitude: Decimal | null
    checkInLongitude: Decimal | null
    checkInAddress: string | null
    workCompleted: string | null
    materialsUsed: string | null
    issuesEncountered: string | null
    isCompliant: boolean | null
    complianceNotes: string | null
    syncStatus: $Enums.SyncStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobDayLogMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    userId: string | null
    jobId: string | null
    startTime: Date | null
    endTime: Date | null
    lunchStart: Date | null
    lunchEnd: Date | null
    checkInLatitude: Decimal | null
    checkInLongitude: Decimal | null
    checkInAddress: string | null
    workCompleted: string | null
    materialsUsed: string | null
    issuesEncountered: string | null
    isCompliant: boolean | null
    complianceNotes: string | null
    syncStatus: $Enums.SyncStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobDayLogCountAggregateOutputType = {
    id: number
    date: number
    userId: number
    jobId: number
    startTime: number
    endTime: number
    lunchStart: number
    lunchEnd: number
    checkInLatitude: number
    checkInLongitude: number
    checkInAddress: number
    workCompleted: number
    materialsUsed: number
    issuesEncountered: number
    startFormData: number
    dailyFormData: number
    endFormData: number
    photos: number
    isCompliant: number
    complianceNotes: number
    syncStatus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JobDayLogAvgAggregateInputType = {
    checkInLatitude?: true
    checkInLongitude?: true
  }

  export type JobDayLogSumAggregateInputType = {
    checkInLatitude?: true
    checkInLongitude?: true
  }

  export type JobDayLogMinAggregateInputType = {
    id?: true
    date?: true
    userId?: true
    jobId?: true
    startTime?: true
    endTime?: true
    lunchStart?: true
    lunchEnd?: true
    checkInLatitude?: true
    checkInLongitude?: true
    checkInAddress?: true
    workCompleted?: true
    materialsUsed?: true
    issuesEncountered?: true
    isCompliant?: true
    complianceNotes?: true
    syncStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobDayLogMaxAggregateInputType = {
    id?: true
    date?: true
    userId?: true
    jobId?: true
    startTime?: true
    endTime?: true
    lunchStart?: true
    lunchEnd?: true
    checkInLatitude?: true
    checkInLongitude?: true
    checkInAddress?: true
    workCompleted?: true
    materialsUsed?: true
    issuesEncountered?: true
    isCompliant?: true
    complianceNotes?: true
    syncStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobDayLogCountAggregateInputType = {
    id?: true
    date?: true
    userId?: true
    jobId?: true
    startTime?: true
    endTime?: true
    lunchStart?: true
    lunchEnd?: true
    checkInLatitude?: true
    checkInLongitude?: true
    checkInAddress?: true
    workCompleted?: true
    materialsUsed?: true
    issuesEncountered?: true
    startFormData?: true
    dailyFormData?: true
    endFormData?: true
    photos?: true
    isCompliant?: true
    complianceNotes?: true
    syncStatus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JobDayLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobDayLog to aggregate.
     */
    where?: JobDayLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobDayLogs to fetch.
     */
    orderBy?: JobDayLogOrderByWithRelationInput | JobDayLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobDayLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobDayLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobDayLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobDayLogs
    **/
    _count?: true | JobDayLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobDayLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobDayLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobDayLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobDayLogMaxAggregateInputType
  }

  export type GetJobDayLogAggregateType<T extends JobDayLogAggregateArgs> = {
        [P in keyof T & keyof AggregateJobDayLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobDayLog[P]>
      : GetScalarType<T[P], AggregateJobDayLog[P]>
  }




  export type JobDayLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobDayLogWhereInput
    orderBy?: JobDayLogOrderByWithAggregationInput | JobDayLogOrderByWithAggregationInput[]
    by: JobDayLogScalarFieldEnum[] | JobDayLogScalarFieldEnum
    having?: JobDayLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobDayLogCountAggregateInputType | true
    _avg?: JobDayLogAvgAggregateInputType
    _sum?: JobDayLogSumAggregateInputType
    _min?: JobDayLogMinAggregateInputType
    _max?: JobDayLogMaxAggregateInputType
  }

  export type JobDayLogGroupByOutputType = {
    id: string
    date: Date
    userId: string
    jobId: string
    startTime: Date | null
    endTime: Date | null
    lunchStart: Date | null
    lunchEnd: Date | null
    checkInLatitude: Decimal | null
    checkInLongitude: Decimal | null
    checkInAddress: string | null
    workCompleted: string | null
    materialsUsed: string | null
    issuesEncountered: string | null
    startFormData: JsonValue | null
    dailyFormData: JsonValue | null
    endFormData: JsonValue | null
    photos: string[]
    isCompliant: boolean
    complianceNotes: string | null
    syncStatus: $Enums.SyncStatus
    createdAt: Date
    updatedAt: Date
    _count: JobDayLogCountAggregateOutputType | null
    _avg: JobDayLogAvgAggregateOutputType | null
    _sum: JobDayLogSumAggregateOutputType | null
    _min: JobDayLogMinAggregateOutputType | null
    _max: JobDayLogMaxAggregateOutputType | null
  }

  type GetJobDayLogGroupByPayload<T extends JobDayLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobDayLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobDayLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobDayLogGroupByOutputType[P]>
            : GetScalarType<T[P], JobDayLogGroupByOutputType[P]>
        }
      >
    >


  export type JobDayLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    userId?: boolean
    jobId?: boolean
    startTime?: boolean
    endTime?: boolean
    lunchStart?: boolean
    lunchEnd?: boolean
    checkInLatitude?: boolean
    checkInLongitude?: boolean
    checkInAddress?: boolean
    workCompleted?: boolean
    materialsUsed?: boolean
    issuesEncountered?: boolean
    startFormData?: boolean
    dailyFormData?: boolean
    endFormData?: boolean
    photos?: boolean
    isCompliant?: boolean
    complianceNotes?: boolean
    syncStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobDayLog"]>

  export type JobDayLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    userId?: boolean
    jobId?: boolean
    startTime?: boolean
    endTime?: boolean
    lunchStart?: boolean
    lunchEnd?: boolean
    checkInLatitude?: boolean
    checkInLongitude?: boolean
    checkInAddress?: boolean
    workCompleted?: boolean
    materialsUsed?: boolean
    issuesEncountered?: boolean
    startFormData?: boolean
    dailyFormData?: boolean
    endFormData?: boolean
    photos?: boolean
    isCompliant?: boolean
    complianceNotes?: boolean
    syncStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobDayLog"]>

  export type JobDayLogSelectScalar = {
    id?: boolean
    date?: boolean
    userId?: boolean
    jobId?: boolean
    startTime?: boolean
    endTime?: boolean
    lunchStart?: boolean
    lunchEnd?: boolean
    checkInLatitude?: boolean
    checkInLongitude?: boolean
    checkInAddress?: boolean
    workCompleted?: boolean
    materialsUsed?: boolean
    issuesEncountered?: boolean
    startFormData?: boolean
    dailyFormData?: boolean
    endFormData?: boolean
    photos?: boolean
    isCompliant?: boolean
    complianceNotes?: boolean
    syncStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JobDayLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
  }
  export type JobDayLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
  }

  export type $JobDayLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobDayLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      job: Prisma.$JobPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      userId: string
      jobId: string
      startTime: Date | null
      endTime: Date | null
      lunchStart: Date | null
      lunchEnd: Date | null
      checkInLatitude: Prisma.Decimal | null
      checkInLongitude: Prisma.Decimal | null
      checkInAddress: string | null
      workCompleted: string | null
      materialsUsed: string | null
      issuesEncountered: string | null
      startFormData: Prisma.JsonValue | null
      dailyFormData: Prisma.JsonValue | null
      endFormData: Prisma.JsonValue | null
      photos: string[]
      isCompliant: boolean
      complianceNotes: string | null
      syncStatus: $Enums.SyncStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["jobDayLog"]>
    composites: {}
  }

  type JobDayLogGetPayload<S extends boolean | null | undefined | JobDayLogDefaultArgs> = $Result.GetResult<Prisma.$JobDayLogPayload, S>

  type JobDayLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JobDayLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JobDayLogCountAggregateInputType | true
    }

  export interface JobDayLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobDayLog'], meta: { name: 'JobDayLog' } }
    /**
     * Find zero or one JobDayLog that matches the filter.
     * @param {JobDayLogFindUniqueArgs} args - Arguments to find a JobDayLog
     * @example
     * // Get one JobDayLog
     * const jobDayLog = await prisma.jobDayLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobDayLogFindUniqueArgs>(args: SelectSubset<T, JobDayLogFindUniqueArgs<ExtArgs>>): Prisma__JobDayLogClient<$Result.GetResult<Prisma.$JobDayLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one JobDayLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JobDayLogFindUniqueOrThrowArgs} args - Arguments to find a JobDayLog
     * @example
     * // Get one JobDayLog
     * const jobDayLog = await prisma.jobDayLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobDayLogFindUniqueOrThrowArgs>(args: SelectSubset<T, JobDayLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobDayLogClient<$Result.GetResult<Prisma.$JobDayLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first JobDayLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobDayLogFindFirstArgs} args - Arguments to find a JobDayLog
     * @example
     * // Get one JobDayLog
     * const jobDayLog = await prisma.jobDayLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobDayLogFindFirstArgs>(args?: SelectSubset<T, JobDayLogFindFirstArgs<ExtArgs>>): Prisma__JobDayLogClient<$Result.GetResult<Prisma.$JobDayLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first JobDayLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobDayLogFindFirstOrThrowArgs} args - Arguments to find a JobDayLog
     * @example
     * // Get one JobDayLog
     * const jobDayLog = await prisma.jobDayLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobDayLogFindFirstOrThrowArgs>(args?: SelectSubset<T, JobDayLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobDayLogClient<$Result.GetResult<Prisma.$JobDayLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more JobDayLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobDayLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobDayLogs
     * const jobDayLogs = await prisma.jobDayLog.findMany()
     * 
     * // Get first 10 JobDayLogs
     * const jobDayLogs = await prisma.jobDayLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobDayLogWithIdOnly = await prisma.jobDayLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobDayLogFindManyArgs>(args?: SelectSubset<T, JobDayLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobDayLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a JobDayLog.
     * @param {JobDayLogCreateArgs} args - Arguments to create a JobDayLog.
     * @example
     * // Create one JobDayLog
     * const JobDayLog = await prisma.jobDayLog.create({
     *   data: {
     *     // ... data to create a JobDayLog
     *   }
     * })
     * 
     */
    create<T extends JobDayLogCreateArgs>(args: SelectSubset<T, JobDayLogCreateArgs<ExtArgs>>): Prisma__JobDayLogClient<$Result.GetResult<Prisma.$JobDayLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many JobDayLogs.
     * @param {JobDayLogCreateManyArgs} args - Arguments to create many JobDayLogs.
     * @example
     * // Create many JobDayLogs
     * const jobDayLog = await prisma.jobDayLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobDayLogCreateManyArgs>(args?: SelectSubset<T, JobDayLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobDayLogs and returns the data saved in the database.
     * @param {JobDayLogCreateManyAndReturnArgs} args - Arguments to create many JobDayLogs.
     * @example
     * // Create many JobDayLogs
     * const jobDayLog = await prisma.jobDayLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobDayLogs and only return the `id`
     * const jobDayLogWithIdOnly = await prisma.jobDayLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobDayLogCreateManyAndReturnArgs>(args?: SelectSubset<T, JobDayLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobDayLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a JobDayLog.
     * @param {JobDayLogDeleteArgs} args - Arguments to delete one JobDayLog.
     * @example
     * // Delete one JobDayLog
     * const JobDayLog = await prisma.jobDayLog.delete({
     *   where: {
     *     // ... filter to delete one JobDayLog
     *   }
     * })
     * 
     */
    delete<T extends JobDayLogDeleteArgs>(args: SelectSubset<T, JobDayLogDeleteArgs<ExtArgs>>): Prisma__JobDayLogClient<$Result.GetResult<Prisma.$JobDayLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one JobDayLog.
     * @param {JobDayLogUpdateArgs} args - Arguments to update one JobDayLog.
     * @example
     * // Update one JobDayLog
     * const jobDayLog = await prisma.jobDayLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobDayLogUpdateArgs>(args: SelectSubset<T, JobDayLogUpdateArgs<ExtArgs>>): Prisma__JobDayLogClient<$Result.GetResult<Prisma.$JobDayLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more JobDayLogs.
     * @param {JobDayLogDeleteManyArgs} args - Arguments to filter JobDayLogs to delete.
     * @example
     * // Delete a few JobDayLogs
     * const { count } = await prisma.jobDayLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobDayLogDeleteManyArgs>(args?: SelectSubset<T, JobDayLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobDayLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobDayLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobDayLogs
     * const jobDayLog = await prisma.jobDayLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobDayLogUpdateManyArgs>(args: SelectSubset<T, JobDayLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JobDayLog.
     * @param {JobDayLogUpsertArgs} args - Arguments to update or create a JobDayLog.
     * @example
     * // Update or create a JobDayLog
     * const jobDayLog = await prisma.jobDayLog.upsert({
     *   create: {
     *     // ... data to create a JobDayLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobDayLog we want to update
     *   }
     * })
     */
    upsert<T extends JobDayLogUpsertArgs>(args: SelectSubset<T, JobDayLogUpsertArgs<ExtArgs>>): Prisma__JobDayLogClient<$Result.GetResult<Prisma.$JobDayLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of JobDayLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobDayLogCountArgs} args - Arguments to filter JobDayLogs to count.
     * @example
     * // Count the number of JobDayLogs
     * const count = await prisma.jobDayLog.count({
     *   where: {
     *     // ... the filter for the JobDayLogs we want to count
     *   }
     * })
    **/
    count<T extends JobDayLogCountArgs>(
      args?: Subset<T, JobDayLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobDayLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobDayLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobDayLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobDayLogAggregateArgs>(args: Subset<T, JobDayLogAggregateArgs>): Prisma.PrismaPromise<GetJobDayLogAggregateType<T>>

    /**
     * Group by JobDayLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobDayLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobDayLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobDayLogGroupByArgs['orderBy'] }
        : { orderBy?: JobDayLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobDayLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobDayLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobDayLog model
   */
  readonly fields: JobDayLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobDayLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobDayLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    job<T extends JobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobDefaultArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobDayLog model
   */ 
  interface JobDayLogFieldRefs {
    readonly id: FieldRef<"JobDayLog", 'String'>
    readonly date: FieldRef<"JobDayLog", 'DateTime'>
    readonly userId: FieldRef<"JobDayLog", 'String'>
    readonly jobId: FieldRef<"JobDayLog", 'String'>
    readonly startTime: FieldRef<"JobDayLog", 'DateTime'>
    readonly endTime: FieldRef<"JobDayLog", 'DateTime'>
    readonly lunchStart: FieldRef<"JobDayLog", 'DateTime'>
    readonly lunchEnd: FieldRef<"JobDayLog", 'DateTime'>
    readonly checkInLatitude: FieldRef<"JobDayLog", 'Decimal'>
    readonly checkInLongitude: FieldRef<"JobDayLog", 'Decimal'>
    readonly checkInAddress: FieldRef<"JobDayLog", 'String'>
    readonly workCompleted: FieldRef<"JobDayLog", 'String'>
    readonly materialsUsed: FieldRef<"JobDayLog", 'String'>
    readonly issuesEncountered: FieldRef<"JobDayLog", 'String'>
    readonly startFormData: FieldRef<"JobDayLog", 'Json'>
    readonly dailyFormData: FieldRef<"JobDayLog", 'Json'>
    readonly endFormData: FieldRef<"JobDayLog", 'Json'>
    readonly photos: FieldRef<"JobDayLog", 'String[]'>
    readonly isCompliant: FieldRef<"JobDayLog", 'Boolean'>
    readonly complianceNotes: FieldRef<"JobDayLog", 'String'>
    readonly syncStatus: FieldRef<"JobDayLog", 'SyncStatus'>
    readonly createdAt: FieldRef<"JobDayLog", 'DateTime'>
    readonly updatedAt: FieldRef<"JobDayLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JobDayLog findUnique
   */
  export type JobDayLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobDayLog
     */
    select?: JobDayLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobDayLogInclude<ExtArgs> | null
    /**
     * Filter, which JobDayLog to fetch.
     */
    where: JobDayLogWhereUniqueInput
  }

  /**
   * JobDayLog findUniqueOrThrow
   */
  export type JobDayLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobDayLog
     */
    select?: JobDayLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobDayLogInclude<ExtArgs> | null
    /**
     * Filter, which JobDayLog to fetch.
     */
    where: JobDayLogWhereUniqueInput
  }

  /**
   * JobDayLog findFirst
   */
  export type JobDayLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobDayLog
     */
    select?: JobDayLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobDayLogInclude<ExtArgs> | null
    /**
     * Filter, which JobDayLog to fetch.
     */
    where?: JobDayLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobDayLogs to fetch.
     */
    orderBy?: JobDayLogOrderByWithRelationInput | JobDayLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobDayLogs.
     */
    cursor?: JobDayLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobDayLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobDayLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobDayLogs.
     */
    distinct?: JobDayLogScalarFieldEnum | JobDayLogScalarFieldEnum[]
  }

  /**
   * JobDayLog findFirstOrThrow
   */
  export type JobDayLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobDayLog
     */
    select?: JobDayLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobDayLogInclude<ExtArgs> | null
    /**
     * Filter, which JobDayLog to fetch.
     */
    where?: JobDayLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobDayLogs to fetch.
     */
    orderBy?: JobDayLogOrderByWithRelationInput | JobDayLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobDayLogs.
     */
    cursor?: JobDayLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobDayLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobDayLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobDayLogs.
     */
    distinct?: JobDayLogScalarFieldEnum | JobDayLogScalarFieldEnum[]
  }

  /**
   * JobDayLog findMany
   */
  export type JobDayLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobDayLog
     */
    select?: JobDayLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobDayLogInclude<ExtArgs> | null
    /**
     * Filter, which JobDayLogs to fetch.
     */
    where?: JobDayLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobDayLogs to fetch.
     */
    orderBy?: JobDayLogOrderByWithRelationInput | JobDayLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobDayLogs.
     */
    cursor?: JobDayLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobDayLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobDayLogs.
     */
    skip?: number
    distinct?: JobDayLogScalarFieldEnum | JobDayLogScalarFieldEnum[]
  }

  /**
   * JobDayLog create
   */
  export type JobDayLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobDayLog
     */
    select?: JobDayLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobDayLogInclude<ExtArgs> | null
    /**
     * The data needed to create a JobDayLog.
     */
    data: XOR<JobDayLogCreateInput, JobDayLogUncheckedCreateInput>
  }

  /**
   * JobDayLog createMany
   */
  export type JobDayLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobDayLogs.
     */
    data: JobDayLogCreateManyInput | JobDayLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobDayLog createManyAndReturn
   */
  export type JobDayLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobDayLog
     */
    select?: JobDayLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many JobDayLogs.
     */
    data: JobDayLogCreateManyInput | JobDayLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobDayLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobDayLog update
   */
  export type JobDayLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobDayLog
     */
    select?: JobDayLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobDayLogInclude<ExtArgs> | null
    /**
     * The data needed to update a JobDayLog.
     */
    data: XOR<JobDayLogUpdateInput, JobDayLogUncheckedUpdateInput>
    /**
     * Choose, which JobDayLog to update.
     */
    where: JobDayLogWhereUniqueInput
  }

  /**
   * JobDayLog updateMany
   */
  export type JobDayLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobDayLogs.
     */
    data: XOR<JobDayLogUpdateManyMutationInput, JobDayLogUncheckedUpdateManyInput>
    /**
     * Filter which JobDayLogs to update
     */
    where?: JobDayLogWhereInput
  }

  /**
   * JobDayLog upsert
   */
  export type JobDayLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobDayLog
     */
    select?: JobDayLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobDayLogInclude<ExtArgs> | null
    /**
     * The filter to search for the JobDayLog to update in case it exists.
     */
    where: JobDayLogWhereUniqueInput
    /**
     * In case the JobDayLog found by the `where` argument doesn't exist, create a new JobDayLog with this data.
     */
    create: XOR<JobDayLogCreateInput, JobDayLogUncheckedCreateInput>
    /**
     * In case the JobDayLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobDayLogUpdateInput, JobDayLogUncheckedUpdateInput>
  }

  /**
   * JobDayLog delete
   */
  export type JobDayLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobDayLog
     */
    select?: JobDayLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobDayLogInclude<ExtArgs> | null
    /**
     * Filter which JobDayLog to delete.
     */
    where: JobDayLogWhereUniqueInput
  }

  /**
   * JobDayLog deleteMany
   */
  export type JobDayLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobDayLogs to delete
     */
    where?: JobDayLogWhereInput
  }

  /**
   * JobDayLog without action
   */
  export type JobDayLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobDayLog
     */
    select?: JobDayLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobDayLogInclude<ExtArgs> | null
  }


  /**
   * Model InstallerCompany
   */

  export type AggregateInstallerCompany = {
    _count: InstallerCompanyCountAggregateOutputType | null
    _min: InstallerCompanyMinAggregateOutputType | null
    _max: InstallerCompanyMaxAggregateOutputType | null
  }

  export type InstallerCompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    contactEmail: string | null
    contactPhone: string | null
    address: string | null
    insuranceExpiry: Date | null
    dbsExpiry: Date | null
    contractSigned: boolean | null
    contractSignedAt: Date | null
    isActive: boolean | null
    isSuspended: boolean | null
    suspensionReason: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstallerCompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    contactEmail: string | null
    contactPhone: string | null
    address: string | null
    insuranceExpiry: Date | null
    dbsExpiry: Date | null
    contractSigned: boolean | null
    contractSignedAt: Date | null
    isActive: boolean | null
    isSuspended: boolean | null
    suspensionReason: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstallerCompanyCountAggregateOutputType = {
    id: number
    name: number
    contactEmail: number
    contactPhone: number
    address: number
    insuranceExpiry: number
    dbsExpiry: number
    contractSigned: number
    contractSignedAt: number
    isActive: number
    isSuspended: number
    suspensionReason: number
    ownerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InstallerCompanyMinAggregateInputType = {
    id?: true
    name?: true
    contactEmail?: true
    contactPhone?: true
    address?: true
    insuranceExpiry?: true
    dbsExpiry?: true
    contractSigned?: true
    contractSignedAt?: true
    isActive?: true
    isSuspended?: true
    suspensionReason?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstallerCompanyMaxAggregateInputType = {
    id?: true
    name?: true
    contactEmail?: true
    contactPhone?: true
    address?: true
    insuranceExpiry?: true
    dbsExpiry?: true
    contractSigned?: true
    contractSignedAt?: true
    isActive?: true
    isSuspended?: true
    suspensionReason?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstallerCompanyCountAggregateInputType = {
    id?: true
    name?: true
    contactEmail?: true
    contactPhone?: true
    address?: true
    insuranceExpiry?: true
    dbsExpiry?: true
    contractSigned?: true
    contractSignedAt?: true
    isActive?: true
    isSuspended?: true
    suspensionReason?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InstallerCompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstallerCompany to aggregate.
     */
    where?: InstallerCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstallerCompanies to fetch.
     */
    orderBy?: InstallerCompanyOrderByWithRelationInput | InstallerCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstallerCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstallerCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstallerCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstallerCompanies
    **/
    _count?: true | InstallerCompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstallerCompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstallerCompanyMaxAggregateInputType
  }

  export type GetInstallerCompanyAggregateType<T extends InstallerCompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateInstallerCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstallerCompany[P]>
      : GetScalarType<T[P], AggregateInstallerCompany[P]>
  }




  export type InstallerCompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstallerCompanyWhereInput
    orderBy?: InstallerCompanyOrderByWithAggregationInput | InstallerCompanyOrderByWithAggregationInput[]
    by: InstallerCompanyScalarFieldEnum[] | InstallerCompanyScalarFieldEnum
    having?: InstallerCompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstallerCompanyCountAggregateInputType | true
    _min?: InstallerCompanyMinAggregateInputType
    _max?: InstallerCompanyMaxAggregateInputType
  }

  export type InstallerCompanyGroupByOutputType = {
    id: string
    name: string
    contactEmail: string
    contactPhone: string
    address: string | null
    insuranceExpiry: Date | null
    dbsExpiry: Date | null
    contractSigned: boolean
    contractSignedAt: Date | null
    isActive: boolean
    isSuspended: boolean
    suspensionReason: string | null
    ownerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: InstallerCompanyCountAggregateOutputType | null
    _min: InstallerCompanyMinAggregateOutputType | null
    _max: InstallerCompanyMaxAggregateOutputType | null
  }

  type GetInstallerCompanyGroupByPayload<T extends InstallerCompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstallerCompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstallerCompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstallerCompanyGroupByOutputType[P]>
            : GetScalarType<T[P], InstallerCompanyGroupByOutputType[P]>
        }
      >
    >


  export type InstallerCompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    insuranceExpiry?: boolean
    dbsExpiry?: boolean
    contractSigned?: boolean
    contractSignedAt?: boolean
    isActive?: boolean
    isSuspended?: boolean
    suspensionReason?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | InstallerCompany$ownerArgs<ExtArgs>
    teamMembers?: boolean | InstallerCompany$teamMembersArgs<ExtArgs>
    jobs?: boolean | InstallerCompany$jobsArgs<ExtArgs>
    _count?: boolean | InstallerCompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["installerCompany"]>

  export type InstallerCompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    insuranceExpiry?: boolean
    dbsExpiry?: boolean
    contractSigned?: boolean
    contractSignedAt?: boolean
    isActive?: boolean
    isSuspended?: boolean
    suspensionReason?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | InstallerCompany$ownerArgs<ExtArgs>
  }, ExtArgs["result"]["installerCompany"]>

  export type InstallerCompanySelectScalar = {
    id?: boolean
    name?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    insuranceExpiry?: boolean
    dbsExpiry?: boolean
    contractSigned?: boolean
    contractSignedAt?: boolean
    isActive?: boolean
    isSuspended?: boolean
    suspensionReason?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InstallerCompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | InstallerCompany$ownerArgs<ExtArgs>
    teamMembers?: boolean | InstallerCompany$teamMembersArgs<ExtArgs>
    jobs?: boolean | InstallerCompany$jobsArgs<ExtArgs>
    _count?: boolean | InstallerCompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InstallerCompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | InstallerCompany$ownerArgs<ExtArgs>
  }

  export type $InstallerCompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstallerCompany"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs> | null
      teamMembers: Prisma.$InstallerTeamMemberPayload<ExtArgs>[]
      jobs: Prisma.$JobPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      contactEmail: string
      contactPhone: string
      address: string | null
      insuranceExpiry: Date | null
      dbsExpiry: Date | null
      contractSigned: boolean
      contractSignedAt: Date | null
      isActive: boolean
      isSuspended: boolean
      suspensionReason: string | null
      ownerId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["installerCompany"]>
    composites: {}
  }

  type InstallerCompanyGetPayload<S extends boolean | null | undefined | InstallerCompanyDefaultArgs> = $Result.GetResult<Prisma.$InstallerCompanyPayload, S>

  type InstallerCompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InstallerCompanyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InstallerCompanyCountAggregateInputType | true
    }

  export interface InstallerCompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstallerCompany'], meta: { name: 'InstallerCompany' } }
    /**
     * Find zero or one InstallerCompany that matches the filter.
     * @param {InstallerCompanyFindUniqueArgs} args - Arguments to find a InstallerCompany
     * @example
     * // Get one InstallerCompany
     * const installerCompany = await prisma.installerCompany.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstallerCompanyFindUniqueArgs>(args: SelectSubset<T, InstallerCompanyFindUniqueArgs<ExtArgs>>): Prisma__InstallerCompanyClient<$Result.GetResult<Prisma.$InstallerCompanyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InstallerCompany that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InstallerCompanyFindUniqueOrThrowArgs} args - Arguments to find a InstallerCompany
     * @example
     * // Get one InstallerCompany
     * const installerCompany = await prisma.installerCompany.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstallerCompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, InstallerCompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstallerCompanyClient<$Result.GetResult<Prisma.$InstallerCompanyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InstallerCompany that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallerCompanyFindFirstArgs} args - Arguments to find a InstallerCompany
     * @example
     * // Get one InstallerCompany
     * const installerCompany = await prisma.installerCompany.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstallerCompanyFindFirstArgs>(args?: SelectSubset<T, InstallerCompanyFindFirstArgs<ExtArgs>>): Prisma__InstallerCompanyClient<$Result.GetResult<Prisma.$InstallerCompanyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InstallerCompany that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallerCompanyFindFirstOrThrowArgs} args - Arguments to find a InstallerCompany
     * @example
     * // Get one InstallerCompany
     * const installerCompany = await prisma.installerCompany.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstallerCompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, InstallerCompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstallerCompanyClient<$Result.GetResult<Prisma.$InstallerCompanyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InstallerCompanies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallerCompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstallerCompanies
     * const installerCompanies = await prisma.installerCompany.findMany()
     * 
     * // Get first 10 InstallerCompanies
     * const installerCompanies = await prisma.installerCompany.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const installerCompanyWithIdOnly = await prisma.installerCompany.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstallerCompanyFindManyArgs>(args?: SelectSubset<T, InstallerCompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallerCompanyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InstallerCompany.
     * @param {InstallerCompanyCreateArgs} args - Arguments to create a InstallerCompany.
     * @example
     * // Create one InstallerCompany
     * const InstallerCompany = await prisma.installerCompany.create({
     *   data: {
     *     // ... data to create a InstallerCompany
     *   }
     * })
     * 
     */
    create<T extends InstallerCompanyCreateArgs>(args: SelectSubset<T, InstallerCompanyCreateArgs<ExtArgs>>): Prisma__InstallerCompanyClient<$Result.GetResult<Prisma.$InstallerCompanyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InstallerCompanies.
     * @param {InstallerCompanyCreateManyArgs} args - Arguments to create many InstallerCompanies.
     * @example
     * // Create many InstallerCompanies
     * const installerCompany = await prisma.installerCompany.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstallerCompanyCreateManyArgs>(args?: SelectSubset<T, InstallerCompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InstallerCompanies and returns the data saved in the database.
     * @param {InstallerCompanyCreateManyAndReturnArgs} args - Arguments to create many InstallerCompanies.
     * @example
     * // Create many InstallerCompanies
     * const installerCompany = await prisma.installerCompany.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InstallerCompanies and only return the `id`
     * const installerCompanyWithIdOnly = await prisma.installerCompany.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstallerCompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, InstallerCompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallerCompanyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InstallerCompany.
     * @param {InstallerCompanyDeleteArgs} args - Arguments to delete one InstallerCompany.
     * @example
     * // Delete one InstallerCompany
     * const InstallerCompany = await prisma.installerCompany.delete({
     *   where: {
     *     // ... filter to delete one InstallerCompany
     *   }
     * })
     * 
     */
    delete<T extends InstallerCompanyDeleteArgs>(args: SelectSubset<T, InstallerCompanyDeleteArgs<ExtArgs>>): Prisma__InstallerCompanyClient<$Result.GetResult<Prisma.$InstallerCompanyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InstallerCompany.
     * @param {InstallerCompanyUpdateArgs} args - Arguments to update one InstallerCompany.
     * @example
     * // Update one InstallerCompany
     * const installerCompany = await prisma.installerCompany.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstallerCompanyUpdateArgs>(args: SelectSubset<T, InstallerCompanyUpdateArgs<ExtArgs>>): Prisma__InstallerCompanyClient<$Result.GetResult<Prisma.$InstallerCompanyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InstallerCompanies.
     * @param {InstallerCompanyDeleteManyArgs} args - Arguments to filter InstallerCompanies to delete.
     * @example
     * // Delete a few InstallerCompanies
     * const { count } = await prisma.installerCompany.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstallerCompanyDeleteManyArgs>(args?: SelectSubset<T, InstallerCompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstallerCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallerCompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstallerCompanies
     * const installerCompany = await prisma.installerCompany.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstallerCompanyUpdateManyArgs>(args: SelectSubset<T, InstallerCompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InstallerCompany.
     * @param {InstallerCompanyUpsertArgs} args - Arguments to update or create a InstallerCompany.
     * @example
     * // Update or create a InstallerCompany
     * const installerCompany = await prisma.installerCompany.upsert({
     *   create: {
     *     // ... data to create a InstallerCompany
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstallerCompany we want to update
     *   }
     * })
     */
    upsert<T extends InstallerCompanyUpsertArgs>(args: SelectSubset<T, InstallerCompanyUpsertArgs<ExtArgs>>): Prisma__InstallerCompanyClient<$Result.GetResult<Prisma.$InstallerCompanyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InstallerCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallerCompanyCountArgs} args - Arguments to filter InstallerCompanies to count.
     * @example
     * // Count the number of InstallerCompanies
     * const count = await prisma.installerCompany.count({
     *   where: {
     *     // ... the filter for the InstallerCompanies we want to count
     *   }
     * })
    **/
    count<T extends InstallerCompanyCountArgs>(
      args?: Subset<T, InstallerCompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstallerCompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstallerCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallerCompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstallerCompanyAggregateArgs>(args: Subset<T, InstallerCompanyAggregateArgs>): Prisma.PrismaPromise<GetInstallerCompanyAggregateType<T>>

    /**
     * Group by InstallerCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallerCompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstallerCompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstallerCompanyGroupByArgs['orderBy'] }
        : { orderBy?: InstallerCompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstallerCompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstallerCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstallerCompany model
   */
  readonly fields: InstallerCompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstallerCompany.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstallerCompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends InstallerCompany$ownerArgs<ExtArgs> = {}>(args?: Subset<T, InstallerCompany$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    teamMembers<T extends InstallerCompany$teamMembersArgs<ExtArgs> = {}>(args?: Subset<T, InstallerCompany$teamMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallerTeamMemberPayload<ExtArgs>, T, "findMany"> | Null>
    jobs<T extends InstallerCompany$jobsArgs<ExtArgs> = {}>(args?: Subset<T, InstallerCompany$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InstallerCompany model
   */ 
  interface InstallerCompanyFieldRefs {
    readonly id: FieldRef<"InstallerCompany", 'String'>
    readonly name: FieldRef<"InstallerCompany", 'String'>
    readonly contactEmail: FieldRef<"InstallerCompany", 'String'>
    readonly contactPhone: FieldRef<"InstallerCompany", 'String'>
    readonly address: FieldRef<"InstallerCompany", 'String'>
    readonly insuranceExpiry: FieldRef<"InstallerCompany", 'DateTime'>
    readonly dbsExpiry: FieldRef<"InstallerCompany", 'DateTime'>
    readonly contractSigned: FieldRef<"InstallerCompany", 'Boolean'>
    readonly contractSignedAt: FieldRef<"InstallerCompany", 'DateTime'>
    readonly isActive: FieldRef<"InstallerCompany", 'Boolean'>
    readonly isSuspended: FieldRef<"InstallerCompany", 'Boolean'>
    readonly suspensionReason: FieldRef<"InstallerCompany", 'String'>
    readonly ownerId: FieldRef<"InstallerCompany", 'String'>
    readonly createdAt: FieldRef<"InstallerCompany", 'DateTime'>
    readonly updatedAt: FieldRef<"InstallerCompany", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InstallerCompany findUnique
   */
  export type InstallerCompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallerCompany
     */
    select?: InstallerCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallerCompanyInclude<ExtArgs> | null
    /**
     * Filter, which InstallerCompany to fetch.
     */
    where: InstallerCompanyWhereUniqueInput
  }

  /**
   * InstallerCompany findUniqueOrThrow
   */
  export type InstallerCompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallerCompany
     */
    select?: InstallerCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallerCompanyInclude<ExtArgs> | null
    /**
     * Filter, which InstallerCompany to fetch.
     */
    where: InstallerCompanyWhereUniqueInput
  }

  /**
   * InstallerCompany findFirst
   */
  export type InstallerCompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallerCompany
     */
    select?: InstallerCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallerCompanyInclude<ExtArgs> | null
    /**
     * Filter, which InstallerCompany to fetch.
     */
    where?: InstallerCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstallerCompanies to fetch.
     */
    orderBy?: InstallerCompanyOrderByWithRelationInput | InstallerCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstallerCompanies.
     */
    cursor?: InstallerCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstallerCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstallerCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstallerCompanies.
     */
    distinct?: InstallerCompanyScalarFieldEnum | InstallerCompanyScalarFieldEnum[]
  }

  /**
   * InstallerCompany findFirstOrThrow
   */
  export type InstallerCompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallerCompany
     */
    select?: InstallerCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallerCompanyInclude<ExtArgs> | null
    /**
     * Filter, which InstallerCompany to fetch.
     */
    where?: InstallerCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstallerCompanies to fetch.
     */
    orderBy?: InstallerCompanyOrderByWithRelationInput | InstallerCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstallerCompanies.
     */
    cursor?: InstallerCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstallerCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstallerCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstallerCompanies.
     */
    distinct?: InstallerCompanyScalarFieldEnum | InstallerCompanyScalarFieldEnum[]
  }

  /**
   * InstallerCompany findMany
   */
  export type InstallerCompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallerCompany
     */
    select?: InstallerCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallerCompanyInclude<ExtArgs> | null
    /**
     * Filter, which InstallerCompanies to fetch.
     */
    where?: InstallerCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstallerCompanies to fetch.
     */
    orderBy?: InstallerCompanyOrderByWithRelationInput | InstallerCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstallerCompanies.
     */
    cursor?: InstallerCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstallerCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstallerCompanies.
     */
    skip?: number
    distinct?: InstallerCompanyScalarFieldEnum | InstallerCompanyScalarFieldEnum[]
  }

  /**
   * InstallerCompany create
   */
  export type InstallerCompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallerCompany
     */
    select?: InstallerCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallerCompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a InstallerCompany.
     */
    data: XOR<InstallerCompanyCreateInput, InstallerCompanyUncheckedCreateInput>
  }

  /**
   * InstallerCompany createMany
   */
  export type InstallerCompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstallerCompanies.
     */
    data: InstallerCompanyCreateManyInput | InstallerCompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InstallerCompany createManyAndReturn
   */
  export type InstallerCompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallerCompany
     */
    select?: InstallerCompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InstallerCompanies.
     */
    data: InstallerCompanyCreateManyInput | InstallerCompanyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallerCompanyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstallerCompany update
   */
  export type InstallerCompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallerCompany
     */
    select?: InstallerCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallerCompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a InstallerCompany.
     */
    data: XOR<InstallerCompanyUpdateInput, InstallerCompanyUncheckedUpdateInput>
    /**
     * Choose, which InstallerCompany to update.
     */
    where: InstallerCompanyWhereUniqueInput
  }

  /**
   * InstallerCompany updateMany
   */
  export type InstallerCompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstallerCompanies.
     */
    data: XOR<InstallerCompanyUpdateManyMutationInput, InstallerCompanyUncheckedUpdateManyInput>
    /**
     * Filter which InstallerCompanies to update
     */
    where?: InstallerCompanyWhereInput
  }

  /**
   * InstallerCompany upsert
   */
  export type InstallerCompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallerCompany
     */
    select?: InstallerCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallerCompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the InstallerCompany to update in case it exists.
     */
    where: InstallerCompanyWhereUniqueInput
    /**
     * In case the InstallerCompany found by the `where` argument doesn't exist, create a new InstallerCompany with this data.
     */
    create: XOR<InstallerCompanyCreateInput, InstallerCompanyUncheckedCreateInput>
    /**
     * In case the InstallerCompany was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstallerCompanyUpdateInput, InstallerCompanyUncheckedUpdateInput>
  }

  /**
   * InstallerCompany delete
   */
  export type InstallerCompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallerCompany
     */
    select?: InstallerCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallerCompanyInclude<ExtArgs> | null
    /**
     * Filter which InstallerCompany to delete.
     */
    where: InstallerCompanyWhereUniqueInput
  }

  /**
   * InstallerCompany deleteMany
   */
  export type InstallerCompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstallerCompanies to delete
     */
    where?: InstallerCompanyWhereInput
  }

  /**
   * InstallerCompany.owner
   */
  export type InstallerCompany$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * InstallerCompany.teamMembers
   */
  export type InstallerCompany$teamMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallerTeamMember
     */
    select?: InstallerTeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallerTeamMemberInclude<ExtArgs> | null
    where?: InstallerTeamMemberWhereInput
    orderBy?: InstallerTeamMemberOrderByWithRelationInput | InstallerTeamMemberOrderByWithRelationInput[]
    cursor?: InstallerTeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstallerTeamMemberScalarFieldEnum | InstallerTeamMemberScalarFieldEnum[]
  }

  /**
   * InstallerCompany.jobs
   */
  export type InstallerCompany$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    cursor?: JobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * InstallerCompany without action
   */
  export type InstallerCompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallerCompany
     */
    select?: InstallerCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallerCompanyInclude<ExtArgs> | null
  }


  /**
   * Model InstallerTeamMember
   */

  export type AggregateInstallerTeamMember = {
    _count: InstallerTeamMemberCountAggregateOutputType | null
    _min: InstallerTeamMemberMinAggregateOutputType | null
    _max: InstallerTeamMemberMaxAggregateOutputType | null
  }

  export type InstallerTeamMemberMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    dbsExpiry: Date | null
    isActive: boolean | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstallerTeamMemberMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    dbsExpiry: Date | null
    isActive: boolean | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstallerTeamMemberCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    phone: number
    dbsExpiry: number
    isActive: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InstallerTeamMemberMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    dbsExpiry?: true
    isActive?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstallerTeamMemberMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    dbsExpiry?: true
    isActive?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstallerTeamMemberCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    dbsExpiry?: true
    isActive?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InstallerTeamMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstallerTeamMember to aggregate.
     */
    where?: InstallerTeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstallerTeamMembers to fetch.
     */
    orderBy?: InstallerTeamMemberOrderByWithRelationInput | InstallerTeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstallerTeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstallerTeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstallerTeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstallerTeamMembers
    **/
    _count?: true | InstallerTeamMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstallerTeamMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstallerTeamMemberMaxAggregateInputType
  }

  export type GetInstallerTeamMemberAggregateType<T extends InstallerTeamMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateInstallerTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstallerTeamMember[P]>
      : GetScalarType<T[P], AggregateInstallerTeamMember[P]>
  }




  export type InstallerTeamMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstallerTeamMemberWhereInput
    orderBy?: InstallerTeamMemberOrderByWithAggregationInput | InstallerTeamMemberOrderByWithAggregationInput[]
    by: InstallerTeamMemberScalarFieldEnum[] | InstallerTeamMemberScalarFieldEnum
    having?: InstallerTeamMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstallerTeamMemberCountAggregateInputType | true
    _min?: InstallerTeamMemberMinAggregateInputType
    _max?: InstallerTeamMemberMaxAggregateInputType
  }

  export type InstallerTeamMemberGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    email: string | null
    phone: string | null
    dbsExpiry: Date | null
    isActive: boolean
    companyId: string
    createdAt: Date
    updatedAt: Date
    _count: InstallerTeamMemberCountAggregateOutputType | null
    _min: InstallerTeamMemberMinAggregateOutputType | null
    _max: InstallerTeamMemberMaxAggregateOutputType | null
  }

  type GetInstallerTeamMemberGroupByPayload<T extends InstallerTeamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstallerTeamMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstallerTeamMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstallerTeamMemberGroupByOutputType[P]>
            : GetScalarType<T[P], InstallerTeamMemberGroupByOutputType[P]>
        }
      >
    >


  export type InstallerTeamMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    dbsExpiry?: boolean
    isActive?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | InstallerCompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["installerTeamMember"]>

  export type InstallerTeamMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    dbsExpiry?: boolean
    isActive?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | InstallerCompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["installerTeamMember"]>

  export type InstallerTeamMemberSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    dbsExpiry?: boolean
    isActive?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InstallerTeamMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | InstallerCompanyDefaultArgs<ExtArgs>
  }
  export type InstallerTeamMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | InstallerCompanyDefaultArgs<ExtArgs>
  }

  export type $InstallerTeamMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstallerTeamMember"
    objects: {
      company: Prisma.$InstallerCompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      email: string | null
      phone: string | null
      dbsExpiry: Date | null
      isActive: boolean
      companyId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["installerTeamMember"]>
    composites: {}
  }

  type InstallerTeamMemberGetPayload<S extends boolean | null | undefined | InstallerTeamMemberDefaultArgs> = $Result.GetResult<Prisma.$InstallerTeamMemberPayload, S>

  type InstallerTeamMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InstallerTeamMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InstallerTeamMemberCountAggregateInputType | true
    }

  export interface InstallerTeamMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstallerTeamMember'], meta: { name: 'InstallerTeamMember' } }
    /**
     * Find zero or one InstallerTeamMember that matches the filter.
     * @param {InstallerTeamMemberFindUniqueArgs} args - Arguments to find a InstallerTeamMember
     * @example
     * // Get one InstallerTeamMember
     * const installerTeamMember = await prisma.installerTeamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstallerTeamMemberFindUniqueArgs>(args: SelectSubset<T, InstallerTeamMemberFindUniqueArgs<ExtArgs>>): Prisma__InstallerTeamMemberClient<$Result.GetResult<Prisma.$InstallerTeamMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InstallerTeamMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InstallerTeamMemberFindUniqueOrThrowArgs} args - Arguments to find a InstallerTeamMember
     * @example
     * // Get one InstallerTeamMember
     * const installerTeamMember = await prisma.installerTeamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstallerTeamMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, InstallerTeamMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstallerTeamMemberClient<$Result.GetResult<Prisma.$InstallerTeamMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InstallerTeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallerTeamMemberFindFirstArgs} args - Arguments to find a InstallerTeamMember
     * @example
     * // Get one InstallerTeamMember
     * const installerTeamMember = await prisma.installerTeamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstallerTeamMemberFindFirstArgs>(args?: SelectSubset<T, InstallerTeamMemberFindFirstArgs<ExtArgs>>): Prisma__InstallerTeamMemberClient<$Result.GetResult<Prisma.$InstallerTeamMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InstallerTeamMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallerTeamMemberFindFirstOrThrowArgs} args - Arguments to find a InstallerTeamMember
     * @example
     * // Get one InstallerTeamMember
     * const installerTeamMember = await prisma.installerTeamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstallerTeamMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, InstallerTeamMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstallerTeamMemberClient<$Result.GetResult<Prisma.$InstallerTeamMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InstallerTeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallerTeamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstallerTeamMembers
     * const installerTeamMembers = await prisma.installerTeamMember.findMany()
     * 
     * // Get first 10 InstallerTeamMembers
     * const installerTeamMembers = await prisma.installerTeamMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const installerTeamMemberWithIdOnly = await prisma.installerTeamMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstallerTeamMemberFindManyArgs>(args?: SelectSubset<T, InstallerTeamMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallerTeamMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InstallerTeamMember.
     * @param {InstallerTeamMemberCreateArgs} args - Arguments to create a InstallerTeamMember.
     * @example
     * // Create one InstallerTeamMember
     * const InstallerTeamMember = await prisma.installerTeamMember.create({
     *   data: {
     *     // ... data to create a InstallerTeamMember
     *   }
     * })
     * 
     */
    create<T extends InstallerTeamMemberCreateArgs>(args: SelectSubset<T, InstallerTeamMemberCreateArgs<ExtArgs>>): Prisma__InstallerTeamMemberClient<$Result.GetResult<Prisma.$InstallerTeamMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InstallerTeamMembers.
     * @param {InstallerTeamMemberCreateManyArgs} args - Arguments to create many InstallerTeamMembers.
     * @example
     * // Create many InstallerTeamMembers
     * const installerTeamMember = await prisma.installerTeamMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstallerTeamMemberCreateManyArgs>(args?: SelectSubset<T, InstallerTeamMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InstallerTeamMembers and returns the data saved in the database.
     * @param {InstallerTeamMemberCreateManyAndReturnArgs} args - Arguments to create many InstallerTeamMembers.
     * @example
     * // Create many InstallerTeamMembers
     * const installerTeamMember = await prisma.installerTeamMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InstallerTeamMembers and only return the `id`
     * const installerTeamMemberWithIdOnly = await prisma.installerTeamMember.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstallerTeamMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, InstallerTeamMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallerTeamMemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InstallerTeamMember.
     * @param {InstallerTeamMemberDeleteArgs} args - Arguments to delete one InstallerTeamMember.
     * @example
     * // Delete one InstallerTeamMember
     * const InstallerTeamMember = await prisma.installerTeamMember.delete({
     *   where: {
     *     // ... filter to delete one InstallerTeamMember
     *   }
     * })
     * 
     */
    delete<T extends InstallerTeamMemberDeleteArgs>(args: SelectSubset<T, InstallerTeamMemberDeleteArgs<ExtArgs>>): Prisma__InstallerTeamMemberClient<$Result.GetResult<Prisma.$InstallerTeamMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InstallerTeamMember.
     * @param {InstallerTeamMemberUpdateArgs} args - Arguments to update one InstallerTeamMember.
     * @example
     * // Update one InstallerTeamMember
     * const installerTeamMember = await prisma.installerTeamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstallerTeamMemberUpdateArgs>(args: SelectSubset<T, InstallerTeamMemberUpdateArgs<ExtArgs>>): Prisma__InstallerTeamMemberClient<$Result.GetResult<Prisma.$InstallerTeamMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InstallerTeamMembers.
     * @param {InstallerTeamMemberDeleteManyArgs} args - Arguments to filter InstallerTeamMembers to delete.
     * @example
     * // Delete a few InstallerTeamMembers
     * const { count } = await prisma.installerTeamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstallerTeamMemberDeleteManyArgs>(args?: SelectSubset<T, InstallerTeamMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstallerTeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallerTeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstallerTeamMembers
     * const installerTeamMember = await prisma.installerTeamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstallerTeamMemberUpdateManyArgs>(args: SelectSubset<T, InstallerTeamMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InstallerTeamMember.
     * @param {InstallerTeamMemberUpsertArgs} args - Arguments to update or create a InstallerTeamMember.
     * @example
     * // Update or create a InstallerTeamMember
     * const installerTeamMember = await prisma.installerTeamMember.upsert({
     *   create: {
     *     // ... data to create a InstallerTeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstallerTeamMember we want to update
     *   }
     * })
     */
    upsert<T extends InstallerTeamMemberUpsertArgs>(args: SelectSubset<T, InstallerTeamMemberUpsertArgs<ExtArgs>>): Prisma__InstallerTeamMemberClient<$Result.GetResult<Prisma.$InstallerTeamMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InstallerTeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallerTeamMemberCountArgs} args - Arguments to filter InstallerTeamMembers to count.
     * @example
     * // Count the number of InstallerTeamMembers
     * const count = await prisma.installerTeamMember.count({
     *   where: {
     *     // ... the filter for the InstallerTeamMembers we want to count
     *   }
     * })
    **/
    count<T extends InstallerTeamMemberCountArgs>(
      args?: Subset<T, InstallerTeamMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstallerTeamMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstallerTeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallerTeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstallerTeamMemberAggregateArgs>(args: Subset<T, InstallerTeamMemberAggregateArgs>): Prisma.PrismaPromise<GetInstallerTeamMemberAggregateType<T>>

    /**
     * Group by InstallerTeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallerTeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstallerTeamMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstallerTeamMemberGroupByArgs['orderBy'] }
        : { orderBy?: InstallerTeamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstallerTeamMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstallerTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstallerTeamMember model
   */
  readonly fields: InstallerTeamMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstallerTeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstallerTeamMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends InstallerCompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstallerCompanyDefaultArgs<ExtArgs>>): Prisma__InstallerCompanyClient<$Result.GetResult<Prisma.$InstallerCompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InstallerTeamMember model
   */ 
  interface InstallerTeamMemberFieldRefs {
    readonly id: FieldRef<"InstallerTeamMember", 'String'>
    readonly firstName: FieldRef<"InstallerTeamMember", 'String'>
    readonly lastName: FieldRef<"InstallerTeamMember", 'String'>
    readonly email: FieldRef<"InstallerTeamMember", 'String'>
    readonly phone: FieldRef<"InstallerTeamMember", 'String'>
    readonly dbsExpiry: FieldRef<"InstallerTeamMember", 'DateTime'>
    readonly isActive: FieldRef<"InstallerTeamMember", 'Boolean'>
    readonly companyId: FieldRef<"InstallerTeamMember", 'String'>
    readonly createdAt: FieldRef<"InstallerTeamMember", 'DateTime'>
    readonly updatedAt: FieldRef<"InstallerTeamMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InstallerTeamMember findUnique
   */
  export type InstallerTeamMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallerTeamMember
     */
    select?: InstallerTeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallerTeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which InstallerTeamMember to fetch.
     */
    where: InstallerTeamMemberWhereUniqueInput
  }

  /**
   * InstallerTeamMember findUniqueOrThrow
   */
  export type InstallerTeamMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallerTeamMember
     */
    select?: InstallerTeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallerTeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which InstallerTeamMember to fetch.
     */
    where: InstallerTeamMemberWhereUniqueInput
  }

  /**
   * InstallerTeamMember findFirst
   */
  export type InstallerTeamMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallerTeamMember
     */
    select?: InstallerTeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallerTeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which InstallerTeamMember to fetch.
     */
    where?: InstallerTeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstallerTeamMembers to fetch.
     */
    orderBy?: InstallerTeamMemberOrderByWithRelationInput | InstallerTeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstallerTeamMembers.
     */
    cursor?: InstallerTeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstallerTeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstallerTeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstallerTeamMembers.
     */
    distinct?: InstallerTeamMemberScalarFieldEnum | InstallerTeamMemberScalarFieldEnum[]
  }

  /**
   * InstallerTeamMember findFirstOrThrow
   */
  export type InstallerTeamMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallerTeamMember
     */
    select?: InstallerTeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallerTeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which InstallerTeamMember to fetch.
     */
    where?: InstallerTeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstallerTeamMembers to fetch.
     */
    orderBy?: InstallerTeamMemberOrderByWithRelationInput | InstallerTeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstallerTeamMembers.
     */
    cursor?: InstallerTeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstallerTeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstallerTeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstallerTeamMembers.
     */
    distinct?: InstallerTeamMemberScalarFieldEnum | InstallerTeamMemberScalarFieldEnum[]
  }

  /**
   * InstallerTeamMember findMany
   */
  export type InstallerTeamMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallerTeamMember
     */
    select?: InstallerTeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallerTeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which InstallerTeamMembers to fetch.
     */
    where?: InstallerTeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstallerTeamMembers to fetch.
     */
    orderBy?: InstallerTeamMemberOrderByWithRelationInput | InstallerTeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstallerTeamMembers.
     */
    cursor?: InstallerTeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstallerTeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstallerTeamMembers.
     */
    skip?: number
    distinct?: InstallerTeamMemberScalarFieldEnum | InstallerTeamMemberScalarFieldEnum[]
  }

  /**
   * InstallerTeamMember create
   */
  export type InstallerTeamMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallerTeamMember
     */
    select?: InstallerTeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallerTeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a InstallerTeamMember.
     */
    data: XOR<InstallerTeamMemberCreateInput, InstallerTeamMemberUncheckedCreateInput>
  }

  /**
   * InstallerTeamMember createMany
   */
  export type InstallerTeamMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstallerTeamMembers.
     */
    data: InstallerTeamMemberCreateManyInput | InstallerTeamMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InstallerTeamMember createManyAndReturn
   */
  export type InstallerTeamMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallerTeamMember
     */
    select?: InstallerTeamMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InstallerTeamMembers.
     */
    data: InstallerTeamMemberCreateManyInput | InstallerTeamMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallerTeamMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstallerTeamMember update
   */
  export type InstallerTeamMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallerTeamMember
     */
    select?: InstallerTeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallerTeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a InstallerTeamMember.
     */
    data: XOR<InstallerTeamMemberUpdateInput, InstallerTeamMemberUncheckedUpdateInput>
    /**
     * Choose, which InstallerTeamMember to update.
     */
    where: InstallerTeamMemberWhereUniqueInput
  }

  /**
   * InstallerTeamMember updateMany
   */
  export type InstallerTeamMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstallerTeamMembers.
     */
    data: XOR<InstallerTeamMemberUpdateManyMutationInput, InstallerTeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which InstallerTeamMembers to update
     */
    where?: InstallerTeamMemberWhereInput
  }

  /**
   * InstallerTeamMember upsert
   */
  export type InstallerTeamMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallerTeamMember
     */
    select?: InstallerTeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallerTeamMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the InstallerTeamMember to update in case it exists.
     */
    where: InstallerTeamMemberWhereUniqueInput
    /**
     * In case the InstallerTeamMember found by the `where` argument doesn't exist, create a new InstallerTeamMember with this data.
     */
    create: XOR<InstallerTeamMemberCreateInput, InstallerTeamMemberUncheckedCreateInput>
    /**
     * In case the InstallerTeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstallerTeamMemberUpdateInput, InstallerTeamMemberUncheckedUpdateInput>
  }

  /**
   * InstallerTeamMember delete
   */
  export type InstallerTeamMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallerTeamMember
     */
    select?: InstallerTeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallerTeamMemberInclude<ExtArgs> | null
    /**
     * Filter which InstallerTeamMember to delete.
     */
    where: InstallerTeamMemberWhereUniqueInput
  }

  /**
   * InstallerTeamMember deleteMany
   */
  export type InstallerTeamMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstallerTeamMembers to delete
     */
    where?: InstallerTeamMemberWhereInput
  }

  /**
   * InstallerTeamMember without action
   */
  export type InstallerTeamMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallerTeamMember
     */
    select?: InstallerTeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallerTeamMemberInclude<ExtArgs> | null
  }


  /**
   * Model DesignVersion
   */

  export type AggregateDesignVersion = {
    _count: DesignVersionCountAggregateOutputType | null
    _avg: DesignVersionAvgAggregateOutputType | null
    _sum: DesignVersionSumAggregateOutputType | null
    _min: DesignVersionMinAggregateOutputType | null
    _max: DesignVersionMaxAggregateOutputType | null
  }

  export type DesignVersionAvgAggregateOutputType = {
    version: number | null
  }

  export type DesignVersionSumAggregateOutputType = {
    version: number | null
  }

  export type DesignVersionMinAggregateOutputType = {
    id: string | null
    version: number | null
    title: string | null
    description: string | null
    status: $Enums.DesignStatus | null
    specSheetUrl: string | null
    isClientVisible: boolean | null
    clientViewedAt: Date | null
    clientApprovedAt: Date | null
    clientFeedback: string | null
    jobId: string | null
    designerId: string | null
    isFinal: boolean | null
    lockedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DesignVersionMaxAggregateOutputType = {
    id: string | null
    version: number | null
    title: string | null
    description: string | null
    status: $Enums.DesignStatus | null
    specSheetUrl: string | null
    isClientVisible: boolean | null
    clientViewedAt: Date | null
    clientApprovedAt: Date | null
    clientFeedback: string | null
    jobId: string | null
    designerId: string | null
    isFinal: boolean | null
    lockedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DesignVersionCountAggregateOutputType = {
    id: number
    version: number
    title: number
    description: number
    status: number
    renderUrls: number
    planUrls: number
    specSheetUrl: number
    isClientVisible: number
    clientViewedAt: number
    clientApprovedAt: number
    clientFeedback: number
    jobId: number
    designerId: number
    isFinal: number
    lockedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DesignVersionAvgAggregateInputType = {
    version?: true
  }

  export type DesignVersionSumAggregateInputType = {
    version?: true
  }

  export type DesignVersionMinAggregateInputType = {
    id?: true
    version?: true
    title?: true
    description?: true
    status?: true
    specSheetUrl?: true
    isClientVisible?: true
    clientViewedAt?: true
    clientApprovedAt?: true
    clientFeedback?: true
    jobId?: true
    designerId?: true
    isFinal?: true
    lockedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DesignVersionMaxAggregateInputType = {
    id?: true
    version?: true
    title?: true
    description?: true
    status?: true
    specSheetUrl?: true
    isClientVisible?: true
    clientViewedAt?: true
    clientApprovedAt?: true
    clientFeedback?: true
    jobId?: true
    designerId?: true
    isFinal?: true
    lockedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DesignVersionCountAggregateInputType = {
    id?: true
    version?: true
    title?: true
    description?: true
    status?: true
    renderUrls?: true
    planUrls?: true
    specSheetUrl?: true
    isClientVisible?: true
    clientViewedAt?: true
    clientApprovedAt?: true
    clientFeedback?: true
    jobId?: true
    designerId?: true
    isFinal?: true
    lockedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DesignVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DesignVersion to aggregate.
     */
    where?: DesignVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignVersions to fetch.
     */
    orderBy?: DesignVersionOrderByWithRelationInput | DesignVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DesignVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DesignVersions
    **/
    _count?: true | DesignVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DesignVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DesignVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DesignVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DesignVersionMaxAggregateInputType
  }

  export type GetDesignVersionAggregateType<T extends DesignVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateDesignVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDesignVersion[P]>
      : GetScalarType<T[P], AggregateDesignVersion[P]>
  }




  export type DesignVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignVersionWhereInput
    orderBy?: DesignVersionOrderByWithAggregationInput | DesignVersionOrderByWithAggregationInput[]
    by: DesignVersionScalarFieldEnum[] | DesignVersionScalarFieldEnum
    having?: DesignVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DesignVersionCountAggregateInputType | true
    _avg?: DesignVersionAvgAggregateInputType
    _sum?: DesignVersionSumAggregateInputType
    _min?: DesignVersionMinAggregateInputType
    _max?: DesignVersionMaxAggregateInputType
  }

  export type DesignVersionGroupByOutputType = {
    id: string
    version: number
    title: string
    description: string | null
    status: $Enums.DesignStatus
    renderUrls: string[]
    planUrls: string[]
    specSheetUrl: string | null
    isClientVisible: boolean
    clientViewedAt: Date | null
    clientApprovedAt: Date | null
    clientFeedback: string | null
    jobId: string
    designerId: string
    isFinal: boolean
    lockedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DesignVersionCountAggregateOutputType | null
    _avg: DesignVersionAvgAggregateOutputType | null
    _sum: DesignVersionSumAggregateOutputType | null
    _min: DesignVersionMinAggregateOutputType | null
    _max: DesignVersionMaxAggregateOutputType | null
  }

  type GetDesignVersionGroupByPayload<T extends DesignVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DesignVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DesignVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DesignVersionGroupByOutputType[P]>
            : GetScalarType<T[P], DesignVersionGroupByOutputType[P]>
        }
      >
    >


  export type DesignVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    renderUrls?: boolean
    planUrls?: boolean
    specSheetUrl?: boolean
    isClientVisible?: boolean
    clientViewedAt?: boolean
    clientApprovedAt?: boolean
    clientFeedback?: boolean
    jobId?: boolean
    designerId?: boolean
    isFinal?: boolean
    lockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
    designer?: boolean | UserDefaultArgs<ExtArgs>
    clashTickets?: boolean | DesignVersion$clashTicketsArgs<ExtArgs>
    _count?: boolean | DesignVersionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["designVersion"]>

  export type DesignVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    renderUrls?: boolean
    planUrls?: boolean
    specSheetUrl?: boolean
    isClientVisible?: boolean
    clientViewedAt?: boolean
    clientApprovedAt?: boolean
    clientFeedback?: boolean
    jobId?: boolean
    designerId?: boolean
    isFinal?: boolean
    lockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
    designer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["designVersion"]>

  export type DesignVersionSelectScalar = {
    id?: boolean
    version?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    renderUrls?: boolean
    planUrls?: boolean
    specSheetUrl?: boolean
    isClientVisible?: boolean
    clientViewedAt?: boolean
    clientApprovedAt?: boolean
    clientFeedback?: boolean
    jobId?: boolean
    designerId?: boolean
    isFinal?: boolean
    lockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DesignVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
    designer?: boolean | UserDefaultArgs<ExtArgs>
    clashTickets?: boolean | DesignVersion$clashTicketsArgs<ExtArgs>
    _count?: boolean | DesignVersionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DesignVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
    designer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DesignVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DesignVersion"
    objects: {
      job: Prisma.$JobPayload<ExtArgs>
      designer: Prisma.$UserPayload<ExtArgs>
      clashTickets: Prisma.$DesignClashTicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      version: number
      title: string
      description: string | null
      status: $Enums.DesignStatus
      renderUrls: string[]
      planUrls: string[]
      specSheetUrl: string | null
      isClientVisible: boolean
      clientViewedAt: Date | null
      clientApprovedAt: Date | null
      clientFeedback: string | null
      jobId: string
      designerId: string
      isFinal: boolean
      lockedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["designVersion"]>
    composites: {}
  }

  type DesignVersionGetPayload<S extends boolean | null | undefined | DesignVersionDefaultArgs> = $Result.GetResult<Prisma.$DesignVersionPayload, S>

  type DesignVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DesignVersionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DesignVersionCountAggregateInputType | true
    }

  export interface DesignVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DesignVersion'], meta: { name: 'DesignVersion' } }
    /**
     * Find zero or one DesignVersion that matches the filter.
     * @param {DesignVersionFindUniqueArgs} args - Arguments to find a DesignVersion
     * @example
     * // Get one DesignVersion
     * const designVersion = await prisma.designVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DesignVersionFindUniqueArgs>(args: SelectSubset<T, DesignVersionFindUniqueArgs<ExtArgs>>): Prisma__DesignVersionClient<$Result.GetResult<Prisma.$DesignVersionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DesignVersion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DesignVersionFindUniqueOrThrowArgs} args - Arguments to find a DesignVersion
     * @example
     * // Get one DesignVersion
     * const designVersion = await prisma.designVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DesignVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, DesignVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DesignVersionClient<$Result.GetResult<Prisma.$DesignVersionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DesignVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignVersionFindFirstArgs} args - Arguments to find a DesignVersion
     * @example
     * // Get one DesignVersion
     * const designVersion = await prisma.designVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DesignVersionFindFirstArgs>(args?: SelectSubset<T, DesignVersionFindFirstArgs<ExtArgs>>): Prisma__DesignVersionClient<$Result.GetResult<Prisma.$DesignVersionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DesignVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignVersionFindFirstOrThrowArgs} args - Arguments to find a DesignVersion
     * @example
     * // Get one DesignVersion
     * const designVersion = await prisma.designVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DesignVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, DesignVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DesignVersionClient<$Result.GetResult<Prisma.$DesignVersionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DesignVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DesignVersions
     * const designVersions = await prisma.designVersion.findMany()
     * 
     * // Get first 10 DesignVersions
     * const designVersions = await prisma.designVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const designVersionWithIdOnly = await prisma.designVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DesignVersionFindManyArgs>(args?: SelectSubset<T, DesignVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignVersionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DesignVersion.
     * @param {DesignVersionCreateArgs} args - Arguments to create a DesignVersion.
     * @example
     * // Create one DesignVersion
     * const DesignVersion = await prisma.designVersion.create({
     *   data: {
     *     // ... data to create a DesignVersion
     *   }
     * })
     * 
     */
    create<T extends DesignVersionCreateArgs>(args: SelectSubset<T, DesignVersionCreateArgs<ExtArgs>>): Prisma__DesignVersionClient<$Result.GetResult<Prisma.$DesignVersionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DesignVersions.
     * @param {DesignVersionCreateManyArgs} args - Arguments to create many DesignVersions.
     * @example
     * // Create many DesignVersions
     * const designVersion = await prisma.designVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DesignVersionCreateManyArgs>(args?: SelectSubset<T, DesignVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DesignVersions and returns the data saved in the database.
     * @param {DesignVersionCreateManyAndReturnArgs} args - Arguments to create many DesignVersions.
     * @example
     * // Create many DesignVersions
     * const designVersion = await prisma.designVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DesignVersions and only return the `id`
     * const designVersionWithIdOnly = await prisma.designVersion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DesignVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, DesignVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignVersionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DesignVersion.
     * @param {DesignVersionDeleteArgs} args - Arguments to delete one DesignVersion.
     * @example
     * // Delete one DesignVersion
     * const DesignVersion = await prisma.designVersion.delete({
     *   where: {
     *     // ... filter to delete one DesignVersion
     *   }
     * })
     * 
     */
    delete<T extends DesignVersionDeleteArgs>(args: SelectSubset<T, DesignVersionDeleteArgs<ExtArgs>>): Prisma__DesignVersionClient<$Result.GetResult<Prisma.$DesignVersionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DesignVersion.
     * @param {DesignVersionUpdateArgs} args - Arguments to update one DesignVersion.
     * @example
     * // Update one DesignVersion
     * const designVersion = await prisma.designVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DesignVersionUpdateArgs>(args: SelectSubset<T, DesignVersionUpdateArgs<ExtArgs>>): Prisma__DesignVersionClient<$Result.GetResult<Prisma.$DesignVersionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DesignVersions.
     * @param {DesignVersionDeleteManyArgs} args - Arguments to filter DesignVersions to delete.
     * @example
     * // Delete a few DesignVersions
     * const { count } = await prisma.designVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DesignVersionDeleteManyArgs>(args?: SelectSubset<T, DesignVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DesignVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DesignVersions
     * const designVersion = await prisma.designVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DesignVersionUpdateManyArgs>(args: SelectSubset<T, DesignVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DesignVersion.
     * @param {DesignVersionUpsertArgs} args - Arguments to update or create a DesignVersion.
     * @example
     * // Update or create a DesignVersion
     * const designVersion = await prisma.designVersion.upsert({
     *   create: {
     *     // ... data to create a DesignVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DesignVersion we want to update
     *   }
     * })
     */
    upsert<T extends DesignVersionUpsertArgs>(args: SelectSubset<T, DesignVersionUpsertArgs<ExtArgs>>): Prisma__DesignVersionClient<$Result.GetResult<Prisma.$DesignVersionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DesignVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignVersionCountArgs} args - Arguments to filter DesignVersions to count.
     * @example
     * // Count the number of DesignVersions
     * const count = await prisma.designVersion.count({
     *   where: {
     *     // ... the filter for the DesignVersions we want to count
     *   }
     * })
    **/
    count<T extends DesignVersionCountArgs>(
      args?: Subset<T, DesignVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DesignVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DesignVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DesignVersionAggregateArgs>(args: Subset<T, DesignVersionAggregateArgs>): Prisma.PrismaPromise<GetDesignVersionAggregateType<T>>

    /**
     * Group by DesignVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DesignVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DesignVersionGroupByArgs['orderBy'] }
        : { orderBy?: DesignVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DesignVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDesignVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DesignVersion model
   */
  readonly fields: DesignVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DesignVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DesignVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends JobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobDefaultArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    designer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    clashTickets<T extends DesignVersion$clashTicketsArgs<ExtArgs> = {}>(args?: Subset<T, DesignVersion$clashTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignClashTicketPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DesignVersion model
   */ 
  interface DesignVersionFieldRefs {
    readonly id: FieldRef<"DesignVersion", 'String'>
    readonly version: FieldRef<"DesignVersion", 'Int'>
    readonly title: FieldRef<"DesignVersion", 'String'>
    readonly description: FieldRef<"DesignVersion", 'String'>
    readonly status: FieldRef<"DesignVersion", 'DesignStatus'>
    readonly renderUrls: FieldRef<"DesignVersion", 'String[]'>
    readonly planUrls: FieldRef<"DesignVersion", 'String[]'>
    readonly specSheetUrl: FieldRef<"DesignVersion", 'String'>
    readonly isClientVisible: FieldRef<"DesignVersion", 'Boolean'>
    readonly clientViewedAt: FieldRef<"DesignVersion", 'DateTime'>
    readonly clientApprovedAt: FieldRef<"DesignVersion", 'DateTime'>
    readonly clientFeedback: FieldRef<"DesignVersion", 'String'>
    readonly jobId: FieldRef<"DesignVersion", 'String'>
    readonly designerId: FieldRef<"DesignVersion", 'String'>
    readonly isFinal: FieldRef<"DesignVersion", 'Boolean'>
    readonly lockedAt: FieldRef<"DesignVersion", 'DateTime'>
    readonly createdAt: FieldRef<"DesignVersion", 'DateTime'>
    readonly updatedAt: FieldRef<"DesignVersion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DesignVersion findUnique
   */
  export type DesignVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignVersion
     */
    select?: DesignVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignVersionInclude<ExtArgs> | null
    /**
     * Filter, which DesignVersion to fetch.
     */
    where: DesignVersionWhereUniqueInput
  }

  /**
   * DesignVersion findUniqueOrThrow
   */
  export type DesignVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignVersion
     */
    select?: DesignVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignVersionInclude<ExtArgs> | null
    /**
     * Filter, which DesignVersion to fetch.
     */
    where: DesignVersionWhereUniqueInput
  }

  /**
   * DesignVersion findFirst
   */
  export type DesignVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignVersion
     */
    select?: DesignVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignVersionInclude<ExtArgs> | null
    /**
     * Filter, which DesignVersion to fetch.
     */
    where?: DesignVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignVersions to fetch.
     */
    orderBy?: DesignVersionOrderByWithRelationInput | DesignVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DesignVersions.
     */
    cursor?: DesignVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DesignVersions.
     */
    distinct?: DesignVersionScalarFieldEnum | DesignVersionScalarFieldEnum[]
  }

  /**
   * DesignVersion findFirstOrThrow
   */
  export type DesignVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignVersion
     */
    select?: DesignVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignVersionInclude<ExtArgs> | null
    /**
     * Filter, which DesignVersion to fetch.
     */
    where?: DesignVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignVersions to fetch.
     */
    orderBy?: DesignVersionOrderByWithRelationInput | DesignVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DesignVersions.
     */
    cursor?: DesignVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DesignVersions.
     */
    distinct?: DesignVersionScalarFieldEnum | DesignVersionScalarFieldEnum[]
  }

  /**
   * DesignVersion findMany
   */
  export type DesignVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignVersion
     */
    select?: DesignVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignVersionInclude<ExtArgs> | null
    /**
     * Filter, which DesignVersions to fetch.
     */
    where?: DesignVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignVersions to fetch.
     */
    orderBy?: DesignVersionOrderByWithRelationInput | DesignVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DesignVersions.
     */
    cursor?: DesignVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignVersions.
     */
    skip?: number
    distinct?: DesignVersionScalarFieldEnum | DesignVersionScalarFieldEnum[]
  }

  /**
   * DesignVersion create
   */
  export type DesignVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignVersion
     */
    select?: DesignVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a DesignVersion.
     */
    data: XOR<DesignVersionCreateInput, DesignVersionUncheckedCreateInput>
  }

  /**
   * DesignVersion createMany
   */
  export type DesignVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DesignVersions.
     */
    data: DesignVersionCreateManyInput | DesignVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DesignVersion createManyAndReturn
   */
  export type DesignVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignVersion
     */
    select?: DesignVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DesignVersions.
     */
    data: DesignVersionCreateManyInput | DesignVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DesignVersion update
   */
  export type DesignVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignVersion
     */
    select?: DesignVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a DesignVersion.
     */
    data: XOR<DesignVersionUpdateInput, DesignVersionUncheckedUpdateInput>
    /**
     * Choose, which DesignVersion to update.
     */
    where: DesignVersionWhereUniqueInput
  }

  /**
   * DesignVersion updateMany
   */
  export type DesignVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DesignVersions.
     */
    data: XOR<DesignVersionUpdateManyMutationInput, DesignVersionUncheckedUpdateManyInput>
    /**
     * Filter which DesignVersions to update
     */
    where?: DesignVersionWhereInput
  }

  /**
   * DesignVersion upsert
   */
  export type DesignVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignVersion
     */
    select?: DesignVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the DesignVersion to update in case it exists.
     */
    where: DesignVersionWhereUniqueInput
    /**
     * In case the DesignVersion found by the `where` argument doesn't exist, create a new DesignVersion with this data.
     */
    create: XOR<DesignVersionCreateInput, DesignVersionUncheckedCreateInput>
    /**
     * In case the DesignVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DesignVersionUpdateInput, DesignVersionUncheckedUpdateInput>
  }

  /**
   * DesignVersion delete
   */
  export type DesignVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignVersion
     */
    select?: DesignVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignVersionInclude<ExtArgs> | null
    /**
     * Filter which DesignVersion to delete.
     */
    where: DesignVersionWhereUniqueInput
  }

  /**
   * DesignVersion deleteMany
   */
  export type DesignVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DesignVersions to delete
     */
    where?: DesignVersionWhereInput
  }

  /**
   * DesignVersion.clashTickets
   */
  export type DesignVersion$clashTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignClashTicket
     */
    select?: DesignClashTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignClashTicketInclude<ExtArgs> | null
    where?: DesignClashTicketWhereInput
    orderBy?: DesignClashTicketOrderByWithRelationInput | DesignClashTicketOrderByWithRelationInput[]
    cursor?: DesignClashTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DesignClashTicketScalarFieldEnum | DesignClashTicketScalarFieldEnum[]
  }

  /**
   * DesignVersion without action
   */
  export type DesignVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignVersion
     */
    select?: DesignVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignVersionInclude<ExtArgs> | null
  }


  /**
   * Model DesignClashTicket
   */

  export type AggregateDesignClashTicket = {
    _count: DesignClashTicketCountAggregateOutputType | null
    _min: DesignClashTicketMinAggregateOutputType | null
    _max: DesignClashTicketMaxAggregateOutputType | null
  }

  export type DesignClashTicketMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.ClashStatus | null
    priority: $Enums.Priority | null
    resolution: string | null
    resolvedAt: Date | null
    designVersionId: string | null
    reportedById: string | null
    assignedToId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DesignClashTicketMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.ClashStatus | null
    priority: $Enums.Priority | null
    resolution: string | null
    resolvedAt: Date | null
    designVersionId: string | null
    reportedById: string | null
    assignedToId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DesignClashTicketCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    priority: number
    photoUrls: number
    resolution: number
    resolvedAt: number
    designVersionId: number
    reportedById: number
    assignedToId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DesignClashTicketMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    resolution?: true
    resolvedAt?: true
    designVersionId?: true
    reportedById?: true
    assignedToId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DesignClashTicketMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    resolution?: true
    resolvedAt?: true
    designVersionId?: true
    reportedById?: true
    assignedToId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DesignClashTicketCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    photoUrls?: true
    resolution?: true
    resolvedAt?: true
    designVersionId?: true
    reportedById?: true
    assignedToId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DesignClashTicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DesignClashTicket to aggregate.
     */
    where?: DesignClashTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignClashTickets to fetch.
     */
    orderBy?: DesignClashTicketOrderByWithRelationInput | DesignClashTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DesignClashTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignClashTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignClashTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DesignClashTickets
    **/
    _count?: true | DesignClashTicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DesignClashTicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DesignClashTicketMaxAggregateInputType
  }

  export type GetDesignClashTicketAggregateType<T extends DesignClashTicketAggregateArgs> = {
        [P in keyof T & keyof AggregateDesignClashTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDesignClashTicket[P]>
      : GetScalarType<T[P], AggregateDesignClashTicket[P]>
  }




  export type DesignClashTicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignClashTicketWhereInput
    orderBy?: DesignClashTicketOrderByWithAggregationInput | DesignClashTicketOrderByWithAggregationInput[]
    by: DesignClashTicketScalarFieldEnum[] | DesignClashTicketScalarFieldEnum
    having?: DesignClashTicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DesignClashTicketCountAggregateInputType | true
    _min?: DesignClashTicketMinAggregateInputType
    _max?: DesignClashTicketMaxAggregateInputType
  }

  export type DesignClashTicketGroupByOutputType = {
    id: string
    title: string
    description: string
    status: $Enums.ClashStatus
    priority: $Enums.Priority
    photoUrls: string[]
    resolution: string | null
    resolvedAt: Date | null
    designVersionId: string
    reportedById: string
    assignedToId: string | null
    createdAt: Date
    updatedAt: Date
    _count: DesignClashTicketCountAggregateOutputType | null
    _min: DesignClashTicketMinAggregateOutputType | null
    _max: DesignClashTicketMaxAggregateOutputType | null
  }

  type GetDesignClashTicketGroupByPayload<T extends DesignClashTicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DesignClashTicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DesignClashTicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DesignClashTicketGroupByOutputType[P]>
            : GetScalarType<T[P], DesignClashTicketGroupByOutputType[P]>
        }
      >
    >


  export type DesignClashTicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    photoUrls?: boolean
    resolution?: boolean
    resolvedAt?: boolean
    designVersionId?: boolean
    reportedById?: boolean
    assignedToId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    designVersion?: boolean | DesignVersionDefaultArgs<ExtArgs>
    reportedBy?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | DesignClashTicket$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["designClashTicket"]>

  export type DesignClashTicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    photoUrls?: boolean
    resolution?: boolean
    resolvedAt?: boolean
    designVersionId?: boolean
    reportedById?: boolean
    assignedToId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    designVersion?: boolean | DesignVersionDefaultArgs<ExtArgs>
    reportedBy?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | DesignClashTicket$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["designClashTicket"]>

  export type DesignClashTicketSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    photoUrls?: boolean
    resolution?: boolean
    resolvedAt?: boolean
    designVersionId?: boolean
    reportedById?: boolean
    assignedToId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DesignClashTicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    designVersion?: boolean | DesignVersionDefaultArgs<ExtArgs>
    reportedBy?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | DesignClashTicket$assignedToArgs<ExtArgs>
  }
  export type DesignClashTicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    designVersion?: boolean | DesignVersionDefaultArgs<ExtArgs>
    reportedBy?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | DesignClashTicket$assignedToArgs<ExtArgs>
  }

  export type $DesignClashTicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DesignClashTicket"
    objects: {
      designVersion: Prisma.$DesignVersionPayload<ExtArgs>
      reportedBy: Prisma.$UserPayload<ExtArgs>
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      status: $Enums.ClashStatus
      priority: $Enums.Priority
      photoUrls: string[]
      resolution: string | null
      resolvedAt: Date | null
      designVersionId: string
      reportedById: string
      assignedToId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["designClashTicket"]>
    composites: {}
  }

  type DesignClashTicketGetPayload<S extends boolean | null | undefined | DesignClashTicketDefaultArgs> = $Result.GetResult<Prisma.$DesignClashTicketPayload, S>

  type DesignClashTicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DesignClashTicketFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DesignClashTicketCountAggregateInputType | true
    }

  export interface DesignClashTicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DesignClashTicket'], meta: { name: 'DesignClashTicket' } }
    /**
     * Find zero or one DesignClashTicket that matches the filter.
     * @param {DesignClashTicketFindUniqueArgs} args - Arguments to find a DesignClashTicket
     * @example
     * // Get one DesignClashTicket
     * const designClashTicket = await prisma.designClashTicket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DesignClashTicketFindUniqueArgs>(args: SelectSubset<T, DesignClashTicketFindUniqueArgs<ExtArgs>>): Prisma__DesignClashTicketClient<$Result.GetResult<Prisma.$DesignClashTicketPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DesignClashTicket that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DesignClashTicketFindUniqueOrThrowArgs} args - Arguments to find a DesignClashTicket
     * @example
     * // Get one DesignClashTicket
     * const designClashTicket = await prisma.designClashTicket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DesignClashTicketFindUniqueOrThrowArgs>(args: SelectSubset<T, DesignClashTicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DesignClashTicketClient<$Result.GetResult<Prisma.$DesignClashTicketPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DesignClashTicket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignClashTicketFindFirstArgs} args - Arguments to find a DesignClashTicket
     * @example
     * // Get one DesignClashTicket
     * const designClashTicket = await prisma.designClashTicket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DesignClashTicketFindFirstArgs>(args?: SelectSubset<T, DesignClashTicketFindFirstArgs<ExtArgs>>): Prisma__DesignClashTicketClient<$Result.GetResult<Prisma.$DesignClashTicketPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DesignClashTicket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignClashTicketFindFirstOrThrowArgs} args - Arguments to find a DesignClashTicket
     * @example
     * // Get one DesignClashTicket
     * const designClashTicket = await prisma.designClashTicket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DesignClashTicketFindFirstOrThrowArgs>(args?: SelectSubset<T, DesignClashTicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__DesignClashTicketClient<$Result.GetResult<Prisma.$DesignClashTicketPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DesignClashTickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignClashTicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DesignClashTickets
     * const designClashTickets = await prisma.designClashTicket.findMany()
     * 
     * // Get first 10 DesignClashTickets
     * const designClashTickets = await prisma.designClashTicket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const designClashTicketWithIdOnly = await prisma.designClashTicket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DesignClashTicketFindManyArgs>(args?: SelectSubset<T, DesignClashTicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignClashTicketPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DesignClashTicket.
     * @param {DesignClashTicketCreateArgs} args - Arguments to create a DesignClashTicket.
     * @example
     * // Create one DesignClashTicket
     * const DesignClashTicket = await prisma.designClashTicket.create({
     *   data: {
     *     // ... data to create a DesignClashTicket
     *   }
     * })
     * 
     */
    create<T extends DesignClashTicketCreateArgs>(args: SelectSubset<T, DesignClashTicketCreateArgs<ExtArgs>>): Prisma__DesignClashTicketClient<$Result.GetResult<Prisma.$DesignClashTicketPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DesignClashTickets.
     * @param {DesignClashTicketCreateManyArgs} args - Arguments to create many DesignClashTickets.
     * @example
     * // Create many DesignClashTickets
     * const designClashTicket = await prisma.designClashTicket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DesignClashTicketCreateManyArgs>(args?: SelectSubset<T, DesignClashTicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DesignClashTickets and returns the data saved in the database.
     * @param {DesignClashTicketCreateManyAndReturnArgs} args - Arguments to create many DesignClashTickets.
     * @example
     * // Create many DesignClashTickets
     * const designClashTicket = await prisma.designClashTicket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DesignClashTickets and only return the `id`
     * const designClashTicketWithIdOnly = await prisma.designClashTicket.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DesignClashTicketCreateManyAndReturnArgs>(args?: SelectSubset<T, DesignClashTicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignClashTicketPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DesignClashTicket.
     * @param {DesignClashTicketDeleteArgs} args - Arguments to delete one DesignClashTicket.
     * @example
     * // Delete one DesignClashTicket
     * const DesignClashTicket = await prisma.designClashTicket.delete({
     *   where: {
     *     // ... filter to delete one DesignClashTicket
     *   }
     * })
     * 
     */
    delete<T extends DesignClashTicketDeleteArgs>(args: SelectSubset<T, DesignClashTicketDeleteArgs<ExtArgs>>): Prisma__DesignClashTicketClient<$Result.GetResult<Prisma.$DesignClashTicketPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DesignClashTicket.
     * @param {DesignClashTicketUpdateArgs} args - Arguments to update one DesignClashTicket.
     * @example
     * // Update one DesignClashTicket
     * const designClashTicket = await prisma.designClashTicket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DesignClashTicketUpdateArgs>(args: SelectSubset<T, DesignClashTicketUpdateArgs<ExtArgs>>): Prisma__DesignClashTicketClient<$Result.GetResult<Prisma.$DesignClashTicketPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DesignClashTickets.
     * @param {DesignClashTicketDeleteManyArgs} args - Arguments to filter DesignClashTickets to delete.
     * @example
     * // Delete a few DesignClashTickets
     * const { count } = await prisma.designClashTicket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DesignClashTicketDeleteManyArgs>(args?: SelectSubset<T, DesignClashTicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DesignClashTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignClashTicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DesignClashTickets
     * const designClashTicket = await prisma.designClashTicket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DesignClashTicketUpdateManyArgs>(args: SelectSubset<T, DesignClashTicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DesignClashTicket.
     * @param {DesignClashTicketUpsertArgs} args - Arguments to update or create a DesignClashTicket.
     * @example
     * // Update or create a DesignClashTicket
     * const designClashTicket = await prisma.designClashTicket.upsert({
     *   create: {
     *     // ... data to create a DesignClashTicket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DesignClashTicket we want to update
     *   }
     * })
     */
    upsert<T extends DesignClashTicketUpsertArgs>(args: SelectSubset<T, DesignClashTicketUpsertArgs<ExtArgs>>): Prisma__DesignClashTicketClient<$Result.GetResult<Prisma.$DesignClashTicketPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DesignClashTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignClashTicketCountArgs} args - Arguments to filter DesignClashTickets to count.
     * @example
     * // Count the number of DesignClashTickets
     * const count = await prisma.designClashTicket.count({
     *   where: {
     *     // ... the filter for the DesignClashTickets we want to count
     *   }
     * })
    **/
    count<T extends DesignClashTicketCountArgs>(
      args?: Subset<T, DesignClashTicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DesignClashTicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DesignClashTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignClashTicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DesignClashTicketAggregateArgs>(args: Subset<T, DesignClashTicketAggregateArgs>): Prisma.PrismaPromise<GetDesignClashTicketAggregateType<T>>

    /**
     * Group by DesignClashTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignClashTicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DesignClashTicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DesignClashTicketGroupByArgs['orderBy'] }
        : { orderBy?: DesignClashTicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DesignClashTicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDesignClashTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DesignClashTicket model
   */
  readonly fields: DesignClashTicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DesignClashTicket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DesignClashTicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    designVersion<T extends DesignVersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DesignVersionDefaultArgs<ExtArgs>>): Prisma__DesignVersionClient<$Result.GetResult<Prisma.$DesignVersionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reportedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assignedTo<T extends DesignClashTicket$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, DesignClashTicket$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DesignClashTicket model
   */ 
  interface DesignClashTicketFieldRefs {
    readonly id: FieldRef<"DesignClashTicket", 'String'>
    readonly title: FieldRef<"DesignClashTicket", 'String'>
    readonly description: FieldRef<"DesignClashTicket", 'String'>
    readonly status: FieldRef<"DesignClashTicket", 'ClashStatus'>
    readonly priority: FieldRef<"DesignClashTicket", 'Priority'>
    readonly photoUrls: FieldRef<"DesignClashTicket", 'String[]'>
    readonly resolution: FieldRef<"DesignClashTicket", 'String'>
    readonly resolvedAt: FieldRef<"DesignClashTicket", 'DateTime'>
    readonly designVersionId: FieldRef<"DesignClashTicket", 'String'>
    readonly reportedById: FieldRef<"DesignClashTicket", 'String'>
    readonly assignedToId: FieldRef<"DesignClashTicket", 'String'>
    readonly createdAt: FieldRef<"DesignClashTicket", 'DateTime'>
    readonly updatedAt: FieldRef<"DesignClashTicket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DesignClashTicket findUnique
   */
  export type DesignClashTicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignClashTicket
     */
    select?: DesignClashTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignClashTicketInclude<ExtArgs> | null
    /**
     * Filter, which DesignClashTicket to fetch.
     */
    where: DesignClashTicketWhereUniqueInput
  }

  /**
   * DesignClashTicket findUniqueOrThrow
   */
  export type DesignClashTicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignClashTicket
     */
    select?: DesignClashTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignClashTicketInclude<ExtArgs> | null
    /**
     * Filter, which DesignClashTicket to fetch.
     */
    where: DesignClashTicketWhereUniqueInput
  }

  /**
   * DesignClashTicket findFirst
   */
  export type DesignClashTicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignClashTicket
     */
    select?: DesignClashTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignClashTicketInclude<ExtArgs> | null
    /**
     * Filter, which DesignClashTicket to fetch.
     */
    where?: DesignClashTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignClashTickets to fetch.
     */
    orderBy?: DesignClashTicketOrderByWithRelationInput | DesignClashTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DesignClashTickets.
     */
    cursor?: DesignClashTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignClashTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignClashTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DesignClashTickets.
     */
    distinct?: DesignClashTicketScalarFieldEnum | DesignClashTicketScalarFieldEnum[]
  }

  /**
   * DesignClashTicket findFirstOrThrow
   */
  export type DesignClashTicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignClashTicket
     */
    select?: DesignClashTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignClashTicketInclude<ExtArgs> | null
    /**
     * Filter, which DesignClashTicket to fetch.
     */
    where?: DesignClashTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignClashTickets to fetch.
     */
    orderBy?: DesignClashTicketOrderByWithRelationInput | DesignClashTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DesignClashTickets.
     */
    cursor?: DesignClashTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignClashTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignClashTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DesignClashTickets.
     */
    distinct?: DesignClashTicketScalarFieldEnum | DesignClashTicketScalarFieldEnum[]
  }

  /**
   * DesignClashTicket findMany
   */
  export type DesignClashTicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignClashTicket
     */
    select?: DesignClashTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignClashTicketInclude<ExtArgs> | null
    /**
     * Filter, which DesignClashTickets to fetch.
     */
    where?: DesignClashTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignClashTickets to fetch.
     */
    orderBy?: DesignClashTicketOrderByWithRelationInput | DesignClashTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DesignClashTickets.
     */
    cursor?: DesignClashTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignClashTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignClashTickets.
     */
    skip?: number
    distinct?: DesignClashTicketScalarFieldEnum | DesignClashTicketScalarFieldEnum[]
  }

  /**
   * DesignClashTicket create
   */
  export type DesignClashTicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignClashTicket
     */
    select?: DesignClashTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignClashTicketInclude<ExtArgs> | null
    /**
     * The data needed to create a DesignClashTicket.
     */
    data: XOR<DesignClashTicketCreateInput, DesignClashTicketUncheckedCreateInput>
  }

  /**
   * DesignClashTicket createMany
   */
  export type DesignClashTicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DesignClashTickets.
     */
    data: DesignClashTicketCreateManyInput | DesignClashTicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DesignClashTicket createManyAndReturn
   */
  export type DesignClashTicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignClashTicket
     */
    select?: DesignClashTicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DesignClashTickets.
     */
    data: DesignClashTicketCreateManyInput | DesignClashTicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignClashTicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DesignClashTicket update
   */
  export type DesignClashTicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignClashTicket
     */
    select?: DesignClashTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignClashTicketInclude<ExtArgs> | null
    /**
     * The data needed to update a DesignClashTicket.
     */
    data: XOR<DesignClashTicketUpdateInput, DesignClashTicketUncheckedUpdateInput>
    /**
     * Choose, which DesignClashTicket to update.
     */
    where: DesignClashTicketWhereUniqueInput
  }

  /**
   * DesignClashTicket updateMany
   */
  export type DesignClashTicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DesignClashTickets.
     */
    data: XOR<DesignClashTicketUpdateManyMutationInput, DesignClashTicketUncheckedUpdateManyInput>
    /**
     * Filter which DesignClashTickets to update
     */
    where?: DesignClashTicketWhereInput
  }

  /**
   * DesignClashTicket upsert
   */
  export type DesignClashTicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignClashTicket
     */
    select?: DesignClashTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignClashTicketInclude<ExtArgs> | null
    /**
     * The filter to search for the DesignClashTicket to update in case it exists.
     */
    where: DesignClashTicketWhereUniqueInput
    /**
     * In case the DesignClashTicket found by the `where` argument doesn't exist, create a new DesignClashTicket with this data.
     */
    create: XOR<DesignClashTicketCreateInput, DesignClashTicketUncheckedCreateInput>
    /**
     * In case the DesignClashTicket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DesignClashTicketUpdateInput, DesignClashTicketUncheckedUpdateInput>
  }

  /**
   * DesignClashTicket delete
   */
  export type DesignClashTicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignClashTicket
     */
    select?: DesignClashTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignClashTicketInclude<ExtArgs> | null
    /**
     * Filter which DesignClashTicket to delete.
     */
    where: DesignClashTicketWhereUniqueInput
  }

  /**
   * DesignClashTicket deleteMany
   */
  export type DesignClashTicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DesignClashTickets to delete
     */
    where?: DesignClashTicketWhereInput
  }

  /**
   * DesignClashTicket.assignedTo
   */
  export type DesignClashTicket$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * DesignClashTicket without action
   */
  export type DesignClashTicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignClashTicket
     */
    select?: DesignClashTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignClashTicketInclude<ExtArgs> | null
  }


  /**
   * Model Moodboard
   */

  export type AggregateMoodboard = {
    _count: MoodboardCountAggregateOutputType | null
    _min: MoodboardMinAggregateOutputType | null
    _max: MoodboardMaxAggregateOutputType | null
  }

  export type MoodboardMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.MoodboardStatus | null
    clientId: string | null
    jobId: string | null
    isClientVisible: boolean | null
    clientLastViewedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MoodboardMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.MoodboardStatus | null
    clientId: string | null
    jobId: string | null
    isClientVisible: boolean | null
    clientLastViewedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MoodboardCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    clientId: number
    jobId: number
    isClientVisible: number
    clientLastViewedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MoodboardMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    clientId?: true
    jobId?: true
    isClientVisible?: true
    clientLastViewedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MoodboardMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    clientId?: true
    jobId?: true
    isClientVisible?: true
    clientLastViewedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MoodboardCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    clientId?: true
    jobId?: true
    isClientVisible?: true
    clientLastViewedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MoodboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Moodboard to aggregate.
     */
    where?: MoodboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Moodboards to fetch.
     */
    orderBy?: MoodboardOrderByWithRelationInput | MoodboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MoodboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Moodboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Moodboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Moodboards
    **/
    _count?: true | MoodboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MoodboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MoodboardMaxAggregateInputType
  }

  export type GetMoodboardAggregateType<T extends MoodboardAggregateArgs> = {
        [P in keyof T & keyof AggregateMoodboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMoodboard[P]>
      : GetScalarType<T[P], AggregateMoodboard[P]>
  }




  export type MoodboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoodboardWhereInput
    orderBy?: MoodboardOrderByWithAggregationInput | MoodboardOrderByWithAggregationInput[]
    by: MoodboardScalarFieldEnum[] | MoodboardScalarFieldEnum
    having?: MoodboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MoodboardCountAggregateInputType | true
    _min?: MoodboardMinAggregateInputType
    _max?: MoodboardMaxAggregateInputType
  }

  export type MoodboardGroupByOutputType = {
    id: string
    title: string
    description: string | null
    status: $Enums.MoodboardStatus
    clientId: string
    jobId: string | null
    isClientVisible: boolean
    clientLastViewedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MoodboardCountAggregateOutputType | null
    _min: MoodboardMinAggregateOutputType | null
    _max: MoodboardMaxAggregateOutputType | null
  }

  type GetMoodboardGroupByPayload<T extends MoodboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MoodboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MoodboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MoodboardGroupByOutputType[P]>
            : GetScalarType<T[P], MoodboardGroupByOutputType[P]>
        }
      >
    >


  export type MoodboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    clientId?: boolean
    jobId?: boolean
    isClientVisible?: boolean
    clientLastViewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    job?: boolean | Moodboard$jobArgs<ExtArgs>
    items?: boolean | Moodboard$itemsArgs<ExtArgs>
    _count?: boolean | MoodboardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moodboard"]>

  export type MoodboardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    clientId?: boolean
    jobId?: boolean
    isClientVisible?: boolean
    clientLastViewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    job?: boolean | Moodboard$jobArgs<ExtArgs>
  }, ExtArgs["result"]["moodboard"]>

  export type MoodboardSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    clientId?: boolean
    jobId?: boolean
    isClientVisible?: boolean
    clientLastViewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MoodboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    job?: boolean | Moodboard$jobArgs<ExtArgs>
    items?: boolean | Moodboard$itemsArgs<ExtArgs>
    _count?: boolean | MoodboardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MoodboardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    job?: boolean | Moodboard$jobArgs<ExtArgs>
  }

  export type $MoodboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Moodboard"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      job: Prisma.$JobPayload<ExtArgs> | null
      items: Prisma.$MoodboardItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      status: $Enums.MoodboardStatus
      clientId: string
      jobId: string | null
      isClientVisible: boolean
      clientLastViewedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["moodboard"]>
    composites: {}
  }

  type MoodboardGetPayload<S extends boolean | null | undefined | MoodboardDefaultArgs> = $Result.GetResult<Prisma.$MoodboardPayload, S>

  type MoodboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MoodboardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MoodboardCountAggregateInputType | true
    }

  export interface MoodboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Moodboard'], meta: { name: 'Moodboard' } }
    /**
     * Find zero or one Moodboard that matches the filter.
     * @param {MoodboardFindUniqueArgs} args - Arguments to find a Moodboard
     * @example
     * // Get one Moodboard
     * const moodboard = await prisma.moodboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MoodboardFindUniqueArgs>(args: SelectSubset<T, MoodboardFindUniqueArgs<ExtArgs>>): Prisma__MoodboardClient<$Result.GetResult<Prisma.$MoodboardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Moodboard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MoodboardFindUniqueOrThrowArgs} args - Arguments to find a Moodboard
     * @example
     * // Get one Moodboard
     * const moodboard = await prisma.moodboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MoodboardFindUniqueOrThrowArgs>(args: SelectSubset<T, MoodboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MoodboardClient<$Result.GetResult<Prisma.$MoodboardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Moodboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodboardFindFirstArgs} args - Arguments to find a Moodboard
     * @example
     * // Get one Moodboard
     * const moodboard = await prisma.moodboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MoodboardFindFirstArgs>(args?: SelectSubset<T, MoodboardFindFirstArgs<ExtArgs>>): Prisma__MoodboardClient<$Result.GetResult<Prisma.$MoodboardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Moodboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodboardFindFirstOrThrowArgs} args - Arguments to find a Moodboard
     * @example
     * // Get one Moodboard
     * const moodboard = await prisma.moodboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MoodboardFindFirstOrThrowArgs>(args?: SelectSubset<T, MoodboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__MoodboardClient<$Result.GetResult<Prisma.$MoodboardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Moodboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Moodboards
     * const moodboards = await prisma.moodboard.findMany()
     * 
     * // Get first 10 Moodboards
     * const moodboards = await prisma.moodboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moodboardWithIdOnly = await prisma.moodboard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MoodboardFindManyArgs>(args?: SelectSubset<T, MoodboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoodboardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Moodboard.
     * @param {MoodboardCreateArgs} args - Arguments to create a Moodboard.
     * @example
     * // Create one Moodboard
     * const Moodboard = await prisma.moodboard.create({
     *   data: {
     *     // ... data to create a Moodboard
     *   }
     * })
     * 
     */
    create<T extends MoodboardCreateArgs>(args: SelectSubset<T, MoodboardCreateArgs<ExtArgs>>): Prisma__MoodboardClient<$Result.GetResult<Prisma.$MoodboardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Moodboards.
     * @param {MoodboardCreateManyArgs} args - Arguments to create many Moodboards.
     * @example
     * // Create many Moodboards
     * const moodboard = await prisma.moodboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MoodboardCreateManyArgs>(args?: SelectSubset<T, MoodboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Moodboards and returns the data saved in the database.
     * @param {MoodboardCreateManyAndReturnArgs} args - Arguments to create many Moodboards.
     * @example
     * // Create many Moodboards
     * const moodboard = await prisma.moodboard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Moodboards and only return the `id`
     * const moodboardWithIdOnly = await prisma.moodboard.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MoodboardCreateManyAndReturnArgs>(args?: SelectSubset<T, MoodboardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoodboardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Moodboard.
     * @param {MoodboardDeleteArgs} args - Arguments to delete one Moodboard.
     * @example
     * // Delete one Moodboard
     * const Moodboard = await prisma.moodboard.delete({
     *   where: {
     *     // ... filter to delete one Moodboard
     *   }
     * })
     * 
     */
    delete<T extends MoodboardDeleteArgs>(args: SelectSubset<T, MoodboardDeleteArgs<ExtArgs>>): Prisma__MoodboardClient<$Result.GetResult<Prisma.$MoodboardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Moodboard.
     * @param {MoodboardUpdateArgs} args - Arguments to update one Moodboard.
     * @example
     * // Update one Moodboard
     * const moodboard = await prisma.moodboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MoodboardUpdateArgs>(args: SelectSubset<T, MoodboardUpdateArgs<ExtArgs>>): Prisma__MoodboardClient<$Result.GetResult<Prisma.$MoodboardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Moodboards.
     * @param {MoodboardDeleteManyArgs} args - Arguments to filter Moodboards to delete.
     * @example
     * // Delete a few Moodboards
     * const { count } = await prisma.moodboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MoodboardDeleteManyArgs>(args?: SelectSubset<T, MoodboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Moodboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Moodboards
     * const moodboard = await prisma.moodboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MoodboardUpdateManyArgs>(args: SelectSubset<T, MoodboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Moodboard.
     * @param {MoodboardUpsertArgs} args - Arguments to update or create a Moodboard.
     * @example
     * // Update or create a Moodboard
     * const moodboard = await prisma.moodboard.upsert({
     *   create: {
     *     // ... data to create a Moodboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Moodboard we want to update
     *   }
     * })
     */
    upsert<T extends MoodboardUpsertArgs>(args: SelectSubset<T, MoodboardUpsertArgs<ExtArgs>>): Prisma__MoodboardClient<$Result.GetResult<Prisma.$MoodboardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Moodboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodboardCountArgs} args - Arguments to filter Moodboards to count.
     * @example
     * // Count the number of Moodboards
     * const count = await prisma.moodboard.count({
     *   where: {
     *     // ... the filter for the Moodboards we want to count
     *   }
     * })
    **/
    count<T extends MoodboardCountArgs>(
      args?: Subset<T, MoodboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MoodboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Moodboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MoodboardAggregateArgs>(args: Subset<T, MoodboardAggregateArgs>): Prisma.PrismaPromise<GetMoodboardAggregateType<T>>

    /**
     * Group by Moodboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MoodboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MoodboardGroupByArgs['orderBy'] }
        : { orderBy?: MoodboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MoodboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMoodboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Moodboard model
   */
  readonly fields: MoodboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Moodboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MoodboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    job<T extends Moodboard$jobArgs<ExtArgs> = {}>(args?: Subset<T, Moodboard$jobArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    items<T extends Moodboard$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Moodboard$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoodboardItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Moodboard model
   */ 
  interface MoodboardFieldRefs {
    readonly id: FieldRef<"Moodboard", 'String'>
    readonly title: FieldRef<"Moodboard", 'String'>
    readonly description: FieldRef<"Moodboard", 'String'>
    readonly status: FieldRef<"Moodboard", 'MoodboardStatus'>
    readonly clientId: FieldRef<"Moodboard", 'String'>
    readonly jobId: FieldRef<"Moodboard", 'String'>
    readonly isClientVisible: FieldRef<"Moodboard", 'Boolean'>
    readonly clientLastViewedAt: FieldRef<"Moodboard", 'DateTime'>
    readonly createdAt: FieldRef<"Moodboard", 'DateTime'>
    readonly updatedAt: FieldRef<"Moodboard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Moodboard findUnique
   */
  export type MoodboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Moodboard
     */
    select?: MoodboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardInclude<ExtArgs> | null
    /**
     * Filter, which Moodboard to fetch.
     */
    where: MoodboardWhereUniqueInput
  }

  /**
   * Moodboard findUniqueOrThrow
   */
  export type MoodboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Moodboard
     */
    select?: MoodboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardInclude<ExtArgs> | null
    /**
     * Filter, which Moodboard to fetch.
     */
    where: MoodboardWhereUniqueInput
  }

  /**
   * Moodboard findFirst
   */
  export type MoodboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Moodboard
     */
    select?: MoodboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardInclude<ExtArgs> | null
    /**
     * Filter, which Moodboard to fetch.
     */
    where?: MoodboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Moodboards to fetch.
     */
    orderBy?: MoodboardOrderByWithRelationInput | MoodboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Moodboards.
     */
    cursor?: MoodboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Moodboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Moodboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Moodboards.
     */
    distinct?: MoodboardScalarFieldEnum | MoodboardScalarFieldEnum[]
  }

  /**
   * Moodboard findFirstOrThrow
   */
  export type MoodboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Moodboard
     */
    select?: MoodboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardInclude<ExtArgs> | null
    /**
     * Filter, which Moodboard to fetch.
     */
    where?: MoodboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Moodboards to fetch.
     */
    orderBy?: MoodboardOrderByWithRelationInput | MoodboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Moodboards.
     */
    cursor?: MoodboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Moodboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Moodboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Moodboards.
     */
    distinct?: MoodboardScalarFieldEnum | MoodboardScalarFieldEnum[]
  }

  /**
   * Moodboard findMany
   */
  export type MoodboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Moodboard
     */
    select?: MoodboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardInclude<ExtArgs> | null
    /**
     * Filter, which Moodboards to fetch.
     */
    where?: MoodboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Moodboards to fetch.
     */
    orderBy?: MoodboardOrderByWithRelationInput | MoodboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Moodboards.
     */
    cursor?: MoodboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Moodboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Moodboards.
     */
    skip?: number
    distinct?: MoodboardScalarFieldEnum | MoodboardScalarFieldEnum[]
  }

  /**
   * Moodboard create
   */
  export type MoodboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Moodboard
     */
    select?: MoodboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardInclude<ExtArgs> | null
    /**
     * The data needed to create a Moodboard.
     */
    data: XOR<MoodboardCreateInput, MoodboardUncheckedCreateInput>
  }

  /**
   * Moodboard createMany
   */
  export type MoodboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Moodboards.
     */
    data: MoodboardCreateManyInput | MoodboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Moodboard createManyAndReturn
   */
  export type MoodboardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Moodboard
     */
    select?: MoodboardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Moodboards.
     */
    data: MoodboardCreateManyInput | MoodboardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Moodboard update
   */
  export type MoodboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Moodboard
     */
    select?: MoodboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardInclude<ExtArgs> | null
    /**
     * The data needed to update a Moodboard.
     */
    data: XOR<MoodboardUpdateInput, MoodboardUncheckedUpdateInput>
    /**
     * Choose, which Moodboard to update.
     */
    where: MoodboardWhereUniqueInput
  }

  /**
   * Moodboard updateMany
   */
  export type MoodboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Moodboards.
     */
    data: XOR<MoodboardUpdateManyMutationInput, MoodboardUncheckedUpdateManyInput>
    /**
     * Filter which Moodboards to update
     */
    where?: MoodboardWhereInput
  }

  /**
   * Moodboard upsert
   */
  export type MoodboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Moodboard
     */
    select?: MoodboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardInclude<ExtArgs> | null
    /**
     * The filter to search for the Moodboard to update in case it exists.
     */
    where: MoodboardWhereUniqueInput
    /**
     * In case the Moodboard found by the `where` argument doesn't exist, create a new Moodboard with this data.
     */
    create: XOR<MoodboardCreateInput, MoodboardUncheckedCreateInput>
    /**
     * In case the Moodboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MoodboardUpdateInput, MoodboardUncheckedUpdateInput>
  }

  /**
   * Moodboard delete
   */
  export type MoodboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Moodboard
     */
    select?: MoodboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardInclude<ExtArgs> | null
    /**
     * Filter which Moodboard to delete.
     */
    where: MoodboardWhereUniqueInput
  }

  /**
   * Moodboard deleteMany
   */
  export type MoodboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Moodboards to delete
     */
    where?: MoodboardWhereInput
  }

  /**
   * Moodboard.job
   */
  export type Moodboard$jobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
  }

  /**
   * Moodboard.items
   */
  export type Moodboard$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardItem
     */
    select?: MoodboardItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardItemInclude<ExtArgs> | null
    where?: MoodboardItemWhereInput
    orderBy?: MoodboardItemOrderByWithRelationInput | MoodboardItemOrderByWithRelationInput[]
    cursor?: MoodboardItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MoodboardItemScalarFieldEnum | MoodboardItemScalarFieldEnum[]
  }

  /**
   * Moodboard without action
   */
  export type MoodboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Moodboard
     */
    select?: MoodboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardInclude<ExtArgs> | null
  }


  /**
   * Model MoodboardItem
   */

  export type AggregateMoodboardItem = {
    _count: MoodboardItemCountAggregateOutputType | null
    _avg: MoodboardItemAvgAggregateOutputType | null
    _sum: MoodboardItemSumAggregateOutputType | null
    _min: MoodboardItemMinAggregateOutputType | null
    _max: MoodboardItemMaxAggregateOutputType | null
  }

  export type MoodboardItemAvgAggregateOutputType = {
    order: number | null
  }

  export type MoodboardItemSumAggregateOutputType = {
    order: number | null
  }

  export type MoodboardItemMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    sourceUrl: string | null
    category: string | null
    order: number | null
    moodboardId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MoodboardItemMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    sourceUrl: string | null
    category: string | null
    order: number | null
    moodboardId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MoodboardItemCountAggregateOutputType = {
    id: number
    title: number
    description: number
    imageUrl: number
    sourceUrl: number
    category: number
    order: number
    moodboardId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MoodboardItemAvgAggregateInputType = {
    order?: true
  }

  export type MoodboardItemSumAggregateInputType = {
    order?: true
  }

  export type MoodboardItemMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    sourceUrl?: true
    category?: true
    order?: true
    moodboardId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MoodboardItemMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    sourceUrl?: true
    category?: true
    order?: true
    moodboardId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MoodboardItemCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    sourceUrl?: true
    category?: true
    order?: true
    moodboardId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MoodboardItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MoodboardItem to aggregate.
     */
    where?: MoodboardItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoodboardItems to fetch.
     */
    orderBy?: MoodboardItemOrderByWithRelationInput | MoodboardItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MoodboardItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoodboardItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoodboardItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MoodboardItems
    **/
    _count?: true | MoodboardItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MoodboardItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MoodboardItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MoodboardItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MoodboardItemMaxAggregateInputType
  }

  export type GetMoodboardItemAggregateType<T extends MoodboardItemAggregateArgs> = {
        [P in keyof T & keyof AggregateMoodboardItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMoodboardItem[P]>
      : GetScalarType<T[P], AggregateMoodboardItem[P]>
  }




  export type MoodboardItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoodboardItemWhereInput
    orderBy?: MoodboardItemOrderByWithAggregationInput | MoodboardItemOrderByWithAggregationInput[]
    by: MoodboardItemScalarFieldEnum[] | MoodboardItemScalarFieldEnum
    having?: MoodboardItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MoodboardItemCountAggregateInputType | true
    _avg?: MoodboardItemAvgAggregateInputType
    _sum?: MoodboardItemSumAggregateInputType
    _min?: MoodboardItemMinAggregateInputType
    _max?: MoodboardItemMaxAggregateInputType
  }

  export type MoodboardItemGroupByOutputType = {
    id: string
    title: string | null
    description: string | null
    imageUrl: string
    sourceUrl: string | null
    category: string | null
    order: number
    moodboardId: string
    createdAt: Date
    updatedAt: Date
    _count: MoodboardItemCountAggregateOutputType | null
    _avg: MoodboardItemAvgAggregateOutputType | null
    _sum: MoodboardItemSumAggregateOutputType | null
    _min: MoodboardItemMinAggregateOutputType | null
    _max: MoodboardItemMaxAggregateOutputType | null
  }

  type GetMoodboardItemGroupByPayload<T extends MoodboardItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MoodboardItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MoodboardItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MoodboardItemGroupByOutputType[P]>
            : GetScalarType<T[P], MoodboardItemGroupByOutputType[P]>
        }
      >
    >


  export type MoodboardItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    sourceUrl?: boolean
    category?: boolean
    order?: boolean
    moodboardId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientComments?: boolean | MoodboardItem$clientCommentsArgs<ExtArgs>
    moodboard?: boolean | MoodboardDefaultArgs<ExtArgs>
    _count?: boolean | MoodboardItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moodboardItem"]>

  export type MoodboardItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    sourceUrl?: boolean
    category?: boolean
    order?: boolean
    moodboardId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    moodboard?: boolean | MoodboardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moodboardItem"]>

  export type MoodboardItemSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    sourceUrl?: boolean
    category?: boolean
    order?: boolean
    moodboardId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MoodboardItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientComments?: boolean | MoodboardItem$clientCommentsArgs<ExtArgs>
    moodboard?: boolean | MoodboardDefaultArgs<ExtArgs>
    _count?: boolean | MoodboardItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MoodboardItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    moodboard?: boolean | MoodboardDefaultArgs<ExtArgs>
  }

  export type $MoodboardItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MoodboardItem"
    objects: {
      clientComments: Prisma.$MoodboardCommentPayload<ExtArgs>[]
      moodboard: Prisma.$MoodboardPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string | null
      description: string | null
      imageUrl: string
      sourceUrl: string | null
      category: string | null
      order: number
      moodboardId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["moodboardItem"]>
    composites: {}
  }

  type MoodboardItemGetPayload<S extends boolean | null | undefined | MoodboardItemDefaultArgs> = $Result.GetResult<Prisma.$MoodboardItemPayload, S>

  type MoodboardItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MoodboardItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MoodboardItemCountAggregateInputType | true
    }

  export interface MoodboardItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MoodboardItem'], meta: { name: 'MoodboardItem' } }
    /**
     * Find zero or one MoodboardItem that matches the filter.
     * @param {MoodboardItemFindUniqueArgs} args - Arguments to find a MoodboardItem
     * @example
     * // Get one MoodboardItem
     * const moodboardItem = await prisma.moodboardItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MoodboardItemFindUniqueArgs>(args: SelectSubset<T, MoodboardItemFindUniqueArgs<ExtArgs>>): Prisma__MoodboardItemClient<$Result.GetResult<Prisma.$MoodboardItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MoodboardItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MoodboardItemFindUniqueOrThrowArgs} args - Arguments to find a MoodboardItem
     * @example
     * // Get one MoodboardItem
     * const moodboardItem = await prisma.moodboardItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MoodboardItemFindUniqueOrThrowArgs>(args: SelectSubset<T, MoodboardItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MoodboardItemClient<$Result.GetResult<Prisma.$MoodboardItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MoodboardItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodboardItemFindFirstArgs} args - Arguments to find a MoodboardItem
     * @example
     * // Get one MoodboardItem
     * const moodboardItem = await prisma.moodboardItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MoodboardItemFindFirstArgs>(args?: SelectSubset<T, MoodboardItemFindFirstArgs<ExtArgs>>): Prisma__MoodboardItemClient<$Result.GetResult<Prisma.$MoodboardItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MoodboardItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodboardItemFindFirstOrThrowArgs} args - Arguments to find a MoodboardItem
     * @example
     * // Get one MoodboardItem
     * const moodboardItem = await prisma.moodboardItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MoodboardItemFindFirstOrThrowArgs>(args?: SelectSubset<T, MoodboardItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__MoodboardItemClient<$Result.GetResult<Prisma.$MoodboardItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MoodboardItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodboardItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MoodboardItems
     * const moodboardItems = await prisma.moodboardItem.findMany()
     * 
     * // Get first 10 MoodboardItems
     * const moodboardItems = await prisma.moodboardItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moodboardItemWithIdOnly = await prisma.moodboardItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MoodboardItemFindManyArgs>(args?: SelectSubset<T, MoodboardItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoodboardItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MoodboardItem.
     * @param {MoodboardItemCreateArgs} args - Arguments to create a MoodboardItem.
     * @example
     * // Create one MoodboardItem
     * const MoodboardItem = await prisma.moodboardItem.create({
     *   data: {
     *     // ... data to create a MoodboardItem
     *   }
     * })
     * 
     */
    create<T extends MoodboardItemCreateArgs>(args: SelectSubset<T, MoodboardItemCreateArgs<ExtArgs>>): Prisma__MoodboardItemClient<$Result.GetResult<Prisma.$MoodboardItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MoodboardItems.
     * @param {MoodboardItemCreateManyArgs} args - Arguments to create many MoodboardItems.
     * @example
     * // Create many MoodboardItems
     * const moodboardItem = await prisma.moodboardItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MoodboardItemCreateManyArgs>(args?: SelectSubset<T, MoodboardItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MoodboardItems and returns the data saved in the database.
     * @param {MoodboardItemCreateManyAndReturnArgs} args - Arguments to create many MoodboardItems.
     * @example
     * // Create many MoodboardItems
     * const moodboardItem = await prisma.moodboardItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MoodboardItems and only return the `id`
     * const moodboardItemWithIdOnly = await prisma.moodboardItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MoodboardItemCreateManyAndReturnArgs>(args?: SelectSubset<T, MoodboardItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoodboardItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MoodboardItem.
     * @param {MoodboardItemDeleteArgs} args - Arguments to delete one MoodboardItem.
     * @example
     * // Delete one MoodboardItem
     * const MoodboardItem = await prisma.moodboardItem.delete({
     *   where: {
     *     // ... filter to delete one MoodboardItem
     *   }
     * })
     * 
     */
    delete<T extends MoodboardItemDeleteArgs>(args: SelectSubset<T, MoodboardItemDeleteArgs<ExtArgs>>): Prisma__MoodboardItemClient<$Result.GetResult<Prisma.$MoodboardItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MoodboardItem.
     * @param {MoodboardItemUpdateArgs} args - Arguments to update one MoodboardItem.
     * @example
     * // Update one MoodboardItem
     * const moodboardItem = await prisma.moodboardItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MoodboardItemUpdateArgs>(args: SelectSubset<T, MoodboardItemUpdateArgs<ExtArgs>>): Prisma__MoodboardItemClient<$Result.GetResult<Prisma.$MoodboardItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MoodboardItems.
     * @param {MoodboardItemDeleteManyArgs} args - Arguments to filter MoodboardItems to delete.
     * @example
     * // Delete a few MoodboardItems
     * const { count } = await prisma.moodboardItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MoodboardItemDeleteManyArgs>(args?: SelectSubset<T, MoodboardItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MoodboardItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodboardItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MoodboardItems
     * const moodboardItem = await prisma.moodboardItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MoodboardItemUpdateManyArgs>(args: SelectSubset<T, MoodboardItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MoodboardItem.
     * @param {MoodboardItemUpsertArgs} args - Arguments to update or create a MoodboardItem.
     * @example
     * // Update or create a MoodboardItem
     * const moodboardItem = await prisma.moodboardItem.upsert({
     *   create: {
     *     // ... data to create a MoodboardItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MoodboardItem we want to update
     *   }
     * })
     */
    upsert<T extends MoodboardItemUpsertArgs>(args: SelectSubset<T, MoodboardItemUpsertArgs<ExtArgs>>): Prisma__MoodboardItemClient<$Result.GetResult<Prisma.$MoodboardItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MoodboardItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodboardItemCountArgs} args - Arguments to filter MoodboardItems to count.
     * @example
     * // Count the number of MoodboardItems
     * const count = await prisma.moodboardItem.count({
     *   where: {
     *     // ... the filter for the MoodboardItems we want to count
     *   }
     * })
    **/
    count<T extends MoodboardItemCountArgs>(
      args?: Subset<T, MoodboardItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MoodboardItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MoodboardItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodboardItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MoodboardItemAggregateArgs>(args: Subset<T, MoodboardItemAggregateArgs>): Prisma.PrismaPromise<GetMoodboardItemAggregateType<T>>

    /**
     * Group by MoodboardItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodboardItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MoodboardItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MoodboardItemGroupByArgs['orderBy'] }
        : { orderBy?: MoodboardItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MoodboardItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMoodboardItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MoodboardItem model
   */
  readonly fields: MoodboardItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MoodboardItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MoodboardItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clientComments<T extends MoodboardItem$clientCommentsArgs<ExtArgs> = {}>(args?: Subset<T, MoodboardItem$clientCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoodboardCommentPayload<ExtArgs>, T, "findMany"> | Null>
    moodboard<T extends MoodboardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MoodboardDefaultArgs<ExtArgs>>): Prisma__MoodboardClient<$Result.GetResult<Prisma.$MoodboardPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MoodboardItem model
   */ 
  interface MoodboardItemFieldRefs {
    readonly id: FieldRef<"MoodboardItem", 'String'>
    readonly title: FieldRef<"MoodboardItem", 'String'>
    readonly description: FieldRef<"MoodboardItem", 'String'>
    readonly imageUrl: FieldRef<"MoodboardItem", 'String'>
    readonly sourceUrl: FieldRef<"MoodboardItem", 'String'>
    readonly category: FieldRef<"MoodboardItem", 'String'>
    readonly order: FieldRef<"MoodboardItem", 'Int'>
    readonly moodboardId: FieldRef<"MoodboardItem", 'String'>
    readonly createdAt: FieldRef<"MoodboardItem", 'DateTime'>
    readonly updatedAt: FieldRef<"MoodboardItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MoodboardItem findUnique
   */
  export type MoodboardItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardItem
     */
    select?: MoodboardItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardItemInclude<ExtArgs> | null
    /**
     * Filter, which MoodboardItem to fetch.
     */
    where: MoodboardItemWhereUniqueInput
  }

  /**
   * MoodboardItem findUniqueOrThrow
   */
  export type MoodboardItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardItem
     */
    select?: MoodboardItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardItemInclude<ExtArgs> | null
    /**
     * Filter, which MoodboardItem to fetch.
     */
    where: MoodboardItemWhereUniqueInput
  }

  /**
   * MoodboardItem findFirst
   */
  export type MoodboardItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardItem
     */
    select?: MoodboardItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardItemInclude<ExtArgs> | null
    /**
     * Filter, which MoodboardItem to fetch.
     */
    where?: MoodboardItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoodboardItems to fetch.
     */
    orderBy?: MoodboardItemOrderByWithRelationInput | MoodboardItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MoodboardItems.
     */
    cursor?: MoodboardItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoodboardItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoodboardItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MoodboardItems.
     */
    distinct?: MoodboardItemScalarFieldEnum | MoodboardItemScalarFieldEnum[]
  }

  /**
   * MoodboardItem findFirstOrThrow
   */
  export type MoodboardItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardItem
     */
    select?: MoodboardItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardItemInclude<ExtArgs> | null
    /**
     * Filter, which MoodboardItem to fetch.
     */
    where?: MoodboardItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoodboardItems to fetch.
     */
    orderBy?: MoodboardItemOrderByWithRelationInput | MoodboardItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MoodboardItems.
     */
    cursor?: MoodboardItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoodboardItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoodboardItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MoodboardItems.
     */
    distinct?: MoodboardItemScalarFieldEnum | MoodboardItemScalarFieldEnum[]
  }

  /**
   * MoodboardItem findMany
   */
  export type MoodboardItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardItem
     */
    select?: MoodboardItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardItemInclude<ExtArgs> | null
    /**
     * Filter, which MoodboardItems to fetch.
     */
    where?: MoodboardItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoodboardItems to fetch.
     */
    orderBy?: MoodboardItemOrderByWithRelationInput | MoodboardItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MoodboardItems.
     */
    cursor?: MoodboardItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoodboardItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoodboardItems.
     */
    skip?: number
    distinct?: MoodboardItemScalarFieldEnum | MoodboardItemScalarFieldEnum[]
  }

  /**
   * MoodboardItem create
   */
  export type MoodboardItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardItem
     */
    select?: MoodboardItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardItemInclude<ExtArgs> | null
    /**
     * The data needed to create a MoodboardItem.
     */
    data: XOR<MoodboardItemCreateInput, MoodboardItemUncheckedCreateInput>
  }

  /**
   * MoodboardItem createMany
   */
  export type MoodboardItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MoodboardItems.
     */
    data: MoodboardItemCreateManyInput | MoodboardItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MoodboardItem createManyAndReturn
   */
  export type MoodboardItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardItem
     */
    select?: MoodboardItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MoodboardItems.
     */
    data: MoodboardItemCreateManyInput | MoodboardItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MoodboardItem update
   */
  export type MoodboardItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardItem
     */
    select?: MoodboardItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardItemInclude<ExtArgs> | null
    /**
     * The data needed to update a MoodboardItem.
     */
    data: XOR<MoodboardItemUpdateInput, MoodboardItemUncheckedUpdateInput>
    /**
     * Choose, which MoodboardItem to update.
     */
    where: MoodboardItemWhereUniqueInput
  }

  /**
   * MoodboardItem updateMany
   */
  export type MoodboardItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MoodboardItems.
     */
    data: XOR<MoodboardItemUpdateManyMutationInput, MoodboardItemUncheckedUpdateManyInput>
    /**
     * Filter which MoodboardItems to update
     */
    where?: MoodboardItemWhereInput
  }

  /**
   * MoodboardItem upsert
   */
  export type MoodboardItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardItem
     */
    select?: MoodboardItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardItemInclude<ExtArgs> | null
    /**
     * The filter to search for the MoodboardItem to update in case it exists.
     */
    where: MoodboardItemWhereUniqueInput
    /**
     * In case the MoodboardItem found by the `where` argument doesn't exist, create a new MoodboardItem with this data.
     */
    create: XOR<MoodboardItemCreateInput, MoodboardItemUncheckedCreateInput>
    /**
     * In case the MoodboardItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MoodboardItemUpdateInput, MoodboardItemUncheckedUpdateInput>
  }

  /**
   * MoodboardItem delete
   */
  export type MoodboardItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardItem
     */
    select?: MoodboardItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardItemInclude<ExtArgs> | null
    /**
     * Filter which MoodboardItem to delete.
     */
    where: MoodboardItemWhereUniqueInput
  }

  /**
   * MoodboardItem deleteMany
   */
  export type MoodboardItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MoodboardItems to delete
     */
    where?: MoodboardItemWhereInput
  }

  /**
   * MoodboardItem.clientComments
   */
  export type MoodboardItem$clientCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardComment
     */
    select?: MoodboardCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardCommentInclude<ExtArgs> | null
    where?: MoodboardCommentWhereInput
    orderBy?: MoodboardCommentOrderByWithRelationInput | MoodboardCommentOrderByWithRelationInput[]
    cursor?: MoodboardCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MoodboardCommentScalarFieldEnum | MoodboardCommentScalarFieldEnum[]
  }

  /**
   * MoodboardItem without action
   */
  export type MoodboardItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardItem
     */
    select?: MoodboardItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardItemInclude<ExtArgs> | null
  }


  /**
   * Model MoodboardComment
   */

  export type AggregateMoodboardComment = {
    _count: MoodboardCommentCountAggregateOutputType | null
    _avg: MoodboardCommentAvgAggregateOutputType | null
    _sum: MoodboardCommentSumAggregateOutputType | null
    _min: MoodboardCommentMinAggregateOutputType | null
    _max: MoodboardCommentMaxAggregateOutputType | null
  }

  export type MoodboardCommentAvgAggregateOutputType = {
    xPosition: number | null
    yPosition: number | null
  }

  export type MoodboardCommentSumAggregateOutputType = {
    xPosition: number | null
    yPosition: number | null
  }

  export type MoodboardCommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    xPosition: number | null
    yPosition: number | null
    authorId: string | null
    authorName: string | null
    itemId: string | null
    createdAt: Date | null
  }

  export type MoodboardCommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    xPosition: number | null
    yPosition: number | null
    authorId: string | null
    authorName: string | null
    itemId: string | null
    createdAt: Date | null
  }

  export type MoodboardCommentCountAggregateOutputType = {
    id: number
    content: number
    xPosition: number
    yPosition: number
    authorId: number
    authorName: number
    itemId: number
    createdAt: number
    _all: number
  }


  export type MoodboardCommentAvgAggregateInputType = {
    xPosition?: true
    yPosition?: true
  }

  export type MoodboardCommentSumAggregateInputType = {
    xPosition?: true
    yPosition?: true
  }

  export type MoodboardCommentMinAggregateInputType = {
    id?: true
    content?: true
    xPosition?: true
    yPosition?: true
    authorId?: true
    authorName?: true
    itemId?: true
    createdAt?: true
  }

  export type MoodboardCommentMaxAggregateInputType = {
    id?: true
    content?: true
    xPosition?: true
    yPosition?: true
    authorId?: true
    authorName?: true
    itemId?: true
    createdAt?: true
  }

  export type MoodboardCommentCountAggregateInputType = {
    id?: true
    content?: true
    xPosition?: true
    yPosition?: true
    authorId?: true
    authorName?: true
    itemId?: true
    createdAt?: true
    _all?: true
  }

  export type MoodboardCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MoodboardComment to aggregate.
     */
    where?: MoodboardCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoodboardComments to fetch.
     */
    orderBy?: MoodboardCommentOrderByWithRelationInput | MoodboardCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MoodboardCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoodboardComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoodboardComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MoodboardComments
    **/
    _count?: true | MoodboardCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MoodboardCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MoodboardCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MoodboardCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MoodboardCommentMaxAggregateInputType
  }

  export type GetMoodboardCommentAggregateType<T extends MoodboardCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateMoodboardComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMoodboardComment[P]>
      : GetScalarType<T[P], AggregateMoodboardComment[P]>
  }




  export type MoodboardCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoodboardCommentWhereInput
    orderBy?: MoodboardCommentOrderByWithAggregationInput | MoodboardCommentOrderByWithAggregationInput[]
    by: MoodboardCommentScalarFieldEnum[] | MoodboardCommentScalarFieldEnum
    having?: MoodboardCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MoodboardCommentCountAggregateInputType | true
    _avg?: MoodboardCommentAvgAggregateInputType
    _sum?: MoodboardCommentSumAggregateInputType
    _min?: MoodboardCommentMinAggregateInputType
    _max?: MoodboardCommentMaxAggregateInputType
  }

  export type MoodboardCommentGroupByOutputType = {
    id: string
    content: string
    xPosition: number
    yPosition: number
    authorId: string | null
    authorName: string | null
    itemId: string
    createdAt: Date
    _count: MoodboardCommentCountAggregateOutputType | null
    _avg: MoodboardCommentAvgAggregateOutputType | null
    _sum: MoodboardCommentSumAggregateOutputType | null
    _min: MoodboardCommentMinAggregateOutputType | null
    _max: MoodboardCommentMaxAggregateOutputType | null
  }

  type GetMoodboardCommentGroupByPayload<T extends MoodboardCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MoodboardCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MoodboardCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MoodboardCommentGroupByOutputType[P]>
            : GetScalarType<T[P], MoodboardCommentGroupByOutputType[P]>
        }
      >
    >


  export type MoodboardCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    xPosition?: boolean
    yPosition?: boolean
    authorId?: boolean
    authorName?: boolean
    itemId?: boolean
    createdAt?: boolean
    author?: boolean | MoodboardComment$authorArgs<ExtArgs>
    item?: boolean | MoodboardItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moodboardComment"]>

  export type MoodboardCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    xPosition?: boolean
    yPosition?: boolean
    authorId?: boolean
    authorName?: boolean
    itemId?: boolean
    createdAt?: boolean
    author?: boolean | MoodboardComment$authorArgs<ExtArgs>
    item?: boolean | MoodboardItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moodboardComment"]>

  export type MoodboardCommentSelectScalar = {
    id?: boolean
    content?: boolean
    xPosition?: boolean
    yPosition?: boolean
    authorId?: boolean
    authorName?: boolean
    itemId?: boolean
    createdAt?: boolean
  }

  export type MoodboardCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | MoodboardComment$authorArgs<ExtArgs>
    item?: boolean | MoodboardItemDefaultArgs<ExtArgs>
  }
  export type MoodboardCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | MoodboardComment$authorArgs<ExtArgs>
    item?: boolean | MoodboardItemDefaultArgs<ExtArgs>
  }

  export type $MoodboardCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MoodboardComment"
    objects: {
      author: Prisma.$UserPayload<ExtArgs> | null
      item: Prisma.$MoodboardItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      xPosition: number
      yPosition: number
      authorId: string | null
      authorName: string | null
      itemId: string
      createdAt: Date
    }, ExtArgs["result"]["moodboardComment"]>
    composites: {}
  }

  type MoodboardCommentGetPayload<S extends boolean | null | undefined | MoodboardCommentDefaultArgs> = $Result.GetResult<Prisma.$MoodboardCommentPayload, S>

  type MoodboardCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MoodboardCommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MoodboardCommentCountAggregateInputType | true
    }

  export interface MoodboardCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MoodboardComment'], meta: { name: 'MoodboardComment' } }
    /**
     * Find zero or one MoodboardComment that matches the filter.
     * @param {MoodboardCommentFindUniqueArgs} args - Arguments to find a MoodboardComment
     * @example
     * // Get one MoodboardComment
     * const moodboardComment = await prisma.moodboardComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MoodboardCommentFindUniqueArgs>(args: SelectSubset<T, MoodboardCommentFindUniqueArgs<ExtArgs>>): Prisma__MoodboardCommentClient<$Result.GetResult<Prisma.$MoodboardCommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MoodboardComment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MoodboardCommentFindUniqueOrThrowArgs} args - Arguments to find a MoodboardComment
     * @example
     * // Get one MoodboardComment
     * const moodboardComment = await prisma.moodboardComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MoodboardCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, MoodboardCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MoodboardCommentClient<$Result.GetResult<Prisma.$MoodboardCommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MoodboardComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodboardCommentFindFirstArgs} args - Arguments to find a MoodboardComment
     * @example
     * // Get one MoodboardComment
     * const moodboardComment = await prisma.moodboardComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MoodboardCommentFindFirstArgs>(args?: SelectSubset<T, MoodboardCommentFindFirstArgs<ExtArgs>>): Prisma__MoodboardCommentClient<$Result.GetResult<Prisma.$MoodboardCommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MoodboardComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodboardCommentFindFirstOrThrowArgs} args - Arguments to find a MoodboardComment
     * @example
     * // Get one MoodboardComment
     * const moodboardComment = await prisma.moodboardComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MoodboardCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, MoodboardCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__MoodboardCommentClient<$Result.GetResult<Prisma.$MoodboardCommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MoodboardComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodboardCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MoodboardComments
     * const moodboardComments = await prisma.moodboardComment.findMany()
     * 
     * // Get first 10 MoodboardComments
     * const moodboardComments = await prisma.moodboardComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moodboardCommentWithIdOnly = await prisma.moodboardComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MoodboardCommentFindManyArgs>(args?: SelectSubset<T, MoodboardCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoodboardCommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MoodboardComment.
     * @param {MoodboardCommentCreateArgs} args - Arguments to create a MoodboardComment.
     * @example
     * // Create one MoodboardComment
     * const MoodboardComment = await prisma.moodboardComment.create({
     *   data: {
     *     // ... data to create a MoodboardComment
     *   }
     * })
     * 
     */
    create<T extends MoodboardCommentCreateArgs>(args: SelectSubset<T, MoodboardCommentCreateArgs<ExtArgs>>): Prisma__MoodboardCommentClient<$Result.GetResult<Prisma.$MoodboardCommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MoodboardComments.
     * @param {MoodboardCommentCreateManyArgs} args - Arguments to create many MoodboardComments.
     * @example
     * // Create many MoodboardComments
     * const moodboardComment = await prisma.moodboardComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MoodboardCommentCreateManyArgs>(args?: SelectSubset<T, MoodboardCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MoodboardComments and returns the data saved in the database.
     * @param {MoodboardCommentCreateManyAndReturnArgs} args - Arguments to create many MoodboardComments.
     * @example
     * // Create many MoodboardComments
     * const moodboardComment = await prisma.moodboardComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MoodboardComments and only return the `id`
     * const moodboardCommentWithIdOnly = await prisma.moodboardComment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MoodboardCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, MoodboardCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoodboardCommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MoodboardComment.
     * @param {MoodboardCommentDeleteArgs} args - Arguments to delete one MoodboardComment.
     * @example
     * // Delete one MoodboardComment
     * const MoodboardComment = await prisma.moodboardComment.delete({
     *   where: {
     *     // ... filter to delete one MoodboardComment
     *   }
     * })
     * 
     */
    delete<T extends MoodboardCommentDeleteArgs>(args: SelectSubset<T, MoodboardCommentDeleteArgs<ExtArgs>>): Prisma__MoodboardCommentClient<$Result.GetResult<Prisma.$MoodboardCommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MoodboardComment.
     * @param {MoodboardCommentUpdateArgs} args - Arguments to update one MoodboardComment.
     * @example
     * // Update one MoodboardComment
     * const moodboardComment = await prisma.moodboardComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MoodboardCommentUpdateArgs>(args: SelectSubset<T, MoodboardCommentUpdateArgs<ExtArgs>>): Prisma__MoodboardCommentClient<$Result.GetResult<Prisma.$MoodboardCommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MoodboardComments.
     * @param {MoodboardCommentDeleteManyArgs} args - Arguments to filter MoodboardComments to delete.
     * @example
     * // Delete a few MoodboardComments
     * const { count } = await prisma.moodboardComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MoodboardCommentDeleteManyArgs>(args?: SelectSubset<T, MoodboardCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MoodboardComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodboardCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MoodboardComments
     * const moodboardComment = await prisma.moodboardComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MoodboardCommentUpdateManyArgs>(args: SelectSubset<T, MoodboardCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MoodboardComment.
     * @param {MoodboardCommentUpsertArgs} args - Arguments to update or create a MoodboardComment.
     * @example
     * // Update or create a MoodboardComment
     * const moodboardComment = await prisma.moodboardComment.upsert({
     *   create: {
     *     // ... data to create a MoodboardComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MoodboardComment we want to update
     *   }
     * })
     */
    upsert<T extends MoodboardCommentUpsertArgs>(args: SelectSubset<T, MoodboardCommentUpsertArgs<ExtArgs>>): Prisma__MoodboardCommentClient<$Result.GetResult<Prisma.$MoodboardCommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MoodboardComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodboardCommentCountArgs} args - Arguments to filter MoodboardComments to count.
     * @example
     * // Count the number of MoodboardComments
     * const count = await prisma.moodboardComment.count({
     *   where: {
     *     // ... the filter for the MoodboardComments we want to count
     *   }
     * })
    **/
    count<T extends MoodboardCommentCountArgs>(
      args?: Subset<T, MoodboardCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MoodboardCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MoodboardComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodboardCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MoodboardCommentAggregateArgs>(args: Subset<T, MoodboardCommentAggregateArgs>): Prisma.PrismaPromise<GetMoodboardCommentAggregateType<T>>

    /**
     * Group by MoodboardComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodboardCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MoodboardCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MoodboardCommentGroupByArgs['orderBy'] }
        : { orderBy?: MoodboardCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MoodboardCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMoodboardCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MoodboardComment model
   */
  readonly fields: MoodboardCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MoodboardComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MoodboardCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends MoodboardComment$authorArgs<ExtArgs> = {}>(args?: Subset<T, MoodboardComment$authorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    item<T extends MoodboardItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MoodboardItemDefaultArgs<ExtArgs>>): Prisma__MoodboardItemClient<$Result.GetResult<Prisma.$MoodboardItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MoodboardComment model
   */ 
  interface MoodboardCommentFieldRefs {
    readonly id: FieldRef<"MoodboardComment", 'String'>
    readonly content: FieldRef<"MoodboardComment", 'String'>
    readonly xPosition: FieldRef<"MoodboardComment", 'Float'>
    readonly yPosition: FieldRef<"MoodboardComment", 'Float'>
    readonly authorId: FieldRef<"MoodboardComment", 'String'>
    readonly authorName: FieldRef<"MoodboardComment", 'String'>
    readonly itemId: FieldRef<"MoodboardComment", 'String'>
    readonly createdAt: FieldRef<"MoodboardComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MoodboardComment findUnique
   */
  export type MoodboardCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardComment
     */
    select?: MoodboardCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardCommentInclude<ExtArgs> | null
    /**
     * Filter, which MoodboardComment to fetch.
     */
    where: MoodboardCommentWhereUniqueInput
  }

  /**
   * MoodboardComment findUniqueOrThrow
   */
  export type MoodboardCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardComment
     */
    select?: MoodboardCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardCommentInclude<ExtArgs> | null
    /**
     * Filter, which MoodboardComment to fetch.
     */
    where: MoodboardCommentWhereUniqueInput
  }

  /**
   * MoodboardComment findFirst
   */
  export type MoodboardCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardComment
     */
    select?: MoodboardCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardCommentInclude<ExtArgs> | null
    /**
     * Filter, which MoodboardComment to fetch.
     */
    where?: MoodboardCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoodboardComments to fetch.
     */
    orderBy?: MoodboardCommentOrderByWithRelationInput | MoodboardCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MoodboardComments.
     */
    cursor?: MoodboardCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoodboardComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoodboardComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MoodboardComments.
     */
    distinct?: MoodboardCommentScalarFieldEnum | MoodboardCommentScalarFieldEnum[]
  }

  /**
   * MoodboardComment findFirstOrThrow
   */
  export type MoodboardCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardComment
     */
    select?: MoodboardCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardCommentInclude<ExtArgs> | null
    /**
     * Filter, which MoodboardComment to fetch.
     */
    where?: MoodboardCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoodboardComments to fetch.
     */
    orderBy?: MoodboardCommentOrderByWithRelationInput | MoodboardCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MoodboardComments.
     */
    cursor?: MoodboardCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoodboardComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoodboardComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MoodboardComments.
     */
    distinct?: MoodboardCommentScalarFieldEnum | MoodboardCommentScalarFieldEnum[]
  }

  /**
   * MoodboardComment findMany
   */
  export type MoodboardCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardComment
     */
    select?: MoodboardCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardCommentInclude<ExtArgs> | null
    /**
     * Filter, which MoodboardComments to fetch.
     */
    where?: MoodboardCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoodboardComments to fetch.
     */
    orderBy?: MoodboardCommentOrderByWithRelationInput | MoodboardCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MoodboardComments.
     */
    cursor?: MoodboardCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoodboardComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoodboardComments.
     */
    skip?: number
    distinct?: MoodboardCommentScalarFieldEnum | MoodboardCommentScalarFieldEnum[]
  }

  /**
   * MoodboardComment create
   */
  export type MoodboardCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardComment
     */
    select?: MoodboardCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a MoodboardComment.
     */
    data: XOR<MoodboardCommentCreateInput, MoodboardCommentUncheckedCreateInput>
  }

  /**
   * MoodboardComment createMany
   */
  export type MoodboardCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MoodboardComments.
     */
    data: MoodboardCommentCreateManyInput | MoodboardCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MoodboardComment createManyAndReturn
   */
  export type MoodboardCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardComment
     */
    select?: MoodboardCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MoodboardComments.
     */
    data: MoodboardCommentCreateManyInput | MoodboardCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MoodboardComment update
   */
  export type MoodboardCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardComment
     */
    select?: MoodboardCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a MoodboardComment.
     */
    data: XOR<MoodboardCommentUpdateInput, MoodboardCommentUncheckedUpdateInput>
    /**
     * Choose, which MoodboardComment to update.
     */
    where: MoodboardCommentWhereUniqueInput
  }

  /**
   * MoodboardComment updateMany
   */
  export type MoodboardCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MoodboardComments.
     */
    data: XOR<MoodboardCommentUpdateManyMutationInput, MoodboardCommentUncheckedUpdateManyInput>
    /**
     * Filter which MoodboardComments to update
     */
    where?: MoodboardCommentWhereInput
  }

  /**
   * MoodboardComment upsert
   */
  export type MoodboardCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardComment
     */
    select?: MoodboardCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the MoodboardComment to update in case it exists.
     */
    where: MoodboardCommentWhereUniqueInput
    /**
     * In case the MoodboardComment found by the `where` argument doesn't exist, create a new MoodboardComment with this data.
     */
    create: XOR<MoodboardCommentCreateInput, MoodboardCommentUncheckedCreateInput>
    /**
     * In case the MoodboardComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MoodboardCommentUpdateInput, MoodboardCommentUncheckedUpdateInput>
  }

  /**
   * MoodboardComment delete
   */
  export type MoodboardCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardComment
     */
    select?: MoodboardCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardCommentInclude<ExtArgs> | null
    /**
     * Filter which MoodboardComment to delete.
     */
    where: MoodboardCommentWhereUniqueInput
  }

  /**
   * MoodboardComment deleteMany
   */
  export type MoodboardCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MoodboardComments to delete
     */
    where?: MoodboardCommentWhereInput
  }

  /**
   * MoodboardComment.author
   */
  export type MoodboardComment$authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * MoodboardComment without action
   */
  export type MoodboardCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodboardComment
     */
    select?: MoodboardCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodboardCommentInclude<ExtArgs> | null
  }


  /**
   * Model ParsedSpecItem
   */

  export type AggregateParsedSpecItem = {
    _count: ParsedSpecItemCountAggregateOutputType | null
    _avg: ParsedSpecItemAvgAggregateOutputType | null
    _sum: ParsedSpecItemSumAggregateOutputType | null
    _min: ParsedSpecItemMinAggregateOutputType | null
    _max: ParsedSpecItemMaxAggregateOutputType | null
  }

  export type ParsedSpecItemAvgAggregateOutputType = {
    parsedQuantity: number | null
    parsedPrice: Decimal | null
    actualPrice: Decimal | null
    parseConfidence: number | null
    sourcePage: number | null
    sourceLineNumber: number | null
  }

  export type ParsedSpecItemSumAggregateOutputType = {
    parsedQuantity: number | null
    parsedPrice: Decimal | null
    actualPrice: Decimal | null
    parseConfidence: number | null
    sourcePage: number | null
    sourceLineNumber: number | null
  }

  export type ParsedSpecItemMinAggregateOutputType = {
    id: string | null
    originalText: string | null
    parsedCategory: string | null
    parsedBrand: string | null
    parsedModel: string | null
    parsedDescription: string | null
    parsedQuantity: number | null
    parsedPrice: Decimal | null
    status: $Enums.SpecItemStatus | null
    notes: string | null
    substitution: string | null
    actualPrice: Decimal | null
    parseConfidence: number | null
    requiresReview: boolean | null
    jobId: string | null
    sourceDocumentId: string | null
    sourcePage: number | null
    sourceLineNumber: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParsedSpecItemMaxAggregateOutputType = {
    id: string | null
    originalText: string | null
    parsedCategory: string | null
    parsedBrand: string | null
    parsedModel: string | null
    parsedDescription: string | null
    parsedQuantity: number | null
    parsedPrice: Decimal | null
    status: $Enums.SpecItemStatus | null
    notes: string | null
    substitution: string | null
    actualPrice: Decimal | null
    parseConfidence: number | null
    requiresReview: boolean | null
    jobId: string | null
    sourceDocumentId: string | null
    sourcePage: number | null
    sourceLineNumber: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParsedSpecItemCountAggregateOutputType = {
    id: number
    originalText: number
    parsedCategory: number
    parsedBrand: number
    parsedModel: number
    parsedDescription: number
    parsedQuantity: number
    parsedPrice: number
    status: number
    notes: number
    substitution: number
    actualPrice: number
    parseConfidence: number
    requiresReview: number
    jobId: number
    sourceDocumentId: number
    sourcePage: number
    sourceLineNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ParsedSpecItemAvgAggregateInputType = {
    parsedQuantity?: true
    parsedPrice?: true
    actualPrice?: true
    parseConfidence?: true
    sourcePage?: true
    sourceLineNumber?: true
  }

  export type ParsedSpecItemSumAggregateInputType = {
    parsedQuantity?: true
    parsedPrice?: true
    actualPrice?: true
    parseConfidence?: true
    sourcePage?: true
    sourceLineNumber?: true
  }

  export type ParsedSpecItemMinAggregateInputType = {
    id?: true
    originalText?: true
    parsedCategory?: true
    parsedBrand?: true
    parsedModel?: true
    parsedDescription?: true
    parsedQuantity?: true
    parsedPrice?: true
    status?: true
    notes?: true
    substitution?: true
    actualPrice?: true
    parseConfidence?: true
    requiresReview?: true
    jobId?: true
    sourceDocumentId?: true
    sourcePage?: true
    sourceLineNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParsedSpecItemMaxAggregateInputType = {
    id?: true
    originalText?: true
    parsedCategory?: true
    parsedBrand?: true
    parsedModel?: true
    parsedDescription?: true
    parsedQuantity?: true
    parsedPrice?: true
    status?: true
    notes?: true
    substitution?: true
    actualPrice?: true
    parseConfidence?: true
    requiresReview?: true
    jobId?: true
    sourceDocumentId?: true
    sourcePage?: true
    sourceLineNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParsedSpecItemCountAggregateInputType = {
    id?: true
    originalText?: true
    parsedCategory?: true
    parsedBrand?: true
    parsedModel?: true
    parsedDescription?: true
    parsedQuantity?: true
    parsedPrice?: true
    status?: true
    notes?: true
    substitution?: true
    actualPrice?: true
    parseConfidence?: true
    requiresReview?: true
    jobId?: true
    sourceDocumentId?: true
    sourcePage?: true
    sourceLineNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ParsedSpecItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParsedSpecItem to aggregate.
     */
    where?: ParsedSpecItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedSpecItems to fetch.
     */
    orderBy?: ParsedSpecItemOrderByWithRelationInput | ParsedSpecItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParsedSpecItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedSpecItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedSpecItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParsedSpecItems
    **/
    _count?: true | ParsedSpecItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParsedSpecItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParsedSpecItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParsedSpecItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParsedSpecItemMaxAggregateInputType
  }

  export type GetParsedSpecItemAggregateType<T extends ParsedSpecItemAggregateArgs> = {
        [P in keyof T & keyof AggregateParsedSpecItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParsedSpecItem[P]>
      : GetScalarType<T[P], AggregateParsedSpecItem[P]>
  }




  export type ParsedSpecItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParsedSpecItemWhereInput
    orderBy?: ParsedSpecItemOrderByWithAggregationInput | ParsedSpecItemOrderByWithAggregationInput[]
    by: ParsedSpecItemScalarFieldEnum[] | ParsedSpecItemScalarFieldEnum
    having?: ParsedSpecItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParsedSpecItemCountAggregateInputType | true
    _avg?: ParsedSpecItemAvgAggregateInputType
    _sum?: ParsedSpecItemSumAggregateInputType
    _min?: ParsedSpecItemMinAggregateInputType
    _max?: ParsedSpecItemMaxAggregateInputType
  }

  export type ParsedSpecItemGroupByOutputType = {
    id: string
    originalText: string
    parsedCategory: string | null
    parsedBrand: string | null
    parsedModel: string | null
    parsedDescription: string | null
    parsedQuantity: number | null
    parsedPrice: Decimal | null
    status: $Enums.SpecItemStatus
    notes: string | null
    substitution: string | null
    actualPrice: Decimal | null
    parseConfidence: number
    requiresReview: boolean
    jobId: string
    sourceDocumentId: string | null
    sourcePage: number | null
    sourceLineNumber: number | null
    createdAt: Date
    updatedAt: Date
    _count: ParsedSpecItemCountAggregateOutputType | null
    _avg: ParsedSpecItemAvgAggregateOutputType | null
    _sum: ParsedSpecItemSumAggregateOutputType | null
    _min: ParsedSpecItemMinAggregateOutputType | null
    _max: ParsedSpecItemMaxAggregateOutputType | null
  }

  type GetParsedSpecItemGroupByPayload<T extends ParsedSpecItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParsedSpecItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParsedSpecItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParsedSpecItemGroupByOutputType[P]>
            : GetScalarType<T[P], ParsedSpecItemGroupByOutputType[P]>
        }
      >
    >


  export type ParsedSpecItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    originalText?: boolean
    parsedCategory?: boolean
    parsedBrand?: boolean
    parsedModel?: boolean
    parsedDescription?: boolean
    parsedQuantity?: boolean
    parsedPrice?: boolean
    status?: boolean
    notes?: boolean
    substitution?: boolean
    actualPrice?: boolean
    parseConfidence?: boolean
    requiresReview?: boolean
    jobId?: boolean
    sourceDocumentId?: boolean
    sourcePage?: boolean
    sourceLineNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsedSpecItem"]>

  export type ParsedSpecItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    originalText?: boolean
    parsedCategory?: boolean
    parsedBrand?: boolean
    parsedModel?: boolean
    parsedDescription?: boolean
    parsedQuantity?: boolean
    parsedPrice?: boolean
    status?: boolean
    notes?: boolean
    substitution?: boolean
    actualPrice?: boolean
    parseConfidence?: boolean
    requiresReview?: boolean
    jobId?: boolean
    sourceDocumentId?: boolean
    sourcePage?: boolean
    sourceLineNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsedSpecItem"]>

  export type ParsedSpecItemSelectScalar = {
    id?: boolean
    originalText?: boolean
    parsedCategory?: boolean
    parsedBrand?: boolean
    parsedModel?: boolean
    parsedDescription?: boolean
    parsedQuantity?: boolean
    parsedPrice?: boolean
    status?: boolean
    notes?: boolean
    substitution?: boolean
    actualPrice?: boolean
    parseConfidence?: boolean
    requiresReview?: boolean
    jobId?: boolean
    sourceDocumentId?: boolean
    sourcePage?: boolean
    sourceLineNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ParsedSpecItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
  }
  export type ParsedSpecItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
  }

  export type $ParsedSpecItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParsedSpecItem"
    objects: {
      job: Prisma.$JobPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      originalText: string
      parsedCategory: string | null
      parsedBrand: string | null
      parsedModel: string | null
      parsedDescription: string | null
      parsedQuantity: number | null
      parsedPrice: Prisma.Decimal | null
      status: $Enums.SpecItemStatus
      notes: string | null
      substitution: string | null
      actualPrice: Prisma.Decimal | null
      parseConfidence: number
      requiresReview: boolean
      jobId: string
      sourceDocumentId: string | null
      sourcePage: number | null
      sourceLineNumber: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["parsedSpecItem"]>
    composites: {}
  }

  type ParsedSpecItemGetPayload<S extends boolean | null | undefined | ParsedSpecItemDefaultArgs> = $Result.GetResult<Prisma.$ParsedSpecItemPayload, S>

  type ParsedSpecItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ParsedSpecItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ParsedSpecItemCountAggregateInputType | true
    }

  export interface ParsedSpecItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParsedSpecItem'], meta: { name: 'ParsedSpecItem' } }
    /**
     * Find zero or one ParsedSpecItem that matches the filter.
     * @param {ParsedSpecItemFindUniqueArgs} args - Arguments to find a ParsedSpecItem
     * @example
     * // Get one ParsedSpecItem
     * const parsedSpecItem = await prisma.parsedSpecItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParsedSpecItemFindUniqueArgs>(args: SelectSubset<T, ParsedSpecItemFindUniqueArgs<ExtArgs>>): Prisma__ParsedSpecItemClient<$Result.GetResult<Prisma.$ParsedSpecItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ParsedSpecItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ParsedSpecItemFindUniqueOrThrowArgs} args - Arguments to find a ParsedSpecItem
     * @example
     * // Get one ParsedSpecItem
     * const parsedSpecItem = await prisma.parsedSpecItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParsedSpecItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ParsedSpecItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParsedSpecItemClient<$Result.GetResult<Prisma.$ParsedSpecItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ParsedSpecItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedSpecItemFindFirstArgs} args - Arguments to find a ParsedSpecItem
     * @example
     * // Get one ParsedSpecItem
     * const parsedSpecItem = await prisma.parsedSpecItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParsedSpecItemFindFirstArgs>(args?: SelectSubset<T, ParsedSpecItemFindFirstArgs<ExtArgs>>): Prisma__ParsedSpecItemClient<$Result.GetResult<Prisma.$ParsedSpecItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ParsedSpecItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedSpecItemFindFirstOrThrowArgs} args - Arguments to find a ParsedSpecItem
     * @example
     * // Get one ParsedSpecItem
     * const parsedSpecItem = await prisma.parsedSpecItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParsedSpecItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ParsedSpecItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParsedSpecItemClient<$Result.GetResult<Prisma.$ParsedSpecItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ParsedSpecItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedSpecItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParsedSpecItems
     * const parsedSpecItems = await prisma.parsedSpecItem.findMany()
     * 
     * // Get first 10 ParsedSpecItems
     * const parsedSpecItems = await prisma.parsedSpecItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parsedSpecItemWithIdOnly = await prisma.parsedSpecItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParsedSpecItemFindManyArgs>(args?: SelectSubset<T, ParsedSpecItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedSpecItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ParsedSpecItem.
     * @param {ParsedSpecItemCreateArgs} args - Arguments to create a ParsedSpecItem.
     * @example
     * // Create one ParsedSpecItem
     * const ParsedSpecItem = await prisma.parsedSpecItem.create({
     *   data: {
     *     // ... data to create a ParsedSpecItem
     *   }
     * })
     * 
     */
    create<T extends ParsedSpecItemCreateArgs>(args: SelectSubset<T, ParsedSpecItemCreateArgs<ExtArgs>>): Prisma__ParsedSpecItemClient<$Result.GetResult<Prisma.$ParsedSpecItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ParsedSpecItems.
     * @param {ParsedSpecItemCreateManyArgs} args - Arguments to create many ParsedSpecItems.
     * @example
     * // Create many ParsedSpecItems
     * const parsedSpecItem = await prisma.parsedSpecItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParsedSpecItemCreateManyArgs>(args?: SelectSubset<T, ParsedSpecItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParsedSpecItems and returns the data saved in the database.
     * @param {ParsedSpecItemCreateManyAndReturnArgs} args - Arguments to create many ParsedSpecItems.
     * @example
     * // Create many ParsedSpecItems
     * const parsedSpecItem = await prisma.parsedSpecItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParsedSpecItems and only return the `id`
     * const parsedSpecItemWithIdOnly = await prisma.parsedSpecItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParsedSpecItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ParsedSpecItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedSpecItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ParsedSpecItem.
     * @param {ParsedSpecItemDeleteArgs} args - Arguments to delete one ParsedSpecItem.
     * @example
     * // Delete one ParsedSpecItem
     * const ParsedSpecItem = await prisma.parsedSpecItem.delete({
     *   where: {
     *     // ... filter to delete one ParsedSpecItem
     *   }
     * })
     * 
     */
    delete<T extends ParsedSpecItemDeleteArgs>(args: SelectSubset<T, ParsedSpecItemDeleteArgs<ExtArgs>>): Prisma__ParsedSpecItemClient<$Result.GetResult<Prisma.$ParsedSpecItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ParsedSpecItem.
     * @param {ParsedSpecItemUpdateArgs} args - Arguments to update one ParsedSpecItem.
     * @example
     * // Update one ParsedSpecItem
     * const parsedSpecItem = await prisma.parsedSpecItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParsedSpecItemUpdateArgs>(args: SelectSubset<T, ParsedSpecItemUpdateArgs<ExtArgs>>): Prisma__ParsedSpecItemClient<$Result.GetResult<Prisma.$ParsedSpecItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ParsedSpecItems.
     * @param {ParsedSpecItemDeleteManyArgs} args - Arguments to filter ParsedSpecItems to delete.
     * @example
     * // Delete a few ParsedSpecItems
     * const { count } = await prisma.parsedSpecItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParsedSpecItemDeleteManyArgs>(args?: SelectSubset<T, ParsedSpecItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParsedSpecItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedSpecItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParsedSpecItems
     * const parsedSpecItem = await prisma.parsedSpecItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParsedSpecItemUpdateManyArgs>(args: SelectSubset<T, ParsedSpecItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ParsedSpecItem.
     * @param {ParsedSpecItemUpsertArgs} args - Arguments to update or create a ParsedSpecItem.
     * @example
     * // Update or create a ParsedSpecItem
     * const parsedSpecItem = await prisma.parsedSpecItem.upsert({
     *   create: {
     *     // ... data to create a ParsedSpecItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParsedSpecItem we want to update
     *   }
     * })
     */
    upsert<T extends ParsedSpecItemUpsertArgs>(args: SelectSubset<T, ParsedSpecItemUpsertArgs<ExtArgs>>): Prisma__ParsedSpecItemClient<$Result.GetResult<Prisma.$ParsedSpecItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ParsedSpecItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedSpecItemCountArgs} args - Arguments to filter ParsedSpecItems to count.
     * @example
     * // Count the number of ParsedSpecItems
     * const count = await prisma.parsedSpecItem.count({
     *   where: {
     *     // ... the filter for the ParsedSpecItems we want to count
     *   }
     * })
    **/
    count<T extends ParsedSpecItemCountArgs>(
      args?: Subset<T, ParsedSpecItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParsedSpecItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParsedSpecItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedSpecItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParsedSpecItemAggregateArgs>(args: Subset<T, ParsedSpecItemAggregateArgs>): Prisma.PrismaPromise<GetParsedSpecItemAggregateType<T>>

    /**
     * Group by ParsedSpecItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedSpecItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParsedSpecItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParsedSpecItemGroupByArgs['orderBy'] }
        : { orderBy?: ParsedSpecItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParsedSpecItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParsedSpecItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParsedSpecItem model
   */
  readonly fields: ParsedSpecItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParsedSpecItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParsedSpecItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends JobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobDefaultArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParsedSpecItem model
   */ 
  interface ParsedSpecItemFieldRefs {
    readonly id: FieldRef<"ParsedSpecItem", 'String'>
    readonly originalText: FieldRef<"ParsedSpecItem", 'String'>
    readonly parsedCategory: FieldRef<"ParsedSpecItem", 'String'>
    readonly parsedBrand: FieldRef<"ParsedSpecItem", 'String'>
    readonly parsedModel: FieldRef<"ParsedSpecItem", 'String'>
    readonly parsedDescription: FieldRef<"ParsedSpecItem", 'String'>
    readonly parsedQuantity: FieldRef<"ParsedSpecItem", 'Int'>
    readonly parsedPrice: FieldRef<"ParsedSpecItem", 'Decimal'>
    readonly status: FieldRef<"ParsedSpecItem", 'SpecItemStatus'>
    readonly notes: FieldRef<"ParsedSpecItem", 'String'>
    readonly substitution: FieldRef<"ParsedSpecItem", 'String'>
    readonly actualPrice: FieldRef<"ParsedSpecItem", 'Decimal'>
    readonly parseConfidence: FieldRef<"ParsedSpecItem", 'Float'>
    readonly requiresReview: FieldRef<"ParsedSpecItem", 'Boolean'>
    readonly jobId: FieldRef<"ParsedSpecItem", 'String'>
    readonly sourceDocumentId: FieldRef<"ParsedSpecItem", 'String'>
    readonly sourcePage: FieldRef<"ParsedSpecItem", 'Int'>
    readonly sourceLineNumber: FieldRef<"ParsedSpecItem", 'Int'>
    readonly createdAt: FieldRef<"ParsedSpecItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ParsedSpecItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ParsedSpecItem findUnique
   */
  export type ParsedSpecItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedSpecItem
     */
    select?: ParsedSpecItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedSpecItemInclude<ExtArgs> | null
    /**
     * Filter, which ParsedSpecItem to fetch.
     */
    where: ParsedSpecItemWhereUniqueInput
  }

  /**
   * ParsedSpecItem findUniqueOrThrow
   */
  export type ParsedSpecItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedSpecItem
     */
    select?: ParsedSpecItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedSpecItemInclude<ExtArgs> | null
    /**
     * Filter, which ParsedSpecItem to fetch.
     */
    where: ParsedSpecItemWhereUniqueInput
  }

  /**
   * ParsedSpecItem findFirst
   */
  export type ParsedSpecItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedSpecItem
     */
    select?: ParsedSpecItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedSpecItemInclude<ExtArgs> | null
    /**
     * Filter, which ParsedSpecItem to fetch.
     */
    where?: ParsedSpecItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedSpecItems to fetch.
     */
    orderBy?: ParsedSpecItemOrderByWithRelationInput | ParsedSpecItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParsedSpecItems.
     */
    cursor?: ParsedSpecItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedSpecItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedSpecItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParsedSpecItems.
     */
    distinct?: ParsedSpecItemScalarFieldEnum | ParsedSpecItemScalarFieldEnum[]
  }

  /**
   * ParsedSpecItem findFirstOrThrow
   */
  export type ParsedSpecItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedSpecItem
     */
    select?: ParsedSpecItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedSpecItemInclude<ExtArgs> | null
    /**
     * Filter, which ParsedSpecItem to fetch.
     */
    where?: ParsedSpecItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedSpecItems to fetch.
     */
    orderBy?: ParsedSpecItemOrderByWithRelationInput | ParsedSpecItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParsedSpecItems.
     */
    cursor?: ParsedSpecItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedSpecItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedSpecItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParsedSpecItems.
     */
    distinct?: ParsedSpecItemScalarFieldEnum | ParsedSpecItemScalarFieldEnum[]
  }

  /**
   * ParsedSpecItem findMany
   */
  export type ParsedSpecItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedSpecItem
     */
    select?: ParsedSpecItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedSpecItemInclude<ExtArgs> | null
    /**
     * Filter, which ParsedSpecItems to fetch.
     */
    where?: ParsedSpecItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedSpecItems to fetch.
     */
    orderBy?: ParsedSpecItemOrderByWithRelationInput | ParsedSpecItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParsedSpecItems.
     */
    cursor?: ParsedSpecItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedSpecItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedSpecItems.
     */
    skip?: number
    distinct?: ParsedSpecItemScalarFieldEnum | ParsedSpecItemScalarFieldEnum[]
  }

  /**
   * ParsedSpecItem create
   */
  export type ParsedSpecItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedSpecItem
     */
    select?: ParsedSpecItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedSpecItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ParsedSpecItem.
     */
    data: XOR<ParsedSpecItemCreateInput, ParsedSpecItemUncheckedCreateInput>
  }

  /**
   * ParsedSpecItem createMany
   */
  export type ParsedSpecItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParsedSpecItems.
     */
    data: ParsedSpecItemCreateManyInput | ParsedSpecItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParsedSpecItem createManyAndReturn
   */
  export type ParsedSpecItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedSpecItem
     */
    select?: ParsedSpecItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ParsedSpecItems.
     */
    data: ParsedSpecItemCreateManyInput | ParsedSpecItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedSpecItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParsedSpecItem update
   */
  export type ParsedSpecItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedSpecItem
     */
    select?: ParsedSpecItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedSpecItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ParsedSpecItem.
     */
    data: XOR<ParsedSpecItemUpdateInput, ParsedSpecItemUncheckedUpdateInput>
    /**
     * Choose, which ParsedSpecItem to update.
     */
    where: ParsedSpecItemWhereUniqueInput
  }

  /**
   * ParsedSpecItem updateMany
   */
  export type ParsedSpecItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParsedSpecItems.
     */
    data: XOR<ParsedSpecItemUpdateManyMutationInput, ParsedSpecItemUncheckedUpdateManyInput>
    /**
     * Filter which ParsedSpecItems to update
     */
    where?: ParsedSpecItemWhereInput
  }

  /**
   * ParsedSpecItem upsert
   */
  export type ParsedSpecItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedSpecItem
     */
    select?: ParsedSpecItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedSpecItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ParsedSpecItem to update in case it exists.
     */
    where: ParsedSpecItemWhereUniqueInput
    /**
     * In case the ParsedSpecItem found by the `where` argument doesn't exist, create a new ParsedSpecItem with this data.
     */
    create: XOR<ParsedSpecItemCreateInput, ParsedSpecItemUncheckedCreateInput>
    /**
     * In case the ParsedSpecItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParsedSpecItemUpdateInput, ParsedSpecItemUncheckedUpdateInput>
  }

  /**
   * ParsedSpecItem delete
   */
  export type ParsedSpecItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedSpecItem
     */
    select?: ParsedSpecItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedSpecItemInclude<ExtArgs> | null
    /**
     * Filter which ParsedSpecItem to delete.
     */
    where: ParsedSpecItemWhereUniqueInput
  }

  /**
   * ParsedSpecItem deleteMany
   */
  export type ParsedSpecItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParsedSpecItems to delete
     */
    where?: ParsedSpecItemWhereInput
  }

  /**
   * ParsedSpecItem without action
   */
  export type ParsedSpecItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedSpecItem
     */
    select?: ParsedSpecItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedSpecItemInclude<ExtArgs> | null
  }


  /**
   * Model Snag
   */

  export type AggregateSnag = {
    _count: SnagCountAggregateOutputType | null
    _min: SnagMinAggregateOutputType | null
    _max: SnagMaxAggregateOutputType | null
  }

  export type SnagMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: $Enums.SnagCategory | null
    severity: $Enums.Priority | null
    status: $Enums.SnagStatus | null
    isClientVisible: boolean | null
    clientNotified: boolean | null
    resolution: string | null
    resolvedAt: Date | null
    jobId: string | null
    reportedById: string | null
    assignedToId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SnagMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: $Enums.SnagCategory | null
    severity: $Enums.Priority | null
    status: $Enums.SnagStatus | null
    isClientVisible: boolean | null
    clientNotified: boolean | null
    resolution: string | null
    resolvedAt: Date | null
    jobId: string | null
    reportedById: string | null
    assignedToId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SnagCountAggregateOutputType = {
    id: number
    title: number
    description: number
    category: number
    severity: number
    status: number
    photoUrls: number
    isClientVisible: number
    clientNotified: number
    resolution: number
    resolvedAt: number
    jobId: number
    reportedById: number
    assignedToId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SnagMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    severity?: true
    status?: true
    isClientVisible?: true
    clientNotified?: true
    resolution?: true
    resolvedAt?: true
    jobId?: true
    reportedById?: true
    assignedToId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SnagMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    severity?: true
    status?: true
    isClientVisible?: true
    clientNotified?: true
    resolution?: true
    resolvedAt?: true
    jobId?: true
    reportedById?: true
    assignedToId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SnagCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    severity?: true
    status?: true
    photoUrls?: true
    isClientVisible?: true
    clientNotified?: true
    resolution?: true
    resolvedAt?: true
    jobId?: true
    reportedById?: true
    assignedToId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SnagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Snag to aggregate.
     */
    where?: SnagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Snags to fetch.
     */
    orderBy?: SnagOrderByWithRelationInput | SnagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SnagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Snags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Snags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Snags
    **/
    _count?: true | SnagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SnagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SnagMaxAggregateInputType
  }

  export type GetSnagAggregateType<T extends SnagAggregateArgs> = {
        [P in keyof T & keyof AggregateSnag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSnag[P]>
      : GetScalarType<T[P], AggregateSnag[P]>
  }




  export type SnagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SnagWhereInput
    orderBy?: SnagOrderByWithAggregationInput | SnagOrderByWithAggregationInput[]
    by: SnagScalarFieldEnum[] | SnagScalarFieldEnum
    having?: SnagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SnagCountAggregateInputType | true
    _min?: SnagMinAggregateInputType
    _max?: SnagMaxAggregateInputType
  }

  export type SnagGroupByOutputType = {
    id: string
    title: string
    description: string
    category: $Enums.SnagCategory
    severity: $Enums.Priority
    status: $Enums.SnagStatus
    photoUrls: string[]
    isClientVisible: boolean
    clientNotified: boolean
    resolution: string | null
    resolvedAt: Date | null
    jobId: string
    reportedById: string
    assignedToId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SnagCountAggregateOutputType | null
    _min: SnagMinAggregateOutputType | null
    _max: SnagMaxAggregateOutputType | null
  }

  type GetSnagGroupByPayload<T extends SnagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SnagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SnagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SnagGroupByOutputType[P]>
            : GetScalarType<T[P], SnagGroupByOutputType[P]>
        }
      >
    >


  export type SnagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    severity?: boolean
    status?: boolean
    photoUrls?: boolean
    isClientVisible?: boolean
    clientNotified?: boolean
    resolution?: boolean
    resolvedAt?: boolean
    jobId?: boolean
    reportedById?: boolean
    assignedToId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
    reportedBy?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Snag$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["snag"]>

  export type SnagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    severity?: boolean
    status?: boolean
    photoUrls?: boolean
    isClientVisible?: boolean
    clientNotified?: boolean
    resolution?: boolean
    resolvedAt?: boolean
    jobId?: boolean
    reportedById?: boolean
    assignedToId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
    reportedBy?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Snag$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["snag"]>

  export type SnagSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    severity?: boolean
    status?: boolean
    photoUrls?: boolean
    isClientVisible?: boolean
    clientNotified?: boolean
    resolution?: boolean
    resolvedAt?: boolean
    jobId?: boolean
    reportedById?: boolean
    assignedToId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SnagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
    reportedBy?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Snag$assignedToArgs<ExtArgs>
  }
  export type SnagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
    reportedBy?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Snag$assignedToArgs<ExtArgs>
  }

  export type $SnagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Snag"
    objects: {
      job: Prisma.$JobPayload<ExtArgs>
      reportedBy: Prisma.$UserPayload<ExtArgs>
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      category: $Enums.SnagCategory
      severity: $Enums.Priority
      status: $Enums.SnagStatus
      photoUrls: string[]
      isClientVisible: boolean
      clientNotified: boolean
      resolution: string | null
      resolvedAt: Date | null
      jobId: string
      reportedById: string
      assignedToId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["snag"]>
    composites: {}
  }

  type SnagGetPayload<S extends boolean | null | undefined | SnagDefaultArgs> = $Result.GetResult<Prisma.$SnagPayload, S>

  type SnagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SnagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SnagCountAggregateInputType | true
    }

  export interface SnagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Snag'], meta: { name: 'Snag' } }
    /**
     * Find zero or one Snag that matches the filter.
     * @param {SnagFindUniqueArgs} args - Arguments to find a Snag
     * @example
     * // Get one Snag
     * const snag = await prisma.snag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SnagFindUniqueArgs>(args: SelectSubset<T, SnagFindUniqueArgs<ExtArgs>>): Prisma__SnagClient<$Result.GetResult<Prisma.$SnagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Snag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SnagFindUniqueOrThrowArgs} args - Arguments to find a Snag
     * @example
     * // Get one Snag
     * const snag = await prisma.snag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SnagFindUniqueOrThrowArgs>(args: SelectSubset<T, SnagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SnagClient<$Result.GetResult<Prisma.$SnagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Snag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnagFindFirstArgs} args - Arguments to find a Snag
     * @example
     * // Get one Snag
     * const snag = await prisma.snag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SnagFindFirstArgs>(args?: SelectSubset<T, SnagFindFirstArgs<ExtArgs>>): Prisma__SnagClient<$Result.GetResult<Prisma.$SnagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Snag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnagFindFirstOrThrowArgs} args - Arguments to find a Snag
     * @example
     * // Get one Snag
     * const snag = await prisma.snag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SnagFindFirstOrThrowArgs>(args?: SelectSubset<T, SnagFindFirstOrThrowArgs<ExtArgs>>): Prisma__SnagClient<$Result.GetResult<Prisma.$SnagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Snags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Snags
     * const snags = await prisma.snag.findMany()
     * 
     * // Get first 10 Snags
     * const snags = await prisma.snag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const snagWithIdOnly = await prisma.snag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SnagFindManyArgs>(args?: SelectSubset<T, SnagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Snag.
     * @param {SnagCreateArgs} args - Arguments to create a Snag.
     * @example
     * // Create one Snag
     * const Snag = await prisma.snag.create({
     *   data: {
     *     // ... data to create a Snag
     *   }
     * })
     * 
     */
    create<T extends SnagCreateArgs>(args: SelectSubset<T, SnagCreateArgs<ExtArgs>>): Prisma__SnagClient<$Result.GetResult<Prisma.$SnagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Snags.
     * @param {SnagCreateManyArgs} args - Arguments to create many Snags.
     * @example
     * // Create many Snags
     * const snag = await prisma.snag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SnagCreateManyArgs>(args?: SelectSubset<T, SnagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Snags and returns the data saved in the database.
     * @param {SnagCreateManyAndReturnArgs} args - Arguments to create many Snags.
     * @example
     * // Create many Snags
     * const snag = await prisma.snag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Snags and only return the `id`
     * const snagWithIdOnly = await prisma.snag.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SnagCreateManyAndReturnArgs>(args?: SelectSubset<T, SnagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnagPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Snag.
     * @param {SnagDeleteArgs} args - Arguments to delete one Snag.
     * @example
     * // Delete one Snag
     * const Snag = await prisma.snag.delete({
     *   where: {
     *     // ... filter to delete one Snag
     *   }
     * })
     * 
     */
    delete<T extends SnagDeleteArgs>(args: SelectSubset<T, SnagDeleteArgs<ExtArgs>>): Prisma__SnagClient<$Result.GetResult<Prisma.$SnagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Snag.
     * @param {SnagUpdateArgs} args - Arguments to update one Snag.
     * @example
     * // Update one Snag
     * const snag = await prisma.snag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SnagUpdateArgs>(args: SelectSubset<T, SnagUpdateArgs<ExtArgs>>): Prisma__SnagClient<$Result.GetResult<Prisma.$SnagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Snags.
     * @param {SnagDeleteManyArgs} args - Arguments to filter Snags to delete.
     * @example
     * // Delete a few Snags
     * const { count } = await prisma.snag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SnagDeleteManyArgs>(args?: SelectSubset<T, SnagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Snags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Snags
     * const snag = await prisma.snag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SnagUpdateManyArgs>(args: SelectSubset<T, SnagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Snag.
     * @param {SnagUpsertArgs} args - Arguments to update or create a Snag.
     * @example
     * // Update or create a Snag
     * const snag = await prisma.snag.upsert({
     *   create: {
     *     // ... data to create a Snag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Snag we want to update
     *   }
     * })
     */
    upsert<T extends SnagUpsertArgs>(args: SelectSubset<T, SnagUpsertArgs<ExtArgs>>): Prisma__SnagClient<$Result.GetResult<Prisma.$SnagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Snags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnagCountArgs} args - Arguments to filter Snags to count.
     * @example
     * // Count the number of Snags
     * const count = await prisma.snag.count({
     *   where: {
     *     // ... the filter for the Snags we want to count
     *   }
     * })
    **/
    count<T extends SnagCountArgs>(
      args?: Subset<T, SnagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SnagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Snag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SnagAggregateArgs>(args: Subset<T, SnagAggregateArgs>): Prisma.PrismaPromise<GetSnagAggregateType<T>>

    /**
     * Group by Snag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SnagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SnagGroupByArgs['orderBy'] }
        : { orderBy?: SnagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SnagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSnagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Snag model
   */
  readonly fields: SnagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Snag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SnagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends JobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobDefaultArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reportedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assignedTo<T extends Snag$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, Snag$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Snag model
   */ 
  interface SnagFieldRefs {
    readonly id: FieldRef<"Snag", 'String'>
    readonly title: FieldRef<"Snag", 'String'>
    readonly description: FieldRef<"Snag", 'String'>
    readonly category: FieldRef<"Snag", 'SnagCategory'>
    readonly severity: FieldRef<"Snag", 'Priority'>
    readonly status: FieldRef<"Snag", 'SnagStatus'>
    readonly photoUrls: FieldRef<"Snag", 'String[]'>
    readonly isClientVisible: FieldRef<"Snag", 'Boolean'>
    readonly clientNotified: FieldRef<"Snag", 'Boolean'>
    readonly resolution: FieldRef<"Snag", 'String'>
    readonly resolvedAt: FieldRef<"Snag", 'DateTime'>
    readonly jobId: FieldRef<"Snag", 'String'>
    readonly reportedById: FieldRef<"Snag", 'String'>
    readonly assignedToId: FieldRef<"Snag", 'String'>
    readonly createdAt: FieldRef<"Snag", 'DateTime'>
    readonly updatedAt: FieldRef<"Snag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Snag findUnique
   */
  export type SnagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagInclude<ExtArgs> | null
    /**
     * Filter, which Snag to fetch.
     */
    where: SnagWhereUniqueInput
  }

  /**
   * Snag findUniqueOrThrow
   */
  export type SnagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagInclude<ExtArgs> | null
    /**
     * Filter, which Snag to fetch.
     */
    where: SnagWhereUniqueInput
  }

  /**
   * Snag findFirst
   */
  export type SnagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagInclude<ExtArgs> | null
    /**
     * Filter, which Snag to fetch.
     */
    where?: SnagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Snags to fetch.
     */
    orderBy?: SnagOrderByWithRelationInput | SnagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Snags.
     */
    cursor?: SnagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Snags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Snags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Snags.
     */
    distinct?: SnagScalarFieldEnum | SnagScalarFieldEnum[]
  }

  /**
   * Snag findFirstOrThrow
   */
  export type SnagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagInclude<ExtArgs> | null
    /**
     * Filter, which Snag to fetch.
     */
    where?: SnagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Snags to fetch.
     */
    orderBy?: SnagOrderByWithRelationInput | SnagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Snags.
     */
    cursor?: SnagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Snags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Snags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Snags.
     */
    distinct?: SnagScalarFieldEnum | SnagScalarFieldEnum[]
  }

  /**
   * Snag findMany
   */
  export type SnagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagInclude<ExtArgs> | null
    /**
     * Filter, which Snags to fetch.
     */
    where?: SnagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Snags to fetch.
     */
    orderBy?: SnagOrderByWithRelationInput | SnagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Snags.
     */
    cursor?: SnagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Snags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Snags.
     */
    skip?: number
    distinct?: SnagScalarFieldEnum | SnagScalarFieldEnum[]
  }

  /**
   * Snag create
   */
  export type SnagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagInclude<ExtArgs> | null
    /**
     * The data needed to create a Snag.
     */
    data: XOR<SnagCreateInput, SnagUncheckedCreateInput>
  }

  /**
   * Snag createMany
   */
  export type SnagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Snags.
     */
    data: SnagCreateManyInput | SnagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Snag createManyAndReturn
   */
  export type SnagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Snags.
     */
    data: SnagCreateManyInput | SnagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Snag update
   */
  export type SnagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagInclude<ExtArgs> | null
    /**
     * The data needed to update a Snag.
     */
    data: XOR<SnagUpdateInput, SnagUncheckedUpdateInput>
    /**
     * Choose, which Snag to update.
     */
    where: SnagWhereUniqueInput
  }

  /**
   * Snag updateMany
   */
  export type SnagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Snags.
     */
    data: XOR<SnagUpdateManyMutationInput, SnagUncheckedUpdateManyInput>
    /**
     * Filter which Snags to update
     */
    where?: SnagWhereInput
  }

  /**
   * Snag upsert
   */
  export type SnagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagInclude<ExtArgs> | null
    /**
     * The filter to search for the Snag to update in case it exists.
     */
    where: SnagWhereUniqueInput
    /**
     * In case the Snag found by the `where` argument doesn't exist, create a new Snag with this data.
     */
    create: XOR<SnagCreateInput, SnagUncheckedCreateInput>
    /**
     * In case the Snag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SnagUpdateInput, SnagUncheckedUpdateInput>
  }

  /**
   * Snag delete
   */
  export type SnagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagInclude<ExtArgs> | null
    /**
     * Filter which Snag to delete.
     */
    where: SnagWhereUniqueInput
  }

  /**
   * Snag deleteMany
   */
  export type SnagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Snags to delete
     */
    where?: SnagWhereInput
  }

  /**
   * Snag.assignedTo
   */
  export type Snag$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Snag without action
   */
  export type SnagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    filename: string | null
    originalFilename: string | null
    mimeType: string | null
    fileSize: number | null
    storageUrl: string | null
    category: $Enums.DocumentCategory | null
    description: string | null
    isPublic: boolean | null
    virusScanStatus: $Enums.VirusScanStatus | null
    virusScanResult: string | null
    clientId: string | null
    dealId: string | null
    jobId: string | null
    createdAt: Date | null
    uploadedById: string | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    filename: string | null
    originalFilename: string | null
    mimeType: string | null
    fileSize: number | null
    storageUrl: string | null
    category: $Enums.DocumentCategory | null
    description: string | null
    isPublic: boolean | null
    virusScanStatus: $Enums.VirusScanStatus | null
    virusScanResult: string | null
    clientId: string | null
    dealId: string | null
    jobId: string | null
    createdAt: Date | null
    uploadedById: string | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    filename: number
    originalFilename: number
    mimeType: number
    fileSize: number
    storageUrl: number
    category: number
    description: number
    isPublic: number
    virusScanStatus: number
    virusScanResult: number
    clientId: number
    dealId: number
    jobId: number
    createdAt: number
    uploadedById: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    fileSize?: true
  }

  export type DocumentSumAggregateInputType = {
    fileSize?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    filename?: true
    originalFilename?: true
    mimeType?: true
    fileSize?: true
    storageUrl?: true
    category?: true
    description?: true
    isPublic?: true
    virusScanStatus?: true
    virusScanResult?: true
    clientId?: true
    dealId?: true
    jobId?: true
    createdAt?: true
    uploadedById?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    filename?: true
    originalFilename?: true
    mimeType?: true
    fileSize?: true
    storageUrl?: true
    category?: true
    description?: true
    isPublic?: true
    virusScanStatus?: true
    virusScanResult?: true
    clientId?: true
    dealId?: true
    jobId?: true
    createdAt?: true
    uploadedById?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    filename?: true
    originalFilename?: true
    mimeType?: true
    fileSize?: true
    storageUrl?: true
    category?: true
    description?: true
    isPublic?: true
    virusScanStatus?: true
    virusScanResult?: true
    clientId?: true
    dealId?: true
    jobId?: true
    createdAt?: true
    uploadedById?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    filename: string
    originalFilename: string
    mimeType: string
    fileSize: number
    storageUrl: string
    category: $Enums.DocumentCategory
    description: string | null
    isPublic: boolean
    virusScanStatus: $Enums.VirusScanStatus
    virusScanResult: string | null
    clientId: string | null
    dealId: string | null
    jobId: string | null
    createdAt: Date
    uploadedById: string
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalFilename?: boolean
    mimeType?: boolean
    fileSize?: boolean
    storageUrl?: boolean
    category?: boolean
    description?: boolean
    isPublic?: boolean
    virusScanStatus?: boolean
    virusScanResult?: boolean
    clientId?: boolean
    dealId?: boolean
    jobId?: boolean
    createdAt?: boolean
    uploadedById?: boolean
    client?: boolean | Document$clientArgs<ExtArgs>
    deal?: boolean | Document$dealArgs<ExtArgs>
    job?: boolean | Document$jobArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalFilename?: boolean
    mimeType?: boolean
    fileSize?: boolean
    storageUrl?: boolean
    category?: boolean
    description?: boolean
    isPublic?: boolean
    virusScanStatus?: boolean
    virusScanResult?: boolean
    clientId?: boolean
    dealId?: boolean
    jobId?: boolean
    createdAt?: boolean
    uploadedById?: boolean
    client?: boolean | Document$clientArgs<ExtArgs>
    deal?: boolean | Document$dealArgs<ExtArgs>
    job?: boolean | Document$jobArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    filename?: boolean
    originalFilename?: boolean
    mimeType?: boolean
    fileSize?: boolean
    storageUrl?: boolean
    category?: boolean
    description?: boolean
    isPublic?: boolean
    virusScanStatus?: boolean
    virusScanResult?: boolean
    clientId?: boolean
    dealId?: boolean
    jobId?: boolean
    createdAt?: boolean
    uploadedById?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Document$clientArgs<ExtArgs>
    deal?: boolean | Document$dealArgs<ExtArgs>
    job?: boolean | Document$jobArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Document$clientArgs<ExtArgs>
    deal?: boolean | Document$dealArgs<ExtArgs>
    job?: boolean | Document$jobArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs> | null
      deal: Prisma.$DealPayload<ExtArgs> | null
      job: Prisma.$JobPayload<ExtArgs> | null
      uploadedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      filename: string
      originalFilename: string
      mimeType: string
      fileSize: number
      storageUrl: string
      category: $Enums.DocumentCategory
      description: string | null
      isPublic: boolean
      virusScanStatus: $Enums.VirusScanStatus
      virusScanResult: string | null
      clientId: string | null
      dealId: string | null
      jobId: string | null
      createdAt: Date
      uploadedById: string
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends Document$clientArgs<ExtArgs> = {}>(args?: Subset<T, Document$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    deal<T extends Document$dealArgs<ExtArgs> = {}>(args?: Subset<T, Document$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    job<T extends Document$jobArgs<ExtArgs> = {}>(args?: Subset<T, Document$jobArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    uploadedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */ 
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly filename: FieldRef<"Document", 'String'>
    readonly originalFilename: FieldRef<"Document", 'String'>
    readonly mimeType: FieldRef<"Document", 'String'>
    readonly fileSize: FieldRef<"Document", 'Int'>
    readonly storageUrl: FieldRef<"Document", 'String'>
    readonly category: FieldRef<"Document", 'DocumentCategory'>
    readonly description: FieldRef<"Document", 'String'>
    readonly isPublic: FieldRef<"Document", 'Boolean'>
    readonly virusScanStatus: FieldRef<"Document", 'VirusScanStatus'>
    readonly virusScanResult: FieldRef<"Document", 'String'>
    readonly clientId: FieldRef<"Document", 'String'>
    readonly dealId: FieldRef<"Document", 'String'>
    readonly jobId: FieldRef<"Document", 'String'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly uploadedById: FieldRef<"Document", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }

  /**
   * Document.client
   */
  export type Document$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Document.deal
   */
  export type Document$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }

  /**
   * Document.job
   */
  export type Document$jobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model FormTemplate
   */

  export type AggregateFormTemplate = {
    _count: FormTemplateCountAggregateOutputType | null
    _avg: FormTemplateAvgAggregateOutputType | null
    _sum: FormTemplateSumAggregateOutputType | null
    _min: FormTemplateMinAggregateOutputType | null
    _max: FormTemplateMaxAggregateOutputType | null
  }

  export type FormTemplateAvgAggregateOutputType = {
    version: number | null
  }

  export type FormTemplateSumAggregateOutputType = {
    version: number | null
  }

  export type FormTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: $Enums.FormCategory | null
    isActive: boolean | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: $Enums.FormCategory | null
    isActive: boolean | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormTemplateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    schema: number
    isActive: number
    version: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FormTemplateAvgAggregateInputType = {
    version?: true
  }

  export type FormTemplateSumAggregateInputType = {
    version?: true
  }

  export type FormTemplateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    isActive?: true
    version?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    isActive?: true
    version?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormTemplateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    schema?: true
    isActive?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FormTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormTemplate to aggregate.
     */
    where?: FormTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormTemplates to fetch.
     */
    orderBy?: FormTemplateOrderByWithRelationInput | FormTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormTemplates
    **/
    _count?: true | FormTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormTemplateMaxAggregateInputType
  }

  export type GetFormTemplateAggregateType<T extends FormTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateFormTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormTemplate[P]>
      : GetScalarType<T[P], AggregateFormTemplate[P]>
  }




  export type FormTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormTemplateWhereInput
    orderBy?: FormTemplateOrderByWithAggregationInput | FormTemplateOrderByWithAggregationInput[]
    by: FormTemplateScalarFieldEnum[] | FormTemplateScalarFieldEnum
    having?: FormTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormTemplateCountAggregateInputType | true
    _avg?: FormTemplateAvgAggregateInputType
    _sum?: FormTemplateSumAggregateInputType
    _min?: FormTemplateMinAggregateInputType
    _max?: FormTemplateMaxAggregateInputType
  }

  export type FormTemplateGroupByOutputType = {
    id: string
    name: string
    description: string | null
    category: $Enums.FormCategory
    schema: JsonValue
    isActive: boolean
    version: number
    createdAt: Date
    updatedAt: Date
    _count: FormTemplateCountAggregateOutputType | null
    _avg: FormTemplateAvgAggregateOutputType | null
    _sum: FormTemplateSumAggregateOutputType | null
    _min: FormTemplateMinAggregateOutputType | null
    _max: FormTemplateMaxAggregateOutputType | null
  }

  type GetFormTemplateGroupByPayload<T extends FormTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], FormTemplateGroupByOutputType[P]>
        }
      >
    >


  export type FormTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    schema?: boolean
    isActive?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    submissions?: boolean | FormTemplate$submissionsArgs<ExtArgs>
    _count?: boolean | FormTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formTemplate"]>

  export type FormTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    schema?: boolean
    isActive?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["formTemplate"]>

  export type FormTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    schema?: boolean
    isActive?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FormTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submissions?: boolean | FormTemplate$submissionsArgs<ExtArgs>
    _count?: boolean | FormTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FormTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FormTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormTemplate"
    objects: {
      submissions: Prisma.$FormSubmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      category: $Enums.FormCategory
      schema: Prisma.JsonValue
      isActive: boolean
      version: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["formTemplate"]>
    composites: {}
  }

  type FormTemplateGetPayload<S extends boolean | null | undefined | FormTemplateDefaultArgs> = $Result.GetResult<Prisma.$FormTemplatePayload, S>

  type FormTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FormTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FormTemplateCountAggregateInputType | true
    }

  export interface FormTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormTemplate'], meta: { name: 'FormTemplate' } }
    /**
     * Find zero or one FormTemplate that matches the filter.
     * @param {FormTemplateFindUniqueArgs} args - Arguments to find a FormTemplate
     * @example
     * // Get one FormTemplate
     * const formTemplate = await prisma.formTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormTemplateFindUniqueArgs>(args: SelectSubset<T, FormTemplateFindUniqueArgs<ExtArgs>>): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FormTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FormTemplateFindUniqueOrThrowArgs} args - Arguments to find a FormTemplate
     * @example
     * // Get one FormTemplate
     * const formTemplate = await prisma.formTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, FormTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FormTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateFindFirstArgs} args - Arguments to find a FormTemplate
     * @example
     * // Get one FormTemplate
     * const formTemplate = await prisma.formTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormTemplateFindFirstArgs>(args?: SelectSubset<T, FormTemplateFindFirstArgs<ExtArgs>>): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FormTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateFindFirstOrThrowArgs} args - Arguments to find a FormTemplate
     * @example
     * // Get one FormTemplate
     * const formTemplate = await prisma.formTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, FormTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FormTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormTemplates
     * const formTemplates = await prisma.formTemplate.findMany()
     * 
     * // Get first 10 FormTemplates
     * const formTemplates = await prisma.formTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formTemplateWithIdOnly = await prisma.formTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormTemplateFindManyArgs>(args?: SelectSubset<T, FormTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FormTemplate.
     * @param {FormTemplateCreateArgs} args - Arguments to create a FormTemplate.
     * @example
     * // Create one FormTemplate
     * const FormTemplate = await prisma.formTemplate.create({
     *   data: {
     *     // ... data to create a FormTemplate
     *   }
     * })
     * 
     */
    create<T extends FormTemplateCreateArgs>(args: SelectSubset<T, FormTemplateCreateArgs<ExtArgs>>): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FormTemplates.
     * @param {FormTemplateCreateManyArgs} args - Arguments to create many FormTemplates.
     * @example
     * // Create many FormTemplates
     * const formTemplate = await prisma.formTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormTemplateCreateManyArgs>(args?: SelectSubset<T, FormTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormTemplates and returns the data saved in the database.
     * @param {FormTemplateCreateManyAndReturnArgs} args - Arguments to create many FormTemplates.
     * @example
     * // Create many FormTemplates
     * const formTemplate = await prisma.formTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormTemplates and only return the `id`
     * const formTemplateWithIdOnly = await prisma.formTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FormTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, FormTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FormTemplate.
     * @param {FormTemplateDeleteArgs} args - Arguments to delete one FormTemplate.
     * @example
     * // Delete one FormTemplate
     * const FormTemplate = await prisma.formTemplate.delete({
     *   where: {
     *     // ... filter to delete one FormTemplate
     *   }
     * })
     * 
     */
    delete<T extends FormTemplateDeleteArgs>(args: SelectSubset<T, FormTemplateDeleteArgs<ExtArgs>>): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FormTemplate.
     * @param {FormTemplateUpdateArgs} args - Arguments to update one FormTemplate.
     * @example
     * // Update one FormTemplate
     * const formTemplate = await prisma.formTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormTemplateUpdateArgs>(args: SelectSubset<T, FormTemplateUpdateArgs<ExtArgs>>): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FormTemplates.
     * @param {FormTemplateDeleteManyArgs} args - Arguments to filter FormTemplates to delete.
     * @example
     * // Delete a few FormTemplates
     * const { count } = await prisma.formTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormTemplateDeleteManyArgs>(args?: SelectSubset<T, FormTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormTemplates
     * const formTemplate = await prisma.formTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormTemplateUpdateManyArgs>(args: SelectSubset<T, FormTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FormTemplate.
     * @param {FormTemplateUpsertArgs} args - Arguments to update or create a FormTemplate.
     * @example
     * // Update or create a FormTemplate
     * const formTemplate = await prisma.formTemplate.upsert({
     *   create: {
     *     // ... data to create a FormTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormTemplate we want to update
     *   }
     * })
     */
    upsert<T extends FormTemplateUpsertArgs>(args: SelectSubset<T, FormTemplateUpsertArgs<ExtArgs>>): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FormTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateCountArgs} args - Arguments to filter FormTemplates to count.
     * @example
     * // Count the number of FormTemplates
     * const count = await prisma.formTemplate.count({
     *   where: {
     *     // ... the filter for the FormTemplates we want to count
     *   }
     * })
    **/
    count<T extends FormTemplateCountArgs>(
      args?: Subset<T, FormTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormTemplateAggregateArgs>(args: Subset<T, FormTemplateAggregateArgs>): Prisma.PrismaPromise<GetFormTemplateAggregateType<T>>

    /**
     * Group by FormTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormTemplateGroupByArgs['orderBy'] }
        : { orderBy?: FormTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormTemplate model
   */
  readonly fields: FormTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    submissions<T extends FormTemplate$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, FormTemplate$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FormTemplate model
   */ 
  interface FormTemplateFieldRefs {
    readonly id: FieldRef<"FormTemplate", 'String'>
    readonly name: FieldRef<"FormTemplate", 'String'>
    readonly description: FieldRef<"FormTemplate", 'String'>
    readonly category: FieldRef<"FormTemplate", 'FormCategory'>
    readonly schema: FieldRef<"FormTemplate", 'Json'>
    readonly isActive: FieldRef<"FormTemplate", 'Boolean'>
    readonly version: FieldRef<"FormTemplate", 'Int'>
    readonly createdAt: FieldRef<"FormTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"FormTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FormTemplate findUnique
   */
  export type FormTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTemplateInclude<ExtArgs> | null
    /**
     * Filter, which FormTemplate to fetch.
     */
    where: FormTemplateWhereUniqueInput
  }

  /**
   * FormTemplate findUniqueOrThrow
   */
  export type FormTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTemplateInclude<ExtArgs> | null
    /**
     * Filter, which FormTemplate to fetch.
     */
    where: FormTemplateWhereUniqueInput
  }

  /**
   * FormTemplate findFirst
   */
  export type FormTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTemplateInclude<ExtArgs> | null
    /**
     * Filter, which FormTemplate to fetch.
     */
    where?: FormTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormTemplates to fetch.
     */
    orderBy?: FormTemplateOrderByWithRelationInput | FormTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormTemplates.
     */
    cursor?: FormTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormTemplates.
     */
    distinct?: FormTemplateScalarFieldEnum | FormTemplateScalarFieldEnum[]
  }

  /**
   * FormTemplate findFirstOrThrow
   */
  export type FormTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTemplateInclude<ExtArgs> | null
    /**
     * Filter, which FormTemplate to fetch.
     */
    where?: FormTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormTemplates to fetch.
     */
    orderBy?: FormTemplateOrderByWithRelationInput | FormTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormTemplates.
     */
    cursor?: FormTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormTemplates.
     */
    distinct?: FormTemplateScalarFieldEnum | FormTemplateScalarFieldEnum[]
  }

  /**
   * FormTemplate findMany
   */
  export type FormTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTemplateInclude<ExtArgs> | null
    /**
     * Filter, which FormTemplates to fetch.
     */
    where?: FormTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormTemplates to fetch.
     */
    orderBy?: FormTemplateOrderByWithRelationInput | FormTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormTemplates.
     */
    cursor?: FormTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormTemplates.
     */
    skip?: number
    distinct?: FormTemplateScalarFieldEnum | FormTemplateScalarFieldEnum[]
  }

  /**
   * FormTemplate create
   */
  export type FormTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a FormTemplate.
     */
    data: XOR<FormTemplateCreateInput, FormTemplateUncheckedCreateInput>
  }

  /**
   * FormTemplate createMany
   */
  export type FormTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormTemplates.
     */
    data: FormTemplateCreateManyInput | FormTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormTemplate createManyAndReturn
   */
  export type FormTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FormTemplates.
     */
    data: FormTemplateCreateManyInput | FormTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormTemplate update
   */
  export type FormTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a FormTemplate.
     */
    data: XOR<FormTemplateUpdateInput, FormTemplateUncheckedUpdateInput>
    /**
     * Choose, which FormTemplate to update.
     */
    where: FormTemplateWhereUniqueInput
  }

  /**
   * FormTemplate updateMany
   */
  export type FormTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormTemplates.
     */
    data: XOR<FormTemplateUpdateManyMutationInput, FormTemplateUncheckedUpdateManyInput>
    /**
     * Filter which FormTemplates to update
     */
    where?: FormTemplateWhereInput
  }

  /**
   * FormTemplate upsert
   */
  export type FormTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the FormTemplate to update in case it exists.
     */
    where: FormTemplateWhereUniqueInput
    /**
     * In case the FormTemplate found by the `where` argument doesn't exist, create a new FormTemplate with this data.
     */
    create: XOR<FormTemplateCreateInput, FormTemplateUncheckedCreateInput>
    /**
     * In case the FormTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormTemplateUpdateInput, FormTemplateUncheckedUpdateInput>
  }

  /**
   * FormTemplate delete
   */
  export type FormTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTemplateInclude<ExtArgs> | null
    /**
     * Filter which FormTemplate to delete.
     */
    where: FormTemplateWhereUniqueInput
  }

  /**
   * FormTemplate deleteMany
   */
  export type FormTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormTemplates to delete
     */
    where?: FormTemplateWhereInput
  }

  /**
   * FormTemplate.submissions
   */
  export type FormTemplate$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    where?: FormSubmissionWhereInput
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    cursor?: FormSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * FormTemplate without action
   */
  export type FormTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTemplateInclude<ExtArgs> | null
  }


  /**
   * Model FormSubmission
   */

  export type AggregateFormSubmission = {
    _count: FormSubmissionCountAggregateOutputType | null
    _min: FormSubmissionMinAggregateOutputType | null
    _max: FormSubmissionMaxAggregateOutputType | null
  }

  export type FormSubmissionMinAggregateOutputType = {
    id: string | null
    submissionSource: $Enums.SubmissionSource | null
    templateId: string | null
    submittedById: string | null
    clientId: string | null
    jobId: string | null
    submittedAt: Date | null
  }

  export type FormSubmissionMaxAggregateOutputType = {
    id: string | null
    submissionSource: $Enums.SubmissionSource | null
    templateId: string | null
    submittedById: string | null
    clientId: string | null
    jobId: string | null
    submittedAt: Date | null
  }

  export type FormSubmissionCountAggregateOutputType = {
    id: number
    data: number
    submissionSource: number
    templateId: number
    submittedById: number
    clientId: number
    jobId: number
    submittedAt: number
    _all: number
  }


  export type FormSubmissionMinAggregateInputType = {
    id?: true
    submissionSource?: true
    templateId?: true
    submittedById?: true
    clientId?: true
    jobId?: true
    submittedAt?: true
  }

  export type FormSubmissionMaxAggregateInputType = {
    id?: true
    submissionSource?: true
    templateId?: true
    submittedById?: true
    clientId?: true
    jobId?: true
    submittedAt?: true
  }

  export type FormSubmissionCountAggregateInputType = {
    id?: true
    data?: true
    submissionSource?: true
    templateId?: true
    submittedById?: true
    clientId?: true
    jobId?: true
    submittedAt?: true
    _all?: true
  }

  export type FormSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormSubmission to aggregate.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormSubmissions
    **/
    _count?: true | FormSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormSubmissionMaxAggregateInputType
  }

  export type GetFormSubmissionAggregateType<T extends FormSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateFormSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormSubmission[P]>
      : GetScalarType<T[P], AggregateFormSubmission[P]>
  }




  export type FormSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormSubmissionWhereInput
    orderBy?: FormSubmissionOrderByWithAggregationInput | FormSubmissionOrderByWithAggregationInput[]
    by: FormSubmissionScalarFieldEnum[] | FormSubmissionScalarFieldEnum
    having?: FormSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormSubmissionCountAggregateInputType | true
    _min?: FormSubmissionMinAggregateInputType
    _max?: FormSubmissionMaxAggregateInputType
  }

  export type FormSubmissionGroupByOutputType = {
    id: string
    data: JsonValue
    submissionSource: $Enums.SubmissionSource
    templateId: string
    submittedById: string | null
    clientId: string | null
    jobId: string | null
    submittedAt: Date
    _count: FormSubmissionCountAggregateOutputType | null
    _min: FormSubmissionMinAggregateOutputType | null
    _max: FormSubmissionMaxAggregateOutputType | null
  }

  type GetFormSubmissionGroupByPayload<T extends FormSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], FormSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type FormSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    data?: boolean
    submissionSource?: boolean
    templateId?: boolean
    submittedById?: boolean
    clientId?: boolean
    jobId?: boolean
    submittedAt?: boolean
    template?: boolean | FormTemplateDefaultArgs<ExtArgs>
    submittedBy?: boolean | FormSubmission$submittedByArgs<ExtArgs>
  }, ExtArgs["result"]["formSubmission"]>

  export type FormSubmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    data?: boolean
    submissionSource?: boolean
    templateId?: boolean
    submittedById?: boolean
    clientId?: boolean
    jobId?: boolean
    submittedAt?: boolean
    template?: boolean | FormTemplateDefaultArgs<ExtArgs>
    submittedBy?: boolean | FormSubmission$submittedByArgs<ExtArgs>
  }, ExtArgs["result"]["formSubmission"]>

  export type FormSubmissionSelectScalar = {
    id?: boolean
    data?: boolean
    submissionSource?: boolean
    templateId?: boolean
    submittedById?: boolean
    clientId?: boolean
    jobId?: boolean
    submittedAt?: boolean
  }

  export type FormSubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | FormTemplateDefaultArgs<ExtArgs>
    submittedBy?: boolean | FormSubmission$submittedByArgs<ExtArgs>
  }
  export type FormSubmissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | FormTemplateDefaultArgs<ExtArgs>
    submittedBy?: boolean | FormSubmission$submittedByArgs<ExtArgs>
  }

  export type $FormSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormSubmission"
    objects: {
      template: Prisma.$FormTemplatePayload<ExtArgs>
      submittedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      data: Prisma.JsonValue
      submissionSource: $Enums.SubmissionSource
      templateId: string
      submittedById: string | null
      clientId: string | null
      jobId: string | null
      submittedAt: Date
    }, ExtArgs["result"]["formSubmission"]>
    composites: {}
  }

  type FormSubmissionGetPayload<S extends boolean | null | undefined | FormSubmissionDefaultArgs> = $Result.GetResult<Prisma.$FormSubmissionPayload, S>

  type FormSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FormSubmissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FormSubmissionCountAggregateInputType | true
    }

  export interface FormSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormSubmission'], meta: { name: 'FormSubmission' } }
    /**
     * Find zero or one FormSubmission that matches the filter.
     * @param {FormSubmissionFindUniqueArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormSubmissionFindUniqueArgs>(args: SelectSubset<T, FormSubmissionFindUniqueArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FormSubmission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FormSubmissionFindUniqueOrThrowArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormSubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, FormSubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FormSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionFindFirstArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormSubmissionFindFirstArgs>(args?: SelectSubset<T, FormSubmissionFindFirstArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FormSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionFindFirstOrThrowArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormSubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, FormSubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FormSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormSubmissions
     * const formSubmissions = await prisma.formSubmission.findMany()
     * 
     * // Get first 10 FormSubmissions
     * const formSubmissions = await prisma.formSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formSubmissionWithIdOnly = await prisma.formSubmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormSubmissionFindManyArgs>(args?: SelectSubset<T, FormSubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FormSubmission.
     * @param {FormSubmissionCreateArgs} args - Arguments to create a FormSubmission.
     * @example
     * // Create one FormSubmission
     * const FormSubmission = await prisma.formSubmission.create({
     *   data: {
     *     // ... data to create a FormSubmission
     *   }
     * })
     * 
     */
    create<T extends FormSubmissionCreateArgs>(args: SelectSubset<T, FormSubmissionCreateArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FormSubmissions.
     * @param {FormSubmissionCreateManyArgs} args - Arguments to create many FormSubmissions.
     * @example
     * // Create many FormSubmissions
     * const formSubmission = await prisma.formSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormSubmissionCreateManyArgs>(args?: SelectSubset<T, FormSubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormSubmissions and returns the data saved in the database.
     * @param {FormSubmissionCreateManyAndReturnArgs} args - Arguments to create many FormSubmissions.
     * @example
     * // Create many FormSubmissions
     * const formSubmission = await prisma.formSubmission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormSubmissions and only return the `id`
     * const formSubmissionWithIdOnly = await prisma.formSubmission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FormSubmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, FormSubmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FormSubmission.
     * @param {FormSubmissionDeleteArgs} args - Arguments to delete one FormSubmission.
     * @example
     * // Delete one FormSubmission
     * const FormSubmission = await prisma.formSubmission.delete({
     *   where: {
     *     // ... filter to delete one FormSubmission
     *   }
     * })
     * 
     */
    delete<T extends FormSubmissionDeleteArgs>(args: SelectSubset<T, FormSubmissionDeleteArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FormSubmission.
     * @param {FormSubmissionUpdateArgs} args - Arguments to update one FormSubmission.
     * @example
     * // Update one FormSubmission
     * const formSubmission = await prisma.formSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormSubmissionUpdateArgs>(args: SelectSubset<T, FormSubmissionUpdateArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FormSubmissions.
     * @param {FormSubmissionDeleteManyArgs} args - Arguments to filter FormSubmissions to delete.
     * @example
     * // Delete a few FormSubmissions
     * const { count } = await prisma.formSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormSubmissionDeleteManyArgs>(args?: SelectSubset<T, FormSubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormSubmissions
     * const formSubmission = await prisma.formSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormSubmissionUpdateManyArgs>(args: SelectSubset<T, FormSubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FormSubmission.
     * @param {FormSubmissionUpsertArgs} args - Arguments to update or create a FormSubmission.
     * @example
     * // Update or create a FormSubmission
     * const formSubmission = await prisma.formSubmission.upsert({
     *   create: {
     *     // ... data to create a FormSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormSubmission we want to update
     *   }
     * })
     */
    upsert<T extends FormSubmissionUpsertArgs>(args: SelectSubset<T, FormSubmissionUpsertArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FormSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionCountArgs} args - Arguments to filter FormSubmissions to count.
     * @example
     * // Count the number of FormSubmissions
     * const count = await prisma.formSubmission.count({
     *   where: {
     *     // ... the filter for the FormSubmissions we want to count
     *   }
     * })
    **/
    count<T extends FormSubmissionCountArgs>(
      args?: Subset<T, FormSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormSubmissionAggregateArgs>(args: Subset<T, FormSubmissionAggregateArgs>): Prisma.PrismaPromise<GetFormSubmissionAggregateType<T>>

    /**
     * Group by FormSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: FormSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormSubmission model
   */
  readonly fields: FormSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    template<T extends FormTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FormTemplateDefaultArgs<ExtArgs>>): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    submittedBy<T extends FormSubmission$submittedByArgs<ExtArgs> = {}>(args?: Subset<T, FormSubmission$submittedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FormSubmission model
   */ 
  interface FormSubmissionFieldRefs {
    readonly id: FieldRef<"FormSubmission", 'String'>
    readonly data: FieldRef<"FormSubmission", 'Json'>
    readonly submissionSource: FieldRef<"FormSubmission", 'SubmissionSource'>
    readonly templateId: FieldRef<"FormSubmission", 'String'>
    readonly submittedById: FieldRef<"FormSubmission", 'String'>
    readonly clientId: FieldRef<"FormSubmission", 'String'>
    readonly jobId: FieldRef<"FormSubmission", 'String'>
    readonly submittedAt: FieldRef<"FormSubmission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FormSubmission findUnique
   */
  export type FormSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission findUniqueOrThrow
   */
  export type FormSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission findFirst
   */
  export type FormSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormSubmissions.
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormSubmissions.
     */
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * FormSubmission findFirstOrThrow
   */
  export type FormSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormSubmissions.
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormSubmissions.
     */
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * FormSubmission findMany
   */
  export type FormSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmissions to fetch.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormSubmissions.
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * FormSubmission create
   */
  export type FormSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a FormSubmission.
     */
    data: XOR<FormSubmissionCreateInput, FormSubmissionUncheckedCreateInput>
  }

  /**
   * FormSubmission createMany
   */
  export type FormSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormSubmissions.
     */
    data: FormSubmissionCreateManyInput | FormSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormSubmission createManyAndReturn
   */
  export type FormSubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FormSubmissions.
     */
    data: FormSubmissionCreateManyInput | FormSubmissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormSubmission update
   */
  export type FormSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a FormSubmission.
     */
    data: XOR<FormSubmissionUpdateInput, FormSubmissionUncheckedUpdateInput>
    /**
     * Choose, which FormSubmission to update.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission updateMany
   */
  export type FormSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormSubmissions.
     */
    data: XOR<FormSubmissionUpdateManyMutationInput, FormSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which FormSubmissions to update
     */
    where?: FormSubmissionWhereInput
  }

  /**
   * FormSubmission upsert
   */
  export type FormSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the FormSubmission to update in case it exists.
     */
    where: FormSubmissionWhereUniqueInput
    /**
     * In case the FormSubmission found by the `where` argument doesn't exist, create a new FormSubmission with this data.
     */
    create: XOR<FormSubmissionCreateInput, FormSubmissionUncheckedCreateInput>
    /**
     * In case the FormSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormSubmissionUpdateInput, FormSubmissionUncheckedUpdateInput>
  }

  /**
   * FormSubmission delete
   */
  export type FormSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter which FormSubmission to delete.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission deleteMany
   */
  export type FormSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormSubmissions to delete
     */
    where?: FormSubmissionWhereInput
  }

  /**
   * FormSubmission.submittedBy
   */
  export type FormSubmission$submittedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * FormSubmission without action
   */
  export type FormSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
  }


  /**
   * Model HandoverPack
   */

  export type AggregateHandoverPack = {
    _count: HandoverPackCountAggregateOutputType | null
    _min: HandoverPackMinAggregateOutputType | null
    _max: HandoverPackMaxAggregateOutputType | null
  }

  export type HandoverPackMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    completionCertUrl: string | null
    isGenerated: boolean | null
    generatedAt: Date | null
    deliveredAt: Date | null
    clientAccessedAt: Date | null
    jobId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HandoverPackMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    completionCertUrl: string | null
    isGenerated: boolean | null
    generatedAt: Date | null
    deliveredAt: Date | null
    clientAccessedAt: Date | null
    jobId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HandoverPackCountAggregateOutputType = {
    id: number
    title: number
    description: number
    completionCertUrl: number
    warrantyDocsUrls: number
    finalPhotosUrls: number
    guidesIncluded: number
    isGenerated: number
    generatedAt: number
    deliveredAt: number
    clientAccessedAt: number
    jobId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HandoverPackMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    completionCertUrl?: true
    isGenerated?: true
    generatedAt?: true
    deliveredAt?: true
    clientAccessedAt?: true
    jobId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HandoverPackMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    completionCertUrl?: true
    isGenerated?: true
    generatedAt?: true
    deliveredAt?: true
    clientAccessedAt?: true
    jobId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HandoverPackCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    completionCertUrl?: true
    warrantyDocsUrls?: true
    finalPhotosUrls?: true
    guidesIncluded?: true
    isGenerated?: true
    generatedAt?: true
    deliveredAt?: true
    clientAccessedAt?: true
    jobId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HandoverPackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HandoverPack to aggregate.
     */
    where?: HandoverPackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HandoverPacks to fetch.
     */
    orderBy?: HandoverPackOrderByWithRelationInput | HandoverPackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HandoverPackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HandoverPacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HandoverPacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HandoverPacks
    **/
    _count?: true | HandoverPackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HandoverPackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HandoverPackMaxAggregateInputType
  }

  export type GetHandoverPackAggregateType<T extends HandoverPackAggregateArgs> = {
        [P in keyof T & keyof AggregateHandoverPack]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHandoverPack[P]>
      : GetScalarType<T[P], AggregateHandoverPack[P]>
  }




  export type HandoverPackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HandoverPackWhereInput
    orderBy?: HandoverPackOrderByWithAggregationInput | HandoverPackOrderByWithAggregationInput[]
    by: HandoverPackScalarFieldEnum[] | HandoverPackScalarFieldEnum
    having?: HandoverPackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HandoverPackCountAggregateInputType | true
    _min?: HandoverPackMinAggregateInputType
    _max?: HandoverPackMaxAggregateInputType
  }

  export type HandoverPackGroupByOutputType = {
    id: string
    title: string
    description: string | null
    completionCertUrl: string | null
    warrantyDocsUrls: string[]
    finalPhotosUrls: string[]
    guidesIncluded: string[]
    isGenerated: boolean
    generatedAt: Date | null
    deliveredAt: Date | null
    clientAccessedAt: Date | null
    jobId: string
    createdAt: Date
    updatedAt: Date
    _count: HandoverPackCountAggregateOutputType | null
    _min: HandoverPackMinAggregateOutputType | null
    _max: HandoverPackMaxAggregateOutputType | null
  }

  type GetHandoverPackGroupByPayload<T extends HandoverPackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HandoverPackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HandoverPackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HandoverPackGroupByOutputType[P]>
            : GetScalarType<T[P], HandoverPackGroupByOutputType[P]>
        }
      >
    >


  export type HandoverPackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    completionCertUrl?: boolean
    warrantyDocsUrls?: boolean
    finalPhotosUrls?: boolean
    guidesIncluded?: boolean
    isGenerated?: boolean
    generatedAt?: boolean
    deliveredAt?: boolean
    clientAccessedAt?: boolean
    jobId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["handoverPack"]>

  export type HandoverPackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    completionCertUrl?: boolean
    warrantyDocsUrls?: boolean
    finalPhotosUrls?: boolean
    guidesIncluded?: boolean
    isGenerated?: boolean
    generatedAt?: boolean
    deliveredAt?: boolean
    clientAccessedAt?: boolean
    jobId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["handoverPack"]>

  export type HandoverPackSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    completionCertUrl?: boolean
    warrantyDocsUrls?: boolean
    finalPhotosUrls?: boolean
    guidesIncluded?: boolean
    isGenerated?: boolean
    generatedAt?: boolean
    deliveredAt?: boolean
    clientAccessedAt?: boolean
    jobId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HandoverPackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
  }
  export type HandoverPackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
  }

  export type $HandoverPackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HandoverPack"
    objects: {
      job: Prisma.$JobPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      completionCertUrl: string | null
      warrantyDocsUrls: string[]
      finalPhotosUrls: string[]
      guidesIncluded: string[]
      isGenerated: boolean
      generatedAt: Date | null
      deliveredAt: Date | null
      clientAccessedAt: Date | null
      jobId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["handoverPack"]>
    composites: {}
  }

  type HandoverPackGetPayload<S extends boolean | null | undefined | HandoverPackDefaultArgs> = $Result.GetResult<Prisma.$HandoverPackPayload, S>

  type HandoverPackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HandoverPackFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HandoverPackCountAggregateInputType | true
    }

  export interface HandoverPackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HandoverPack'], meta: { name: 'HandoverPack' } }
    /**
     * Find zero or one HandoverPack that matches the filter.
     * @param {HandoverPackFindUniqueArgs} args - Arguments to find a HandoverPack
     * @example
     * // Get one HandoverPack
     * const handoverPack = await prisma.handoverPack.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HandoverPackFindUniqueArgs>(args: SelectSubset<T, HandoverPackFindUniqueArgs<ExtArgs>>): Prisma__HandoverPackClient<$Result.GetResult<Prisma.$HandoverPackPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HandoverPack that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HandoverPackFindUniqueOrThrowArgs} args - Arguments to find a HandoverPack
     * @example
     * // Get one HandoverPack
     * const handoverPack = await prisma.handoverPack.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HandoverPackFindUniqueOrThrowArgs>(args: SelectSubset<T, HandoverPackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HandoverPackClient<$Result.GetResult<Prisma.$HandoverPackPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HandoverPack that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HandoverPackFindFirstArgs} args - Arguments to find a HandoverPack
     * @example
     * // Get one HandoverPack
     * const handoverPack = await prisma.handoverPack.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HandoverPackFindFirstArgs>(args?: SelectSubset<T, HandoverPackFindFirstArgs<ExtArgs>>): Prisma__HandoverPackClient<$Result.GetResult<Prisma.$HandoverPackPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HandoverPack that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HandoverPackFindFirstOrThrowArgs} args - Arguments to find a HandoverPack
     * @example
     * // Get one HandoverPack
     * const handoverPack = await prisma.handoverPack.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HandoverPackFindFirstOrThrowArgs>(args?: SelectSubset<T, HandoverPackFindFirstOrThrowArgs<ExtArgs>>): Prisma__HandoverPackClient<$Result.GetResult<Prisma.$HandoverPackPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HandoverPacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HandoverPackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HandoverPacks
     * const handoverPacks = await prisma.handoverPack.findMany()
     * 
     * // Get first 10 HandoverPacks
     * const handoverPacks = await prisma.handoverPack.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const handoverPackWithIdOnly = await prisma.handoverPack.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HandoverPackFindManyArgs>(args?: SelectSubset<T, HandoverPackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HandoverPackPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HandoverPack.
     * @param {HandoverPackCreateArgs} args - Arguments to create a HandoverPack.
     * @example
     * // Create one HandoverPack
     * const HandoverPack = await prisma.handoverPack.create({
     *   data: {
     *     // ... data to create a HandoverPack
     *   }
     * })
     * 
     */
    create<T extends HandoverPackCreateArgs>(args: SelectSubset<T, HandoverPackCreateArgs<ExtArgs>>): Prisma__HandoverPackClient<$Result.GetResult<Prisma.$HandoverPackPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HandoverPacks.
     * @param {HandoverPackCreateManyArgs} args - Arguments to create many HandoverPacks.
     * @example
     * // Create many HandoverPacks
     * const handoverPack = await prisma.handoverPack.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HandoverPackCreateManyArgs>(args?: SelectSubset<T, HandoverPackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HandoverPacks and returns the data saved in the database.
     * @param {HandoverPackCreateManyAndReturnArgs} args - Arguments to create many HandoverPacks.
     * @example
     * // Create many HandoverPacks
     * const handoverPack = await prisma.handoverPack.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HandoverPacks and only return the `id`
     * const handoverPackWithIdOnly = await prisma.handoverPack.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HandoverPackCreateManyAndReturnArgs>(args?: SelectSubset<T, HandoverPackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HandoverPackPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HandoverPack.
     * @param {HandoverPackDeleteArgs} args - Arguments to delete one HandoverPack.
     * @example
     * // Delete one HandoverPack
     * const HandoverPack = await prisma.handoverPack.delete({
     *   where: {
     *     // ... filter to delete one HandoverPack
     *   }
     * })
     * 
     */
    delete<T extends HandoverPackDeleteArgs>(args: SelectSubset<T, HandoverPackDeleteArgs<ExtArgs>>): Prisma__HandoverPackClient<$Result.GetResult<Prisma.$HandoverPackPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HandoverPack.
     * @param {HandoverPackUpdateArgs} args - Arguments to update one HandoverPack.
     * @example
     * // Update one HandoverPack
     * const handoverPack = await prisma.handoverPack.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HandoverPackUpdateArgs>(args: SelectSubset<T, HandoverPackUpdateArgs<ExtArgs>>): Prisma__HandoverPackClient<$Result.GetResult<Prisma.$HandoverPackPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HandoverPacks.
     * @param {HandoverPackDeleteManyArgs} args - Arguments to filter HandoverPacks to delete.
     * @example
     * // Delete a few HandoverPacks
     * const { count } = await prisma.handoverPack.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HandoverPackDeleteManyArgs>(args?: SelectSubset<T, HandoverPackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HandoverPacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HandoverPackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HandoverPacks
     * const handoverPack = await prisma.handoverPack.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HandoverPackUpdateManyArgs>(args: SelectSubset<T, HandoverPackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HandoverPack.
     * @param {HandoverPackUpsertArgs} args - Arguments to update or create a HandoverPack.
     * @example
     * // Update or create a HandoverPack
     * const handoverPack = await prisma.handoverPack.upsert({
     *   create: {
     *     // ... data to create a HandoverPack
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HandoverPack we want to update
     *   }
     * })
     */
    upsert<T extends HandoverPackUpsertArgs>(args: SelectSubset<T, HandoverPackUpsertArgs<ExtArgs>>): Prisma__HandoverPackClient<$Result.GetResult<Prisma.$HandoverPackPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HandoverPacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HandoverPackCountArgs} args - Arguments to filter HandoverPacks to count.
     * @example
     * // Count the number of HandoverPacks
     * const count = await prisma.handoverPack.count({
     *   where: {
     *     // ... the filter for the HandoverPacks we want to count
     *   }
     * })
    **/
    count<T extends HandoverPackCountArgs>(
      args?: Subset<T, HandoverPackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HandoverPackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HandoverPack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HandoverPackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HandoverPackAggregateArgs>(args: Subset<T, HandoverPackAggregateArgs>): Prisma.PrismaPromise<GetHandoverPackAggregateType<T>>

    /**
     * Group by HandoverPack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HandoverPackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HandoverPackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HandoverPackGroupByArgs['orderBy'] }
        : { orderBy?: HandoverPackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HandoverPackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHandoverPackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HandoverPack model
   */
  readonly fields: HandoverPackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HandoverPack.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HandoverPackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends JobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobDefaultArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HandoverPack model
   */ 
  interface HandoverPackFieldRefs {
    readonly id: FieldRef<"HandoverPack", 'String'>
    readonly title: FieldRef<"HandoverPack", 'String'>
    readonly description: FieldRef<"HandoverPack", 'String'>
    readonly completionCertUrl: FieldRef<"HandoverPack", 'String'>
    readonly warrantyDocsUrls: FieldRef<"HandoverPack", 'String[]'>
    readonly finalPhotosUrls: FieldRef<"HandoverPack", 'String[]'>
    readonly guidesIncluded: FieldRef<"HandoverPack", 'String[]'>
    readonly isGenerated: FieldRef<"HandoverPack", 'Boolean'>
    readonly generatedAt: FieldRef<"HandoverPack", 'DateTime'>
    readonly deliveredAt: FieldRef<"HandoverPack", 'DateTime'>
    readonly clientAccessedAt: FieldRef<"HandoverPack", 'DateTime'>
    readonly jobId: FieldRef<"HandoverPack", 'String'>
    readonly createdAt: FieldRef<"HandoverPack", 'DateTime'>
    readonly updatedAt: FieldRef<"HandoverPack", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HandoverPack findUnique
   */
  export type HandoverPackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HandoverPack
     */
    select?: HandoverPackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandoverPackInclude<ExtArgs> | null
    /**
     * Filter, which HandoverPack to fetch.
     */
    where: HandoverPackWhereUniqueInput
  }

  /**
   * HandoverPack findUniqueOrThrow
   */
  export type HandoverPackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HandoverPack
     */
    select?: HandoverPackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandoverPackInclude<ExtArgs> | null
    /**
     * Filter, which HandoverPack to fetch.
     */
    where: HandoverPackWhereUniqueInput
  }

  /**
   * HandoverPack findFirst
   */
  export type HandoverPackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HandoverPack
     */
    select?: HandoverPackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandoverPackInclude<ExtArgs> | null
    /**
     * Filter, which HandoverPack to fetch.
     */
    where?: HandoverPackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HandoverPacks to fetch.
     */
    orderBy?: HandoverPackOrderByWithRelationInput | HandoverPackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HandoverPacks.
     */
    cursor?: HandoverPackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HandoverPacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HandoverPacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HandoverPacks.
     */
    distinct?: HandoverPackScalarFieldEnum | HandoverPackScalarFieldEnum[]
  }

  /**
   * HandoverPack findFirstOrThrow
   */
  export type HandoverPackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HandoverPack
     */
    select?: HandoverPackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandoverPackInclude<ExtArgs> | null
    /**
     * Filter, which HandoverPack to fetch.
     */
    where?: HandoverPackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HandoverPacks to fetch.
     */
    orderBy?: HandoverPackOrderByWithRelationInput | HandoverPackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HandoverPacks.
     */
    cursor?: HandoverPackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HandoverPacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HandoverPacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HandoverPacks.
     */
    distinct?: HandoverPackScalarFieldEnum | HandoverPackScalarFieldEnum[]
  }

  /**
   * HandoverPack findMany
   */
  export type HandoverPackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HandoverPack
     */
    select?: HandoverPackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandoverPackInclude<ExtArgs> | null
    /**
     * Filter, which HandoverPacks to fetch.
     */
    where?: HandoverPackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HandoverPacks to fetch.
     */
    orderBy?: HandoverPackOrderByWithRelationInput | HandoverPackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HandoverPacks.
     */
    cursor?: HandoverPackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HandoverPacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HandoverPacks.
     */
    skip?: number
    distinct?: HandoverPackScalarFieldEnum | HandoverPackScalarFieldEnum[]
  }

  /**
   * HandoverPack create
   */
  export type HandoverPackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HandoverPack
     */
    select?: HandoverPackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandoverPackInclude<ExtArgs> | null
    /**
     * The data needed to create a HandoverPack.
     */
    data: XOR<HandoverPackCreateInput, HandoverPackUncheckedCreateInput>
  }

  /**
   * HandoverPack createMany
   */
  export type HandoverPackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HandoverPacks.
     */
    data: HandoverPackCreateManyInput | HandoverPackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HandoverPack createManyAndReturn
   */
  export type HandoverPackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HandoverPack
     */
    select?: HandoverPackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HandoverPacks.
     */
    data: HandoverPackCreateManyInput | HandoverPackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandoverPackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HandoverPack update
   */
  export type HandoverPackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HandoverPack
     */
    select?: HandoverPackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandoverPackInclude<ExtArgs> | null
    /**
     * The data needed to update a HandoverPack.
     */
    data: XOR<HandoverPackUpdateInput, HandoverPackUncheckedUpdateInput>
    /**
     * Choose, which HandoverPack to update.
     */
    where: HandoverPackWhereUniqueInput
  }

  /**
   * HandoverPack updateMany
   */
  export type HandoverPackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HandoverPacks.
     */
    data: XOR<HandoverPackUpdateManyMutationInput, HandoverPackUncheckedUpdateManyInput>
    /**
     * Filter which HandoverPacks to update
     */
    where?: HandoverPackWhereInput
  }

  /**
   * HandoverPack upsert
   */
  export type HandoverPackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HandoverPack
     */
    select?: HandoverPackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandoverPackInclude<ExtArgs> | null
    /**
     * The filter to search for the HandoverPack to update in case it exists.
     */
    where: HandoverPackWhereUniqueInput
    /**
     * In case the HandoverPack found by the `where` argument doesn't exist, create a new HandoverPack with this data.
     */
    create: XOR<HandoverPackCreateInput, HandoverPackUncheckedCreateInput>
    /**
     * In case the HandoverPack was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HandoverPackUpdateInput, HandoverPackUncheckedUpdateInput>
  }

  /**
   * HandoverPack delete
   */
  export type HandoverPackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HandoverPack
     */
    select?: HandoverPackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandoverPackInclude<ExtArgs> | null
    /**
     * Filter which HandoverPack to delete.
     */
    where: HandoverPackWhereUniqueInput
  }

  /**
   * HandoverPack deleteMany
   */
  export type HandoverPackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HandoverPacks to delete
     */
    where?: HandoverPackWhereInput
  }

  /**
   * HandoverPack without action
   */
  export type HandoverPackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HandoverPack
     */
    select?: HandoverPackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandoverPackInclude<ExtArgs> | null
  }


  /**
   * Model Guide
   */

  export type AggregateGuide = {
    _count: GuideCountAggregateOutputType | null
    _min: GuideMinAggregateOutputType | null
    _max: GuideMaxAggregateOutputType | null
  }

  export type GuideMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    content: string | null
    category: $Enums.GuideCategory | null
    isPublished: boolean | null
    featured: boolean | null
    metaDescription: string | null
    createdAt: Date | null
    updatedAt: Date | null
    publishedAt: Date | null
  }

  export type GuideMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    content: string | null
    category: $Enums.GuideCategory | null
    isPublished: boolean | null
    featured: boolean | null
    metaDescription: string | null
    createdAt: Date | null
    updatedAt: Date | null
    publishedAt: Date | null
  }

  export type GuideCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    content: number
    category: number
    tags: number
    isPublished: number
    featured: number
    metaDescription: number
    createdAt: number
    updatedAt: number
    publishedAt: number
    _all: number
  }


  export type GuideMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    category?: true
    isPublished?: true
    featured?: true
    metaDescription?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
  }

  export type GuideMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    category?: true
    isPublished?: true
    featured?: true
    metaDescription?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
  }

  export type GuideCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    category?: true
    tags?: true
    isPublished?: true
    featured?: true
    metaDescription?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
    _all?: true
  }

  export type GuideAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guide to aggregate.
     */
    where?: GuideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guides to fetch.
     */
    orderBy?: GuideOrderByWithRelationInput | GuideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Guides
    **/
    _count?: true | GuideCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuideMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuideMaxAggregateInputType
  }

  export type GetGuideAggregateType<T extends GuideAggregateArgs> = {
        [P in keyof T & keyof AggregateGuide]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuide[P]>
      : GetScalarType<T[P], AggregateGuide[P]>
  }




  export type GuideGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuideWhereInput
    orderBy?: GuideOrderByWithAggregationInput | GuideOrderByWithAggregationInput[]
    by: GuideScalarFieldEnum[] | GuideScalarFieldEnum
    having?: GuideScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuideCountAggregateInputType | true
    _min?: GuideMinAggregateInputType
    _max?: GuideMaxAggregateInputType
  }

  export type GuideGroupByOutputType = {
    id: string
    title: string
    slug: string
    content: string
    category: $Enums.GuideCategory
    tags: string[]
    isPublished: boolean
    featured: boolean
    metaDescription: string | null
    createdAt: Date
    updatedAt: Date
    publishedAt: Date | null
    _count: GuideCountAggregateOutputType | null
    _min: GuideMinAggregateOutputType | null
    _max: GuideMaxAggregateOutputType | null
  }

  type GetGuideGroupByPayload<T extends GuideGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuideGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuideGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuideGroupByOutputType[P]>
            : GetScalarType<T[P], GuideGroupByOutputType[P]>
        }
      >
    >


  export type GuideSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    category?: boolean
    tags?: boolean
    isPublished?: boolean
    featured?: boolean
    metaDescription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
  }, ExtArgs["result"]["guide"]>

  export type GuideSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    category?: boolean
    tags?: boolean
    isPublished?: boolean
    featured?: boolean
    metaDescription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
  }, ExtArgs["result"]["guide"]>

  export type GuideSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    category?: boolean
    tags?: boolean
    isPublished?: boolean
    featured?: boolean
    metaDescription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
  }


  export type $GuidePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Guide"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      content: string
      category: $Enums.GuideCategory
      tags: string[]
      isPublished: boolean
      featured: boolean
      metaDescription: string | null
      createdAt: Date
      updatedAt: Date
      publishedAt: Date | null
    }, ExtArgs["result"]["guide"]>
    composites: {}
  }

  type GuideGetPayload<S extends boolean | null | undefined | GuideDefaultArgs> = $Result.GetResult<Prisma.$GuidePayload, S>

  type GuideCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GuideFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GuideCountAggregateInputType | true
    }

  export interface GuideDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Guide'], meta: { name: 'Guide' } }
    /**
     * Find zero or one Guide that matches the filter.
     * @param {GuideFindUniqueArgs} args - Arguments to find a Guide
     * @example
     * // Get one Guide
     * const guide = await prisma.guide.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuideFindUniqueArgs>(args: SelectSubset<T, GuideFindUniqueArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Guide that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GuideFindUniqueOrThrowArgs} args - Arguments to find a Guide
     * @example
     * // Get one Guide
     * const guide = await prisma.guide.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuideFindUniqueOrThrowArgs>(args: SelectSubset<T, GuideFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Guide that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideFindFirstArgs} args - Arguments to find a Guide
     * @example
     * // Get one Guide
     * const guide = await prisma.guide.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuideFindFirstArgs>(args?: SelectSubset<T, GuideFindFirstArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Guide that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideFindFirstOrThrowArgs} args - Arguments to find a Guide
     * @example
     * // Get one Guide
     * const guide = await prisma.guide.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuideFindFirstOrThrowArgs>(args?: SelectSubset<T, GuideFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Guides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guides
     * const guides = await prisma.guide.findMany()
     * 
     * // Get first 10 Guides
     * const guides = await prisma.guide.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guideWithIdOnly = await prisma.guide.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuideFindManyArgs>(args?: SelectSubset<T, GuideFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Guide.
     * @param {GuideCreateArgs} args - Arguments to create a Guide.
     * @example
     * // Create one Guide
     * const Guide = await prisma.guide.create({
     *   data: {
     *     // ... data to create a Guide
     *   }
     * })
     * 
     */
    create<T extends GuideCreateArgs>(args: SelectSubset<T, GuideCreateArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Guides.
     * @param {GuideCreateManyArgs} args - Arguments to create many Guides.
     * @example
     * // Create many Guides
     * const guide = await prisma.guide.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuideCreateManyArgs>(args?: SelectSubset<T, GuideCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Guides and returns the data saved in the database.
     * @param {GuideCreateManyAndReturnArgs} args - Arguments to create many Guides.
     * @example
     * // Create many Guides
     * const guide = await prisma.guide.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Guides and only return the `id`
     * const guideWithIdOnly = await prisma.guide.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GuideCreateManyAndReturnArgs>(args?: SelectSubset<T, GuideCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Guide.
     * @param {GuideDeleteArgs} args - Arguments to delete one Guide.
     * @example
     * // Delete one Guide
     * const Guide = await prisma.guide.delete({
     *   where: {
     *     // ... filter to delete one Guide
     *   }
     * })
     * 
     */
    delete<T extends GuideDeleteArgs>(args: SelectSubset<T, GuideDeleteArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Guide.
     * @param {GuideUpdateArgs} args - Arguments to update one Guide.
     * @example
     * // Update one Guide
     * const guide = await prisma.guide.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuideUpdateArgs>(args: SelectSubset<T, GuideUpdateArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Guides.
     * @param {GuideDeleteManyArgs} args - Arguments to filter Guides to delete.
     * @example
     * // Delete a few Guides
     * const { count } = await prisma.guide.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuideDeleteManyArgs>(args?: SelectSubset<T, GuideDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guides
     * const guide = await prisma.guide.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuideUpdateManyArgs>(args: SelectSubset<T, GuideUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Guide.
     * @param {GuideUpsertArgs} args - Arguments to update or create a Guide.
     * @example
     * // Update or create a Guide
     * const guide = await prisma.guide.upsert({
     *   create: {
     *     // ... data to create a Guide
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guide we want to update
     *   }
     * })
     */
    upsert<T extends GuideUpsertArgs>(args: SelectSubset<T, GuideUpsertArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Guides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideCountArgs} args - Arguments to filter Guides to count.
     * @example
     * // Count the number of Guides
     * const count = await prisma.guide.count({
     *   where: {
     *     // ... the filter for the Guides we want to count
     *   }
     * })
    **/
    count<T extends GuideCountArgs>(
      args?: Subset<T, GuideCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuideCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guide.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuideAggregateArgs>(args: Subset<T, GuideAggregateArgs>): Prisma.PrismaPromise<GetGuideAggregateType<T>>

    /**
     * Group by Guide.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuideGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuideGroupByArgs['orderBy'] }
        : { orderBy?: GuideGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuideGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuideGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Guide model
   */
  readonly fields: GuideFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Guide.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuideClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Guide model
   */ 
  interface GuideFieldRefs {
    readonly id: FieldRef<"Guide", 'String'>
    readonly title: FieldRef<"Guide", 'String'>
    readonly slug: FieldRef<"Guide", 'String'>
    readonly content: FieldRef<"Guide", 'String'>
    readonly category: FieldRef<"Guide", 'GuideCategory'>
    readonly tags: FieldRef<"Guide", 'String[]'>
    readonly isPublished: FieldRef<"Guide", 'Boolean'>
    readonly featured: FieldRef<"Guide", 'Boolean'>
    readonly metaDescription: FieldRef<"Guide", 'String'>
    readonly createdAt: FieldRef<"Guide", 'DateTime'>
    readonly updatedAt: FieldRef<"Guide", 'DateTime'>
    readonly publishedAt: FieldRef<"Guide", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Guide findUnique
   */
  export type GuideFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Filter, which Guide to fetch.
     */
    where: GuideWhereUniqueInput
  }

  /**
   * Guide findUniqueOrThrow
   */
  export type GuideFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Filter, which Guide to fetch.
     */
    where: GuideWhereUniqueInput
  }

  /**
   * Guide findFirst
   */
  export type GuideFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Filter, which Guide to fetch.
     */
    where?: GuideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guides to fetch.
     */
    orderBy?: GuideOrderByWithRelationInput | GuideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guides.
     */
    cursor?: GuideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guides.
     */
    distinct?: GuideScalarFieldEnum | GuideScalarFieldEnum[]
  }

  /**
   * Guide findFirstOrThrow
   */
  export type GuideFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Filter, which Guide to fetch.
     */
    where?: GuideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guides to fetch.
     */
    orderBy?: GuideOrderByWithRelationInput | GuideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guides.
     */
    cursor?: GuideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guides.
     */
    distinct?: GuideScalarFieldEnum | GuideScalarFieldEnum[]
  }

  /**
   * Guide findMany
   */
  export type GuideFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Filter, which Guides to fetch.
     */
    where?: GuideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guides to fetch.
     */
    orderBy?: GuideOrderByWithRelationInput | GuideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Guides.
     */
    cursor?: GuideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guides.
     */
    skip?: number
    distinct?: GuideScalarFieldEnum | GuideScalarFieldEnum[]
  }

  /**
   * Guide create
   */
  export type GuideCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * The data needed to create a Guide.
     */
    data: XOR<GuideCreateInput, GuideUncheckedCreateInput>
  }

  /**
   * Guide createMany
   */
  export type GuideCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Guides.
     */
    data: GuideCreateManyInput | GuideCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Guide createManyAndReturn
   */
  export type GuideCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Guides.
     */
    data: GuideCreateManyInput | GuideCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Guide update
   */
  export type GuideUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * The data needed to update a Guide.
     */
    data: XOR<GuideUpdateInput, GuideUncheckedUpdateInput>
    /**
     * Choose, which Guide to update.
     */
    where: GuideWhereUniqueInput
  }

  /**
   * Guide updateMany
   */
  export type GuideUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Guides.
     */
    data: XOR<GuideUpdateManyMutationInput, GuideUncheckedUpdateManyInput>
    /**
     * Filter which Guides to update
     */
    where?: GuideWhereInput
  }

  /**
   * Guide upsert
   */
  export type GuideUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * The filter to search for the Guide to update in case it exists.
     */
    where: GuideWhereUniqueInput
    /**
     * In case the Guide found by the `where` argument doesn't exist, create a new Guide with this data.
     */
    create: XOR<GuideCreateInput, GuideUncheckedCreateInput>
    /**
     * In case the Guide was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuideUpdateInput, GuideUncheckedUpdateInput>
  }

  /**
   * Guide delete
   */
  export type GuideDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Filter which Guide to delete.
     */
    where: GuideWhereUniqueInput
  }

  /**
   * Guide deleteMany
   */
  export type GuideDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guides to delete
     */
    where?: GuideWhereInput
  }

  /**
   * Guide without action
   */
  export type GuideDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
  }


  /**
   * Model EmailJourney
   */

  export type AggregateEmailJourney = {
    _count: EmailJourneyCountAggregateOutputType | null
    _avg: EmailJourneyAvgAggregateOutputType | null
    _sum: EmailJourneySumAggregateOutputType | null
    _min: EmailJourneyMinAggregateOutputType | null
    _max: EmailJourneyMaxAggregateOutputType | null
  }

  export type EmailJourneyAvgAggregateOutputType = {
    totalSent: number | null
    totalOpened: number | null
    totalClicked: number | null
  }

  export type EmailJourneySumAggregateOutputType = {
    totalSent: number | null
    totalOpened: number | null
    totalClicked: number | null
  }

  export type EmailJourneyMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    triggerEvent: $Enums.EmailTrigger | null
    totalSent: number | null
    totalOpened: number | null
    totalClicked: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailJourneyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    triggerEvent: $Enums.EmailTrigger | null
    totalSent: number | null
    totalOpened: number | null
    totalClicked: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailJourneyCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    triggerEvent: number
    triggerConditions: number
    totalSent: number
    totalOpened: number
    totalClicked: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailJourneyAvgAggregateInputType = {
    totalSent?: true
    totalOpened?: true
    totalClicked?: true
  }

  export type EmailJourneySumAggregateInputType = {
    totalSent?: true
    totalOpened?: true
    totalClicked?: true
  }

  export type EmailJourneyMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    triggerEvent?: true
    totalSent?: true
    totalOpened?: true
    totalClicked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailJourneyMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    triggerEvent?: true
    totalSent?: true
    totalOpened?: true
    totalClicked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailJourneyCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    triggerEvent?: true
    triggerConditions?: true
    totalSent?: true
    totalOpened?: true
    totalClicked?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailJourneyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailJourney to aggregate.
     */
    where?: EmailJourneyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailJourneys to fetch.
     */
    orderBy?: EmailJourneyOrderByWithRelationInput | EmailJourneyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailJourneyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailJourneys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailJourneys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailJourneys
    **/
    _count?: true | EmailJourneyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailJourneyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailJourneySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailJourneyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailJourneyMaxAggregateInputType
  }

  export type GetEmailJourneyAggregateType<T extends EmailJourneyAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailJourney]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailJourney[P]>
      : GetScalarType<T[P], AggregateEmailJourney[P]>
  }




  export type EmailJourneyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailJourneyWhereInput
    orderBy?: EmailJourneyOrderByWithAggregationInput | EmailJourneyOrderByWithAggregationInput[]
    by: EmailJourneyScalarFieldEnum[] | EmailJourneyScalarFieldEnum
    having?: EmailJourneyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailJourneyCountAggregateInputType | true
    _avg?: EmailJourneyAvgAggregateInputType
    _sum?: EmailJourneySumAggregateInputType
    _min?: EmailJourneyMinAggregateInputType
    _max?: EmailJourneyMaxAggregateInputType
  }

  export type EmailJourneyGroupByOutputType = {
    id: string
    name: string
    description: string | null
    isActive: boolean
    triggerEvent: $Enums.EmailTrigger
    triggerConditions: JsonValue
    totalSent: number
    totalOpened: number
    totalClicked: number
    createdAt: Date
    updatedAt: Date
    _count: EmailJourneyCountAggregateOutputType | null
    _avg: EmailJourneyAvgAggregateOutputType | null
    _sum: EmailJourneySumAggregateOutputType | null
    _min: EmailJourneyMinAggregateOutputType | null
    _max: EmailJourneyMaxAggregateOutputType | null
  }

  type GetEmailJourneyGroupByPayload<T extends EmailJourneyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailJourneyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailJourneyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailJourneyGroupByOutputType[P]>
            : GetScalarType<T[P], EmailJourneyGroupByOutputType[P]>
        }
      >
    >


  export type EmailJourneySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    triggerEvent?: boolean
    triggerConditions?: boolean
    totalSent?: boolean
    totalOpened?: boolean
    totalClicked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailSequence?: boolean | EmailJourney$emailSequenceArgs<ExtArgs>
    _count?: boolean | EmailJourneyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailJourney"]>

  export type EmailJourneySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    triggerEvent?: boolean
    triggerConditions?: boolean
    totalSent?: boolean
    totalOpened?: boolean
    totalClicked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailJourney"]>

  export type EmailJourneySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    triggerEvent?: boolean
    triggerConditions?: boolean
    totalSent?: boolean
    totalOpened?: boolean
    totalClicked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailJourneyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailSequence?: boolean | EmailJourney$emailSequenceArgs<ExtArgs>
    _count?: boolean | EmailJourneyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmailJourneyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EmailJourneyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailJourney"
    objects: {
      emailSequence: Prisma.$EmailSequenceStepPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      isActive: boolean
      triggerEvent: $Enums.EmailTrigger
      triggerConditions: Prisma.JsonValue
      totalSent: number
      totalOpened: number
      totalClicked: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailJourney"]>
    composites: {}
  }

  type EmailJourneyGetPayload<S extends boolean | null | undefined | EmailJourneyDefaultArgs> = $Result.GetResult<Prisma.$EmailJourneyPayload, S>

  type EmailJourneyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailJourneyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailJourneyCountAggregateInputType | true
    }

  export interface EmailJourneyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailJourney'], meta: { name: 'EmailJourney' } }
    /**
     * Find zero or one EmailJourney that matches the filter.
     * @param {EmailJourneyFindUniqueArgs} args - Arguments to find a EmailJourney
     * @example
     * // Get one EmailJourney
     * const emailJourney = await prisma.emailJourney.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailJourneyFindUniqueArgs>(args: SelectSubset<T, EmailJourneyFindUniqueArgs<ExtArgs>>): Prisma__EmailJourneyClient<$Result.GetResult<Prisma.$EmailJourneyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmailJourney that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmailJourneyFindUniqueOrThrowArgs} args - Arguments to find a EmailJourney
     * @example
     * // Get one EmailJourney
     * const emailJourney = await prisma.emailJourney.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailJourneyFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailJourneyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailJourneyClient<$Result.GetResult<Prisma.$EmailJourneyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmailJourney that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailJourneyFindFirstArgs} args - Arguments to find a EmailJourney
     * @example
     * // Get one EmailJourney
     * const emailJourney = await prisma.emailJourney.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailJourneyFindFirstArgs>(args?: SelectSubset<T, EmailJourneyFindFirstArgs<ExtArgs>>): Prisma__EmailJourneyClient<$Result.GetResult<Prisma.$EmailJourneyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmailJourney that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailJourneyFindFirstOrThrowArgs} args - Arguments to find a EmailJourney
     * @example
     * // Get one EmailJourney
     * const emailJourney = await prisma.emailJourney.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailJourneyFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailJourneyFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailJourneyClient<$Result.GetResult<Prisma.$EmailJourneyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmailJourneys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailJourneyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailJourneys
     * const emailJourneys = await prisma.emailJourney.findMany()
     * 
     * // Get first 10 EmailJourneys
     * const emailJourneys = await prisma.emailJourney.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailJourneyWithIdOnly = await prisma.emailJourney.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailJourneyFindManyArgs>(args?: SelectSubset<T, EmailJourneyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailJourneyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmailJourney.
     * @param {EmailJourneyCreateArgs} args - Arguments to create a EmailJourney.
     * @example
     * // Create one EmailJourney
     * const EmailJourney = await prisma.emailJourney.create({
     *   data: {
     *     // ... data to create a EmailJourney
     *   }
     * })
     * 
     */
    create<T extends EmailJourneyCreateArgs>(args: SelectSubset<T, EmailJourneyCreateArgs<ExtArgs>>): Prisma__EmailJourneyClient<$Result.GetResult<Prisma.$EmailJourneyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmailJourneys.
     * @param {EmailJourneyCreateManyArgs} args - Arguments to create many EmailJourneys.
     * @example
     * // Create many EmailJourneys
     * const emailJourney = await prisma.emailJourney.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailJourneyCreateManyArgs>(args?: SelectSubset<T, EmailJourneyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailJourneys and returns the data saved in the database.
     * @param {EmailJourneyCreateManyAndReturnArgs} args - Arguments to create many EmailJourneys.
     * @example
     * // Create many EmailJourneys
     * const emailJourney = await prisma.emailJourney.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailJourneys and only return the `id`
     * const emailJourneyWithIdOnly = await prisma.emailJourney.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailJourneyCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailJourneyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailJourneyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmailJourney.
     * @param {EmailJourneyDeleteArgs} args - Arguments to delete one EmailJourney.
     * @example
     * // Delete one EmailJourney
     * const EmailJourney = await prisma.emailJourney.delete({
     *   where: {
     *     // ... filter to delete one EmailJourney
     *   }
     * })
     * 
     */
    delete<T extends EmailJourneyDeleteArgs>(args: SelectSubset<T, EmailJourneyDeleteArgs<ExtArgs>>): Prisma__EmailJourneyClient<$Result.GetResult<Prisma.$EmailJourneyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmailJourney.
     * @param {EmailJourneyUpdateArgs} args - Arguments to update one EmailJourney.
     * @example
     * // Update one EmailJourney
     * const emailJourney = await prisma.emailJourney.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailJourneyUpdateArgs>(args: SelectSubset<T, EmailJourneyUpdateArgs<ExtArgs>>): Prisma__EmailJourneyClient<$Result.GetResult<Prisma.$EmailJourneyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmailJourneys.
     * @param {EmailJourneyDeleteManyArgs} args - Arguments to filter EmailJourneys to delete.
     * @example
     * // Delete a few EmailJourneys
     * const { count } = await prisma.emailJourney.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailJourneyDeleteManyArgs>(args?: SelectSubset<T, EmailJourneyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailJourneys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailJourneyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailJourneys
     * const emailJourney = await prisma.emailJourney.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailJourneyUpdateManyArgs>(args: SelectSubset<T, EmailJourneyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailJourney.
     * @param {EmailJourneyUpsertArgs} args - Arguments to update or create a EmailJourney.
     * @example
     * // Update or create a EmailJourney
     * const emailJourney = await prisma.emailJourney.upsert({
     *   create: {
     *     // ... data to create a EmailJourney
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailJourney we want to update
     *   }
     * })
     */
    upsert<T extends EmailJourneyUpsertArgs>(args: SelectSubset<T, EmailJourneyUpsertArgs<ExtArgs>>): Prisma__EmailJourneyClient<$Result.GetResult<Prisma.$EmailJourneyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmailJourneys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailJourneyCountArgs} args - Arguments to filter EmailJourneys to count.
     * @example
     * // Count the number of EmailJourneys
     * const count = await prisma.emailJourney.count({
     *   where: {
     *     // ... the filter for the EmailJourneys we want to count
     *   }
     * })
    **/
    count<T extends EmailJourneyCountArgs>(
      args?: Subset<T, EmailJourneyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailJourneyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailJourney.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailJourneyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailJourneyAggregateArgs>(args: Subset<T, EmailJourneyAggregateArgs>): Prisma.PrismaPromise<GetEmailJourneyAggregateType<T>>

    /**
     * Group by EmailJourney.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailJourneyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailJourneyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailJourneyGroupByArgs['orderBy'] }
        : { orderBy?: EmailJourneyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailJourneyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailJourneyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailJourney model
   */
  readonly fields: EmailJourneyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailJourney.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailJourneyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emailSequence<T extends EmailJourney$emailSequenceArgs<ExtArgs> = {}>(args?: Subset<T, EmailJourney$emailSequenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSequenceStepPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailJourney model
   */ 
  interface EmailJourneyFieldRefs {
    readonly id: FieldRef<"EmailJourney", 'String'>
    readonly name: FieldRef<"EmailJourney", 'String'>
    readonly description: FieldRef<"EmailJourney", 'String'>
    readonly isActive: FieldRef<"EmailJourney", 'Boolean'>
    readonly triggerEvent: FieldRef<"EmailJourney", 'EmailTrigger'>
    readonly triggerConditions: FieldRef<"EmailJourney", 'Json'>
    readonly totalSent: FieldRef<"EmailJourney", 'Int'>
    readonly totalOpened: FieldRef<"EmailJourney", 'Int'>
    readonly totalClicked: FieldRef<"EmailJourney", 'Int'>
    readonly createdAt: FieldRef<"EmailJourney", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailJourney", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailJourney findUnique
   */
  export type EmailJourneyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJourney
     */
    select?: EmailJourneySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJourneyInclude<ExtArgs> | null
    /**
     * Filter, which EmailJourney to fetch.
     */
    where: EmailJourneyWhereUniqueInput
  }

  /**
   * EmailJourney findUniqueOrThrow
   */
  export type EmailJourneyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJourney
     */
    select?: EmailJourneySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJourneyInclude<ExtArgs> | null
    /**
     * Filter, which EmailJourney to fetch.
     */
    where: EmailJourneyWhereUniqueInput
  }

  /**
   * EmailJourney findFirst
   */
  export type EmailJourneyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJourney
     */
    select?: EmailJourneySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJourneyInclude<ExtArgs> | null
    /**
     * Filter, which EmailJourney to fetch.
     */
    where?: EmailJourneyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailJourneys to fetch.
     */
    orderBy?: EmailJourneyOrderByWithRelationInput | EmailJourneyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailJourneys.
     */
    cursor?: EmailJourneyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailJourneys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailJourneys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailJourneys.
     */
    distinct?: EmailJourneyScalarFieldEnum | EmailJourneyScalarFieldEnum[]
  }

  /**
   * EmailJourney findFirstOrThrow
   */
  export type EmailJourneyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJourney
     */
    select?: EmailJourneySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJourneyInclude<ExtArgs> | null
    /**
     * Filter, which EmailJourney to fetch.
     */
    where?: EmailJourneyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailJourneys to fetch.
     */
    orderBy?: EmailJourneyOrderByWithRelationInput | EmailJourneyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailJourneys.
     */
    cursor?: EmailJourneyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailJourneys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailJourneys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailJourneys.
     */
    distinct?: EmailJourneyScalarFieldEnum | EmailJourneyScalarFieldEnum[]
  }

  /**
   * EmailJourney findMany
   */
  export type EmailJourneyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJourney
     */
    select?: EmailJourneySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJourneyInclude<ExtArgs> | null
    /**
     * Filter, which EmailJourneys to fetch.
     */
    where?: EmailJourneyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailJourneys to fetch.
     */
    orderBy?: EmailJourneyOrderByWithRelationInput | EmailJourneyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailJourneys.
     */
    cursor?: EmailJourneyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailJourneys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailJourneys.
     */
    skip?: number
    distinct?: EmailJourneyScalarFieldEnum | EmailJourneyScalarFieldEnum[]
  }

  /**
   * EmailJourney create
   */
  export type EmailJourneyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJourney
     */
    select?: EmailJourneySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJourneyInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailJourney.
     */
    data: XOR<EmailJourneyCreateInput, EmailJourneyUncheckedCreateInput>
  }

  /**
   * EmailJourney createMany
   */
  export type EmailJourneyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailJourneys.
     */
    data: EmailJourneyCreateManyInput | EmailJourneyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailJourney createManyAndReturn
   */
  export type EmailJourneyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJourney
     */
    select?: EmailJourneySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmailJourneys.
     */
    data: EmailJourneyCreateManyInput | EmailJourneyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailJourney update
   */
  export type EmailJourneyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJourney
     */
    select?: EmailJourneySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJourneyInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailJourney.
     */
    data: XOR<EmailJourneyUpdateInput, EmailJourneyUncheckedUpdateInput>
    /**
     * Choose, which EmailJourney to update.
     */
    where: EmailJourneyWhereUniqueInput
  }

  /**
   * EmailJourney updateMany
   */
  export type EmailJourneyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailJourneys.
     */
    data: XOR<EmailJourneyUpdateManyMutationInput, EmailJourneyUncheckedUpdateManyInput>
    /**
     * Filter which EmailJourneys to update
     */
    where?: EmailJourneyWhereInput
  }

  /**
   * EmailJourney upsert
   */
  export type EmailJourneyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJourney
     */
    select?: EmailJourneySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJourneyInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailJourney to update in case it exists.
     */
    where: EmailJourneyWhereUniqueInput
    /**
     * In case the EmailJourney found by the `where` argument doesn't exist, create a new EmailJourney with this data.
     */
    create: XOR<EmailJourneyCreateInput, EmailJourneyUncheckedCreateInput>
    /**
     * In case the EmailJourney was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailJourneyUpdateInput, EmailJourneyUncheckedUpdateInput>
  }

  /**
   * EmailJourney delete
   */
  export type EmailJourneyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJourney
     */
    select?: EmailJourneySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJourneyInclude<ExtArgs> | null
    /**
     * Filter which EmailJourney to delete.
     */
    where: EmailJourneyWhereUniqueInput
  }

  /**
   * EmailJourney deleteMany
   */
  export type EmailJourneyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailJourneys to delete
     */
    where?: EmailJourneyWhereInput
  }

  /**
   * EmailJourney.emailSequence
   */
  export type EmailJourney$emailSequenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSequenceStep
     */
    select?: EmailSequenceStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSequenceStepInclude<ExtArgs> | null
    where?: EmailSequenceStepWhereInput
    orderBy?: EmailSequenceStepOrderByWithRelationInput | EmailSequenceStepOrderByWithRelationInput[]
    cursor?: EmailSequenceStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailSequenceStepScalarFieldEnum | EmailSequenceStepScalarFieldEnum[]
  }

  /**
   * EmailJourney without action
   */
  export type EmailJourneyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJourney
     */
    select?: EmailJourneySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJourneyInclude<ExtArgs> | null
  }


  /**
   * Model EmailSequenceStep
   */

  export type AggregateEmailSequenceStep = {
    _count: EmailSequenceStepCountAggregateOutputType | null
    _avg: EmailSequenceStepAvgAggregateOutputType | null
    _sum: EmailSequenceStepSumAggregateOutputType | null
    _min: EmailSequenceStepMinAggregateOutputType | null
    _max: EmailSequenceStepMaxAggregateOutputType | null
  }

  export type EmailSequenceStepAvgAggregateOutputType = {
    stepNumber: number | null
    delayDays: number | null
    delayHours: number | null
  }

  export type EmailSequenceStepSumAggregateOutputType = {
    stepNumber: number | null
    delayDays: number | null
    delayHours: number | null
  }

  export type EmailSequenceStepMinAggregateOutputType = {
    id: string | null
    stepNumber: number | null
    templateId: string | null
    delayDays: number | null
    delayHours: number | null
    journeyId: string | null
  }

  export type EmailSequenceStepMaxAggregateOutputType = {
    id: string | null
    stepNumber: number | null
    templateId: string | null
    delayDays: number | null
    delayHours: number | null
    journeyId: string | null
  }

  export type EmailSequenceStepCountAggregateOutputType = {
    id: number
    stepNumber: number
    templateId: number
    delayDays: number
    delayHours: number
    sendConditions: number
    journeyId: number
    _all: number
  }


  export type EmailSequenceStepAvgAggregateInputType = {
    stepNumber?: true
    delayDays?: true
    delayHours?: true
  }

  export type EmailSequenceStepSumAggregateInputType = {
    stepNumber?: true
    delayDays?: true
    delayHours?: true
  }

  export type EmailSequenceStepMinAggregateInputType = {
    id?: true
    stepNumber?: true
    templateId?: true
    delayDays?: true
    delayHours?: true
    journeyId?: true
  }

  export type EmailSequenceStepMaxAggregateInputType = {
    id?: true
    stepNumber?: true
    templateId?: true
    delayDays?: true
    delayHours?: true
    journeyId?: true
  }

  export type EmailSequenceStepCountAggregateInputType = {
    id?: true
    stepNumber?: true
    templateId?: true
    delayDays?: true
    delayHours?: true
    sendConditions?: true
    journeyId?: true
    _all?: true
  }

  export type EmailSequenceStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailSequenceStep to aggregate.
     */
    where?: EmailSequenceStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSequenceSteps to fetch.
     */
    orderBy?: EmailSequenceStepOrderByWithRelationInput | EmailSequenceStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailSequenceStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSequenceSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSequenceSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailSequenceSteps
    **/
    _count?: true | EmailSequenceStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailSequenceStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailSequenceStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailSequenceStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailSequenceStepMaxAggregateInputType
  }

  export type GetEmailSequenceStepAggregateType<T extends EmailSequenceStepAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailSequenceStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailSequenceStep[P]>
      : GetScalarType<T[P], AggregateEmailSequenceStep[P]>
  }




  export type EmailSequenceStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailSequenceStepWhereInput
    orderBy?: EmailSequenceStepOrderByWithAggregationInput | EmailSequenceStepOrderByWithAggregationInput[]
    by: EmailSequenceStepScalarFieldEnum[] | EmailSequenceStepScalarFieldEnum
    having?: EmailSequenceStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailSequenceStepCountAggregateInputType | true
    _avg?: EmailSequenceStepAvgAggregateInputType
    _sum?: EmailSequenceStepSumAggregateInputType
    _min?: EmailSequenceStepMinAggregateInputType
    _max?: EmailSequenceStepMaxAggregateInputType
  }

  export type EmailSequenceStepGroupByOutputType = {
    id: string
    stepNumber: number
    templateId: string
    delayDays: number
    delayHours: number
    sendConditions: JsonValue
    journeyId: string
    _count: EmailSequenceStepCountAggregateOutputType | null
    _avg: EmailSequenceStepAvgAggregateOutputType | null
    _sum: EmailSequenceStepSumAggregateOutputType | null
    _min: EmailSequenceStepMinAggregateOutputType | null
    _max: EmailSequenceStepMaxAggregateOutputType | null
  }

  type GetEmailSequenceStepGroupByPayload<T extends EmailSequenceStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailSequenceStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailSequenceStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailSequenceStepGroupByOutputType[P]>
            : GetScalarType<T[P], EmailSequenceStepGroupByOutputType[P]>
        }
      >
    >


  export type EmailSequenceStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stepNumber?: boolean
    templateId?: boolean
    delayDays?: boolean
    delayHours?: boolean
    sendConditions?: boolean
    journeyId?: boolean
    journey?: boolean | EmailJourneyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailSequenceStep"]>

  export type EmailSequenceStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stepNumber?: boolean
    templateId?: boolean
    delayDays?: boolean
    delayHours?: boolean
    sendConditions?: boolean
    journeyId?: boolean
    journey?: boolean | EmailJourneyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailSequenceStep"]>

  export type EmailSequenceStepSelectScalar = {
    id?: boolean
    stepNumber?: boolean
    templateId?: boolean
    delayDays?: boolean
    delayHours?: boolean
    sendConditions?: boolean
    journeyId?: boolean
  }

  export type EmailSequenceStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journey?: boolean | EmailJourneyDefaultArgs<ExtArgs>
  }
  export type EmailSequenceStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journey?: boolean | EmailJourneyDefaultArgs<ExtArgs>
  }

  export type $EmailSequenceStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailSequenceStep"
    objects: {
      journey: Prisma.$EmailJourneyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stepNumber: number
      templateId: string
      delayDays: number
      delayHours: number
      sendConditions: Prisma.JsonValue
      journeyId: string
    }, ExtArgs["result"]["emailSequenceStep"]>
    composites: {}
  }

  type EmailSequenceStepGetPayload<S extends boolean | null | undefined | EmailSequenceStepDefaultArgs> = $Result.GetResult<Prisma.$EmailSequenceStepPayload, S>

  type EmailSequenceStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailSequenceStepFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailSequenceStepCountAggregateInputType | true
    }

  export interface EmailSequenceStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailSequenceStep'], meta: { name: 'EmailSequenceStep' } }
    /**
     * Find zero or one EmailSequenceStep that matches the filter.
     * @param {EmailSequenceStepFindUniqueArgs} args - Arguments to find a EmailSequenceStep
     * @example
     * // Get one EmailSequenceStep
     * const emailSequenceStep = await prisma.emailSequenceStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailSequenceStepFindUniqueArgs>(args: SelectSubset<T, EmailSequenceStepFindUniqueArgs<ExtArgs>>): Prisma__EmailSequenceStepClient<$Result.GetResult<Prisma.$EmailSequenceStepPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmailSequenceStep that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmailSequenceStepFindUniqueOrThrowArgs} args - Arguments to find a EmailSequenceStep
     * @example
     * // Get one EmailSequenceStep
     * const emailSequenceStep = await prisma.emailSequenceStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailSequenceStepFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailSequenceStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailSequenceStepClient<$Result.GetResult<Prisma.$EmailSequenceStepPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmailSequenceStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSequenceStepFindFirstArgs} args - Arguments to find a EmailSequenceStep
     * @example
     * // Get one EmailSequenceStep
     * const emailSequenceStep = await prisma.emailSequenceStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailSequenceStepFindFirstArgs>(args?: SelectSubset<T, EmailSequenceStepFindFirstArgs<ExtArgs>>): Prisma__EmailSequenceStepClient<$Result.GetResult<Prisma.$EmailSequenceStepPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmailSequenceStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSequenceStepFindFirstOrThrowArgs} args - Arguments to find a EmailSequenceStep
     * @example
     * // Get one EmailSequenceStep
     * const emailSequenceStep = await prisma.emailSequenceStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailSequenceStepFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailSequenceStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailSequenceStepClient<$Result.GetResult<Prisma.$EmailSequenceStepPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmailSequenceSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSequenceStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailSequenceSteps
     * const emailSequenceSteps = await prisma.emailSequenceStep.findMany()
     * 
     * // Get first 10 EmailSequenceSteps
     * const emailSequenceSteps = await prisma.emailSequenceStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailSequenceStepWithIdOnly = await prisma.emailSequenceStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailSequenceStepFindManyArgs>(args?: SelectSubset<T, EmailSequenceStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSequenceStepPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmailSequenceStep.
     * @param {EmailSequenceStepCreateArgs} args - Arguments to create a EmailSequenceStep.
     * @example
     * // Create one EmailSequenceStep
     * const EmailSequenceStep = await prisma.emailSequenceStep.create({
     *   data: {
     *     // ... data to create a EmailSequenceStep
     *   }
     * })
     * 
     */
    create<T extends EmailSequenceStepCreateArgs>(args: SelectSubset<T, EmailSequenceStepCreateArgs<ExtArgs>>): Prisma__EmailSequenceStepClient<$Result.GetResult<Prisma.$EmailSequenceStepPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmailSequenceSteps.
     * @param {EmailSequenceStepCreateManyArgs} args - Arguments to create many EmailSequenceSteps.
     * @example
     * // Create many EmailSequenceSteps
     * const emailSequenceStep = await prisma.emailSequenceStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailSequenceStepCreateManyArgs>(args?: SelectSubset<T, EmailSequenceStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailSequenceSteps and returns the data saved in the database.
     * @param {EmailSequenceStepCreateManyAndReturnArgs} args - Arguments to create many EmailSequenceSteps.
     * @example
     * // Create many EmailSequenceSteps
     * const emailSequenceStep = await prisma.emailSequenceStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailSequenceSteps and only return the `id`
     * const emailSequenceStepWithIdOnly = await prisma.emailSequenceStep.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailSequenceStepCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailSequenceStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSequenceStepPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmailSequenceStep.
     * @param {EmailSequenceStepDeleteArgs} args - Arguments to delete one EmailSequenceStep.
     * @example
     * // Delete one EmailSequenceStep
     * const EmailSequenceStep = await prisma.emailSequenceStep.delete({
     *   where: {
     *     // ... filter to delete one EmailSequenceStep
     *   }
     * })
     * 
     */
    delete<T extends EmailSequenceStepDeleteArgs>(args: SelectSubset<T, EmailSequenceStepDeleteArgs<ExtArgs>>): Prisma__EmailSequenceStepClient<$Result.GetResult<Prisma.$EmailSequenceStepPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmailSequenceStep.
     * @param {EmailSequenceStepUpdateArgs} args - Arguments to update one EmailSequenceStep.
     * @example
     * // Update one EmailSequenceStep
     * const emailSequenceStep = await prisma.emailSequenceStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailSequenceStepUpdateArgs>(args: SelectSubset<T, EmailSequenceStepUpdateArgs<ExtArgs>>): Prisma__EmailSequenceStepClient<$Result.GetResult<Prisma.$EmailSequenceStepPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmailSequenceSteps.
     * @param {EmailSequenceStepDeleteManyArgs} args - Arguments to filter EmailSequenceSteps to delete.
     * @example
     * // Delete a few EmailSequenceSteps
     * const { count } = await prisma.emailSequenceStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailSequenceStepDeleteManyArgs>(args?: SelectSubset<T, EmailSequenceStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailSequenceSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSequenceStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailSequenceSteps
     * const emailSequenceStep = await prisma.emailSequenceStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailSequenceStepUpdateManyArgs>(args: SelectSubset<T, EmailSequenceStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailSequenceStep.
     * @param {EmailSequenceStepUpsertArgs} args - Arguments to update or create a EmailSequenceStep.
     * @example
     * // Update or create a EmailSequenceStep
     * const emailSequenceStep = await prisma.emailSequenceStep.upsert({
     *   create: {
     *     // ... data to create a EmailSequenceStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailSequenceStep we want to update
     *   }
     * })
     */
    upsert<T extends EmailSequenceStepUpsertArgs>(args: SelectSubset<T, EmailSequenceStepUpsertArgs<ExtArgs>>): Prisma__EmailSequenceStepClient<$Result.GetResult<Prisma.$EmailSequenceStepPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmailSequenceSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSequenceStepCountArgs} args - Arguments to filter EmailSequenceSteps to count.
     * @example
     * // Count the number of EmailSequenceSteps
     * const count = await prisma.emailSequenceStep.count({
     *   where: {
     *     // ... the filter for the EmailSequenceSteps we want to count
     *   }
     * })
    **/
    count<T extends EmailSequenceStepCountArgs>(
      args?: Subset<T, EmailSequenceStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailSequenceStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailSequenceStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSequenceStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailSequenceStepAggregateArgs>(args: Subset<T, EmailSequenceStepAggregateArgs>): Prisma.PrismaPromise<GetEmailSequenceStepAggregateType<T>>

    /**
     * Group by EmailSequenceStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSequenceStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailSequenceStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailSequenceStepGroupByArgs['orderBy'] }
        : { orderBy?: EmailSequenceStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailSequenceStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailSequenceStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailSequenceStep model
   */
  readonly fields: EmailSequenceStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailSequenceStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailSequenceStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    journey<T extends EmailJourneyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailJourneyDefaultArgs<ExtArgs>>): Prisma__EmailJourneyClient<$Result.GetResult<Prisma.$EmailJourneyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailSequenceStep model
   */ 
  interface EmailSequenceStepFieldRefs {
    readonly id: FieldRef<"EmailSequenceStep", 'String'>
    readonly stepNumber: FieldRef<"EmailSequenceStep", 'Int'>
    readonly templateId: FieldRef<"EmailSequenceStep", 'String'>
    readonly delayDays: FieldRef<"EmailSequenceStep", 'Int'>
    readonly delayHours: FieldRef<"EmailSequenceStep", 'Int'>
    readonly sendConditions: FieldRef<"EmailSequenceStep", 'Json'>
    readonly journeyId: FieldRef<"EmailSequenceStep", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmailSequenceStep findUnique
   */
  export type EmailSequenceStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSequenceStep
     */
    select?: EmailSequenceStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSequenceStepInclude<ExtArgs> | null
    /**
     * Filter, which EmailSequenceStep to fetch.
     */
    where: EmailSequenceStepWhereUniqueInput
  }

  /**
   * EmailSequenceStep findUniqueOrThrow
   */
  export type EmailSequenceStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSequenceStep
     */
    select?: EmailSequenceStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSequenceStepInclude<ExtArgs> | null
    /**
     * Filter, which EmailSequenceStep to fetch.
     */
    where: EmailSequenceStepWhereUniqueInput
  }

  /**
   * EmailSequenceStep findFirst
   */
  export type EmailSequenceStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSequenceStep
     */
    select?: EmailSequenceStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSequenceStepInclude<ExtArgs> | null
    /**
     * Filter, which EmailSequenceStep to fetch.
     */
    where?: EmailSequenceStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSequenceSteps to fetch.
     */
    orderBy?: EmailSequenceStepOrderByWithRelationInput | EmailSequenceStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailSequenceSteps.
     */
    cursor?: EmailSequenceStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSequenceSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSequenceSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailSequenceSteps.
     */
    distinct?: EmailSequenceStepScalarFieldEnum | EmailSequenceStepScalarFieldEnum[]
  }

  /**
   * EmailSequenceStep findFirstOrThrow
   */
  export type EmailSequenceStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSequenceStep
     */
    select?: EmailSequenceStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSequenceStepInclude<ExtArgs> | null
    /**
     * Filter, which EmailSequenceStep to fetch.
     */
    where?: EmailSequenceStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSequenceSteps to fetch.
     */
    orderBy?: EmailSequenceStepOrderByWithRelationInput | EmailSequenceStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailSequenceSteps.
     */
    cursor?: EmailSequenceStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSequenceSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSequenceSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailSequenceSteps.
     */
    distinct?: EmailSequenceStepScalarFieldEnum | EmailSequenceStepScalarFieldEnum[]
  }

  /**
   * EmailSequenceStep findMany
   */
  export type EmailSequenceStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSequenceStep
     */
    select?: EmailSequenceStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSequenceStepInclude<ExtArgs> | null
    /**
     * Filter, which EmailSequenceSteps to fetch.
     */
    where?: EmailSequenceStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSequenceSteps to fetch.
     */
    orderBy?: EmailSequenceStepOrderByWithRelationInput | EmailSequenceStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailSequenceSteps.
     */
    cursor?: EmailSequenceStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSequenceSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSequenceSteps.
     */
    skip?: number
    distinct?: EmailSequenceStepScalarFieldEnum | EmailSequenceStepScalarFieldEnum[]
  }

  /**
   * EmailSequenceStep create
   */
  export type EmailSequenceStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSequenceStep
     */
    select?: EmailSequenceStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSequenceStepInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailSequenceStep.
     */
    data: XOR<EmailSequenceStepCreateInput, EmailSequenceStepUncheckedCreateInput>
  }

  /**
   * EmailSequenceStep createMany
   */
  export type EmailSequenceStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailSequenceSteps.
     */
    data: EmailSequenceStepCreateManyInput | EmailSequenceStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailSequenceStep createManyAndReturn
   */
  export type EmailSequenceStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSequenceStep
     */
    select?: EmailSequenceStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmailSequenceSteps.
     */
    data: EmailSequenceStepCreateManyInput | EmailSequenceStepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSequenceStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailSequenceStep update
   */
  export type EmailSequenceStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSequenceStep
     */
    select?: EmailSequenceStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSequenceStepInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailSequenceStep.
     */
    data: XOR<EmailSequenceStepUpdateInput, EmailSequenceStepUncheckedUpdateInput>
    /**
     * Choose, which EmailSequenceStep to update.
     */
    where: EmailSequenceStepWhereUniqueInput
  }

  /**
   * EmailSequenceStep updateMany
   */
  export type EmailSequenceStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailSequenceSteps.
     */
    data: XOR<EmailSequenceStepUpdateManyMutationInput, EmailSequenceStepUncheckedUpdateManyInput>
    /**
     * Filter which EmailSequenceSteps to update
     */
    where?: EmailSequenceStepWhereInput
  }

  /**
   * EmailSequenceStep upsert
   */
  export type EmailSequenceStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSequenceStep
     */
    select?: EmailSequenceStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSequenceStepInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailSequenceStep to update in case it exists.
     */
    where: EmailSequenceStepWhereUniqueInput
    /**
     * In case the EmailSequenceStep found by the `where` argument doesn't exist, create a new EmailSequenceStep with this data.
     */
    create: XOR<EmailSequenceStepCreateInput, EmailSequenceStepUncheckedCreateInput>
    /**
     * In case the EmailSequenceStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailSequenceStepUpdateInput, EmailSequenceStepUncheckedUpdateInput>
  }

  /**
   * EmailSequenceStep delete
   */
  export type EmailSequenceStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSequenceStep
     */
    select?: EmailSequenceStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSequenceStepInclude<ExtArgs> | null
    /**
     * Filter which EmailSequenceStep to delete.
     */
    where: EmailSequenceStepWhereUniqueInput
  }

  /**
   * EmailSequenceStep deleteMany
   */
  export type EmailSequenceStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailSequenceSteps to delete
     */
    where?: EmailSequenceStepWhereInput
  }

  /**
   * EmailSequenceStep without action
   */
  export type EmailSequenceStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSequenceStep
     */
    select?: EmailSequenceStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSequenceStepInclude<ExtArgs> | null
  }


  /**
   * Model Webhook
   */

  export type AggregateWebhook = {
    _count: WebhookCountAggregateOutputType | null
    _avg: WebhookAvgAggregateOutputType | null
    _sum: WebhookSumAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  export type WebhookAvgAggregateOutputType = {
    totalDeliveries: number | null
  }

  export type WebhookSumAggregateOutputType = {
    totalDeliveries: number | null
  }

  export type WebhookMinAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    secret: string | null
    isActive: boolean | null
    totalDeliveries: number | null
    lastDeliveryAt: Date | null
    lastSuccessAt: Date | null
    lastFailureAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookMaxAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    secret: string | null
    isActive: boolean | null
    totalDeliveries: number | null
    lastDeliveryAt: Date | null
    lastSuccessAt: Date | null
    lastFailureAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookCountAggregateOutputType = {
    id: number
    name: number
    url: number
    events: number
    secret: number
    isActive: number
    totalDeliveries: number
    lastDeliveryAt: number
    lastSuccessAt: number
    lastFailureAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WebhookAvgAggregateInputType = {
    totalDeliveries?: true
  }

  export type WebhookSumAggregateInputType = {
    totalDeliveries?: true
  }

  export type WebhookMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    secret?: true
    isActive?: true
    totalDeliveries?: true
    lastDeliveryAt?: true
    lastSuccessAt?: true
    lastFailureAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    secret?: true
    isActive?: true
    totalDeliveries?: true
    lastDeliveryAt?: true
    lastSuccessAt?: true
    lastFailureAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    events?: true
    secret?: true
    isActive?: true
    totalDeliveries?: true
    lastDeliveryAt?: true
    lastSuccessAt?: true
    lastFailureAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WebhookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhook to aggregate.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Webhooks
    **/
    _count?: true | WebhookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookMaxAggregateInputType
  }

  export type GetWebhookAggregateType<T extends WebhookAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhook[P]>
      : GetScalarType<T[P], AggregateWebhook[P]>
  }




  export type WebhookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookWhereInput
    orderBy?: WebhookOrderByWithAggregationInput | WebhookOrderByWithAggregationInput[]
    by: WebhookScalarFieldEnum[] | WebhookScalarFieldEnum
    having?: WebhookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookCountAggregateInputType | true
    _avg?: WebhookAvgAggregateInputType
    _sum?: WebhookSumAggregateInputType
    _min?: WebhookMinAggregateInputType
    _max?: WebhookMaxAggregateInputType
  }

  export type WebhookGroupByOutputType = {
    id: string
    name: string
    url: string
    events: $Enums.WebhookEvent[]
    secret: string | null
    isActive: boolean
    totalDeliveries: number
    lastDeliveryAt: Date | null
    lastSuccessAt: Date | null
    lastFailureAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: WebhookCountAggregateOutputType | null
    _avg: WebhookAvgAggregateOutputType | null
    _sum: WebhookSumAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  type GetWebhookGroupByPayload<T extends WebhookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookGroupByOutputType[P]>
        }
      >
    >


  export type WebhookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    events?: boolean
    secret?: boolean
    isActive?: boolean
    totalDeliveries?: boolean
    lastDeliveryAt?: boolean
    lastSuccessAt?: boolean
    lastFailureAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deliveries?: boolean | Webhook$deliveriesArgs<ExtArgs>
    _count?: boolean | WebhookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    events?: boolean
    secret?: boolean
    isActive?: boolean
    totalDeliveries?: boolean
    lastDeliveryAt?: boolean
    lastSuccessAt?: boolean
    lastFailureAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    events?: boolean
    secret?: boolean
    isActive?: boolean
    totalDeliveries?: boolean
    lastDeliveryAt?: boolean
    lastSuccessAt?: boolean
    lastFailureAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WebhookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveries?: boolean | Webhook$deliveriesArgs<ExtArgs>
    _count?: boolean | WebhookCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WebhookIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WebhookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Webhook"
    objects: {
      deliveries: Prisma.$WebhookDeliveryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      url: string
      events: $Enums.WebhookEvent[]
      secret: string | null
      isActive: boolean
      totalDeliveries: number
      lastDeliveryAt: Date | null
      lastSuccessAt: Date | null
      lastFailureAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["webhook"]>
    composites: {}
  }

  type WebhookGetPayload<S extends boolean | null | undefined | WebhookDefaultArgs> = $Result.GetResult<Prisma.$WebhookPayload, S>

  type WebhookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WebhookFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WebhookCountAggregateInputType | true
    }

  export interface WebhookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Webhook'], meta: { name: 'Webhook' } }
    /**
     * Find zero or one Webhook that matches the filter.
     * @param {WebhookFindUniqueArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookFindUniqueArgs>(args: SelectSubset<T, WebhookFindUniqueArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Webhook that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WebhookFindUniqueOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Webhook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookFindFirstArgs>(args?: SelectSubset<T, WebhookFindFirstArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Webhook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Webhooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Webhooks
     * const webhooks = await prisma.webhook.findMany()
     * 
     * // Get first 10 Webhooks
     * const webhooks = await prisma.webhook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookWithIdOnly = await prisma.webhook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookFindManyArgs>(args?: SelectSubset<T, WebhookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Webhook.
     * @param {WebhookCreateArgs} args - Arguments to create a Webhook.
     * @example
     * // Create one Webhook
     * const Webhook = await prisma.webhook.create({
     *   data: {
     *     // ... data to create a Webhook
     *   }
     * })
     * 
     */
    create<T extends WebhookCreateArgs>(args: SelectSubset<T, WebhookCreateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Webhooks.
     * @param {WebhookCreateManyArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookCreateManyArgs>(args?: SelectSubset<T, WebhookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Webhooks and returns the data saved in the database.
     * @param {WebhookCreateManyAndReturnArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Webhooks and only return the `id`
     * const webhookWithIdOnly = await prisma.webhook.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Webhook.
     * @param {WebhookDeleteArgs} args - Arguments to delete one Webhook.
     * @example
     * // Delete one Webhook
     * const Webhook = await prisma.webhook.delete({
     *   where: {
     *     // ... filter to delete one Webhook
     *   }
     * })
     * 
     */
    delete<T extends WebhookDeleteArgs>(args: SelectSubset<T, WebhookDeleteArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Webhook.
     * @param {WebhookUpdateArgs} args - Arguments to update one Webhook.
     * @example
     * // Update one Webhook
     * const webhook = await prisma.webhook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookUpdateArgs>(args: SelectSubset<T, WebhookUpdateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Webhooks.
     * @param {WebhookDeleteManyArgs} args - Arguments to filter Webhooks to delete.
     * @example
     * // Delete a few Webhooks
     * const { count } = await prisma.webhook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookDeleteManyArgs>(args?: SelectSubset<T, WebhookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Webhooks
     * const webhook = await prisma.webhook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookUpdateManyArgs>(args: SelectSubset<T, WebhookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Webhook.
     * @param {WebhookUpsertArgs} args - Arguments to update or create a Webhook.
     * @example
     * // Update or create a Webhook
     * const webhook = await prisma.webhook.upsert({
     *   create: {
     *     // ... data to create a Webhook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Webhook we want to update
     *   }
     * })
     */
    upsert<T extends WebhookUpsertArgs>(args: SelectSubset<T, WebhookUpsertArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookCountArgs} args - Arguments to filter Webhooks to count.
     * @example
     * // Count the number of Webhooks
     * const count = await prisma.webhook.count({
     *   where: {
     *     // ... the filter for the Webhooks we want to count
     *   }
     * })
    **/
    count<T extends WebhookCountArgs>(
      args?: Subset<T, WebhookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookAggregateArgs>(args: Subset<T, WebhookAggregateArgs>): Prisma.PrismaPromise<GetWebhookAggregateType<T>>

    /**
     * Group by Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookGroupByArgs['orderBy'] }
        : { orderBy?: WebhookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Webhook model
   */
  readonly fields: WebhookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Webhook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deliveries<T extends Webhook$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, Webhook$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Webhook model
   */ 
  interface WebhookFieldRefs {
    readonly id: FieldRef<"Webhook", 'String'>
    readonly name: FieldRef<"Webhook", 'String'>
    readonly url: FieldRef<"Webhook", 'String'>
    readonly events: FieldRef<"Webhook", 'WebhookEvent[]'>
    readonly secret: FieldRef<"Webhook", 'String'>
    readonly isActive: FieldRef<"Webhook", 'Boolean'>
    readonly totalDeliveries: FieldRef<"Webhook", 'Int'>
    readonly lastDeliveryAt: FieldRef<"Webhook", 'DateTime'>
    readonly lastSuccessAt: FieldRef<"Webhook", 'DateTime'>
    readonly lastFailureAt: FieldRef<"Webhook", 'DateTime'>
    readonly createdAt: FieldRef<"Webhook", 'DateTime'>
    readonly updatedAt: FieldRef<"Webhook", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Webhook findUnique
   */
  export type WebhookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findUniqueOrThrow
   */
  export type WebhookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findFirst
   */
  export type WebhookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findFirstOrThrow
   */
  export type WebhookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findMany
   */
  export type WebhookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhooks to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook create
   */
  export type WebhookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The data needed to create a Webhook.
     */
    data: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
  }

  /**
   * Webhook createMany
   */
  export type WebhookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Webhook createManyAndReturn
   */
  export type WebhookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Webhook update
   */
  export type WebhookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The data needed to update a Webhook.
     */
    data: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
    /**
     * Choose, which Webhook to update.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook updateMany
   */
  export type WebhookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Webhooks.
     */
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyInput>
    /**
     * Filter which Webhooks to update
     */
    where?: WebhookWhereInput
  }

  /**
   * Webhook upsert
   */
  export type WebhookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The filter to search for the Webhook to update in case it exists.
     */
    where: WebhookWhereUniqueInput
    /**
     * In case the Webhook found by the `where` argument doesn't exist, create a new Webhook with this data.
     */
    create: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
    /**
     * In case the Webhook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
  }

  /**
   * Webhook delete
   */
  export type WebhookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter which Webhook to delete.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook deleteMany
   */
  export type WebhookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhooks to delete
     */
    where?: WebhookWhereInput
  }

  /**
   * Webhook.deliveries
   */
  export type Webhook$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    where?: WebhookDeliveryWhereInput
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    cursor?: WebhookDeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * Webhook without action
   */
  export type WebhookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
  }


  /**
   * Model WebhookDelivery
   */

  export type AggregateWebhookDelivery = {
    _count: WebhookDeliveryCountAggregateOutputType | null
    _avg: WebhookDeliveryAvgAggregateOutputType | null
    _sum: WebhookDeliverySumAggregateOutputType | null
    _min: WebhookDeliveryMinAggregateOutputType | null
    _max: WebhookDeliveryMaxAggregateOutputType | null
  }

  export type WebhookDeliveryAvgAggregateOutputType = {
    httpStatus: number | null
    deliveryAttempts: number | null
  }

  export type WebhookDeliverySumAggregateOutputType = {
    httpStatus: number | null
    deliveryAttempts: number | null
  }

  export type WebhookDeliveryMinAggregateOutputType = {
    id: string | null
    eventType: $Enums.WebhookEvent | null
    httpStatus: number | null
    responseBody: string | null
    errorMessage: string | null
    deliveryAttempts: number | null
    deliveredAt: Date | null
    webhookId: string | null
    createdAt: Date | null
  }

  export type WebhookDeliveryMaxAggregateOutputType = {
    id: string | null
    eventType: $Enums.WebhookEvent | null
    httpStatus: number | null
    responseBody: string | null
    errorMessage: string | null
    deliveryAttempts: number | null
    deliveredAt: Date | null
    webhookId: string | null
    createdAt: Date | null
  }

  export type WebhookDeliveryCountAggregateOutputType = {
    id: number
    eventType: number
    payload: number
    httpStatus: number
    responseBody: number
    errorMessage: number
    deliveryAttempts: number
    deliveredAt: number
    webhookId: number
    createdAt: number
    _all: number
  }


  export type WebhookDeliveryAvgAggregateInputType = {
    httpStatus?: true
    deliveryAttempts?: true
  }

  export type WebhookDeliverySumAggregateInputType = {
    httpStatus?: true
    deliveryAttempts?: true
  }

  export type WebhookDeliveryMinAggregateInputType = {
    id?: true
    eventType?: true
    httpStatus?: true
    responseBody?: true
    errorMessage?: true
    deliveryAttempts?: true
    deliveredAt?: true
    webhookId?: true
    createdAt?: true
  }

  export type WebhookDeliveryMaxAggregateInputType = {
    id?: true
    eventType?: true
    httpStatus?: true
    responseBody?: true
    errorMessage?: true
    deliveryAttempts?: true
    deliveredAt?: true
    webhookId?: true
    createdAt?: true
  }

  export type WebhookDeliveryCountAggregateInputType = {
    id?: true
    eventType?: true
    payload?: true
    httpStatus?: true
    responseBody?: true
    errorMessage?: true
    deliveryAttempts?: true
    deliveredAt?: true
    webhookId?: true
    createdAt?: true
    _all?: true
  }

  export type WebhookDeliveryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookDelivery to aggregate.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookDeliveries
    **/
    _count?: true | WebhookDeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookDeliveryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookDeliverySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookDeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookDeliveryMaxAggregateInputType
  }

  export type GetWebhookDeliveryAggregateType<T extends WebhookDeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookDelivery[P]>
      : GetScalarType<T[P], AggregateWebhookDelivery[P]>
  }




  export type WebhookDeliveryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookDeliveryWhereInput
    orderBy?: WebhookDeliveryOrderByWithAggregationInput | WebhookDeliveryOrderByWithAggregationInput[]
    by: WebhookDeliveryScalarFieldEnum[] | WebhookDeliveryScalarFieldEnum
    having?: WebhookDeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookDeliveryCountAggregateInputType | true
    _avg?: WebhookDeliveryAvgAggregateInputType
    _sum?: WebhookDeliverySumAggregateInputType
    _min?: WebhookDeliveryMinAggregateInputType
    _max?: WebhookDeliveryMaxAggregateInputType
  }

  export type WebhookDeliveryGroupByOutputType = {
    id: string
    eventType: $Enums.WebhookEvent
    payload: JsonValue
    httpStatus: number | null
    responseBody: string | null
    errorMessage: string | null
    deliveryAttempts: number
    deliveredAt: Date | null
    webhookId: string
    createdAt: Date
    _count: WebhookDeliveryCountAggregateOutputType | null
    _avg: WebhookDeliveryAvgAggregateOutputType | null
    _sum: WebhookDeliverySumAggregateOutputType | null
    _min: WebhookDeliveryMinAggregateOutputType | null
    _max: WebhookDeliveryMaxAggregateOutputType | null
  }

  type GetWebhookDeliveryGroupByPayload<T extends WebhookDeliveryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookDeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookDeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookDeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookDeliveryGroupByOutputType[P]>
        }
      >
    >


  export type WebhookDeliverySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    payload?: boolean
    httpStatus?: boolean
    responseBody?: boolean
    errorMessage?: boolean
    deliveryAttempts?: boolean
    deliveredAt?: boolean
    webhookId?: boolean
    createdAt?: boolean
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookDelivery"]>

  export type WebhookDeliverySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    payload?: boolean
    httpStatus?: boolean
    responseBody?: boolean
    errorMessage?: boolean
    deliveryAttempts?: boolean
    deliveredAt?: boolean
    webhookId?: boolean
    createdAt?: boolean
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookDelivery"]>

  export type WebhookDeliverySelectScalar = {
    id?: boolean
    eventType?: boolean
    payload?: boolean
    httpStatus?: boolean
    responseBody?: boolean
    errorMessage?: boolean
    deliveryAttempts?: boolean
    deliveredAt?: boolean
    webhookId?: boolean
    createdAt?: boolean
  }

  export type WebhookDeliveryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }
  export type WebhookDeliveryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }

  export type $WebhookDeliveryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookDelivery"
    objects: {
      webhook: Prisma.$WebhookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventType: $Enums.WebhookEvent
      payload: Prisma.JsonValue
      httpStatus: number | null
      responseBody: string | null
      errorMessage: string | null
      deliveryAttempts: number
      deliveredAt: Date | null
      webhookId: string
      createdAt: Date
    }, ExtArgs["result"]["webhookDelivery"]>
    composites: {}
  }

  type WebhookDeliveryGetPayload<S extends boolean | null | undefined | WebhookDeliveryDefaultArgs> = $Result.GetResult<Prisma.$WebhookDeliveryPayload, S>

  type WebhookDeliveryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WebhookDeliveryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WebhookDeliveryCountAggregateInputType | true
    }

  export interface WebhookDeliveryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookDelivery'], meta: { name: 'WebhookDelivery' } }
    /**
     * Find zero or one WebhookDelivery that matches the filter.
     * @param {WebhookDeliveryFindUniqueArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookDeliveryFindUniqueArgs>(args: SelectSubset<T, WebhookDeliveryFindUniqueArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WebhookDelivery that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WebhookDeliveryFindUniqueOrThrowArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookDeliveryFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WebhookDelivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindFirstArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookDeliveryFindFirstArgs>(args?: SelectSubset<T, WebhookDeliveryFindFirstArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WebhookDelivery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindFirstOrThrowArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookDeliveryFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookDeliveryFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WebhookDeliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookDeliveries
     * const webhookDeliveries = await prisma.webhookDelivery.findMany()
     * 
     * // Get first 10 WebhookDeliveries
     * const webhookDeliveries = await prisma.webhookDelivery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookDeliveryWithIdOnly = await prisma.webhookDelivery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookDeliveryFindManyArgs>(args?: SelectSubset<T, WebhookDeliveryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WebhookDelivery.
     * @param {WebhookDeliveryCreateArgs} args - Arguments to create a WebhookDelivery.
     * @example
     * // Create one WebhookDelivery
     * const WebhookDelivery = await prisma.webhookDelivery.create({
     *   data: {
     *     // ... data to create a WebhookDelivery
     *   }
     * })
     * 
     */
    create<T extends WebhookDeliveryCreateArgs>(args: SelectSubset<T, WebhookDeliveryCreateArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WebhookDeliveries.
     * @param {WebhookDeliveryCreateManyArgs} args - Arguments to create many WebhookDeliveries.
     * @example
     * // Create many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookDeliveryCreateManyArgs>(args?: SelectSubset<T, WebhookDeliveryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookDeliveries and returns the data saved in the database.
     * @param {WebhookDeliveryCreateManyAndReturnArgs} args - Arguments to create many WebhookDeliveries.
     * @example
     * // Create many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookDeliveries and only return the `id`
     * const webhookDeliveryWithIdOnly = await prisma.webhookDelivery.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookDeliveryCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookDeliveryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WebhookDelivery.
     * @param {WebhookDeliveryDeleteArgs} args - Arguments to delete one WebhookDelivery.
     * @example
     * // Delete one WebhookDelivery
     * const WebhookDelivery = await prisma.webhookDelivery.delete({
     *   where: {
     *     // ... filter to delete one WebhookDelivery
     *   }
     * })
     * 
     */
    delete<T extends WebhookDeliveryDeleteArgs>(args: SelectSubset<T, WebhookDeliveryDeleteArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WebhookDelivery.
     * @param {WebhookDeliveryUpdateArgs} args - Arguments to update one WebhookDelivery.
     * @example
     * // Update one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookDeliveryUpdateArgs>(args: SelectSubset<T, WebhookDeliveryUpdateArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WebhookDeliveries.
     * @param {WebhookDeliveryDeleteManyArgs} args - Arguments to filter WebhookDeliveries to delete.
     * @example
     * // Delete a few WebhookDeliveries
     * const { count } = await prisma.webhookDelivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookDeliveryDeleteManyArgs>(args?: SelectSubset<T, WebhookDeliveryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookDeliveryUpdateManyArgs>(args: SelectSubset<T, WebhookDeliveryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WebhookDelivery.
     * @param {WebhookDeliveryUpsertArgs} args - Arguments to update or create a WebhookDelivery.
     * @example
     * // Update or create a WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.upsert({
     *   create: {
     *     // ... data to create a WebhookDelivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookDelivery we want to update
     *   }
     * })
     */
    upsert<T extends WebhookDeliveryUpsertArgs>(args: SelectSubset<T, WebhookDeliveryUpsertArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WebhookDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryCountArgs} args - Arguments to filter WebhookDeliveries to count.
     * @example
     * // Count the number of WebhookDeliveries
     * const count = await prisma.webhookDelivery.count({
     *   where: {
     *     // ... the filter for the WebhookDeliveries we want to count
     *   }
     * })
    **/
    count<T extends WebhookDeliveryCountArgs>(
      args?: Subset<T, WebhookDeliveryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookDeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookDeliveryAggregateArgs>(args: Subset<T, WebhookDeliveryAggregateArgs>): Prisma.PrismaPromise<GetWebhookDeliveryAggregateType<T>>

    /**
     * Group by WebhookDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookDeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookDeliveryGroupByArgs['orderBy'] }
        : { orderBy?: WebhookDeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookDeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookDeliveryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookDelivery model
   */
  readonly fields: WebhookDeliveryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookDelivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookDeliveryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    webhook<T extends WebhookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WebhookDefaultArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookDelivery model
   */ 
  interface WebhookDeliveryFieldRefs {
    readonly id: FieldRef<"WebhookDelivery", 'String'>
    readonly eventType: FieldRef<"WebhookDelivery", 'WebhookEvent'>
    readonly payload: FieldRef<"WebhookDelivery", 'Json'>
    readonly httpStatus: FieldRef<"WebhookDelivery", 'Int'>
    readonly responseBody: FieldRef<"WebhookDelivery", 'String'>
    readonly errorMessage: FieldRef<"WebhookDelivery", 'String'>
    readonly deliveryAttempts: FieldRef<"WebhookDelivery", 'Int'>
    readonly deliveredAt: FieldRef<"WebhookDelivery", 'DateTime'>
    readonly webhookId: FieldRef<"WebhookDelivery", 'String'>
    readonly createdAt: FieldRef<"WebhookDelivery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebhookDelivery findUnique
   */
  export type WebhookDeliveryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery findUniqueOrThrow
   */
  export type WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery findFirst
   */
  export type WebhookDeliveryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookDeliveries.
     */
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery findFirstOrThrow
   */
  export type WebhookDeliveryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookDeliveries.
     */
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery findMany
   */
  export type WebhookDeliveryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDeliveries to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery create
   */
  export type WebhookDeliveryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to create a WebhookDelivery.
     */
    data: XOR<WebhookDeliveryCreateInput, WebhookDeliveryUncheckedCreateInput>
  }

  /**
   * WebhookDelivery createMany
   */
  export type WebhookDeliveryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookDeliveries.
     */
    data: WebhookDeliveryCreateManyInput | WebhookDeliveryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookDelivery createManyAndReturn
   */
  export type WebhookDeliveryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WebhookDeliveries.
     */
    data: WebhookDeliveryCreateManyInput | WebhookDeliveryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebhookDelivery update
   */
  export type WebhookDeliveryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to update a WebhookDelivery.
     */
    data: XOR<WebhookDeliveryUpdateInput, WebhookDeliveryUncheckedUpdateInput>
    /**
     * Choose, which WebhookDelivery to update.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery updateMany
   */
  export type WebhookDeliveryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookDeliveries.
     */
    data: XOR<WebhookDeliveryUpdateManyMutationInput, WebhookDeliveryUncheckedUpdateManyInput>
    /**
     * Filter which WebhookDeliveries to update
     */
    where?: WebhookDeliveryWhereInput
  }

  /**
   * WebhookDelivery upsert
   */
  export type WebhookDeliveryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * The filter to search for the WebhookDelivery to update in case it exists.
     */
    where: WebhookDeliveryWhereUniqueInput
    /**
     * In case the WebhookDelivery found by the `where` argument doesn't exist, create a new WebhookDelivery with this data.
     */
    create: XOR<WebhookDeliveryCreateInput, WebhookDeliveryUncheckedCreateInput>
    /**
     * In case the WebhookDelivery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookDeliveryUpdateInput, WebhookDeliveryUncheckedUpdateInput>
  }

  /**
   * WebhookDelivery delete
   */
  export type WebhookDeliveryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter which WebhookDelivery to delete.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery deleteMany
   */
  export type WebhookDeliveryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookDeliveries to delete
     */
    where?: WebhookDeliveryWhereInput
  }

  /**
   * WebhookDelivery without action
   */
  export type WebhookDeliveryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
  }


  /**
   * Model EventLog
   */

  export type AggregateEventLog = {
    _count: EventLogCountAggregateOutputType | null
    _min: EventLogMinAggregateOutputType | null
    _max: EventLogMaxAggregateOutputType | null
  }

  export type EventLogMinAggregateOutputType = {
    id: string | null
    eventType: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
    occurredAt: Date | null
  }

  export type EventLogMaxAggregateOutputType = {
    id: string | null
    eventType: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
    occurredAt: Date | null
  }

  export type EventLogCountAggregateOutputType = {
    id: number
    eventType: number
    entityType: number
    entityId: number
    changes: number
    metadata: number
    ipAddress: number
    userAgent: number
    userId: number
    occurredAt: number
    _all: number
  }


  export type EventLogMinAggregateInputType = {
    id?: true
    eventType?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    occurredAt?: true
  }

  export type EventLogMaxAggregateInputType = {
    id?: true
    eventType?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    occurredAt?: true
  }

  export type EventLogCountAggregateInputType = {
    id?: true
    eventType?: true
    entityType?: true
    entityId?: true
    changes?: true
    metadata?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    occurredAt?: true
    _all?: true
  }

  export type EventLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventLog to aggregate.
     */
    where?: EventLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventLogs to fetch.
     */
    orderBy?: EventLogOrderByWithRelationInput | EventLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventLogs
    **/
    _count?: true | EventLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventLogMaxAggregateInputType
  }

  export type GetEventLogAggregateType<T extends EventLogAggregateArgs> = {
        [P in keyof T & keyof AggregateEventLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventLog[P]>
      : GetScalarType<T[P], AggregateEventLog[P]>
  }




  export type EventLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventLogWhereInput
    orderBy?: EventLogOrderByWithAggregationInput | EventLogOrderByWithAggregationInput[]
    by: EventLogScalarFieldEnum[] | EventLogScalarFieldEnum
    having?: EventLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventLogCountAggregateInputType | true
    _min?: EventLogMinAggregateInputType
    _max?: EventLogMaxAggregateInputType
  }

  export type EventLogGroupByOutputType = {
    id: string
    eventType: string
    entityType: string
    entityId: string
    changes: JsonValue
    metadata: JsonValue
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
    occurredAt: Date
    _count: EventLogCountAggregateOutputType | null
    _min: EventLogMinAggregateOutputType | null
    _max: EventLogMaxAggregateOutputType | null
  }

  type GetEventLogGroupByPayload<T extends EventLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventLogGroupByOutputType[P]>
            : GetScalarType<T[P], EventLogGroupByOutputType[P]>
        }
      >
    >


  export type EventLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    occurredAt?: boolean
    user?: boolean | EventLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["eventLog"]>

  export type EventLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    occurredAt?: boolean
    user?: boolean | EventLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["eventLog"]>

  export type EventLogSelectScalar = {
    id?: boolean
    eventType?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    occurredAt?: boolean
  }

  export type EventLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | EventLog$userArgs<ExtArgs>
  }
  export type EventLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | EventLog$userArgs<ExtArgs>
  }

  export type $EventLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventType: string
      entityType: string
      entityId: string
      changes: Prisma.JsonValue
      metadata: Prisma.JsonValue
      ipAddress: string | null
      userAgent: string | null
      userId: string | null
      occurredAt: Date
    }, ExtArgs["result"]["eventLog"]>
    composites: {}
  }

  type EventLogGetPayload<S extends boolean | null | undefined | EventLogDefaultArgs> = $Result.GetResult<Prisma.$EventLogPayload, S>

  type EventLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventLogCountAggregateInputType | true
    }

  export interface EventLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventLog'], meta: { name: 'EventLog' } }
    /**
     * Find zero or one EventLog that matches the filter.
     * @param {EventLogFindUniqueArgs} args - Arguments to find a EventLog
     * @example
     * // Get one EventLog
     * const eventLog = await prisma.eventLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventLogFindUniqueArgs>(args: SelectSubset<T, EventLogFindUniqueArgs<ExtArgs>>): Prisma__EventLogClient<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EventLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventLogFindUniqueOrThrowArgs} args - Arguments to find a EventLog
     * @example
     * // Get one EventLog
     * const eventLog = await prisma.eventLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventLogFindUniqueOrThrowArgs>(args: SelectSubset<T, EventLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventLogClient<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EventLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLogFindFirstArgs} args - Arguments to find a EventLog
     * @example
     * // Get one EventLog
     * const eventLog = await prisma.eventLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventLogFindFirstArgs>(args?: SelectSubset<T, EventLogFindFirstArgs<ExtArgs>>): Prisma__EventLogClient<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EventLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLogFindFirstOrThrowArgs} args - Arguments to find a EventLog
     * @example
     * // Get one EventLog
     * const eventLog = await prisma.eventLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventLogFindFirstOrThrowArgs>(args?: SelectSubset<T, EventLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventLogClient<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EventLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventLogs
     * const eventLogs = await prisma.eventLog.findMany()
     * 
     * // Get first 10 EventLogs
     * const eventLogs = await prisma.eventLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventLogWithIdOnly = await prisma.eventLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventLogFindManyArgs>(args?: SelectSubset<T, EventLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EventLog.
     * @param {EventLogCreateArgs} args - Arguments to create a EventLog.
     * @example
     * // Create one EventLog
     * const EventLog = await prisma.eventLog.create({
     *   data: {
     *     // ... data to create a EventLog
     *   }
     * })
     * 
     */
    create<T extends EventLogCreateArgs>(args: SelectSubset<T, EventLogCreateArgs<ExtArgs>>): Prisma__EventLogClient<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EventLogs.
     * @param {EventLogCreateManyArgs} args - Arguments to create many EventLogs.
     * @example
     * // Create many EventLogs
     * const eventLog = await prisma.eventLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventLogCreateManyArgs>(args?: SelectSubset<T, EventLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventLogs and returns the data saved in the database.
     * @param {EventLogCreateManyAndReturnArgs} args - Arguments to create many EventLogs.
     * @example
     * // Create many EventLogs
     * const eventLog = await prisma.eventLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventLogs and only return the `id`
     * const eventLogWithIdOnly = await prisma.eventLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventLogCreateManyAndReturnArgs>(args?: SelectSubset<T, EventLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EventLog.
     * @param {EventLogDeleteArgs} args - Arguments to delete one EventLog.
     * @example
     * // Delete one EventLog
     * const EventLog = await prisma.eventLog.delete({
     *   where: {
     *     // ... filter to delete one EventLog
     *   }
     * })
     * 
     */
    delete<T extends EventLogDeleteArgs>(args: SelectSubset<T, EventLogDeleteArgs<ExtArgs>>): Prisma__EventLogClient<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EventLog.
     * @param {EventLogUpdateArgs} args - Arguments to update one EventLog.
     * @example
     * // Update one EventLog
     * const eventLog = await prisma.eventLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventLogUpdateArgs>(args: SelectSubset<T, EventLogUpdateArgs<ExtArgs>>): Prisma__EventLogClient<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EventLogs.
     * @param {EventLogDeleteManyArgs} args - Arguments to filter EventLogs to delete.
     * @example
     * // Delete a few EventLogs
     * const { count } = await prisma.eventLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventLogDeleteManyArgs>(args?: SelectSubset<T, EventLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventLogs
     * const eventLog = await prisma.eventLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventLogUpdateManyArgs>(args: SelectSubset<T, EventLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventLog.
     * @param {EventLogUpsertArgs} args - Arguments to update or create a EventLog.
     * @example
     * // Update or create a EventLog
     * const eventLog = await prisma.eventLog.upsert({
     *   create: {
     *     // ... data to create a EventLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventLog we want to update
     *   }
     * })
     */
    upsert<T extends EventLogUpsertArgs>(args: SelectSubset<T, EventLogUpsertArgs<ExtArgs>>): Prisma__EventLogClient<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EventLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLogCountArgs} args - Arguments to filter EventLogs to count.
     * @example
     * // Count the number of EventLogs
     * const count = await prisma.eventLog.count({
     *   where: {
     *     // ... the filter for the EventLogs we want to count
     *   }
     * })
    **/
    count<T extends EventLogCountArgs>(
      args?: Subset<T, EventLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventLogAggregateArgs>(args: Subset<T, EventLogAggregateArgs>): Prisma.PrismaPromise<GetEventLogAggregateType<T>>

    /**
     * Group by EventLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventLogGroupByArgs['orderBy'] }
        : { orderBy?: EventLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventLog model
   */
  readonly fields: EventLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends EventLog$userArgs<ExtArgs> = {}>(args?: Subset<T, EventLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventLog model
   */ 
  interface EventLogFieldRefs {
    readonly id: FieldRef<"EventLog", 'String'>
    readonly eventType: FieldRef<"EventLog", 'String'>
    readonly entityType: FieldRef<"EventLog", 'String'>
    readonly entityId: FieldRef<"EventLog", 'String'>
    readonly changes: FieldRef<"EventLog", 'Json'>
    readonly metadata: FieldRef<"EventLog", 'Json'>
    readonly ipAddress: FieldRef<"EventLog", 'String'>
    readonly userAgent: FieldRef<"EventLog", 'String'>
    readonly userId: FieldRef<"EventLog", 'String'>
    readonly occurredAt: FieldRef<"EventLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventLog findUnique
   */
  export type EventLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventLogInclude<ExtArgs> | null
    /**
     * Filter, which EventLog to fetch.
     */
    where: EventLogWhereUniqueInput
  }

  /**
   * EventLog findUniqueOrThrow
   */
  export type EventLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventLogInclude<ExtArgs> | null
    /**
     * Filter, which EventLog to fetch.
     */
    where: EventLogWhereUniqueInput
  }

  /**
   * EventLog findFirst
   */
  export type EventLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventLogInclude<ExtArgs> | null
    /**
     * Filter, which EventLog to fetch.
     */
    where?: EventLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventLogs to fetch.
     */
    orderBy?: EventLogOrderByWithRelationInput | EventLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventLogs.
     */
    cursor?: EventLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventLogs.
     */
    distinct?: EventLogScalarFieldEnum | EventLogScalarFieldEnum[]
  }

  /**
   * EventLog findFirstOrThrow
   */
  export type EventLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventLogInclude<ExtArgs> | null
    /**
     * Filter, which EventLog to fetch.
     */
    where?: EventLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventLogs to fetch.
     */
    orderBy?: EventLogOrderByWithRelationInput | EventLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventLogs.
     */
    cursor?: EventLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventLogs.
     */
    distinct?: EventLogScalarFieldEnum | EventLogScalarFieldEnum[]
  }

  /**
   * EventLog findMany
   */
  export type EventLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventLogInclude<ExtArgs> | null
    /**
     * Filter, which EventLogs to fetch.
     */
    where?: EventLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventLogs to fetch.
     */
    orderBy?: EventLogOrderByWithRelationInput | EventLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventLogs.
     */
    cursor?: EventLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventLogs.
     */
    skip?: number
    distinct?: EventLogScalarFieldEnum | EventLogScalarFieldEnum[]
  }

  /**
   * EventLog create
   */
  export type EventLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventLogInclude<ExtArgs> | null
    /**
     * The data needed to create a EventLog.
     */
    data: XOR<EventLogCreateInput, EventLogUncheckedCreateInput>
  }

  /**
   * EventLog createMany
   */
  export type EventLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventLogs.
     */
    data: EventLogCreateManyInput | EventLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventLog createManyAndReturn
   */
  export type EventLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EventLogs.
     */
    data: EventLogCreateManyInput | EventLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventLog update
   */
  export type EventLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventLogInclude<ExtArgs> | null
    /**
     * The data needed to update a EventLog.
     */
    data: XOR<EventLogUpdateInput, EventLogUncheckedUpdateInput>
    /**
     * Choose, which EventLog to update.
     */
    where: EventLogWhereUniqueInput
  }

  /**
   * EventLog updateMany
   */
  export type EventLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventLogs.
     */
    data: XOR<EventLogUpdateManyMutationInput, EventLogUncheckedUpdateManyInput>
    /**
     * Filter which EventLogs to update
     */
    where?: EventLogWhereInput
  }

  /**
   * EventLog upsert
   */
  export type EventLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventLogInclude<ExtArgs> | null
    /**
     * The filter to search for the EventLog to update in case it exists.
     */
    where: EventLogWhereUniqueInput
    /**
     * In case the EventLog found by the `where` argument doesn't exist, create a new EventLog with this data.
     */
    create: XOR<EventLogCreateInput, EventLogUncheckedCreateInput>
    /**
     * In case the EventLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventLogUpdateInput, EventLogUncheckedUpdateInput>
  }

  /**
   * EventLog delete
   */
  export type EventLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventLogInclude<ExtArgs> | null
    /**
     * Filter which EventLog to delete.
     */
    where: EventLogWhereUniqueInput
  }

  /**
   * EventLog deleteMany
   */
  export type EventLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventLogs to delete
     */
    where?: EventLogWhereInput
  }

  /**
   * EventLog.user
   */
  export type EventLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * EventLog without action
   */
  export type EventLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventLogInclude<ExtArgs> | null
  }


  /**
   * Model Integration
   */

  export type AggregateIntegration = {
    _count: IntegrationCountAggregateOutputType | null
    _min: IntegrationMinAggregateOutputType | null
    _max: IntegrationMaxAggregateOutputType | null
  }

  export type IntegrationMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.IntegrationType | null
    isActive: boolean | null
    lastSyncAt: Date | null
    nextSyncAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntegrationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.IntegrationType | null
    isActive: boolean | null
    lastSyncAt: Date | null
    nextSyncAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntegrationCountAggregateOutputType = {
    id: number
    name: number
    type: number
    config: number
    isActive: number
    lastSyncAt: number
    nextSyncAt: number
    syncErrors: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntegrationMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    isActive?: true
    lastSyncAt?: true
    nextSyncAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntegrationMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    isActive?: true
    lastSyncAt?: true
    nextSyncAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntegrationCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    config?: true
    isActive?: true
    lastSyncAt?: true
    nextSyncAt?: true
    syncErrors?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Integration to aggregate.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Integrations
    **/
    _count?: true | IntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntegrationMaxAggregateInputType
  }

  export type GetIntegrationAggregateType<T extends IntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntegration[P]>
      : GetScalarType<T[P], AggregateIntegration[P]>
  }




  export type IntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationWhereInput
    orderBy?: IntegrationOrderByWithAggregationInput | IntegrationOrderByWithAggregationInput[]
    by: IntegrationScalarFieldEnum[] | IntegrationScalarFieldEnum
    having?: IntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntegrationCountAggregateInputType | true
    _min?: IntegrationMinAggregateInputType
    _max?: IntegrationMaxAggregateInputType
  }

  export type IntegrationGroupByOutputType = {
    id: string
    name: string
    type: $Enums.IntegrationType
    config: JsonValue
    isActive: boolean
    lastSyncAt: Date | null
    nextSyncAt: Date | null
    syncErrors: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: IntegrationCountAggregateOutputType | null
    _min: IntegrationMinAggregateOutputType | null
    _max: IntegrationMaxAggregateOutputType | null
  }

  type GetIntegrationGroupByPayload<T extends IntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], IntegrationGroupByOutputType[P]>
        }
      >
    >


  export type IntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    config?: boolean
    isActive?: boolean
    lastSyncAt?: boolean
    nextSyncAt?: boolean
    syncErrors?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["integration"]>

  export type IntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    config?: boolean
    isActive?: boolean
    lastSyncAt?: boolean
    nextSyncAt?: boolean
    syncErrors?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["integration"]>

  export type IntegrationSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    config?: boolean
    isActive?: boolean
    lastSyncAt?: boolean
    nextSyncAt?: boolean
    syncErrors?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $IntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Integration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.IntegrationType
      config: Prisma.JsonValue
      isActive: boolean
      lastSyncAt: Date | null
      nextSyncAt: Date | null
      syncErrors: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["integration"]>
    composites: {}
  }

  type IntegrationGetPayload<S extends boolean | null | undefined | IntegrationDefaultArgs> = $Result.GetResult<Prisma.$IntegrationPayload, S>

  type IntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IntegrationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IntegrationCountAggregateInputType | true
    }

  export interface IntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Integration'], meta: { name: 'Integration' } }
    /**
     * Find zero or one Integration that matches the filter.
     * @param {IntegrationFindUniqueArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntegrationFindUniqueArgs>(args: SelectSubset<T, IntegrationFindUniqueArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Integration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IntegrationFindUniqueOrThrowArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, IntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Integration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindFirstArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntegrationFindFirstArgs>(args?: SelectSubset<T, IntegrationFindFirstArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Integration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindFirstOrThrowArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, IntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Integrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Integrations
     * const integrations = await prisma.integration.findMany()
     * 
     * // Get first 10 Integrations
     * const integrations = await prisma.integration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const integrationWithIdOnly = await prisma.integration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntegrationFindManyArgs>(args?: SelectSubset<T, IntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Integration.
     * @param {IntegrationCreateArgs} args - Arguments to create a Integration.
     * @example
     * // Create one Integration
     * const Integration = await prisma.integration.create({
     *   data: {
     *     // ... data to create a Integration
     *   }
     * })
     * 
     */
    create<T extends IntegrationCreateArgs>(args: SelectSubset<T, IntegrationCreateArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Integrations.
     * @param {IntegrationCreateManyArgs} args - Arguments to create many Integrations.
     * @example
     * // Create many Integrations
     * const integration = await prisma.integration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntegrationCreateManyArgs>(args?: SelectSubset<T, IntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Integrations and returns the data saved in the database.
     * @param {IntegrationCreateManyAndReturnArgs} args - Arguments to create many Integrations.
     * @example
     * // Create many Integrations
     * const integration = await prisma.integration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Integrations and only return the `id`
     * const integrationWithIdOnly = await prisma.integration.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, IntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Integration.
     * @param {IntegrationDeleteArgs} args - Arguments to delete one Integration.
     * @example
     * // Delete one Integration
     * const Integration = await prisma.integration.delete({
     *   where: {
     *     // ... filter to delete one Integration
     *   }
     * })
     * 
     */
    delete<T extends IntegrationDeleteArgs>(args: SelectSubset<T, IntegrationDeleteArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Integration.
     * @param {IntegrationUpdateArgs} args - Arguments to update one Integration.
     * @example
     * // Update one Integration
     * const integration = await prisma.integration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntegrationUpdateArgs>(args: SelectSubset<T, IntegrationUpdateArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Integrations.
     * @param {IntegrationDeleteManyArgs} args - Arguments to filter Integrations to delete.
     * @example
     * // Delete a few Integrations
     * const { count } = await prisma.integration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntegrationDeleteManyArgs>(args?: SelectSubset<T, IntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Integrations
     * const integration = await prisma.integration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntegrationUpdateManyArgs>(args: SelectSubset<T, IntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Integration.
     * @param {IntegrationUpsertArgs} args - Arguments to update or create a Integration.
     * @example
     * // Update or create a Integration
     * const integration = await prisma.integration.upsert({
     *   create: {
     *     // ... data to create a Integration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Integration we want to update
     *   }
     * })
     */
    upsert<T extends IntegrationUpsertArgs>(args: SelectSubset<T, IntegrationUpsertArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationCountArgs} args - Arguments to filter Integrations to count.
     * @example
     * // Count the number of Integrations
     * const count = await prisma.integration.count({
     *   where: {
     *     // ... the filter for the Integrations we want to count
     *   }
     * })
    **/
    count<T extends IntegrationCountArgs>(
      args?: Subset<T, IntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Integration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntegrationAggregateArgs>(args: Subset<T, IntegrationAggregateArgs>): Prisma.PrismaPromise<GetIntegrationAggregateType<T>>

    /**
     * Group by Integration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntegrationGroupByArgs['orderBy'] }
        : { orderBy?: IntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Integration model
   */
  readonly fields: IntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Integration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Integration model
   */ 
  interface IntegrationFieldRefs {
    readonly id: FieldRef<"Integration", 'String'>
    readonly name: FieldRef<"Integration", 'String'>
    readonly type: FieldRef<"Integration", 'IntegrationType'>
    readonly config: FieldRef<"Integration", 'Json'>
    readonly isActive: FieldRef<"Integration", 'Boolean'>
    readonly lastSyncAt: FieldRef<"Integration", 'DateTime'>
    readonly nextSyncAt: FieldRef<"Integration", 'DateTime'>
    readonly syncErrors: FieldRef<"Integration", 'Json'>
    readonly createdAt: FieldRef<"Integration", 'DateTime'>
    readonly updatedAt: FieldRef<"Integration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Integration findUnique
   */
  export type IntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration findUniqueOrThrow
   */
  export type IntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration findFirst
   */
  export type IntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Integrations.
     */
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration findFirstOrThrow
   */
  export type IntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Integrations.
     */
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration findMany
   */
  export type IntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Filter, which Integrations to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration create
   */
  export type IntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * The data needed to create a Integration.
     */
    data: XOR<IntegrationCreateInput, IntegrationUncheckedCreateInput>
  }

  /**
   * Integration createMany
   */
  export type IntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Integrations.
     */
    data: IntegrationCreateManyInput | IntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Integration createManyAndReturn
   */
  export type IntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Integrations.
     */
    data: IntegrationCreateManyInput | IntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Integration update
   */
  export type IntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * The data needed to update a Integration.
     */
    data: XOR<IntegrationUpdateInput, IntegrationUncheckedUpdateInput>
    /**
     * Choose, which Integration to update.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration updateMany
   */
  export type IntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Integrations.
     */
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyInput>
    /**
     * Filter which Integrations to update
     */
    where?: IntegrationWhereInput
  }

  /**
   * Integration upsert
   */
  export type IntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * The filter to search for the Integration to update in case it exists.
     */
    where: IntegrationWhereUniqueInput
    /**
     * In case the Integration found by the `where` argument doesn't exist, create a new Integration with this data.
     */
    create: XOR<IntegrationCreateInput, IntegrationUncheckedCreateInput>
    /**
     * In case the Integration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntegrationUpdateInput, IntegrationUncheckedUpdateInput>
  }

  /**
   * Integration delete
   */
  export type IntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Filter which Integration to delete.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration deleteMany
   */
  export type IntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Integrations to delete
     */
    where?: IntegrationWhereInput
  }

  /**
   * Integration without action
   */
  export type IntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
  }


  /**
   * Model MergeQueue
   */

  export type AggregateMergeQueue = {
    _count: MergeQueueCountAggregateOutputType | null
    _min: MergeQueueMinAggregateOutputType | null
    _max: MergeQueueMaxAggregateOutputType | null
  }

  export type MergeQueueMinAggregateOutputType = {
    id: string | null
    entityType: string | null
    primaryEntityId: string | null
    duplicateEntityId: string | null
    status: $Enums.MergeStatus | null
    reviewedById: string | null
    reviewedAt: Date | null
    mergedAt: Date | null
    createdAt: Date | null
  }

  export type MergeQueueMaxAggregateOutputType = {
    id: string | null
    entityType: string | null
    primaryEntityId: string | null
    duplicateEntityId: string | null
    status: $Enums.MergeStatus | null
    reviewedById: string | null
    reviewedAt: Date | null
    mergedAt: Date | null
    createdAt: Date | null
  }

  export type MergeQueueCountAggregateOutputType = {
    id: number
    entityType: number
    primaryEntityId: number
    duplicateEntityId: number
    status: number
    mergeRules: number
    reviewedById: number
    reviewedAt: number
    mergedAt: number
    createdAt: number
    _all: number
  }


  export type MergeQueueMinAggregateInputType = {
    id?: true
    entityType?: true
    primaryEntityId?: true
    duplicateEntityId?: true
    status?: true
    reviewedById?: true
    reviewedAt?: true
    mergedAt?: true
    createdAt?: true
  }

  export type MergeQueueMaxAggregateInputType = {
    id?: true
    entityType?: true
    primaryEntityId?: true
    duplicateEntityId?: true
    status?: true
    reviewedById?: true
    reviewedAt?: true
    mergedAt?: true
    createdAt?: true
  }

  export type MergeQueueCountAggregateInputType = {
    id?: true
    entityType?: true
    primaryEntityId?: true
    duplicateEntityId?: true
    status?: true
    mergeRules?: true
    reviewedById?: true
    reviewedAt?: true
    mergedAt?: true
    createdAt?: true
    _all?: true
  }

  export type MergeQueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MergeQueue to aggregate.
     */
    where?: MergeQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MergeQueues to fetch.
     */
    orderBy?: MergeQueueOrderByWithRelationInput | MergeQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MergeQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MergeQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MergeQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MergeQueues
    **/
    _count?: true | MergeQueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MergeQueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MergeQueueMaxAggregateInputType
  }

  export type GetMergeQueueAggregateType<T extends MergeQueueAggregateArgs> = {
        [P in keyof T & keyof AggregateMergeQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMergeQueue[P]>
      : GetScalarType<T[P], AggregateMergeQueue[P]>
  }




  export type MergeQueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MergeQueueWhereInput
    orderBy?: MergeQueueOrderByWithAggregationInput | MergeQueueOrderByWithAggregationInput[]
    by: MergeQueueScalarFieldEnum[] | MergeQueueScalarFieldEnum
    having?: MergeQueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MergeQueueCountAggregateInputType | true
    _min?: MergeQueueMinAggregateInputType
    _max?: MergeQueueMaxAggregateInputType
  }

  export type MergeQueueGroupByOutputType = {
    id: string
    entityType: string
    primaryEntityId: string
    duplicateEntityId: string
    status: $Enums.MergeStatus
    mergeRules: JsonValue
    reviewedById: string | null
    reviewedAt: Date | null
    mergedAt: Date | null
    createdAt: Date
    _count: MergeQueueCountAggregateOutputType | null
    _min: MergeQueueMinAggregateOutputType | null
    _max: MergeQueueMaxAggregateOutputType | null
  }

  type GetMergeQueueGroupByPayload<T extends MergeQueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MergeQueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MergeQueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MergeQueueGroupByOutputType[P]>
            : GetScalarType<T[P], MergeQueueGroupByOutputType[P]>
        }
      >
    >


  export type MergeQueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    primaryEntityId?: boolean
    duplicateEntityId?: boolean
    status?: boolean
    mergeRules?: boolean
    reviewedById?: boolean
    reviewedAt?: boolean
    mergedAt?: boolean
    createdAt?: boolean
    reviewedBy?: boolean | MergeQueue$reviewedByArgs<ExtArgs>
  }, ExtArgs["result"]["mergeQueue"]>

  export type MergeQueueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    primaryEntityId?: boolean
    duplicateEntityId?: boolean
    status?: boolean
    mergeRules?: boolean
    reviewedById?: boolean
    reviewedAt?: boolean
    mergedAt?: boolean
    createdAt?: boolean
    reviewedBy?: boolean | MergeQueue$reviewedByArgs<ExtArgs>
  }, ExtArgs["result"]["mergeQueue"]>

  export type MergeQueueSelectScalar = {
    id?: boolean
    entityType?: boolean
    primaryEntityId?: boolean
    duplicateEntityId?: boolean
    status?: boolean
    mergeRules?: boolean
    reviewedById?: boolean
    reviewedAt?: boolean
    mergedAt?: boolean
    createdAt?: boolean
  }

  export type MergeQueueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviewedBy?: boolean | MergeQueue$reviewedByArgs<ExtArgs>
  }
  export type MergeQueueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviewedBy?: boolean | MergeQueue$reviewedByArgs<ExtArgs>
  }

  export type $MergeQueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MergeQueue"
    objects: {
      reviewedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityType: string
      primaryEntityId: string
      duplicateEntityId: string
      status: $Enums.MergeStatus
      mergeRules: Prisma.JsonValue
      reviewedById: string | null
      reviewedAt: Date | null
      mergedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["mergeQueue"]>
    composites: {}
  }

  type MergeQueueGetPayload<S extends boolean | null | undefined | MergeQueueDefaultArgs> = $Result.GetResult<Prisma.$MergeQueuePayload, S>

  type MergeQueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MergeQueueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MergeQueueCountAggregateInputType | true
    }

  export interface MergeQueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MergeQueue'], meta: { name: 'MergeQueue' } }
    /**
     * Find zero or one MergeQueue that matches the filter.
     * @param {MergeQueueFindUniqueArgs} args - Arguments to find a MergeQueue
     * @example
     * // Get one MergeQueue
     * const mergeQueue = await prisma.mergeQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MergeQueueFindUniqueArgs>(args: SelectSubset<T, MergeQueueFindUniqueArgs<ExtArgs>>): Prisma__MergeQueueClient<$Result.GetResult<Prisma.$MergeQueuePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MergeQueue that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MergeQueueFindUniqueOrThrowArgs} args - Arguments to find a MergeQueue
     * @example
     * // Get one MergeQueue
     * const mergeQueue = await prisma.mergeQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MergeQueueFindUniqueOrThrowArgs>(args: SelectSubset<T, MergeQueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MergeQueueClient<$Result.GetResult<Prisma.$MergeQueuePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MergeQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MergeQueueFindFirstArgs} args - Arguments to find a MergeQueue
     * @example
     * // Get one MergeQueue
     * const mergeQueue = await prisma.mergeQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MergeQueueFindFirstArgs>(args?: SelectSubset<T, MergeQueueFindFirstArgs<ExtArgs>>): Prisma__MergeQueueClient<$Result.GetResult<Prisma.$MergeQueuePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MergeQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MergeQueueFindFirstOrThrowArgs} args - Arguments to find a MergeQueue
     * @example
     * // Get one MergeQueue
     * const mergeQueue = await prisma.mergeQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MergeQueueFindFirstOrThrowArgs>(args?: SelectSubset<T, MergeQueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__MergeQueueClient<$Result.GetResult<Prisma.$MergeQueuePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MergeQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MergeQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MergeQueues
     * const mergeQueues = await prisma.mergeQueue.findMany()
     * 
     * // Get first 10 MergeQueues
     * const mergeQueues = await prisma.mergeQueue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mergeQueueWithIdOnly = await prisma.mergeQueue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MergeQueueFindManyArgs>(args?: SelectSubset<T, MergeQueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MergeQueuePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MergeQueue.
     * @param {MergeQueueCreateArgs} args - Arguments to create a MergeQueue.
     * @example
     * // Create one MergeQueue
     * const MergeQueue = await prisma.mergeQueue.create({
     *   data: {
     *     // ... data to create a MergeQueue
     *   }
     * })
     * 
     */
    create<T extends MergeQueueCreateArgs>(args: SelectSubset<T, MergeQueueCreateArgs<ExtArgs>>): Prisma__MergeQueueClient<$Result.GetResult<Prisma.$MergeQueuePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MergeQueues.
     * @param {MergeQueueCreateManyArgs} args - Arguments to create many MergeQueues.
     * @example
     * // Create many MergeQueues
     * const mergeQueue = await prisma.mergeQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MergeQueueCreateManyArgs>(args?: SelectSubset<T, MergeQueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MergeQueues and returns the data saved in the database.
     * @param {MergeQueueCreateManyAndReturnArgs} args - Arguments to create many MergeQueues.
     * @example
     * // Create many MergeQueues
     * const mergeQueue = await prisma.mergeQueue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MergeQueues and only return the `id`
     * const mergeQueueWithIdOnly = await prisma.mergeQueue.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MergeQueueCreateManyAndReturnArgs>(args?: SelectSubset<T, MergeQueueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MergeQueuePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MergeQueue.
     * @param {MergeQueueDeleteArgs} args - Arguments to delete one MergeQueue.
     * @example
     * // Delete one MergeQueue
     * const MergeQueue = await prisma.mergeQueue.delete({
     *   where: {
     *     // ... filter to delete one MergeQueue
     *   }
     * })
     * 
     */
    delete<T extends MergeQueueDeleteArgs>(args: SelectSubset<T, MergeQueueDeleteArgs<ExtArgs>>): Prisma__MergeQueueClient<$Result.GetResult<Prisma.$MergeQueuePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MergeQueue.
     * @param {MergeQueueUpdateArgs} args - Arguments to update one MergeQueue.
     * @example
     * // Update one MergeQueue
     * const mergeQueue = await prisma.mergeQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MergeQueueUpdateArgs>(args: SelectSubset<T, MergeQueueUpdateArgs<ExtArgs>>): Prisma__MergeQueueClient<$Result.GetResult<Prisma.$MergeQueuePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MergeQueues.
     * @param {MergeQueueDeleteManyArgs} args - Arguments to filter MergeQueues to delete.
     * @example
     * // Delete a few MergeQueues
     * const { count } = await prisma.mergeQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MergeQueueDeleteManyArgs>(args?: SelectSubset<T, MergeQueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MergeQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MergeQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MergeQueues
     * const mergeQueue = await prisma.mergeQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MergeQueueUpdateManyArgs>(args: SelectSubset<T, MergeQueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MergeQueue.
     * @param {MergeQueueUpsertArgs} args - Arguments to update or create a MergeQueue.
     * @example
     * // Update or create a MergeQueue
     * const mergeQueue = await prisma.mergeQueue.upsert({
     *   create: {
     *     // ... data to create a MergeQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MergeQueue we want to update
     *   }
     * })
     */
    upsert<T extends MergeQueueUpsertArgs>(args: SelectSubset<T, MergeQueueUpsertArgs<ExtArgs>>): Prisma__MergeQueueClient<$Result.GetResult<Prisma.$MergeQueuePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MergeQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MergeQueueCountArgs} args - Arguments to filter MergeQueues to count.
     * @example
     * // Count the number of MergeQueues
     * const count = await prisma.mergeQueue.count({
     *   where: {
     *     // ... the filter for the MergeQueues we want to count
     *   }
     * })
    **/
    count<T extends MergeQueueCountArgs>(
      args?: Subset<T, MergeQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MergeQueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MergeQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MergeQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MergeQueueAggregateArgs>(args: Subset<T, MergeQueueAggregateArgs>): Prisma.PrismaPromise<GetMergeQueueAggregateType<T>>

    /**
     * Group by MergeQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MergeQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MergeQueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MergeQueueGroupByArgs['orderBy'] }
        : { orderBy?: MergeQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MergeQueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMergeQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MergeQueue model
   */
  readonly fields: MergeQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MergeQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MergeQueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reviewedBy<T extends MergeQueue$reviewedByArgs<ExtArgs> = {}>(args?: Subset<T, MergeQueue$reviewedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MergeQueue model
   */ 
  interface MergeQueueFieldRefs {
    readonly id: FieldRef<"MergeQueue", 'String'>
    readonly entityType: FieldRef<"MergeQueue", 'String'>
    readonly primaryEntityId: FieldRef<"MergeQueue", 'String'>
    readonly duplicateEntityId: FieldRef<"MergeQueue", 'String'>
    readonly status: FieldRef<"MergeQueue", 'MergeStatus'>
    readonly mergeRules: FieldRef<"MergeQueue", 'Json'>
    readonly reviewedById: FieldRef<"MergeQueue", 'String'>
    readonly reviewedAt: FieldRef<"MergeQueue", 'DateTime'>
    readonly mergedAt: FieldRef<"MergeQueue", 'DateTime'>
    readonly createdAt: FieldRef<"MergeQueue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MergeQueue findUnique
   */
  export type MergeQueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MergeQueue
     */
    select?: MergeQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MergeQueueInclude<ExtArgs> | null
    /**
     * Filter, which MergeQueue to fetch.
     */
    where: MergeQueueWhereUniqueInput
  }

  /**
   * MergeQueue findUniqueOrThrow
   */
  export type MergeQueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MergeQueue
     */
    select?: MergeQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MergeQueueInclude<ExtArgs> | null
    /**
     * Filter, which MergeQueue to fetch.
     */
    where: MergeQueueWhereUniqueInput
  }

  /**
   * MergeQueue findFirst
   */
  export type MergeQueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MergeQueue
     */
    select?: MergeQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MergeQueueInclude<ExtArgs> | null
    /**
     * Filter, which MergeQueue to fetch.
     */
    where?: MergeQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MergeQueues to fetch.
     */
    orderBy?: MergeQueueOrderByWithRelationInput | MergeQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MergeQueues.
     */
    cursor?: MergeQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MergeQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MergeQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MergeQueues.
     */
    distinct?: MergeQueueScalarFieldEnum | MergeQueueScalarFieldEnum[]
  }

  /**
   * MergeQueue findFirstOrThrow
   */
  export type MergeQueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MergeQueue
     */
    select?: MergeQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MergeQueueInclude<ExtArgs> | null
    /**
     * Filter, which MergeQueue to fetch.
     */
    where?: MergeQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MergeQueues to fetch.
     */
    orderBy?: MergeQueueOrderByWithRelationInput | MergeQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MergeQueues.
     */
    cursor?: MergeQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MergeQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MergeQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MergeQueues.
     */
    distinct?: MergeQueueScalarFieldEnum | MergeQueueScalarFieldEnum[]
  }

  /**
   * MergeQueue findMany
   */
  export type MergeQueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MergeQueue
     */
    select?: MergeQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MergeQueueInclude<ExtArgs> | null
    /**
     * Filter, which MergeQueues to fetch.
     */
    where?: MergeQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MergeQueues to fetch.
     */
    orderBy?: MergeQueueOrderByWithRelationInput | MergeQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MergeQueues.
     */
    cursor?: MergeQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MergeQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MergeQueues.
     */
    skip?: number
    distinct?: MergeQueueScalarFieldEnum | MergeQueueScalarFieldEnum[]
  }

  /**
   * MergeQueue create
   */
  export type MergeQueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MergeQueue
     */
    select?: MergeQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MergeQueueInclude<ExtArgs> | null
    /**
     * The data needed to create a MergeQueue.
     */
    data: XOR<MergeQueueCreateInput, MergeQueueUncheckedCreateInput>
  }

  /**
   * MergeQueue createMany
   */
  export type MergeQueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MergeQueues.
     */
    data: MergeQueueCreateManyInput | MergeQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MergeQueue createManyAndReturn
   */
  export type MergeQueueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MergeQueue
     */
    select?: MergeQueueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MergeQueues.
     */
    data: MergeQueueCreateManyInput | MergeQueueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MergeQueueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MergeQueue update
   */
  export type MergeQueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MergeQueue
     */
    select?: MergeQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MergeQueueInclude<ExtArgs> | null
    /**
     * The data needed to update a MergeQueue.
     */
    data: XOR<MergeQueueUpdateInput, MergeQueueUncheckedUpdateInput>
    /**
     * Choose, which MergeQueue to update.
     */
    where: MergeQueueWhereUniqueInput
  }

  /**
   * MergeQueue updateMany
   */
  export type MergeQueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MergeQueues.
     */
    data: XOR<MergeQueueUpdateManyMutationInput, MergeQueueUncheckedUpdateManyInput>
    /**
     * Filter which MergeQueues to update
     */
    where?: MergeQueueWhereInput
  }

  /**
   * MergeQueue upsert
   */
  export type MergeQueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MergeQueue
     */
    select?: MergeQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MergeQueueInclude<ExtArgs> | null
    /**
     * The filter to search for the MergeQueue to update in case it exists.
     */
    where: MergeQueueWhereUniqueInput
    /**
     * In case the MergeQueue found by the `where` argument doesn't exist, create a new MergeQueue with this data.
     */
    create: XOR<MergeQueueCreateInput, MergeQueueUncheckedCreateInput>
    /**
     * In case the MergeQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MergeQueueUpdateInput, MergeQueueUncheckedUpdateInput>
  }

  /**
   * MergeQueue delete
   */
  export type MergeQueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MergeQueue
     */
    select?: MergeQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MergeQueueInclude<ExtArgs> | null
    /**
     * Filter which MergeQueue to delete.
     */
    where: MergeQueueWhereUniqueInput
  }

  /**
   * MergeQueue deleteMany
   */
  export type MergeQueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MergeQueues to delete
     */
    where?: MergeQueueWhereInput
  }

  /**
   * MergeQueue.reviewedBy
   */
  export type MergeQueue$reviewedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * MergeQueue without action
   */
  export type MergeQueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MergeQueue
     */
    select?: MergeQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MergeQueueInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    role: 'role',
    isActive: 'isActive',
    lastLoginAt: 'lastLoginAt',
    emailVerifiedAt: 'emailVerifiedAt',
    twoFactorSecret: 'twoFactorSecret',
    twoFactorEnabled: 'twoFactorEnabled',
    avatarUrl: 'avatarUrl',
    timezone: 'timezone',
    preferences: 'preferences',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    updatedById: 'updatedById'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    companyName: 'companyName',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    mobile: 'mobile',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    county: 'county',
    postcode: 'postcode',
    country: 'country',
    clientType: 'clientType',
    leadSource: 'leadSource',
    referralSource: 'referralSource',
    portalKey: 'portalKey',
    portalLastAccessAt: 'portalLastAccessAt',
    marketingConsent: 'marketingConsent',
    marketingConsentDate: 'marketingConsentDate',
    emailConsent: 'emailConsent',
    smsConsent: 'smsConsent',
    callRecordingConsent: 'callRecordingConsent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    updatedById: 'updatedById',
    ownerId: 'ownerId'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    mobile: 'mobile',
    jobTitle: 'jobTitle',
    isPrimary: 'isPrimary',
    clientId: 'clientId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    updatedById: 'updatedById'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const LeadScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    estimatedValue: 'estimatedValue',
    probability: 'probability',
    expectedCloseDate: 'expectedCloseDate',
    source: 'source',
    campaign: 'campaign',
    medium: 'medium',
    firstResponseAt: 'firstResponseAt',
    responseTime: 'responseTime',
    clientId: 'clientId',
    ownerId: 'ownerId',
    dealId: 'dealId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    updatedById: 'updatedById'
  };

  export type LeadScalarFieldEnum = (typeof LeadScalarFieldEnum)[keyof typeof LeadScalarFieldEnum]


  export const DealScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    value: 'value',
    probability: 'probability',
    expectedCloseDate: 'expectedCloseDate',
    actualCloseDate: 'actualCloseDate',
    stageId: 'stageId',
    clientId: 'clientId',
    ownerId: 'ownerId',
    jobId: 'jobId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    updatedById: 'updatedById'
  };

  export type DealScalarFieldEnum = (typeof DealScalarFieldEnum)[keyof typeof DealScalarFieldEnum]


  export const PipelineStageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    order: 'order',
    probability: 'probability',
    isClosedWon: 'isClosedWon',
    isClosedLost: 'isClosedLost',
    autoTasks: 'autoTasks',
    autoEmails: 'autoEmails',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PipelineStageScalarFieldEnum = (typeof PipelineStageScalarFieldEnum)[keyof typeof PipelineStageScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    description: 'description',
    direction: 'direction',
    duration: 'duration',
    outcome: 'outcome',
    userId: 'userId',
    clientId: 'clientId',
    contactId: 'contactId',
    leadId: 'leadId',
    dealId: 'dealId',
    emailMessageId: 'emailMessageId',
    callRecordingUrl: 'callRecordingUrl',
    metadata: 'metadata',
    createdAt: 'createdAt',
    scheduledAt: 'scheduledAt',
    completedAt: 'completedAt'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    dueDate: 'dueDate',
    completedAt: 'completedAt',
    assigneeId: 'assigneeId',
    createdById: 'createdById',
    clientId: 'clientId',
    leadId: 'leadId',
    dealId: 'dealId',
    jobId: 'jobId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    startTime: 'startTime',
    endTime: 'endTime',
    location: 'location',
    meetingUrl: 'meetingUrl',
    status: 'status',
    userId: 'userId',
    clientId: 'clientId',
    jobId: 'jobId',
    outlookEventId: 'outlookEventId',
    calendarSynced: 'calendarSynced',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    length: 'length',
    width: 'width',
    height: 'height',
    currentCondition: 'currentCondition',
    accessNotes: 'accessNotes',
    clientId: 'clientId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const JobScalarFieldEnum: {
    id: 'id',
    jobNumber: 'jobNumber',
    title: 'title',
    description: 'description',
    status: 'status',
    quotedDate: 'quotedDate',
    surveyDate: 'surveyDate',
    designDate: 'designDate',
    startDate: 'startDate',
    expectedEndDate: 'expectedEndDate',
    actualEndDate: 'actualEndDate',
    quotedValue: 'quotedValue',
    finalValue: 'finalValue',
    depositAmount: 'depositAmount',
    depositPaid: 'depositPaid',
    designFeePaid: 'designFeePaid',
    balancePaid: 'balancePaid',
    clientId: 'clientId',
    roomId: 'roomId',
    dealId: 'dealId',
    installerCompanyId: 'installerCompanyId',
    designerId: 'designerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JobScalarFieldEnum = (typeof JobScalarFieldEnum)[keyof typeof JobScalarFieldEnum]


  export const JobDayLogScalarFieldEnum: {
    id: 'id',
    date: 'date',
    userId: 'userId',
    jobId: 'jobId',
    startTime: 'startTime',
    endTime: 'endTime',
    lunchStart: 'lunchStart',
    lunchEnd: 'lunchEnd',
    checkInLatitude: 'checkInLatitude',
    checkInLongitude: 'checkInLongitude',
    checkInAddress: 'checkInAddress',
    workCompleted: 'workCompleted',
    materialsUsed: 'materialsUsed',
    issuesEncountered: 'issuesEncountered',
    startFormData: 'startFormData',
    dailyFormData: 'dailyFormData',
    endFormData: 'endFormData',
    photos: 'photos',
    isCompliant: 'isCompliant',
    complianceNotes: 'complianceNotes',
    syncStatus: 'syncStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JobDayLogScalarFieldEnum = (typeof JobDayLogScalarFieldEnum)[keyof typeof JobDayLogScalarFieldEnum]


  export const InstallerCompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contactEmail: 'contactEmail',
    contactPhone: 'contactPhone',
    address: 'address',
    insuranceExpiry: 'insuranceExpiry',
    dbsExpiry: 'dbsExpiry',
    contractSigned: 'contractSigned',
    contractSignedAt: 'contractSignedAt',
    isActive: 'isActive',
    isSuspended: 'isSuspended',
    suspensionReason: 'suspensionReason',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InstallerCompanyScalarFieldEnum = (typeof InstallerCompanyScalarFieldEnum)[keyof typeof InstallerCompanyScalarFieldEnum]


  export const InstallerTeamMemberScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    dbsExpiry: 'dbsExpiry',
    isActive: 'isActive',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InstallerTeamMemberScalarFieldEnum = (typeof InstallerTeamMemberScalarFieldEnum)[keyof typeof InstallerTeamMemberScalarFieldEnum]


  export const DesignVersionScalarFieldEnum: {
    id: 'id',
    version: 'version',
    title: 'title',
    description: 'description',
    status: 'status',
    renderUrls: 'renderUrls',
    planUrls: 'planUrls',
    specSheetUrl: 'specSheetUrl',
    isClientVisible: 'isClientVisible',
    clientViewedAt: 'clientViewedAt',
    clientApprovedAt: 'clientApprovedAt',
    clientFeedback: 'clientFeedback',
    jobId: 'jobId',
    designerId: 'designerId',
    isFinal: 'isFinal',
    lockedAt: 'lockedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DesignVersionScalarFieldEnum = (typeof DesignVersionScalarFieldEnum)[keyof typeof DesignVersionScalarFieldEnum]


  export const DesignClashTicketScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    photoUrls: 'photoUrls',
    resolution: 'resolution',
    resolvedAt: 'resolvedAt',
    designVersionId: 'designVersionId',
    reportedById: 'reportedById',
    assignedToId: 'assignedToId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DesignClashTicketScalarFieldEnum = (typeof DesignClashTicketScalarFieldEnum)[keyof typeof DesignClashTicketScalarFieldEnum]


  export const MoodboardScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    clientId: 'clientId',
    jobId: 'jobId',
    isClientVisible: 'isClientVisible',
    clientLastViewedAt: 'clientLastViewedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MoodboardScalarFieldEnum = (typeof MoodboardScalarFieldEnum)[keyof typeof MoodboardScalarFieldEnum]


  export const MoodboardItemScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    imageUrl: 'imageUrl',
    sourceUrl: 'sourceUrl',
    category: 'category',
    order: 'order',
    moodboardId: 'moodboardId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MoodboardItemScalarFieldEnum = (typeof MoodboardItemScalarFieldEnum)[keyof typeof MoodboardItemScalarFieldEnum]


  export const MoodboardCommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    xPosition: 'xPosition',
    yPosition: 'yPosition',
    authorId: 'authorId',
    authorName: 'authorName',
    itemId: 'itemId',
    createdAt: 'createdAt'
  };

  export type MoodboardCommentScalarFieldEnum = (typeof MoodboardCommentScalarFieldEnum)[keyof typeof MoodboardCommentScalarFieldEnum]


  export const ParsedSpecItemScalarFieldEnum: {
    id: 'id',
    originalText: 'originalText',
    parsedCategory: 'parsedCategory',
    parsedBrand: 'parsedBrand',
    parsedModel: 'parsedModel',
    parsedDescription: 'parsedDescription',
    parsedQuantity: 'parsedQuantity',
    parsedPrice: 'parsedPrice',
    status: 'status',
    notes: 'notes',
    substitution: 'substitution',
    actualPrice: 'actualPrice',
    parseConfidence: 'parseConfidence',
    requiresReview: 'requiresReview',
    jobId: 'jobId',
    sourceDocumentId: 'sourceDocumentId',
    sourcePage: 'sourcePage',
    sourceLineNumber: 'sourceLineNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ParsedSpecItemScalarFieldEnum = (typeof ParsedSpecItemScalarFieldEnum)[keyof typeof ParsedSpecItemScalarFieldEnum]


  export const SnagScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    category: 'category',
    severity: 'severity',
    status: 'status',
    photoUrls: 'photoUrls',
    isClientVisible: 'isClientVisible',
    clientNotified: 'clientNotified',
    resolution: 'resolution',
    resolvedAt: 'resolvedAt',
    jobId: 'jobId',
    reportedById: 'reportedById',
    assignedToId: 'assignedToId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SnagScalarFieldEnum = (typeof SnagScalarFieldEnum)[keyof typeof SnagScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    originalFilename: 'originalFilename',
    mimeType: 'mimeType',
    fileSize: 'fileSize',
    storageUrl: 'storageUrl',
    category: 'category',
    description: 'description',
    isPublic: 'isPublic',
    virusScanStatus: 'virusScanStatus',
    virusScanResult: 'virusScanResult',
    clientId: 'clientId',
    dealId: 'dealId',
    jobId: 'jobId',
    createdAt: 'createdAt',
    uploadedById: 'uploadedById'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const FormTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    schema: 'schema',
    isActive: 'isActive',
    version: 'version',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FormTemplateScalarFieldEnum = (typeof FormTemplateScalarFieldEnum)[keyof typeof FormTemplateScalarFieldEnum]


  export const FormSubmissionScalarFieldEnum: {
    id: 'id',
    data: 'data',
    submissionSource: 'submissionSource',
    templateId: 'templateId',
    submittedById: 'submittedById',
    clientId: 'clientId',
    jobId: 'jobId',
    submittedAt: 'submittedAt'
  };

  export type FormSubmissionScalarFieldEnum = (typeof FormSubmissionScalarFieldEnum)[keyof typeof FormSubmissionScalarFieldEnum]


  export const HandoverPackScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    completionCertUrl: 'completionCertUrl',
    warrantyDocsUrls: 'warrantyDocsUrls',
    finalPhotosUrls: 'finalPhotosUrls',
    guidesIncluded: 'guidesIncluded',
    isGenerated: 'isGenerated',
    generatedAt: 'generatedAt',
    deliveredAt: 'deliveredAt',
    clientAccessedAt: 'clientAccessedAt',
    jobId: 'jobId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HandoverPackScalarFieldEnum = (typeof HandoverPackScalarFieldEnum)[keyof typeof HandoverPackScalarFieldEnum]


  export const GuideScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    content: 'content',
    category: 'category',
    tags: 'tags',
    isPublished: 'isPublished',
    featured: 'featured',
    metaDescription: 'metaDescription',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    publishedAt: 'publishedAt'
  };

  export type GuideScalarFieldEnum = (typeof GuideScalarFieldEnum)[keyof typeof GuideScalarFieldEnum]


  export const EmailJourneyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    triggerEvent: 'triggerEvent',
    triggerConditions: 'triggerConditions',
    totalSent: 'totalSent',
    totalOpened: 'totalOpened',
    totalClicked: 'totalClicked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailJourneyScalarFieldEnum = (typeof EmailJourneyScalarFieldEnum)[keyof typeof EmailJourneyScalarFieldEnum]


  export const EmailSequenceStepScalarFieldEnum: {
    id: 'id',
    stepNumber: 'stepNumber',
    templateId: 'templateId',
    delayDays: 'delayDays',
    delayHours: 'delayHours',
    sendConditions: 'sendConditions',
    journeyId: 'journeyId'
  };

  export type EmailSequenceStepScalarFieldEnum = (typeof EmailSequenceStepScalarFieldEnum)[keyof typeof EmailSequenceStepScalarFieldEnum]


  export const WebhookScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    events: 'events',
    secret: 'secret',
    isActive: 'isActive',
    totalDeliveries: 'totalDeliveries',
    lastDeliveryAt: 'lastDeliveryAt',
    lastSuccessAt: 'lastSuccessAt',
    lastFailureAt: 'lastFailureAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WebhookScalarFieldEnum = (typeof WebhookScalarFieldEnum)[keyof typeof WebhookScalarFieldEnum]


  export const WebhookDeliveryScalarFieldEnum: {
    id: 'id',
    eventType: 'eventType',
    payload: 'payload',
    httpStatus: 'httpStatus',
    responseBody: 'responseBody',
    errorMessage: 'errorMessage',
    deliveryAttempts: 'deliveryAttempts',
    deliveredAt: 'deliveredAt',
    webhookId: 'webhookId',
    createdAt: 'createdAt'
  };

  export type WebhookDeliveryScalarFieldEnum = (typeof WebhookDeliveryScalarFieldEnum)[keyof typeof WebhookDeliveryScalarFieldEnum]


  export const EventLogScalarFieldEnum: {
    id: 'id',
    eventType: 'eventType',
    entityType: 'entityType',
    entityId: 'entityId',
    changes: 'changes',
    metadata: 'metadata',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId',
    occurredAt: 'occurredAt'
  };

  export type EventLogScalarFieldEnum = (typeof EventLogScalarFieldEnum)[keyof typeof EventLogScalarFieldEnum]


  export const IntegrationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    config: 'config',
    isActive: 'isActive',
    lastSyncAt: 'lastSyncAt',
    nextSyncAt: 'nextSyncAt',
    syncErrors: 'syncErrors',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntegrationScalarFieldEnum = (typeof IntegrationScalarFieldEnum)[keyof typeof IntegrationScalarFieldEnum]


  export const MergeQueueScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    primaryEntityId: 'primaryEntityId',
    duplicateEntityId: 'duplicateEntityId',
    status: 'status',
    mergeRules: 'mergeRules',
    reviewedById: 'reviewedById',
    reviewedAt: 'reviewedAt',
    mergedAt: 'mergedAt',
    createdAt: 'createdAt'
  };

  export type MergeQueueScalarFieldEnum = (typeof MergeQueueScalarFieldEnum)[keyof typeof MergeQueueScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'ClientType'
   */
  export type EnumClientTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientType'>
    


  /**
   * Reference to a field of type 'ClientType[]'
   */
  export type ListEnumClientTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientType[]'>
    


  /**
   * Reference to a field of type 'LeadStatus'
   */
  export type EnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus'>
    


  /**
   * Reference to a field of type 'LeadStatus[]'
   */
  export type ListEnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ActivityType'
   */
  export type EnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType'>
    


  /**
   * Reference to a field of type 'ActivityType[]'
   */
  export type ListEnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType[]'>
    


  /**
   * Reference to a field of type 'Direction'
   */
  export type EnumDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Direction'>
    


  /**
   * Reference to a field of type 'Direction[]'
   */
  export type ListEnumDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Direction[]'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'TaskStatus[]'
   */
  export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus[]'>
    


  /**
   * Reference to a field of type 'AppointmentStatus'
   */
  export type EnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus'>
    


  /**
   * Reference to a field of type 'AppointmentStatus[]'
   */
  export type ListEnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus[]'>
    


  /**
   * Reference to a field of type 'RoomType'
   */
  export type EnumRoomTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomType'>
    


  /**
   * Reference to a field of type 'RoomType[]'
   */
  export type ListEnumRoomTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomType[]'>
    


  /**
   * Reference to a field of type 'JobStatus'
   */
  export type EnumJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobStatus'>
    


  /**
   * Reference to a field of type 'JobStatus[]'
   */
  export type ListEnumJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobStatus[]'>
    


  /**
   * Reference to a field of type 'SyncStatus'
   */
  export type EnumSyncStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyncStatus'>
    


  /**
   * Reference to a field of type 'SyncStatus[]'
   */
  export type ListEnumSyncStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyncStatus[]'>
    


  /**
   * Reference to a field of type 'DesignStatus'
   */
  export type EnumDesignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DesignStatus'>
    


  /**
   * Reference to a field of type 'DesignStatus[]'
   */
  export type ListEnumDesignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DesignStatus[]'>
    


  /**
   * Reference to a field of type 'ClashStatus'
   */
  export type EnumClashStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClashStatus'>
    


  /**
   * Reference to a field of type 'ClashStatus[]'
   */
  export type ListEnumClashStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClashStatus[]'>
    


  /**
   * Reference to a field of type 'MoodboardStatus'
   */
  export type EnumMoodboardStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MoodboardStatus'>
    


  /**
   * Reference to a field of type 'MoodboardStatus[]'
   */
  export type ListEnumMoodboardStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MoodboardStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'SpecItemStatus'
   */
  export type EnumSpecItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SpecItemStatus'>
    


  /**
   * Reference to a field of type 'SpecItemStatus[]'
   */
  export type ListEnumSpecItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SpecItemStatus[]'>
    


  /**
   * Reference to a field of type 'SnagCategory'
   */
  export type EnumSnagCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SnagCategory'>
    


  /**
   * Reference to a field of type 'SnagCategory[]'
   */
  export type ListEnumSnagCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SnagCategory[]'>
    


  /**
   * Reference to a field of type 'SnagStatus'
   */
  export type EnumSnagStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SnagStatus'>
    


  /**
   * Reference to a field of type 'SnagStatus[]'
   */
  export type ListEnumSnagStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SnagStatus[]'>
    


  /**
   * Reference to a field of type 'DocumentCategory'
   */
  export type EnumDocumentCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentCategory'>
    


  /**
   * Reference to a field of type 'DocumentCategory[]'
   */
  export type ListEnumDocumentCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentCategory[]'>
    


  /**
   * Reference to a field of type 'VirusScanStatus'
   */
  export type EnumVirusScanStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VirusScanStatus'>
    


  /**
   * Reference to a field of type 'VirusScanStatus[]'
   */
  export type ListEnumVirusScanStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VirusScanStatus[]'>
    


  /**
   * Reference to a field of type 'FormCategory'
   */
  export type EnumFormCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FormCategory'>
    


  /**
   * Reference to a field of type 'FormCategory[]'
   */
  export type ListEnumFormCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FormCategory[]'>
    


  /**
   * Reference to a field of type 'SubmissionSource'
   */
  export type EnumSubmissionSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubmissionSource'>
    


  /**
   * Reference to a field of type 'SubmissionSource[]'
   */
  export type ListEnumSubmissionSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubmissionSource[]'>
    


  /**
   * Reference to a field of type 'GuideCategory'
   */
  export type EnumGuideCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GuideCategory'>
    


  /**
   * Reference to a field of type 'GuideCategory[]'
   */
  export type ListEnumGuideCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GuideCategory[]'>
    


  /**
   * Reference to a field of type 'EmailTrigger'
   */
  export type EnumEmailTriggerFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailTrigger'>
    


  /**
   * Reference to a field of type 'EmailTrigger[]'
   */
  export type ListEnumEmailTriggerFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailTrigger[]'>
    


  /**
   * Reference to a field of type 'WebhookEvent[]'
   */
  export type ListEnumWebhookEventFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WebhookEvent[]'>
    


  /**
   * Reference to a field of type 'WebhookEvent'
   */
  export type EnumWebhookEventFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WebhookEvent'>
    


  /**
   * Reference to a field of type 'IntegrationType'
   */
  export type EnumIntegrationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IntegrationType'>
    


  /**
   * Reference to a field of type 'IntegrationType[]'
   */
  export type ListEnumIntegrationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IntegrationType[]'>
    


  /**
   * Reference to a field of type 'MergeStatus'
   */
  export type EnumMergeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MergeStatus'>
    


  /**
   * Reference to a field of type 'MergeStatus[]'
   */
  export type ListEnumMergeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MergeStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    avatarUrl?: StringNullableFilter<"User"> | string | null
    timezone?: StringFilter<"User"> | string
    preferences?: JsonFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdById?: StringNullableFilter<"User"> | string | null
    updatedById?: StringNullableFilter<"User"> | string | null
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    createdUsers?: UserListRelationFilter
    updatedUsers?: UserListRelationFilter
    ownedClients?: ClientListRelationFilter
    ownedLeads?: LeadListRelationFilter
    ownedDeals?: DealListRelationFilter
    assignedTasks?: TaskListRelationFilter
    createdTasks?: TaskListRelationFilter
    activities?: ActivityListRelationFilter
    appointments?: AppointmentListRelationFilter
    jobDayLogs?: JobDayLogListRelationFilter
    designVersions?: DesignVersionListRelationFilter
    createdClients?: ClientListRelationFilter
    updatedClients?: ClientListRelationFilter
    designerJobs?: JobListRelationFilter
    installerCompanies?: InstallerCompanyListRelationFilter
    clashReports?: DesignClashTicketListRelationFilter
    clashAssignments?: DesignClashTicketListRelationFilter
    moodboardComments?: MoodboardCommentListRelationFilter
    snagReports?: SnagListRelationFilter
    snagAssignments?: SnagListRelationFilter
    uploadedDocuments?: DocumentListRelationFilter
    formSubmissions?: FormSubmissionListRelationFilter
    eventLogs?: EventLogListRelationFilter
    mergeReviews?: MergeQueueListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    timezone?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
    createdUsers?: UserOrderByRelationAggregateInput
    updatedUsers?: UserOrderByRelationAggregateInput
    ownedClients?: ClientOrderByRelationAggregateInput
    ownedLeads?: LeadOrderByRelationAggregateInput
    ownedDeals?: DealOrderByRelationAggregateInput
    assignedTasks?: TaskOrderByRelationAggregateInput
    createdTasks?: TaskOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    jobDayLogs?: JobDayLogOrderByRelationAggregateInput
    designVersions?: DesignVersionOrderByRelationAggregateInput
    createdClients?: ClientOrderByRelationAggregateInput
    updatedClients?: ClientOrderByRelationAggregateInput
    designerJobs?: JobOrderByRelationAggregateInput
    installerCompanies?: InstallerCompanyOrderByRelationAggregateInput
    clashReports?: DesignClashTicketOrderByRelationAggregateInput
    clashAssignments?: DesignClashTicketOrderByRelationAggregateInput
    moodboardComments?: MoodboardCommentOrderByRelationAggregateInput
    snagReports?: SnagOrderByRelationAggregateInput
    snagAssignments?: SnagOrderByRelationAggregateInput
    uploadedDocuments?: DocumentOrderByRelationAggregateInput
    formSubmissions?: FormSubmissionOrderByRelationAggregateInput
    eventLogs?: EventLogOrderByRelationAggregateInput
    mergeReviews?: MergeQueueOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    avatarUrl?: StringNullableFilter<"User"> | string | null
    timezone?: StringFilter<"User"> | string
    preferences?: JsonFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdById?: StringNullableFilter<"User"> | string | null
    updatedById?: StringNullableFilter<"User"> | string | null
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    createdUsers?: UserListRelationFilter
    updatedUsers?: UserListRelationFilter
    ownedClients?: ClientListRelationFilter
    ownedLeads?: LeadListRelationFilter
    ownedDeals?: DealListRelationFilter
    assignedTasks?: TaskListRelationFilter
    createdTasks?: TaskListRelationFilter
    activities?: ActivityListRelationFilter
    appointments?: AppointmentListRelationFilter
    jobDayLogs?: JobDayLogListRelationFilter
    designVersions?: DesignVersionListRelationFilter
    createdClients?: ClientListRelationFilter
    updatedClients?: ClientListRelationFilter
    designerJobs?: JobListRelationFilter
    installerCompanies?: InstallerCompanyListRelationFilter
    clashReports?: DesignClashTicketListRelationFilter
    clashAssignments?: DesignClashTicketListRelationFilter
    moodboardComments?: MoodboardCommentListRelationFilter
    snagReports?: SnagListRelationFilter
    snagAssignments?: SnagListRelationFilter
    uploadedDocuments?: DocumentListRelationFilter
    formSubmissions?: FormSubmissionListRelationFilter
    eventLogs?: EventLogListRelationFilter
    mergeReviews?: MergeQueueListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    timezone?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    emailVerifiedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    twoFactorSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    twoFactorEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    timezone?: StringWithAggregatesFilter<"User"> | string
    preferences?: JsonWithAggregatesFilter<"User">
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"User"> | string | null
    updatedById?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    companyName?: StringNullableFilter<"Client"> | string | null
    firstName?: StringFilter<"Client"> | string
    lastName?: StringFilter<"Client"> | string
    email?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    mobile?: StringNullableFilter<"Client"> | string | null
    addressLine1?: StringNullableFilter<"Client"> | string | null
    addressLine2?: StringNullableFilter<"Client"> | string | null
    city?: StringNullableFilter<"Client"> | string | null
    county?: StringNullableFilter<"Client"> | string | null
    postcode?: StringNullableFilter<"Client"> | string | null
    country?: StringFilter<"Client"> | string
    clientType?: EnumClientTypeFilter<"Client"> | $Enums.ClientType
    leadSource?: StringNullableFilter<"Client"> | string | null
    referralSource?: StringNullableFilter<"Client"> | string | null
    portalKey?: StringNullableFilter<"Client"> | string | null
    portalLastAccessAt?: DateTimeNullableFilter<"Client"> | Date | string | null
    marketingConsent?: BoolFilter<"Client"> | boolean
    marketingConsentDate?: DateTimeNullableFilter<"Client"> | Date | string | null
    emailConsent?: BoolFilter<"Client"> | boolean
    smsConsent?: BoolFilter<"Client"> | boolean
    callRecordingConsent?: BoolFilter<"Client"> | boolean
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    createdById?: StringNullableFilter<"Client"> | string | null
    updatedById?: StringNullableFilter<"Client"> | string | null
    ownerId?: StringFilter<"Client"> | string
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    owner?: XOR<UserRelationFilter, UserWhereInput>
    contacts?: ContactListRelationFilter
    leads?: LeadListRelationFilter
    deals?: DealListRelationFilter
    rooms?: RoomListRelationFilter
    jobs?: JobListRelationFilter
    activities?: ActivityListRelationFilter
    documents?: DocumentListRelationFilter
    appointments?: AppointmentListRelationFilter
    moodboards?: MoodboardListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    companyName?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    county?: SortOrderInput | SortOrder
    postcode?: SortOrderInput | SortOrder
    country?: SortOrder
    clientType?: SortOrder
    leadSource?: SortOrderInput | SortOrder
    referralSource?: SortOrderInput | SortOrder
    portalKey?: SortOrderInput | SortOrder
    portalLastAccessAt?: SortOrderInput | SortOrder
    marketingConsent?: SortOrder
    marketingConsentDate?: SortOrderInput | SortOrder
    emailConsent?: SortOrder
    smsConsent?: SortOrder
    callRecordingConsent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    contacts?: ContactOrderByRelationAggregateInput
    leads?: LeadOrderByRelationAggregateInput
    deals?: DealOrderByRelationAggregateInput
    rooms?: RoomOrderByRelationAggregateInput
    jobs?: JobOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    moodboards?: MoodboardOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    portalKey?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    companyName?: StringNullableFilter<"Client"> | string | null
    firstName?: StringFilter<"Client"> | string
    lastName?: StringFilter<"Client"> | string
    email?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    mobile?: StringNullableFilter<"Client"> | string | null
    addressLine1?: StringNullableFilter<"Client"> | string | null
    addressLine2?: StringNullableFilter<"Client"> | string | null
    city?: StringNullableFilter<"Client"> | string | null
    county?: StringNullableFilter<"Client"> | string | null
    postcode?: StringNullableFilter<"Client"> | string | null
    country?: StringFilter<"Client"> | string
    clientType?: EnumClientTypeFilter<"Client"> | $Enums.ClientType
    leadSource?: StringNullableFilter<"Client"> | string | null
    referralSource?: StringNullableFilter<"Client"> | string | null
    portalLastAccessAt?: DateTimeNullableFilter<"Client"> | Date | string | null
    marketingConsent?: BoolFilter<"Client"> | boolean
    marketingConsentDate?: DateTimeNullableFilter<"Client"> | Date | string | null
    emailConsent?: BoolFilter<"Client"> | boolean
    smsConsent?: BoolFilter<"Client"> | boolean
    callRecordingConsent?: BoolFilter<"Client"> | boolean
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    createdById?: StringNullableFilter<"Client"> | string | null
    updatedById?: StringNullableFilter<"Client"> | string | null
    ownerId?: StringFilter<"Client"> | string
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    owner?: XOR<UserRelationFilter, UserWhereInput>
    contacts?: ContactListRelationFilter
    leads?: LeadListRelationFilter
    deals?: DealListRelationFilter
    rooms?: RoomListRelationFilter
    jobs?: JobListRelationFilter
    activities?: ActivityListRelationFilter
    documents?: DocumentListRelationFilter
    appointments?: AppointmentListRelationFilter
    moodboards?: MoodboardListRelationFilter
  }, "id" | "portalKey">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    companyName?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    county?: SortOrderInput | SortOrder
    postcode?: SortOrderInput | SortOrder
    country?: SortOrder
    clientType?: SortOrder
    leadSource?: SortOrderInput | SortOrder
    referralSource?: SortOrderInput | SortOrder
    portalKey?: SortOrderInput | SortOrder
    portalLastAccessAt?: SortOrderInput | SortOrder
    marketingConsent?: SortOrder
    marketingConsentDate?: SortOrderInput | SortOrder
    emailConsent?: SortOrder
    smsConsent?: SortOrder
    callRecordingConsent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    companyName?: StringNullableWithAggregatesFilter<"Client"> | string | null
    firstName?: StringWithAggregatesFilter<"Client"> | string
    lastName?: StringWithAggregatesFilter<"Client"> | string
    email?: StringNullableWithAggregatesFilter<"Client"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Client"> | string | null
    mobile?: StringNullableWithAggregatesFilter<"Client"> | string | null
    addressLine1?: StringNullableWithAggregatesFilter<"Client"> | string | null
    addressLine2?: StringNullableWithAggregatesFilter<"Client"> | string | null
    city?: StringNullableWithAggregatesFilter<"Client"> | string | null
    county?: StringNullableWithAggregatesFilter<"Client"> | string | null
    postcode?: StringNullableWithAggregatesFilter<"Client"> | string | null
    country?: StringWithAggregatesFilter<"Client"> | string
    clientType?: EnumClientTypeWithAggregatesFilter<"Client"> | $Enums.ClientType
    leadSource?: StringNullableWithAggregatesFilter<"Client"> | string | null
    referralSource?: StringNullableWithAggregatesFilter<"Client"> | string | null
    portalKey?: StringNullableWithAggregatesFilter<"Client"> | string | null
    portalLastAccessAt?: DateTimeNullableWithAggregatesFilter<"Client"> | Date | string | null
    marketingConsent?: BoolWithAggregatesFilter<"Client"> | boolean
    marketingConsentDate?: DateTimeNullableWithAggregatesFilter<"Client"> | Date | string | null
    emailConsent?: BoolWithAggregatesFilter<"Client"> | boolean
    smsConsent?: BoolWithAggregatesFilter<"Client"> | boolean
    callRecordingConsent?: BoolWithAggregatesFilter<"Client"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"Client"> | string | null
    updatedById?: StringNullableWithAggregatesFilter<"Client"> | string | null
    ownerId?: StringWithAggregatesFilter<"Client"> | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    firstName?: StringFilter<"Contact"> | string
    lastName?: StringFilter<"Contact"> | string
    email?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    mobile?: StringNullableFilter<"Contact"> | string | null
    jobTitle?: StringNullableFilter<"Contact"> | string | null
    isPrimary?: BoolFilter<"Contact"> | boolean
    clientId?: StringFilter<"Contact"> | string
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    createdById?: StringNullableFilter<"Contact"> | string | null
    updatedById?: StringNullableFilter<"Contact"> | string | null
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    activities?: ActivityListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    jobTitle?: SortOrderInput | SortOrder
    isPrimary?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    client?: ClientOrderByWithRelationInput
    activities?: ActivityOrderByRelationAggregateInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    firstName?: StringFilter<"Contact"> | string
    lastName?: StringFilter<"Contact"> | string
    email?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    mobile?: StringNullableFilter<"Contact"> | string | null
    jobTitle?: StringNullableFilter<"Contact"> | string | null
    isPrimary?: BoolFilter<"Contact"> | boolean
    clientId?: StringFilter<"Contact"> | string
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    createdById?: StringNullableFilter<"Contact"> | string | null
    updatedById?: StringNullableFilter<"Contact"> | string | null
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    activities?: ActivityListRelationFilter
  }, "id">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    jobTitle?: SortOrderInput | SortOrder
    isPrimary?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    firstName?: StringWithAggregatesFilter<"Contact"> | string
    lastName?: StringWithAggregatesFilter<"Contact"> | string
    email?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    mobile?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    jobTitle?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    isPrimary?: BoolWithAggregatesFilter<"Contact"> | boolean
    clientId?: StringWithAggregatesFilter<"Contact"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    updatedById?: StringNullableWithAggregatesFilter<"Contact"> | string | null
  }

  export type LeadWhereInput = {
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    id?: StringFilter<"Lead"> | string
    title?: StringFilter<"Lead"> | string
    description?: StringNullableFilter<"Lead"> | string | null
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    priority?: EnumPriorityFilter<"Lead"> | $Enums.Priority
    estimatedValue?: DecimalNullableFilter<"Lead"> | Decimal | DecimalJsLike | number | string | null
    probability?: IntFilter<"Lead"> | number
    expectedCloseDate?: DateTimeNullableFilter<"Lead"> | Date | string | null
    source?: StringNullableFilter<"Lead"> | string | null
    campaign?: StringNullableFilter<"Lead"> | string | null
    medium?: StringNullableFilter<"Lead"> | string | null
    firstResponseAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    responseTime?: IntNullableFilter<"Lead"> | number | null
    clientId?: StringFilter<"Lead"> | string
    ownerId?: StringFilter<"Lead"> | string
    dealId?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    createdById?: StringNullableFilter<"Lead"> | string | null
    updatedById?: StringNullableFilter<"Lead"> | string | null
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    owner?: XOR<UserRelationFilter, UserWhereInput>
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
    activities?: ActivityListRelationFilter
    tasks?: TaskListRelationFilter
  }

  export type LeadOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    estimatedValue?: SortOrderInput | SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    campaign?: SortOrderInput | SortOrder
    medium?: SortOrderInput | SortOrder
    firstResponseAt?: SortOrderInput | SortOrder
    responseTime?: SortOrderInput | SortOrder
    clientId?: SortOrder
    ownerId?: SortOrder
    dealId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    client?: ClientOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
    activities?: ActivityOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type LeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    dealId?: string
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    title?: StringFilter<"Lead"> | string
    description?: StringNullableFilter<"Lead"> | string | null
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    priority?: EnumPriorityFilter<"Lead"> | $Enums.Priority
    estimatedValue?: DecimalNullableFilter<"Lead"> | Decimal | DecimalJsLike | number | string | null
    probability?: IntFilter<"Lead"> | number
    expectedCloseDate?: DateTimeNullableFilter<"Lead"> | Date | string | null
    source?: StringNullableFilter<"Lead"> | string | null
    campaign?: StringNullableFilter<"Lead"> | string | null
    medium?: StringNullableFilter<"Lead"> | string | null
    firstResponseAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    responseTime?: IntNullableFilter<"Lead"> | number | null
    clientId?: StringFilter<"Lead"> | string
    ownerId?: StringFilter<"Lead"> | string
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    createdById?: StringNullableFilter<"Lead"> | string | null
    updatedById?: StringNullableFilter<"Lead"> | string | null
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    owner?: XOR<UserRelationFilter, UserWhereInput>
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
    activities?: ActivityListRelationFilter
    tasks?: TaskListRelationFilter
  }, "id" | "dealId">

  export type LeadOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    estimatedValue?: SortOrderInput | SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    campaign?: SortOrderInput | SortOrder
    medium?: SortOrderInput | SortOrder
    firstResponseAt?: SortOrderInput | SortOrder
    responseTime?: SortOrderInput | SortOrder
    clientId?: SortOrder
    ownerId?: SortOrder
    dealId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    _count?: LeadCountOrderByAggregateInput
    _avg?: LeadAvgOrderByAggregateInput
    _max?: LeadMaxOrderByAggregateInput
    _min?: LeadMinOrderByAggregateInput
    _sum?: LeadSumOrderByAggregateInput
  }

  export type LeadScalarWhereWithAggregatesInput = {
    AND?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    OR?: LeadScalarWhereWithAggregatesInput[]
    NOT?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lead"> | string
    title?: StringWithAggregatesFilter<"Lead"> | string
    description?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    status?: EnumLeadStatusWithAggregatesFilter<"Lead"> | $Enums.LeadStatus
    priority?: EnumPriorityWithAggregatesFilter<"Lead"> | $Enums.Priority
    estimatedValue?: DecimalNullableWithAggregatesFilter<"Lead"> | Decimal | DecimalJsLike | number | string | null
    probability?: IntWithAggregatesFilter<"Lead"> | number
    expectedCloseDate?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    source?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    campaign?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    medium?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    firstResponseAt?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    responseTime?: IntNullableWithAggregatesFilter<"Lead"> | number | null
    clientId?: StringWithAggregatesFilter<"Lead"> | string
    ownerId?: StringWithAggregatesFilter<"Lead"> | string
    dealId?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    updatedById?: StringNullableWithAggregatesFilter<"Lead"> | string | null
  }

  export type DealWhereInput = {
    AND?: DealWhereInput | DealWhereInput[]
    OR?: DealWhereInput[]
    NOT?: DealWhereInput | DealWhereInput[]
    id?: StringFilter<"Deal"> | string
    title?: StringFilter<"Deal"> | string
    description?: StringNullableFilter<"Deal"> | string | null
    value?: DecimalFilter<"Deal"> | Decimal | DecimalJsLike | number | string
    probability?: IntFilter<"Deal"> | number
    expectedCloseDate?: DateTimeNullableFilter<"Deal"> | Date | string | null
    actualCloseDate?: DateTimeNullableFilter<"Deal"> | Date | string | null
    stageId?: StringFilter<"Deal"> | string
    clientId?: StringFilter<"Deal"> | string
    ownerId?: StringFilter<"Deal"> | string
    jobId?: StringNullableFilter<"Deal"> | string | null
    createdAt?: DateTimeFilter<"Deal"> | Date | string
    updatedAt?: DateTimeFilter<"Deal"> | Date | string
    createdById?: StringNullableFilter<"Deal"> | string | null
    updatedById?: StringNullableFilter<"Deal"> | string | null
    stage?: XOR<PipelineStageRelationFilter, PipelineStageWhereInput>
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    owner?: XOR<UserRelationFilter, UserWhereInput>
    lead?: XOR<LeadNullableRelationFilter, LeadWhereInput> | null
    job?: XOR<JobNullableRelationFilter, JobWhereInput> | null
    activities?: ActivityListRelationFilter
    tasks?: TaskListRelationFilter
    documents?: DocumentListRelationFilter
  }

  export type DealOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    value?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrderInput | SortOrder
    actualCloseDate?: SortOrderInput | SortOrder
    stageId?: SortOrder
    clientId?: SortOrder
    ownerId?: SortOrder
    jobId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    stage?: PipelineStageOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    lead?: LeadOrderByWithRelationInput
    job?: JobOrderByWithRelationInput
    activities?: ActivityOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
  }

  export type DealWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jobId?: string
    AND?: DealWhereInput | DealWhereInput[]
    OR?: DealWhereInput[]
    NOT?: DealWhereInput | DealWhereInput[]
    title?: StringFilter<"Deal"> | string
    description?: StringNullableFilter<"Deal"> | string | null
    value?: DecimalFilter<"Deal"> | Decimal | DecimalJsLike | number | string
    probability?: IntFilter<"Deal"> | number
    expectedCloseDate?: DateTimeNullableFilter<"Deal"> | Date | string | null
    actualCloseDate?: DateTimeNullableFilter<"Deal"> | Date | string | null
    stageId?: StringFilter<"Deal"> | string
    clientId?: StringFilter<"Deal"> | string
    ownerId?: StringFilter<"Deal"> | string
    createdAt?: DateTimeFilter<"Deal"> | Date | string
    updatedAt?: DateTimeFilter<"Deal"> | Date | string
    createdById?: StringNullableFilter<"Deal"> | string | null
    updatedById?: StringNullableFilter<"Deal"> | string | null
    stage?: XOR<PipelineStageRelationFilter, PipelineStageWhereInput>
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    owner?: XOR<UserRelationFilter, UserWhereInput>
    lead?: XOR<LeadNullableRelationFilter, LeadWhereInput> | null
    job?: XOR<JobNullableRelationFilter, JobWhereInput> | null
    activities?: ActivityListRelationFilter
    tasks?: TaskListRelationFilter
    documents?: DocumentListRelationFilter
  }, "id" | "jobId">

  export type DealOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    value?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrderInput | SortOrder
    actualCloseDate?: SortOrderInput | SortOrder
    stageId?: SortOrder
    clientId?: SortOrder
    ownerId?: SortOrder
    jobId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    _count?: DealCountOrderByAggregateInput
    _avg?: DealAvgOrderByAggregateInput
    _max?: DealMaxOrderByAggregateInput
    _min?: DealMinOrderByAggregateInput
    _sum?: DealSumOrderByAggregateInput
  }

  export type DealScalarWhereWithAggregatesInput = {
    AND?: DealScalarWhereWithAggregatesInput | DealScalarWhereWithAggregatesInput[]
    OR?: DealScalarWhereWithAggregatesInput[]
    NOT?: DealScalarWhereWithAggregatesInput | DealScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Deal"> | string
    title?: StringWithAggregatesFilter<"Deal"> | string
    description?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    value?: DecimalWithAggregatesFilter<"Deal"> | Decimal | DecimalJsLike | number | string
    probability?: IntWithAggregatesFilter<"Deal"> | number
    expectedCloseDate?: DateTimeNullableWithAggregatesFilter<"Deal"> | Date | string | null
    actualCloseDate?: DateTimeNullableWithAggregatesFilter<"Deal"> | Date | string | null
    stageId?: StringWithAggregatesFilter<"Deal"> | string
    clientId?: StringWithAggregatesFilter<"Deal"> | string
    ownerId?: StringWithAggregatesFilter<"Deal"> | string
    jobId?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Deal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Deal"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    updatedById?: StringNullableWithAggregatesFilter<"Deal"> | string | null
  }

  export type PipelineStageWhereInput = {
    AND?: PipelineStageWhereInput | PipelineStageWhereInput[]
    OR?: PipelineStageWhereInput[]
    NOT?: PipelineStageWhereInput | PipelineStageWhereInput[]
    id?: StringFilter<"PipelineStage"> | string
    name?: StringFilter<"PipelineStage"> | string
    description?: StringNullableFilter<"PipelineStage"> | string | null
    order?: IntFilter<"PipelineStage"> | number
    probability?: IntFilter<"PipelineStage"> | number
    isClosedWon?: BoolFilter<"PipelineStage"> | boolean
    isClosedLost?: BoolFilter<"PipelineStage"> | boolean
    autoTasks?: JsonFilter<"PipelineStage">
    autoEmails?: JsonFilter<"PipelineStage">
    createdAt?: DateTimeFilter<"PipelineStage"> | Date | string
    updatedAt?: DateTimeFilter<"PipelineStage"> | Date | string
    deals?: DealListRelationFilter
  }

  export type PipelineStageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    probability?: SortOrder
    isClosedWon?: SortOrder
    isClosedLost?: SortOrder
    autoTasks?: SortOrder
    autoEmails?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deals?: DealOrderByRelationAggregateInput
  }

  export type PipelineStageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PipelineStageWhereInput | PipelineStageWhereInput[]
    OR?: PipelineStageWhereInput[]
    NOT?: PipelineStageWhereInput | PipelineStageWhereInput[]
    name?: StringFilter<"PipelineStage"> | string
    description?: StringNullableFilter<"PipelineStage"> | string | null
    order?: IntFilter<"PipelineStage"> | number
    probability?: IntFilter<"PipelineStage"> | number
    isClosedWon?: BoolFilter<"PipelineStage"> | boolean
    isClosedLost?: BoolFilter<"PipelineStage"> | boolean
    autoTasks?: JsonFilter<"PipelineStage">
    autoEmails?: JsonFilter<"PipelineStage">
    createdAt?: DateTimeFilter<"PipelineStage"> | Date | string
    updatedAt?: DateTimeFilter<"PipelineStage"> | Date | string
    deals?: DealListRelationFilter
  }, "id">

  export type PipelineStageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    probability?: SortOrder
    isClosedWon?: SortOrder
    isClosedLost?: SortOrder
    autoTasks?: SortOrder
    autoEmails?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PipelineStageCountOrderByAggregateInput
    _avg?: PipelineStageAvgOrderByAggregateInput
    _max?: PipelineStageMaxOrderByAggregateInput
    _min?: PipelineStageMinOrderByAggregateInput
    _sum?: PipelineStageSumOrderByAggregateInput
  }

  export type PipelineStageScalarWhereWithAggregatesInput = {
    AND?: PipelineStageScalarWhereWithAggregatesInput | PipelineStageScalarWhereWithAggregatesInput[]
    OR?: PipelineStageScalarWhereWithAggregatesInput[]
    NOT?: PipelineStageScalarWhereWithAggregatesInput | PipelineStageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PipelineStage"> | string
    name?: StringWithAggregatesFilter<"PipelineStage"> | string
    description?: StringNullableWithAggregatesFilter<"PipelineStage"> | string | null
    order?: IntWithAggregatesFilter<"PipelineStage"> | number
    probability?: IntWithAggregatesFilter<"PipelineStage"> | number
    isClosedWon?: BoolWithAggregatesFilter<"PipelineStage"> | boolean
    isClosedLost?: BoolWithAggregatesFilter<"PipelineStage"> | boolean
    autoTasks?: JsonWithAggregatesFilter<"PipelineStage">
    autoEmails?: JsonWithAggregatesFilter<"PipelineStage">
    createdAt?: DateTimeWithAggregatesFilter<"PipelineStage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PipelineStage"> | Date | string
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: StringFilter<"Activity"> | string
    type?: EnumActivityTypeFilter<"Activity"> | $Enums.ActivityType
    title?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    direction?: EnumDirectionNullableFilter<"Activity"> | $Enums.Direction | null
    duration?: IntNullableFilter<"Activity"> | number | null
    outcome?: StringNullableFilter<"Activity"> | string | null
    userId?: StringFilter<"Activity"> | string
    clientId?: StringNullableFilter<"Activity"> | string | null
    contactId?: StringNullableFilter<"Activity"> | string | null
    leadId?: StringNullableFilter<"Activity"> | string | null
    dealId?: StringNullableFilter<"Activity"> | string | null
    emailMessageId?: StringNullableFilter<"Activity"> | string | null
    callRecordingUrl?: StringNullableFilter<"Activity"> | string | null
    metadata?: JsonFilter<"Activity">
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    scheduledAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    contact?: XOR<ContactNullableRelationFilter, ContactWhereInput> | null
    lead?: XOR<LeadNullableRelationFilter, LeadWhereInput> | null
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    direction?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    userId?: SortOrder
    clientId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    leadId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    emailMessageId?: SortOrderInput | SortOrder
    callRecordingUrl?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    lead?: LeadOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    type?: EnumActivityTypeFilter<"Activity"> | $Enums.ActivityType
    title?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    direction?: EnumDirectionNullableFilter<"Activity"> | $Enums.Direction | null
    duration?: IntNullableFilter<"Activity"> | number | null
    outcome?: StringNullableFilter<"Activity"> | string | null
    userId?: StringFilter<"Activity"> | string
    clientId?: StringNullableFilter<"Activity"> | string | null
    contactId?: StringNullableFilter<"Activity"> | string | null
    leadId?: StringNullableFilter<"Activity"> | string | null
    dealId?: StringNullableFilter<"Activity"> | string | null
    emailMessageId?: StringNullableFilter<"Activity"> | string | null
    callRecordingUrl?: StringNullableFilter<"Activity"> | string | null
    metadata?: JsonFilter<"Activity">
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    scheduledAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    contact?: XOR<ContactNullableRelationFilter, ContactWhereInput> | null
    lead?: XOR<LeadNullableRelationFilter, LeadWhereInput> | null
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    direction?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    userId?: SortOrder
    clientId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    leadId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    emailMessageId?: SortOrderInput | SortOrder
    callRecordingUrl?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _avg?: ActivityAvgOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
    _sum?: ActivitySumOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Activity"> | string
    type?: EnumActivityTypeWithAggregatesFilter<"Activity"> | $Enums.ActivityType
    title?: StringWithAggregatesFilter<"Activity"> | string
    description?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    direction?: EnumDirectionNullableWithAggregatesFilter<"Activity"> | $Enums.Direction | null
    duration?: IntNullableWithAggregatesFilter<"Activity"> | number | null
    outcome?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    userId?: StringWithAggregatesFilter<"Activity"> | string
    clientId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    contactId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    leadId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    dealId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    emailMessageId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    callRecordingUrl?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    metadata?: JsonWithAggregatesFilter<"Activity">
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"Activity"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Activity"> | Date | string | null
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    priority?: EnumPriorityFilter<"Task"> | $Enums.Priority
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    assigneeId?: StringFilter<"Task"> | string
    createdById?: StringFilter<"Task"> | string
    clientId?: StringNullableFilter<"Task"> | string | null
    leadId?: StringNullableFilter<"Task"> | string | null
    dealId?: StringNullableFilter<"Task"> | string | null
    jobId?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    assignee?: XOR<UserRelationFilter, UserWhereInput>
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    lead?: XOR<LeadNullableRelationFilter, LeadWhereInput> | null
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
    job?: XOR<JobNullableRelationFilter, JobWhereInput> | null
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    assigneeId?: SortOrder
    createdById?: SortOrder
    clientId?: SortOrderInput | SortOrder
    leadId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    jobId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignee?: UserOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    lead?: LeadOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
    job?: JobOrderByWithRelationInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    priority?: EnumPriorityFilter<"Task"> | $Enums.Priority
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    assigneeId?: StringFilter<"Task"> | string
    createdById?: StringFilter<"Task"> | string
    clientId?: StringNullableFilter<"Task"> | string | null
    leadId?: StringNullableFilter<"Task"> | string | null
    dealId?: StringNullableFilter<"Task"> | string | null
    jobId?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    assignee?: XOR<UserRelationFilter, UserWhereInput>
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    lead?: XOR<LeadNullableRelationFilter, LeadWhereInput> | null
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
    job?: XOR<JobNullableRelationFilter, JobWhereInput> | null
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    assigneeId?: SortOrder
    createdById?: SortOrder
    clientId?: SortOrderInput | SortOrder
    leadId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    jobId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    status?: EnumTaskStatusWithAggregatesFilter<"Task"> | $Enums.TaskStatus
    priority?: EnumPriorityWithAggregatesFilter<"Task"> | $Enums.Priority
    dueDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    assigneeId?: StringWithAggregatesFilter<"Task"> | string
    createdById?: StringWithAggregatesFilter<"Task"> | string
    clientId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    leadId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    dealId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    jobId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: StringFilter<"Appointment"> | string
    title?: StringFilter<"Appointment"> | string
    description?: StringNullableFilter<"Appointment"> | string | null
    startTime?: DateTimeFilter<"Appointment"> | Date | string
    endTime?: DateTimeFilter<"Appointment"> | Date | string
    location?: StringNullableFilter<"Appointment"> | string | null
    meetingUrl?: StringNullableFilter<"Appointment"> | string | null
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    userId?: StringFilter<"Appointment"> | string
    clientId?: StringFilter<"Appointment"> | string
    jobId?: StringNullableFilter<"Appointment"> | string | null
    outlookEventId?: StringNullableFilter<"Appointment"> | string | null
    calendarSynced?: BoolFilter<"Appointment"> | boolean
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    job?: XOR<JobNullableRelationFilter, JobWhereInput> | null
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrderInput | SortOrder
    meetingUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    jobId?: SortOrderInput | SortOrder
    outlookEventId?: SortOrderInput | SortOrder
    calendarSynced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    job?: JobOrderByWithRelationInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    title?: StringFilter<"Appointment"> | string
    description?: StringNullableFilter<"Appointment"> | string | null
    startTime?: DateTimeFilter<"Appointment"> | Date | string
    endTime?: DateTimeFilter<"Appointment"> | Date | string
    location?: StringNullableFilter<"Appointment"> | string | null
    meetingUrl?: StringNullableFilter<"Appointment"> | string | null
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    userId?: StringFilter<"Appointment"> | string
    clientId?: StringFilter<"Appointment"> | string
    jobId?: StringNullableFilter<"Appointment"> | string | null
    outlookEventId?: StringNullableFilter<"Appointment"> | string | null
    calendarSynced?: BoolFilter<"Appointment"> | boolean
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    job?: XOR<JobNullableRelationFilter, JobWhereInput> | null
  }, "id">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrderInput | SortOrder
    meetingUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    jobId?: SortOrderInput | SortOrder
    outlookEventId?: SortOrderInput | SortOrder
    calendarSynced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Appointment"> | string
    title?: StringWithAggregatesFilter<"Appointment"> | string
    description?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    startTime?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    location?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    meetingUrl?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    status?: EnumAppointmentStatusWithAggregatesFilter<"Appointment"> | $Enums.AppointmentStatus
    userId?: StringWithAggregatesFilter<"Appointment"> | string
    clientId?: StringWithAggregatesFilter<"Appointment"> | string
    jobId?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    outlookEventId?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    calendarSynced?: BoolWithAggregatesFilter<"Appointment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
  }

  export type RoomWhereInput = {
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    id?: StringFilter<"Room"> | string
    name?: StringFilter<"Room"> | string
    type?: EnumRoomTypeFilter<"Room"> | $Enums.RoomType
    length?: IntNullableFilter<"Room"> | number | null
    width?: IntNullableFilter<"Room"> | number | null
    height?: IntNullableFilter<"Room"> | number | null
    currentCondition?: StringNullableFilter<"Room"> | string | null
    accessNotes?: StringNullableFilter<"Room"> | string | null
    clientId?: StringFilter<"Room"> | string
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    jobs?: JobListRelationFilter
  }

  export type RoomOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    length?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    currentCondition?: SortOrderInput | SortOrder
    accessNotes?: SortOrderInput | SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    jobs?: JobOrderByRelationAggregateInput
  }

  export type RoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    name?: StringFilter<"Room"> | string
    type?: EnumRoomTypeFilter<"Room"> | $Enums.RoomType
    length?: IntNullableFilter<"Room"> | number | null
    width?: IntNullableFilter<"Room"> | number | null
    height?: IntNullableFilter<"Room"> | number | null
    currentCondition?: StringNullableFilter<"Room"> | string | null
    accessNotes?: StringNullableFilter<"Room"> | string | null
    clientId?: StringFilter<"Room"> | string
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    jobs?: JobListRelationFilter
  }, "id">

  export type RoomOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    length?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    currentCondition?: SortOrderInput | SortOrder
    accessNotes?: SortOrderInput | SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoomCountOrderByAggregateInput
    _avg?: RoomAvgOrderByAggregateInput
    _max?: RoomMaxOrderByAggregateInput
    _min?: RoomMinOrderByAggregateInput
    _sum?: RoomSumOrderByAggregateInput
  }

  export type RoomScalarWhereWithAggregatesInput = {
    AND?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    OR?: RoomScalarWhereWithAggregatesInput[]
    NOT?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Room"> | string
    name?: StringWithAggregatesFilter<"Room"> | string
    type?: EnumRoomTypeWithAggregatesFilter<"Room"> | $Enums.RoomType
    length?: IntNullableWithAggregatesFilter<"Room"> | number | null
    width?: IntNullableWithAggregatesFilter<"Room"> | number | null
    height?: IntNullableWithAggregatesFilter<"Room"> | number | null
    currentCondition?: StringNullableWithAggregatesFilter<"Room"> | string | null
    accessNotes?: StringNullableWithAggregatesFilter<"Room"> | string | null
    clientId?: StringWithAggregatesFilter<"Room"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
  }

  export type JobWhereInput = {
    AND?: JobWhereInput | JobWhereInput[]
    OR?: JobWhereInput[]
    NOT?: JobWhereInput | JobWhereInput[]
    id?: StringFilter<"Job"> | string
    jobNumber?: StringFilter<"Job"> | string
    title?: StringFilter<"Job"> | string
    description?: StringNullableFilter<"Job"> | string | null
    status?: EnumJobStatusFilter<"Job"> | $Enums.JobStatus
    quotedDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    surveyDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    designDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    startDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    expectedEndDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    actualEndDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    quotedValue?: DecimalNullableFilter<"Job"> | Decimal | DecimalJsLike | number | string | null
    finalValue?: DecimalNullableFilter<"Job"> | Decimal | DecimalJsLike | number | string | null
    depositAmount?: DecimalNullableFilter<"Job"> | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFilter<"Job"> | boolean
    designFeePaid?: BoolFilter<"Job"> | boolean
    balancePaid?: BoolFilter<"Job"> | boolean
    clientId?: StringFilter<"Job"> | string
    roomId?: StringFilter<"Job"> | string
    dealId?: StringNullableFilter<"Job"> | string | null
    installerCompanyId?: StringNullableFilter<"Job"> | string | null
    designerId?: StringNullableFilter<"Job"> | string | null
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    room?: XOR<RoomRelationFilter, RoomWhereInput>
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
    installerCompany?: XOR<InstallerCompanyNullableRelationFilter, InstallerCompanyWhereInput> | null
    designer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    tasks?: TaskListRelationFilter
    appointments?: AppointmentListRelationFilter
    jobDayLogs?: JobDayLogListRelationFilter
    designVersions?: DesignVersionListRelationFilter
    snags?: SnagListRelationFilter
    documents?: DocumentListRelationFilter
    parsedSpecItems?: ParsedSpecItemListRelationFilter
    moodboards?: MoodboardListRelationFilter
    handoverPacks?: HandoverPackListRelationFilter
  }

  export type JobOrderByWithRelationInput = {
    id?: SortOrder
    jobNumber?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    quotedDate?: SortOrderInput | SortOrder
    surveyDate?: SortOrderInput | SortOrder
    designDate?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    expectedEndDate?: SortOrderInput | SortOrder
    actualEndDate?: SortOrderInput | SortOrder
    quotedValue?: SortOrderInput | SortOrder
    finalValue?: SortOrderInput | SortOrder
    depositAmount?: SortOrderInput | SortOrder
    depositPaid?: SortOrder
    designFeePaid?: SortOrder
    balancePaid?: SortOrder
    clientId?: SortOrder
    roomId?: SortOrder
    dealId?: SortOrderInput | SortOrder
    installerCompanyId?: SortOrderInput | SortOrder
    designerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    room?: RoomOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
    installerCompany?: InstallerCompanyOrderByWithRelationInput
    designer?: UserOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    jobDayLogs?: JobDayLogOrderByRelationAggregateInput
    designVersions?: DesignVersionOrderByRelationAggregateInput
    snags?: SnagOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    parsedSpecItems?: ParsedSpecItemOrderByRelationAggregateInput
    moodboards?: MoodboardOrderByRelationAggregateInput
    handoverPacks?: HandoverPackOrderByRelationAggregateInput
  }

  export type JobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jobNumber?: string
    dealId?: string
    AND?: JobWhereInput | JobWhereInput[]
    OR?: JobWhereInput[]
    NOT?: JobWhereInput | JobWhereInput[]
    title?: StringFilter<"Job"> | string
    description?: StringNullableFilter<"Job"> | string | null
    status?: EnumJobStatusFilter<"Job"> | $Enums.JobStatus
    quotedDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    surveyDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    designDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    startDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    expectedEndDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    actualEndDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    quotedValue?: DecimalNullableFilter<"Job"> | Decimal | DecimalJsLike | number | string | null
    finalValue?: DecimalNullableFilter<"Job"> | Decimal | DecimalJsLike | number | string | null
    depositAmount?: DecimalNullableFilter<"Job"> | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFilter<"Job"> | boolean
    designFeePaid?: BoolFilter<"Job"> | boolean
    balancePaid?: BoolFilter<"Job"> | boolean
    clientId?: StringFilter<"Job"> | string
    roomId?: StringFilter<"Job"> | string
    installerCompanyId?: StringNullableFilter<"Job"> | string | null
    designerId?: StringNullableFilter<"Job"> | string | null
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    room?: XOR<RoomRelationFilter, RoomWhereInput>
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
    installerCompany?: XOR<InstallerCompanyNullableRelationFilter, InstallerCompanyWhereInput> | null
    designer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    tasks?: TaskListRelationFilter
    appointments?: AppointmentListRelationFilter
    jobDayLogs?: JobDayLogListRelationFilter
    designVersions?: DesignVersionListRelationFilter
    snags?: SnagListRelationFilter
    documents?: DocumentListRelationFilter
    parsedSpecItems?: ParsedSpecItemListRelationFilter
    moodboards?: MoodboardListRelationFilter
    handoverPacks?: HandoverPackListRelationFilter
  }, "id" | "jobNumber" | "dealId">

  export type JobOrderByWithAggregationInput = {
    id?: SortOrder
    jobNumber?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    quotedDate?: SortOrderInput | SortOrder
    surveyDate?: SortOrderInput | SortOrder
    designDate?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    expectedEndDate?: SortOrderInput | SortOrder
    actualEndDate?: SortOrderInput | SortOrder
    quotedValue?: SortOrderInput | SortOrder
    finalValue?: SortOrderInput | SortOrder
    depositAmount?: SortOrderInput | SortOrder
    depositPaid?: SortOrder
    designFeePaid?: SortOrder
    balancePaid?: SortOrder
    clientId?: SortOrder
    roomId?: SortOrder
    dealId?: SortOrderInput | SortOrder
    installerCompanyId?: SortOrderInput | SortOrder
    designerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JobCountOrderByAggregateInput
    _avg?: JobAvgOrderByAggregateInput
    _max?: JobMaxOrderByAggregateInput
    _min?: JobMinOrderByAggregateInput
    _sum?: JobSumOrderByAggregateInput
  }

  export type JobScalarWhereWithAggregatesInput = {
    AND?: JobScalarWhereWithAggregatesInput | JobScalarWhereWithAggregatesInput[]
    OR?: JobScalarWhereWithAggregatesInput[]
    NOT?: JobScalarWhereWithAggregatesInput | JobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Job"> | string
    jobNumber?: StringWithAggregatesFilter<"Job"> | string
    title?: StringWithAggregatesFilter<"Job"> | string
    description?: StringNullableWithAggregatesFilter<"Job"> | string | null
    status?: EnumJobStatusWithAggregatesFilter<"Job"> | $Enums.JobStatus
    quotedDate?: DateTimeNullableWithAggregatesFilter<"Job"> | Date | string | null
    surveyDate?: DateTimeNullableWithAggregatesFilter<"Job"> | Date | string | null
    designDate?: DateTimeNullableWithAggregatesFilter<"Job"> | Date | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Job"> | Date | string | null
    expectedEndDate?: DateTimeNullableWithAggregatesFilter<"Job"> | Date | string | null
    actualEndDate?: DateTimeNullableWithAggregatesFilter<"Job"> | Date | string | null
    quotedValue?: DecimalNullableWithAggregatesFilter<"Job"> | Decimal | DecimalJsLike | number | string | null
    finalValue?: DecimalNullableWithAggregatesFilter<"Job"> | Decimal | DecimalJsLike | number | string | null
    depositAmount?: DecimalNullableWithAggregatesFilter<"Job"> | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolWithAggregatesFilter<"Job"> | boolean
    designFeePaid?: BoolWithAggregatesFilter<"Job"> | boolean
    balancePaid?: BoolWithAggregatesFilter<"Job"> | boolean
    clientId?: StringWithAggregatesFilter<"Job"> | string
    roomId?: StringWithAggregatesFilter<"Job"> | string
    dealId?: StringNullableWithAggregatesFilter<"Job"> | string | null
    installerCompanyId?: StringNullableWithAggregatesFilter<"Job"> | string | null
    designerId?: StringNullableWithAggregatesFilter<"Job"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Job"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Job"> | Date | string
  }

  export type JobDayLogWhereInput = {
    AND?: JobDayLogWhereInput | JobDayLogWhereInput[]
    OR?: JobDayLogWhereInput[]
    NOT?: JobDayLogWhereInput | JobDayLogWhereInput[]
    id?: StringFilter<"JobDayLog"> | string
    date?: DateTimeFilter<"JobDayLog"> | Date | string
    userId?: StringFilter<"JobDayLog"> | string
    jobId?: StringFilter<"JobDayLog"> | string
    startTime?: DateTimeNullableFilter<"JobDayLog"> | Date | string | null
    endTime?: DateTimeNullableFilter<"JobDayLog"> | Date | string | null
    lunchStart?: DateTimeNullableFilter<"JobDayLog"> | Date | string | null
    lunchEnd?: DateTimeNullableFilter<"JobDayLog"> | Date | string | null
    checkInLatitude?: DecimalNullableFilter<"JobDayLog"> | Decimal | DecimalJsLike | number | string | null
    checkInLongitude?: DecimalNullableFilter<"JobDayLog"> | Decimal | DecimalJsLike | number | string | null
    checkInAddress?: StringNullableFilter<"JobDayLog"> | string | null
    workCompleted?: StringNullableFilter<"JobDayLog"> | string | null
    materialsUsed?: StringNullableFilter<"JobDayLog"> | string | null
    issuesEncountered?: StringNullableFilter<"JobDayLog"> | string | null
    startFormData?: JsonNullableFilter<"JobDayLog">
    dailyFormData?: JsonNullableFilter<"JobDayLog">
    endFormData?: JsonNullableFilter<"JobDayLog">
    photos?: StringNullableListFilter<"JobDayLog">
    isCompliant?: BoolFilter<"JobDayLog"> | boolean
    complianceNotes?: StringNullableFilter<"JobDayLog"> | string | null
    syncStatus?: EnumSyncStatusFilter<"JobDayLog"> | $Enums.SyncStatus
    createdAt?: DateTimeFilter<"JobDayLog"> | Date | string
    updatedAt?: DateTimeFilter<"JobDayLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    job?: XOR<JobRelationFilter, JobWhereInput>
  }

  export type JobDayLogOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    jobId?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    lunchStart?: SortOrderInput | SortOrder
    lunchEnd?: SortOrderInput | SortOrder
    checkInLatitude?: SortOrderInput | SortOrder
    checkInLongitude?: SortOrderInput | SortOrder
    checkInAddress?: SortOrderInput | SortOrder
    workCompleted?: SortOrderInput | SortOrder
    materialsUsed?: SortOrderInput | SortOrder
    issuesEncountered?: SortOrderInput | SortOrder
    startFormData?: SortOrderInput | SortOrder
    dailyFormData?: SortOrderInput | SortOrder
    endFormData?: SortOrderInput | SortOrder
    photos?: SortOrder
    isCompliant?: SortOrder
    complianceNotes?: SortOrderInput | SortOrder
    syncStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    job?: JobOrderByWithRelationInput
  }

  export type JobDayLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_jobId_date?: JobDayLogUserIdJobIdDateCompoundUniqueInput
    AND?: JobDayLogWhereInput | JobDayLogWhereInput[]
    OR?: JobDayLogWhereInput[]
    NOT?: JobDayLogWhereInput | JobDayLogWhereInput[]
    date?: DateTimeFilter<"JobDayLog"> | Date | string
    userId?: StringFilter<"JobDayLog"> | string
    jobId?: StringFilter<"JobDayLog"> | string
    startTime?: DateTimeNullableFilter<"JobDayLog"> | Date | string | null
    endTime?: DateTimeNullableFilter<"JobDayLog"> | Date | string | null
    lunchStart?: DateTimeNullableFilter<"JobDayLog"> | Date | string | null
    lunchEnd?: DateTimeNullableFilter<"JobDayLog"> | Date | string | null
    checkInLatitude?: DecimalNullableFilter<"JobDayLog"> | Decimal | DecimalJsLike | number | string | null
    checkInLongitude?: DecimalNullableFilter<"JobDayLog"> | Decimal | DecimalJsLike | number | string | null
    checkInAddress?: StringNullableFilter<"JobDayLog"> | string | null
    workCompleted?: StringNullableFilter<"JobDayLog"> | string | null
    materialsUsed?: StringNullableFilter<"JobDayLog"> | string | null
    issuesEncountered?: StringNullableFilter<"JobDayLog"> | string | null
    startFormData?: JsonNullableFilter<"JobDayLog">
    dailyFormData?: JsonNullableFilter<"JobDayLog">
    endFormData?: JsonNullableFilter<"JobDayLog">
    photos?: StringNullableListFilter<"JobDayLog">
    isCompliant?: BoolFilter<"JobDayLog"> | boolean
    complianceNotes?: StringNullableFilter<"JobDayLog"> | string | null
    syncStatus?: EnumSyncStatusFilter<"JobDayLog"> | $Enums.SyncStatus
    createdAt?: DateTimeFilter<"JobDayLog"> | Date | string
    updatedAt?: DateTimeFilter<"JobDayLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    job?: XOR<JobRelationFilter, JobWhereInput>
  }, "id" | "userId_jobId_date">

  export type JobDayLogOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    jobId?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    lunchStart?: SortOrderInput | SortOrder
    lunchEnd?: SortOrderInput | SortOrder
    checkInLatitude?: SortOrderInput | SortOrder
    checkInLongitude?: SortOrderInput | SortOrder
    checkInAddress?: SortOrderInput | SortOrder
    workCompleted?: SortOrderInput | SortOrder
    materialsUsed?: SortOrderInput | SortOrder
    issuesEncountered?: SortOrderInput | SortOrder
    startFormData?: SortOrderInput | SortOrder
    dailyFormData?: SortOrderInput | SortOrder
    endFormData?: SortOrderInput | SortOrder
    photos?: SortOrder
    isCompliant?: SortOrder
    complianceNotes?: SortOrderInput | SortOrder
    syncStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JobDayLogCountOrderByAggregateInput
    _avg?: JobDayLogAvgOrderByAggregateInput
    _max?: JobDayLogMaxOrderByAggregateInput
    _min?: JobDayLogMinOrderByAggregateInput
    _sum?: JobDayLogSumOrderByAggregateInput
  }

  export type JobDayLogScalarWhereWithAggregatesInput = {
    AND?: JobDayLogScalarWhereWithAggregatesInput | JobDayLogScalarWhereWithAggregatesInput[]
    OR?: JobDayLogScalarWhereWithAggregatesInput[]
    NOT?: JobDayLogScalarWhereWithAggregatesInput | JobDayLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobDayLog"> | string
    date?: DateTimeWithAggregatesFilter<"JobDayLog"> | Date | string
    userId?: StringWithAggregatesFilter<"JobDayLog"> | string
    jobId?: StringWithAggregatesFilter<"JobDayLog"> | string
    startTime?: DateTimeNullableWithAggregatesFilter<"JobDayLog"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"JobDayLog"> | Date | string | null
    lunchStart?: DateTimeNullableWithAggregatesFilter<"JobDayLog"> | Date | string | null
    lunchEnd?: DateTimeNullableWithAggregatesFilter<"JobDayLog"> | Date | string | null
    checkInLatitude?: DecimalNullableWithAggregatesFilter<"JobDayLog"> | Decimal | DecimalJsLike | number | string | null
    checkInLongitude?: DecimalNullableWithAggregatesFilter<"JobDayLog"> | Decimal | DecimalJsLike | number | string | null
    checkInAddress?: StringNullableWithAggregatesFilter<"JobDayLog"> | string | null
    workCompleted?: StringNullableWithAggregatesFilter<"JobDayLog"> | string | null
    materialsUsed?: StringNullableWithAggregatesFilter<"JobDayLog"> | string | null
    issuesEncountered?: StringNullableWithAggregatesFilter<"JobDayLog"> | string | null
    startFormData?: JsonNullableWithAggregatesFilter<"JobDayLog">
    dailyFormData?: JsonNullableWithAggregatesFilter<"JobDayLog">
    endFormData?: JsonNullableWithAggregatesFilter<"JobDayLog">
    photos?: StringNullableListFilter<"JobDayLog">
    isCompliant?: BoolWithAggregatesFilter<"JobDayLog"> | boolean
    complianceNotes?: StringNullableWithAggregatesFilter<"JobDayLog"> | string | null
    syncStatus?: EnumSyncStatusWithAggregatesFilter<"JobDayLog"> | $Enums.SyncStatus
    createdAt?: DateTimeWithAggregatesFilter<"JobDayLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JobDayLog"> | Date | string
  }

  export type InstallerCompanyWhereInput = {
    AND?: InstallerCompanyWhereInput | InstallerCompanyWhereInput[]
    OR?: InstallerCompanyWhereInput[]
    NOT?: InstallerCompanyWhereInput | InstallerCompanyWhereInput[]
    id?: StringFilter<"InstallerCompany"> | string
    name?: StringFilter<"InstallerCompany"> | string
    contactEmail?: StringFilter<"InstallerCompany"> | string
    contactPhone?: StringFilter<"InstallerCompany"> | string
    address?: StringNullableFilter<"InstallerCompany"> | string | null
    insuranceExpiry?: DateTimeNullableFilter<"InstallerCompany"> | Date | string | null
    dbsExpiry?: DateTimeNullableFilter<"InstallerCompany"> | Date | string | null
    contractSigned?: BoolFilter<"InstallerCompany"> | boolean
    contractSignedAt?: DateTimeNullableFilter<"InstallerCompany"> | Date | string | null
    isActive?: BoolFilter<"InstallerCompany"> | boolean
    isSuspended?: BoolFilter<"InstallerCompany"> | boolean
    suspensionReason?: StringNullableFilter<"InstallerCompany"> | string | null
    ownerId?: StringNullableFilter<"InstallerCompany"> | string | null
    createdAt?: DateTimeFilter<"InstallerCompany"> | Date | string
    updatedAt?: DateTimeFilter<"InstallerCompany"> | Date | string
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    teamMembers?: InstallerTeamMemberListRelationFilter
    jobs?: JobListRelationFilter
  }

  export type InstallerCompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    address?: SortOrderInput | SortOrder
    insuranceExpiry?: SortOrderInput | SortOrder
    dbsExpiry?: SortOrderInput | SortOrder
    contractSigned?: SortOrder
    contractSignedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isSuspended?: SortOrder
    suspensionReason?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    teamMembers?: InstallerTeamMemberOrderByRelationAggregateInput
    jobs?: JobOrderByRelationAggregateInput
  }

  export type InstallerCompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InstallerCompanyWhereInput | InstallerCompanyWhereInput[]
    OR?: InstallerCompanyWhereInput[]
    NOT?: InstallerCompanyWhereInput | InstallerCompanyWhereInput[]
    name?: StringFilter<"InstallerCompany"> | string
    contactEmail?: StringFilter<"InstallerCompany"> | string
    contactPhone?: StringFilter<"InstallerCompany"> | string
    address?: StringNullableFilter<"InstallerCompany"> | string | null
    insuranceExpiry?: DateTimeNullableFilter<"InstallerCompany"> | Date | string | null
    dbsExpiry?: DateTimeNullableFilter<"InstallerCompany"> | Date | string | null
    contractSigned?: BoolFilter<"InstallerCompany"> | boolean
    contractSignedAt?: DateTimeNullableFilter<"InstallerCompany"> | Date | string | null
    isActive?: BoolFilter<"InstallerCompany"> | boolean
    isSuspended?: BoolFilter<"InstallerCompany"> | boolean
    suspensionReason?: StringNullableFilter<"InstallerCompany"> | string | null
    ownerId?: StringNullableFilter<"InstallerCompany"> | string | null
    createdAt?: DateTimeFilter<"InstallerCompany"> | Date | string
    updatedAt?: DateTimeFilter<"InstallerCompany"> | Date | string
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    teamMembers?: InstallerTeamMemberListRelationFilter
    jobs?: JobListRelationFilter
  }, "id">

  export type InstallerCompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    address?: SortOrderInput | SortOrder
    insuranceExpiry?: SortOrderInput | SortOrder
    dbsExpiry?: SortOrderInput | SortOrder
    contractSigned?: SortOrder
    contractSignedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isSuspended?: SortOrder
    suspensionReason?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InstallerCompanyCountOrderByAggregateInput
    _max?: InstallerCompanyMaxOrderByAggregateInput
    _min?: InstallerCompanyMinOrderByAggregateInput
  }

  export type InstallerCompanyScalarWhereWithAggregatesInput = {
    AND?: InstallerCompanyScalarWhereWithAggregatesInput | InstallerCompanyScalarWhereWithAggregatesInput[]
    OR?: InstallerCompanyScalarWhereWithAggregatesInput[]
    NOT?: InstallerCompanyScalarWhereWithAggregatesInput | InstallerCompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InstallerCompany"> | string
    name?: StringWithAggregatesFilter<"InstallerCompany"> | string
    contactEmail?: StringWithAggregatesFilter<"InstallerCompany"> | string
    contactPhone?: StringWithAggregatesFilter<"InstallerCompany"> | string
    address?: StringNullableWithAggregatesFilter<"InstallerCompany"> | string | null
    insuranceExpiry?: DateTimeNullableWithAggregatesFilter<"InstallerCompany"> | Date | string | null
    dbsExpiry?: DateTimeNullableWithAggregatesFilter<"InstallerCompany"> | Date | string | null
    contractSigned?: BoolWithAggregatesFilter<"InstallerCompany"> | boolean
    contractSignedAt?: DateTimeNullableWithAggregatesFilter<"InstallerCompany"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"InstallerCompany"> | boolean
    isSuspended?: BoolWithAggregatesFilter<"InstallerCompany"> | boolean
    suspensionReason?: StringNullableWithAggregatesFilter<"InstallerCompany"> | string | null
    ownerId?: StringNullableWithAggregatesFilter<"InstallerCompany"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InstallerCompany"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InstallerCompany"> | Date | string
  }

  export type InstallerTeamMemberWhereInput = {
    AND?: InstallerTeamMemberWhereInput | InstallerTeamMemberWhereInput[]
    OR?: InstallerTeamMemberWhereInput[]
    NOT?: InstallerTeamMemberWhereInput | InstallerTeamMemberWhereInput[]
    id?: StringFilter<"InstallerTeamMember"> | string
    firstName?: StringFilter<"InstallerTeamMember"> | string
    lastName?: StringFilter<"InstallerTeamMember"> | string
    email?: StringNullableFilter<"InstallerTeamMember"> | string | null
    phone?: StringNullableFilter<"InstallerTeamMember"> | string | null
    dbsExpiry?: DateTimeNullableFilter<"InstallerTeamMember"> | Date | string | null
    isActive?: BoolFilter<"InstallerTeamMember"> | boolean
    companyId?: StringFilter<"InstallerTeamMember"> | string
    createdAt?: DateTimeFilter<"InstallerTeamMember"> | Date | string
    updatedAt?: DateTimeFilter<"InstallerTeamMember"> | Date | string
    company?: XOR<InstallerCompanyRelationFilter, InstallerCompanyWhereInput>
  }

  export type InstallerTeamMemberOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    dbsExpiry?: SortOrderInput | SortOrder
    isActive?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: InstallerCompanyOrderByWithRelationInput
  }

  export type InstallerTeamMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InstallerTeamMemberWhereInput | InstallerTeamMemberWhereInput[]
    OR?: InstallerTeamMemberWhereInput[]
    NOT?: InstallerTeamMemberWhereInput | InstallerTeamMemberWhereInput[]
    firstName?: StringFilter<"InstallerTeamMember"> | string
    lastName?: StringFilter<"InstallerTeamMember"> | string
    email?: StringNullableFilter<"InstallerTeamMember"> | string | null
    phone?: StringNullableFilter<"InstallerTeamMember"> | string | null
    dbsExpiry?: DateTimeNullableFilter<"InstallerTeamMember"> | Date | string | null
    isActive?: BoolFilter<"InstallerTeamMember"> | boolean
    companyId?: StringFilter<"InstallerTeamMember"> | string
    createdAt?: DateTimeFilter<"InstallerTeamMember"> | Date | string
    updatedAt?: DateTimeFilter<"InstallerTeamMember"> | Date | string
    company?: XOR<InstallerCompanyRelationFilter, InstallerCompanyWhereInput>
  }, "id">

  export type InstallerTeamMemberOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    dbsExpiry?: SortOrderInput | SortOrder
    isActive?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InstallerTeamMemberCountOrderByAggregateInput
    _max?: InstallerTeamMemberMaxOrderByAggregateInput
    _min?: InstallerTeamMemberMinOrderByAggregateInput
  }

  export type InstallerTeamMemberScalarWhereWithAggregatesInput = {
    AND?: InstallerTeamMemberScalarWhereWithAggregatesInput | InstallerTeamMemberScalarWhereWithAggregatesInput[]
    OR?: InstallerTeamMemberScalarWhereWithAggregatesInput[]
    NOT?: InstallerTeamMemberScalarWhereWithAggregatesInput | InstallerTeamMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InstallerTeamMember"> | string
    firstName?: StringWithAggregatesFilter<"InstallerTeamMember"> | string
    lastName?: StringWithAggregatesFilter<"InstallerTeamMember"> | string
    email?: StringNullableWithAggregatesFilter<"InstallerTeamMember"> | string | null
    phone?: StringNullableWithAggregatesFilter<"InstallerTeamMember"> | string | null
    dbsExpiry?: DateTimeNullableWithAggregatesFilter<"InstallerTeamMember"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"InstallerTeamMember"> | boolean
    companyId?: StringWithAggregatesFilter<"InstallerTeamMember"> | string
    createdAt?: DateTimeWithAggregatesFilter<"InstallerTeamMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InstallerTeamMember"> | Date | string
  }

  export type DesignVersionWhereInput = {
    AND?: DesignVersionWhereInput | DesignVersionWhereInput[]
    OR?: DesignVersionWhereInput[]
    NOT?: DesignVersionWhereInput | DesignVersionWhereInput[]
    id?: StringFilter<"DesignVersion"> | string
    version?: IntFilter<"DesignVersion"> | number
    title?: StringFilter<"DesignVersion"> | string
    description?: StringNullableFilter<"DesignVersion"> | string | null
    status?: EnumDesignStatusFilter<"DesignVersion"> | $Enums.DesignStatus
    renderUrls?: StringNullableListFilter<"DesignVersion">
    planUrls?: StringNullableListFilter<"DesignVersion">
    specSheetUrl?: StringNullableFilter<"DesignVersion"> | string | null
    isClientVisible?: BoolFilter<"DesignVersion"> | boolean
    clientViewedAt?: DateTimeNullableFilter<"DesignVersion"> | Date | string | null
    clientApprovedAt?: DateTimeNullableFilter<"DesignVersion"> | Date | string | null
    clientFeedback?: StringNullableFilter<"DesignVersion"> | string | null
    jobId?: StringFilter<"DesignVersion"> | string
    designerId?: StringFilter<"DesignVersion"> | string
    isFinal?: BoolFilter<"DesignVersion"> | boolean
    lockedAt?: DateTimeNullableFilter<"DesignVersion"> | Date | string | null
    createdAt?: DateTimeFilter<"DesignVersion"> | Date | string
    updatedAt?: DateTimeFilter<"DesignVersion"> | Date | string
    job?: XOR<JobRelationFilter, JobWhereInput>
    designer?: XOR<UserRelationFilter, UserWhereInput>
    clashTickets?: DesignClashTicketListRelationFilter
  }

  export type DesignVersionOrderByWithRelationInput = {
    id?: SortOrder
    version?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    renderUrls?: SortOrder
    planUrls?: SortOrder
    specSheetUrl?: SortOrderInput | SortOrder
    isClientVisible?: SortOrder
    clientViewedAt?: SortOrderInput | SortOrder
    clientApprovedAt?: SortOrderInput | SortOrder
    clientFeedback?: SortOrderInput | SortOrder
    jobId?: SortOrder
    designerId?: SortOrder
    isFinal?: SortOrder
    lockedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    job?: JobOrderByWithRelationInput
    designer?: UserOrderByWithRelationInput
    clashTickets?: DesignClashTicketOrderByRelationAggregateInput
  }

  export type DesignVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DesignVersionWhereInput | DesignVersionWhereInput[]
    OR?: DesignVersionWhereInput[]
    NOT?: DesignVersionWhereInput | DesignVersionWhereInput[]
    version?: IntFilter<"DesignVersion"> | number
    title?: StringFilter<"DesignVersion"> | string
    description?: StringNullableFilter<"DesignVersion"> | string | null
    status?: EnumDesignStatusFilter<"DesignVersion"> | $Enums.DesignStatus
    renderUrls?: StringNullableListFilter<"DesignVersion">
    planUrls?: StringNullableListFilter<"DesignVersion">
    specSheetUrl?: StringNullableFilter<"DesignVersion"> | string | null
    isClientVisible?: BoolFilter<"DesignVersion"> | boolean
    clientViewedAt?: DateTimeNullableFilter<"DesignVersion"> | Date | string | null
    clientApprovedAt?: DateTimeNullableFilter<"DesignVersion"> | Date | string | null
    clientFeedback?: StringNullableFilter<"DesignVersion"> | string | null
    jobId?: StringFilter<"DesignVersion"> | string
    designerId?: StringFilter<"DesignVersion"> | string
    isFinal?: BoolFilter<"DesignVersion"> | boolean
    lockedAt?: DateTimeNullableFilter<"DesignVersion"> | Date | string | null
    createdAt?: DateTimeFilter<"DesignVersion"> | Date | string
    updatedAt?: DateTimeFilter<"DesignVersion"> | Date | string
    job?: XOR<JobRelationFilter, JobWhereInput>
    designer?: XOR<UserRelationFilter, UserWhereInput>
    clashTickets?: DesignClashTicketListRelationFilter
  }, "id">

  export type DesignVersionOrderByWithAggregationInput = {
    id?: SortOrder
    version?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    renderUrls?: SortOrder
    planUrls?: SortOrder
    specSheetUrl?: SortOrderInput | SortOrder
    isClientVisible?: SortOrder
    clientViewedAt?: SortOrderInput | SortOrder
    clientApprovedAt?: SortOrderInput | SortOrder
    clientFeedback?: SortOrderInput | SortOrder
    jobId?: SortOrder
    designerId?: SortOrder
    isFinal?: SortOrder
    lockedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DesignVersionCountOrderByAggregateInput
    _avg?: DesignVersionAvgOrderByAggregateInput
    _max?: DesignVersionMaxOrderByAggregateInput
    _min?: DesignVersionMinOrderByAggregateInput
    _sum?: DesignVersionSumOrderByAggregateInput
  }

  export type DesignVersionScalarWhereWithAggregatesInput = {
    AND?: DesignVersionScalarWhereWithAggregatesInput | DesignVersionScalarWhereWithAggregatesInput[]
    OR?: DesignVersionScalarWhereWithAggregatesInput[]
    NOT?: DesignVersionScalarWhereWithAggregatesInput | DesignVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DesignVersion"> | string
    version?: IntWithAggregatesFilter<"DesignVersion"> | number
    title?: StringWithAggregatesFilter<"DesignVersion"> | string
    description?: StringNullableWithAggregatesFilter<"DesignVersion"> | string | null
    status?: EnumDesignStatusWithAggregatesFilter<"DesignVersion"> | $Enums.DesignStatus
    renderUrls?: StringNullableListFilter<"DesignVersion">
    planUrls?: StringNullableListFilter<"DesignVersion">
    specSheetUrl?: StringNullableWithAggregatesFilter<"DesignVersion"> | string | null
    isClientVisible?: BoolWithAggregatesFilter<"DesignVersion"> | boolean
    clientViewedAt?: DateTimeNullableWithAggregatesFilter<"DesignVersion"> | Date | string | null
    clientApprovedAt?: DateTimeNullableWithAggregatesFilter<"DesignVersion"> | Date | string | null
    clientFeedback?: StringNullableWithAggregatesFilter<"DesignVersion"> | string | null
    jobId?: StringWithAggregatesFilter<"DesignVersion"> | string
    designerId?: StringWithAggregatesFilter<"DesignVersion"> | string
    isFinal?: BoolWithAggregatesFilter<"DesignVersion"> | boolean
    lockedAt?: DateTimeNullableWithAggregatesFilter<"DesignVersion"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DesignVersion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DesignVersion"> | Date | string
  }

  export type DesignClashTicketWhereInput = {
    AND?: DesignClashTicketWhereInput | DesignClashTicketWhereInput[]
    OR?: DesignClashTicketWhereInput[]
    NOT?: DesignClashTicketWhereInput | DesignClashTicketWhereInput[]
    id?: StringFilter<"DesignClashTicket"> | string
    title?: StringFilter<"DesignClashTicket"> | string
    description?: StringFilter<"DesignClashTicket"> | string
    status?: EnumClashStatusFilter<"DesignClashTicket"> | $Enums.ClashStatus
    priority?: EnumPriorityFilter<"DesignClashTicket"> | $Enums.Priority
    photoUrls?: StringNullableListFilter<"DesignClashTicket">
    resolution?: StringNullableFilter<"DesignClashTicket"> | string | null
    resolvedAt?: DateTimeNullableFilter<"DesignClashTicket"> | Date | string | null
    designVersionId?: StringFilter<"DesignClashTicket"> | string
    reportedById?: StringFilter<"DesignClashTicket"> | string
    assignedToId?: StringNullableFilter<"DesignClashTicket"> | string | null
    createdAt?: DateTimeFilter<"DesignClashTicket"> | Date | string
    updatedAt?: DateTimeFilter<"DesignClashTicket"> | Date | string
    designVersion?: XOR<DesignVersionRelationFilter, DesignVersionWhereInput>
    reportedBy?: XOR<UserRelationFilter, UserWhereInput>
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type DesignClashTicketOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    photoUrls?: SortOrder
    resolution?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    designVersionId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    designVersion?: DesignVersionOrderByWithRelationInput
    reportedBy?: UserOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
  }

  export type DesignClashTicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DesignClashTicketWhereInput | DesignClashTicketWhereInput[]
    OR?: DesignClashTicketWhereInput[]
    NOT?: DesignClashTicketWhereInput | DesignClashTicketWhereInput[]
    title?: StringFilter<"DesignClashTicket"> | string
    description?: StringFilter<"DesignClashTicket"> | string
    status?: EnumClashStatusFilter<"DesignClashTicket"> | $Enums.ClashStatus
    priority?: EnumPriorityFilter<"DesignClashTicket"> | $Enums.Priority
    photoUrls?: StringNullableListFilter<"DesignClashTicket">
    resolution?: StringNullableFilter<"DesignClashTicket"> | string | null
    resolvedAt?: DateTimeNullableFilter<"DesignClashTicket"> | Date | string | null
    designVersionId?: StringFilter<"DesignClashTicket"> | string
    reportedById?: StringFilter<"DesignClashTicket"> | string
    assignedToId?: StringNullableFilter<"DesignClashTicket"> | string | null
    createdAt?: DateTimeFilter<"DesignClashTicket"> | Date | string
    updatedAt?: DateTimeFilter<"DesignClashTicket"> | Date | string
    designVersion?: XOR<DesignVersionRelationFilter, DesignVersionWhereInput>
    reportedBy?: XOR<UserRelationFilter, UserWhereInput>
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type DesignClashTicketOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    photoUrls?: SortOrder
    resolution?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    designVersionId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DesignClashTicketCountOrderByAggregateInput
    _max?: DesignClashTicketMaxOrderByAggregateInput
    _min?: DesignClashTicketMinOrderByAggregateInput
  }

  export type DesignClashTicketScalarWhereWithAggregatesInput = {
    AND?: DesignClashTicketScalarWhereWithAggregatesInput | DesignClashTicketScalarWhereWithAggregatesInput[]
    OR?: DesignClashTicketScalarWhereWithAggregatesInput[]
    NOT?: DesignClashTicketScalarWhereWithAggregatesInput | DesignClashTicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DesignClashTicket"> | string
    title?: StringWithAggregatesFilter<"DesignClashTicket"> | string
    description?: StringWithAggregatesFilter<"DesignClashTicket"> | string
    status?: EnumClashStatusWithAggregatesFilter<"DesignClashTicket"> | $Enums.ClashStatus
    priority?: EnumPriorityWithAggregatesFilter<"DesignClashTicket"> | $Enums.Priority
    photoUrls?: StringNullableListFilter<"DesignClashTicket">
    resolution?: StringNullableWithAggregatesFilter<"DesignClashTicket"> | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"DesignClashTicket"> | Date | string | null
    designVersionId?: StringWithAggregatesFilter<"DesignClashTicket"> | string
    reportedById?: StringWithAggregatesFilter<"DesignClashTicket"> | string
    assignedToId?: StringNullableWithAggregatesFilter<"DesignClashTicket"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DesignClashTicket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DesignClashTicket"> | Date | string
  }

  export type MoodboardWhereInput = {
    AND?: MoodboardWhereInput | MoodboardWhereInput[]
    OR?: MoodboardWhereInput[]
    NOT?: MoodboardWhereInput | MoodboardWhereInput[]
    id?: StringFilter<"Moodboard"> | string
    title?: StringFilter<"Moodboard"> | string
    description?: StringNullableFilter<"Moodboard"> | string | null
    status?: EnumMoodboardStatusFilter<"Moodboard"> | $Enums.MoodboardStatus
    clientId?: StringFilter<"Moodboard"> | string
    jobId?: StringNullableFilter<"Moodboard"> | string | null
    isClientVisible?: BoolFilter<"Moodboard"> | boolean
    clientLastViewedAt?: DateTimeNullableFilter<"Moodboard"> | Date | string | null
    createdAt?: DateTimeFilter<"Moodboard"> | Date | string
    updatedAt?: DateTimeFilter<"Moodboard"> | Date | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    job?: XOR<JobNullableRelationFilter, JobWhereInput> | null
    items?: MoodboardItemListRelationFilter
  }

  export type MoodboardOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    clientId?: SortOrder
    jobId?: SortOrderInput | SortOrder
    isClientVisible?: SortOrder
    clientLastViewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    job?: JobOrderByWithRelationInput
    items?: MoodboardItemOrderByRelationAggregateInput
  }

  export type MoodboardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MoodboardWhereInput | MoodboardWhereInput[]
    OR?: MoodboardWhereInput[]
    NOT?: MoodboardWhereInput | MoodboardWhereInput[]
    title?: StringFilter<"Moodboard"> | string
    description?: StringNullableFilter<"Moodboard"> | string | null
    status?: EnumMoodboardStatusFilter<"Moodboard"> | $Enums.MoodboardStatus
    clientId?: StringFilter<"Moodboard"> | string
    jobId?: StringNullableFilter<"Moodboard"> | string | null
    isClientVisible?: BoolFilter<"Moodboard"> | boolean
    clientLastViewedAt?: DateTimeNullableFilter<"Moodboard"> | Date | string | null
    createdAt?: DateTimeFilter<"Moodboard"> | Date | string
    updatedAt?: DateTimeFilter<"Moodboard"> | Date | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    job?: XOR<JobNullableRelationFilter, JobWhereInput> | null
    items?: MoodboardItemListRelationFilter
  }, "id">

  export type MoodboardOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    clientId?: SortOrder
    jobId?: SortOrderInput | SortOrder
    isClientVisible?: SortOrder
    clientLastViewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MoodboardCountOrderByAggregateInput
    _max?: MoodboardMaxOrderByAggregateInput
    _min?: MoodboardMinOrderByAggregateInput
  }

  export type MoodboardScalarWhereWithAggregatesInput = {
    AND?: MoodboardScalarWhereWithAggregatesInput | MoodboardScalarWhereWithAggregatesInput[]
    OR?: MoodboardScalarWhereWithAggregatesInput[]
    NOT?: MoodboardScalarWhereWithAggregatesInput | MoodboardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Moodboard"> | string
    title?: StringWithAggregatesFilter<"Moodboard"> | string
    description?: StringNullableWithAggregatesFilter<"Moodboard"> | string | null
    status?: EnumMoodboardStatusWithAggregatesFilter<"Moodboard"> | $Enums.MoodboardStatus
    clientId?: StringWithAggregatesFilter<"Moodboard"> | string
    jobId?: StringNullableWithAggregatesFilter<"Moodboard"> | string | null
    isClientVisible?: BoolWithAggregatesFilter<"Moodboard"> | boolean
    clientLastViewedAt?: DateTimeNullableWithAggregatesFilter<"Moodboard"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Moodboard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Moodboard"> | Date | string
  }

  export type MoodboardItemWhereInput = {
    AND?: MoodboardItemWhereInput | MoodboardItemWhereInput[]
    OR?: MoodboardItemWhereInput[]
    NOT?: MoodboardItemWhereInput | MoodboardItemWhereInput[]
    id?: StringFilter<"MoodboardItem"> | string
    title?: StringNullableFilter<"MoodboardItem"> | string | null
    description?: StringNullableFilter<"MoodboardItem"> | string | null
    imageUrl?: StringFilter<"MoodboardItem"> | string
    sourceUrl?: StringNullableFilter<"MoodboardItem"> | string | null
    category?: StringNullableFilter<"MoodboardItem"> | string | null
    order?: IntFilter<"MoodboardItem"> | number
    moodboardId?: StringFilter<"MoodboardItem"> | string
    createdAt?: DateTimeFilter<"MoodboardItem"> | Date | string
    updatedAt?: DateTimeFilter<"MoodboardItem"> | Date | string
    clientComments?: MoodboardCommentListRelationFilter
    moodboard?: XOR<MoodboardRelationFilter, MoodboardWhereInput>
  }

  export type MoodboardItemOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    order?: SortOrder
    moodboardId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientComments?: MoodboardCommentOrderByRelationAggregateInput
    moodboard?: MoodboardOrderByWithRelationInput
  }

  export type MoodboardItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MoodboardItemWhereInput | MoodboardItemWhereInput[]
    OR?: MoodboardItemWhereInput[]
    NOT?: MoodboardItemWhereInput | MoodboardItemWhereInput[]
    title?: StringNullableFilter<"MoodboardItem"> | string | null
    description?: StringNullableFilter<"MoodboardItem"> | string | null
    imageUrl?: StringFilter<"MoodboardItem"> | string
    sourceUrl?: StringNullableFilter<"MoodboardItem"> | string | null
    category?: StringNullableFilter<"MoodboardItem"> | string | null
    order?: IntFilter<"MoodboardItem"> | number
    moodboardId?: StringFilter<"MoodboardItem"> | string
    createdAt?: DateTimeFilter<"MoodboardItem"> | Date | string
    updatedAt?: DateTimeFilter<"MoodboardItem"> | Date | string
    clientComments?: MoodboardCommentListRelationFilter
    moodboard?: XOR<MoodboardRelationFilter, MoodboardWhereInput>
  }, "id">

  export type MoodboardItemOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    order?: SortOrder
    moodboardId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MoodboardItemCountOrderByAggregateInput
    _avg?: MoodboardItemAvgOrderByAggregateInput
    _max?: MoodboardItemMaxOrderByAggregateInput
    _min?: MoodboardItemMinOrderByAggregateInput
    _sum?: MoodboardItemSumOrderByAggregateInput
  }

  export type MoodboardItemScalarWhereWithAggregatesInput = {
    AND?: MoodboardItemScalarWhereWithAggregatesInput | MoodboardItemScalarWhereWithAggregatesInput[]
    OR?: MoodboardItemScalarWhereWithAggregatesInput[]
    NOT?: MoodboardItemScalarWhereWithAggregatesInput | MoodboardItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MoodboardItem"> | string
    title?: StringNullableWithAggregatesFilter<"MoodboardItem"> | string | null
    description?: StringNullableWithAggregatesFilter<"MoodboardItem"> | string | null
    imageUrl?: StringWithAggregatesFilter<"MoodboardItem"> | string
    sourceUrl?: StringNullableWithAggregatesFilter<"MoodboardItem"> | string | null
    category?: StringNullableWithAggregatesFilter<"MoodboardItem"> | string | null
    order?: IntWithAggregatesFilter<"MoodboardItem"> | number
    moodboardId?: StringWithAggregatesFilter<"MoodboardItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MoodboardItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MoodboardItem"> | Date | string
  }

  export type MoodboardCommentWhereInput = {
    AND?: MoodboardCommentWhereInput | MoodboardCommentWhereInput[]
    OR?: MoodboardCommentWhereInput[]
    NOT?: MoodboardCommentWhereInput | MoodboardCommentWhereInput[]
    id?: StringFilter<"MoodboardComment"> | string
    content?: StringFilter<"MoodboardComment"> | string
    xPosition?: FloatFilter<"MoodboardComment"> | number
    yPosition?: FloatFilter<"MoodboardComment"> | number
    authorId?: StringNullableFilter<"MoodboardComment"> | string | null
    authorName?: StringNullableFilter<"MoodboardComment"> | string | null
    itemId?: StringFilter<"MoodboardComment"> | string
    createdAt?: DateTimeFilter<"MoodboardComment"> | Date | string
    author?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    item?: XOR<MoodboardItemRelationFilter, MoodboardItemWhereInput>
  }

  export type MoodboardCommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    xPosition?: SortOrder
    yPosition?: SortOrder
    authorId?: SortOrderInput | SortOrder
    authorName?: SortOrderInput | SortOrder
    itemId?: SortOrder
    createdAt?: SortOrder
    author?: UserOrderByWithRelationInput
    item?: MoodboardItemOrderByWithRelationInput
  }

  export type MoodboardCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MoodboardCommentWhereInput | MoodboardCommentWhereInput[]
    OR?: MoodboardCommentWhereInput[]
    NOT?: MoodboardCommentWhereInput | MoodboardCommentWhereInput[]
    content?: StringFilter<"MoodboardComment"> | string
    xPosition?: FloatFilter<"MoodboardComment"> | number
    yPosition?: FloatFilter<"MoodboardComment"> | number
    authorId?: StringNullableFilter<"MoodboardComment"> | string | null
    authorName?: StringNullableFilter<"MoodboardComment"> | string | null
    itemId?: StringFilter<"MoodboardComment"> | string
    createdAt?: DateTimeFilter<"MoodboardComment"> | Date | string
    author?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    item?: XOR<MoodboardItemRelationFilter, MoodboardItemWhereInput>
  }, "id">

  export type MoodboardCommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    xPosition?: SortOrder
    yPosition?: SortOrder
    authorId?: SortOrderInput | SortOrder
    authorName?: SortOrderInput | SortOrder
    itemId?: SortOrder
    createdAt?: SortOrder
    _count?: MoodboardCommentCountOrderByAggregateInput
    _avg?: MoodboardCommentAvgOrderByAggregateInput
    _max?: MoodboardCommentMaxOrderByAggregateInput
    _min?: MoodboardCommentMinOrderByAggregateInput
    _sum?: MoodboardCommentSumOrderByAggregateInput
  }

  export type MoodboardCommentScalarWhereWithAggregatesInput = {
    AND?: MoodboardCommentScalarWhereWithAggregatesInput | MoodboardCommentScalarWhereWithAggregatesInput[]
    OR?: MoodboardCommentScalarWhereWithAggregatesInput[]
    NOT?: MoodboardCommentScalarWhereWithAggregatesInput | MoodboardCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MoodboardComment"> | string
    content?: StringWithAggregatesFilter<"MoodboardComment"> | string
    xPosition?: FloatWithAggregatesFilter<"MoodboardComment"> | number
    yPosition?: FloatWithAggregatesFilter<"MoodboardComment"> | number
    authorId?: StringNullableWithAggregatesFilter<"MoodboardComment"> | string | null
    authorName?: StringNullableWithAggregatesFilter<"MoodboardComment"> | string | null
    itemId?: StringWithAggregatesFilter<"MoodboardComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MoodboardComment"> | Date | string
  }

  export type ParsedSpecItemWhereInput = {
    AND?: ParsedSpecItemWhereInput | ParsedSpecItemWhereInput[]
    OR?: ParsedSpecItemWhereInput[]
    NOT?: ParsedSpecItemWhereInput | ParsedSpecItemWhereInput[]
    id?: StringFilter<"ParsedSpecItem"> | string
    originalText?: StringFilter<"ParsedSpecItem"> | string
    parsedCategory?: StringNullableFilter<"ParsedSpecItem"> | string | null
    parsedBrand?: StringNullableFilter<"ParsedSpecItem"> | string | null
    parsedModel?: StringNullableFilter<"ParsedSpecItem"> | string | null
    parsedDescription?: StringNullableFilter<"ParsedSpecItem"> | string | null
    parsedQuantity?: IntNullableFilter<"ParsedSpecItem"> | number | null
    parsedPrice?: DecimalNullableFilter<"ParsedSpecItem"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumSpecItemStatusFilter<"ParsedSpecItem"> | $Enums.SpecItemStatus
    notes?: StringNullableFilter<"ParsedSpecItem"> | string | null
    substitution?: StringNullableFilter<"ParsedSpecItem"> | string | null
    actualPrice?: DecimalNullableFilter<"ParsedSpecItem"> | Decimal | DecimalJsLike | number | string | null
    parseConfidence?: FloatFilter<"ParsedSpecItem"> | number
    requiresReview?: BoolFilter<"ParsedSpecItem"> | boolean
    jobId?: StringFilter<"ParsedSpecItem"> | string
    sourceDocumentId?: StringNullableFilter<"ParsedSpecItem"> | string | null
    sourcePage?: IntNullableFilter<"ParsedSpecItem"> | number | null
    sourceLineNumber?: IntNullableFilter<"ParsedSpecItem"> | number | null
    createdAt?: DateTimeFilter<"ParsedSpecItem"> | Date | string
    updatedAt?: DateTimeFilter<"ParsedSpecItem"> | Date | string
    job?: XOR<JobRelationFilter, JobWhereInput>
  }

  export type ParsedSpecItemOrderByWithRelationInput = {
    id?: SortOrder
    originalText?: SortOrder
    parsedCategory?: SortOrderInput | SortOrder
    parsedBrand?: SortOrderInput | SortOrder
    parsedModel?: SortOrderInput | SortOrder
    parsedDescription?: SortOrderInput | SortOrder
    parsedQuantity?: SortOrderInput | SortOrder
    parsedPrice?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    substitution?: SortOrderInput | SortOrder
    actualPrice?: SortOrderInput | SortOrder
    parseConfidence?: SortOrder
    requiresReview?: SortOrder
    jobId?: SortOrder
    sourceDocumentId?: SortOrderInput | SortOrder
    sourcePage?: SortOrderInput | SortOrder
    sourceLineNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    job?: JobOrderByWithRelationInput
  }

  export type ParsedSpecItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ParsedSpecItemWhereInput | ParsedSpecItemWhereInput[]
    OR?: ParsedSpecItemWhereInput[]
    NOT?: ParsedSpecItemWhereInput | ParsedSpecItemWhereInput[]
    originalText?: StringFilter<"ParsedSpecItem"> | string
    parsedCategory?: StringNullableFilter<"ParsedSpecItem"> | string | null
    parsedBrand?: StringNullableFilter<"ParsedSpecItem"> | string | null
    parsedModel?: StringNullableFilter<"ParsedSpecItem"> | string | null
    parsedDescription?: StringNullableFilter<"ParsedSpecItem"> | string | null
    parsedQuantity?: IntNullableFilter<"ParsedSpecItem"> | number | null
    parsedPrice?: DecimalNullableFilter<"ParsedSpecItem"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumSpecItemStatusFilter<"ParsedSpecItem"> | $Enums.SpecItemStatus
    notes?: StringNullableFilter<"ParsedSpecItem"> | string | null
    substitution?: StringNullableFilter<"ParsedSpecItem"> | string | null
    actualPrice?: DecimalNullableFilter<"ParsedSpecItem"> | Decimal | DecimalJsLike | number | string | null
    parseConfidence?: FloatFilter<"ParsedSpecItem"> | number
    requiresReview?: BoolFilter<"ParsedSpecItem"> | boolean
    jobId?: StringFilter<"ParsedSpecItem"> | string
    sourceDocumentId?: StringNullableFilter<"ParsedSpecItem"> | string | null
    sourcePage?: IntNullableFilter<"ParsedSpecItem"> | number | null
    sourceLineNumber?: IntNullableFilter<"ParsedSpecItem"> | number | null
    createdAt?: DateTimeFilter<"ParsedSpecItem"> | Date | string
    updatedAt?: DateTimeFilter<"ParsedSpecItem"> | Date | string
    job?: XOR<JobRelationFilter, JobWhereInput>
  }, "id">

  export type ParsedSpecItemOrderByWithAggregationInput = {
    id?: SortOrder
    originalText?: SortOrder
    parsedCategory?: SortOrderInput | SortOrder
    parsedBrand?: SortOrderInput | SortOrder
    parsedModel?: SortOrderInput | SortOrder
    parsedDescription?: SortOrderInput | SortOrder
    parsedQuantity?: SortOrderInput | SortOrder
    parsedPrice?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    substitution?: SortOrderInput | SortOrder
    actualPrice?: SortOrderInput | SortOrder
    parseConfidence?: SortOrder
    requiresReview?: SortOrder
    jobId?: SortOrder
    sourceDocumentId?: SortOrderInput | SortOrder
    sourcePage?: SortOrderInput | SortOrder
    sourceLineNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ParsedSpecItemCountOrderByAggregateInput
    _avg?: ParsedSpecItemAvgOrderByAggregateInput
    _max?: ParsedSpecItemMaxOrderByAggregateInput
    _min?: ParsedSpecItemMinOrderByAggregateInput
    _sum?: ParsedSpecItemSumOrderByAggregateInput
  }

  export type ParsedSpecItemScalarWhereWithAggregatesInput = {
    AND?: ParsedSpecItemScalarWhereWithAggregatesInput | ParsedSpecItemScalarWhereWithAggregatesInput[]
    OR?: ParsedSpecItemScalarWhereWithAggregatesInput[]
    NOT?: ParsedSpecItemScalarWhereWithAggregatesInput | ParsedSpecItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ParsedSpecItem"> | string
    originalText?: StringWithAggregatesFilter<"ParsedSpecItem"> | string
    parsedCategory?: StringNullableWithAggregatesFilter<"ParsedSpecItem"> | string | null
    parsedBrand?: StringNullableWithAggregatesFilter<"ParsedSpecItem"> | string | null
    parsedModel?: StringNullableWithAggregatesFilter<"ParsedSpecItem"> | string | null
    parsedDescription?: StringNullableWithAggregatesFilter<"ParsedSpecItem"> | string | null
    parsedQuantity?: IntNullableWithAggregatesFilter<"ParsedSpecItem"> | number | null
    parsedPrice?: DecimalNullableWithAggregatesFilter<"ParsedSpecItem"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumSpecItemStatusWithAggregatesFilter<"ParsedSpecItem"> | $Enums.SpecItemStatus
    notes?: StringNullableWithAggregatesFilter<"ParsedSpecItem"> | string | null
    substitution?: StringNullableWithAggregatesFilter<"ParsedSpecItem"> | string | null
    actualPrice?: DecimalNullableWithAggregatesFilter<"ParsedSpecItem"> | Decimal | DecimalJsLike | number | string | null
    parseConfidence?: FloatWithAggregatesFilter<"ParsedSpecItem"> | number
    requiresReview?: BoolWithAggregatesFilter<"ParsedSpecItem"> | boolean
    jobId?: StringWithAggregatesFilter<"ParsedSpecItem"> | string
    sourceDocumentId?: StringNullableWithAggregatesFilter<"ParsedSpecItem"> | string | null
    sourcePage?: IntNullableWithAggregatesFilter<"ParsedSpecItem"> | number | null
    sourceLineNumber?: IntNullableWithAggregatesFilter<"ParsedSpecItem"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ParsedSpecItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ParsedSpecItem"> | Date | string
  }

  export type SnagWhereInput = {
    AND?: SnagWhereInput | SnagWhereInput[]
    OR?: SnagWhereInput[]
    NOT?: SnagWhereInput | SnagWhereInput[]
    id?: StringFilter<"Snag"> | string
    title?: StringFilter<"Snag"> | string
    description?: StringFilter<"Snag"> | string
    category?: EnumSnagCategoryFilter<"Snag"> | $Enums.SnagCategory
    severity?: EnumPriorityFilter<"Snag"> | $Enums.Priority
    status?: EnumSnagStatusFilter<"Snag"> | $Enums.SnagStatus
    photoUrls?: StringNullableListFilter<"Snag">
    isClientVisible?: BoolFilter<"Snag"> | boolean
    clientNotified?: BoolFilter<"Snag"> | boolean
    resolution?: StringNullableFilter<"Snag"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Snag"> | Date | string | null
    jobId?: StringFilter<"Snag"> | string
    reportedById?: StringFilter<"Snag"> | string
    assignedToId?: StringNullableFilter<"Snag"> | string | null
    createdAt?: DateTimeFilter<"Snag"> | Date | string
    updatedAt?: DateTimeFilter<"Snag"> | Date | string
    job?: XOR<JobRelationFilter, JobWhereInput>
    reportedBy?: XOR<UserRelationFilter, UserWhereInput>
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type SnagOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    photoUrls?: SortOrder
    isClientVisible?: SortOrder
    clientNotified?: SortOrder
    resolution?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    jobId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    job?: JobOrderByWithRelationInput
    reportedBy?: UserOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
  }

  export type SnagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SnagWhereInput | SnagWhereInput[]
    OR?: SnagWhereInput[]
    NOT?: SnagWhereInput | SnagWhereInput[]
    title?: StringFilter<"Snag"> | string
    description?: StringFilter<"Snag"> | string
    category?: EnumSnagCategoryFilter<"Snag"> | $Enums.SnagCategory
    severity?: EnumPriorityFilter<"Snag"> | $Enums.Priority
    status?: EnumSnagStatusFilter<"Snag"> | $Enums.SnagStatus
    photoUrls?: StringNullableListFilter<"Snag">
    isClientVisible?: BoolFilter<"Snag"> | boolean
    clientNotified?: BoolFilter<"Snag"> | boolean
    resolution?: StringNullableFilter<"Snag"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Snag"> | Date | string | null
    jobId?: StringFilter<"Snag"> | string
    reportedById?: StringFilter<"Snag"> | string
    assignedToId?: StringNullableFilter<"Snag"> | string | null
    createdAt?: DateTimeFilter<"Snag"> | Date | string
    updatedAt?: DateTimeFilter<"Snag"> | Date | string
    job?: XOR<JobRelationFilter, JobWhereInput>
    reportedBy?: XOR<UserRelationFilter, UserWhereInput>
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type SnagOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    photoUrls?: SortOrder
    isClientVisible?: SortOrder
    clientNotified?: SortOrder
    resolution?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    jobId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SnagCountOrderByAggregateInput
    _max?: SnagMaxOrderByAggregateInput
    _min?: SnagMinOrderByAggregateInput
  }

  export type SnagScalarWhereWithAggregatesInput = {
    AND?: SnagScalarWhereWithAggregatesInput | SnagScalarWhereWithAggregatesInput[]
    OR?: SnagScalarWhereWithAggregatesInput[]
    NOT?: SnagScalarWhereWithAggregatesInput | SnagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Snag"> | string
    title?: StringWithAggregatesFilter<"Snag"> | string
    description?: StringWithAggregatesFilter<"Snag"> | string
    category?: EnumSnagCategoryWithAggregatesFilter<"Snag"> | $Enums.SnagCategory
    severity?: EnumPriorityWithAggregatesFilter<"Snag"> | $Enums.Priority
    status?: EnumSnagStatusWithAggregatesFilter<"Snag"> | $Enums.SnagStatus
    photoUrls?: StringNullableListFilter<"Snag">
    isClientVisible?: BoolWithAggregatesFilter<"Snag"> | boolean
    clientNotified?: BoolWithAggregatesFilter<"Snag"> | boolean
    resolution?: StringNullableWithAggregatesFilter<"Snag"> | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Snag"> | Date | string | null
    jobId?: StringWithAggregatesFilter<"Snag"> | string
    reportedById?: StringWithAggregatesFilter<"Snag"> | string
    assignedToId?: StringNullableWithAggregatesFilter<"Snag"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Snag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Snag"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    filename?: StringFilter<"Document"> | string
    originalFilename?: StringFilter<"Document"> | string
    mimeType?: StringFilter<"Document"> | string
    fileSize?: IntFilter<"Document"> | number
    storageUrl?: StringFilter<"Document"> | string
    category?: EnumDocumentCategoryFilter<"Document"> | $Enums.DocumentCategory
    description?: StringNullableFilter<"Document"> | string | null
    isPublic?: BoolFilter<"Document"> | boolean
    virusScanStatus?: EnumVirusScanStatusFilter<"Document"> | $Enums.VirusScanStatus
    virusScanResult?: StringNullableFilter<"Document"> | string | null
    clientId?: StringNullableFilter<"Document"> | string | null
    dealId?: StringNullableFilter<"Document"> | string | null
    jobId?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    uploadedById?: StringFilter<"Document"> | string
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
    job?: XOR<JobNullableRelationFilter, JobWhereInput> | null
    uploadedBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    originalFilename?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    storageUrl?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    virusScanStatus?: SortOrder
    virusScanResult?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    jobId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    uploadedById?: SortOrder
    client?: ClientOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
    job?: JobOrderByWithRelationInput
    uploadedBy?: UserOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    filename?: StringFilter<"Document"> | string
    originalFilename?: StringFilter<"Document"> | string
    mimeType?: StringFilter<"Document"> | string
    fileSize?: IntFilter<"Document"> | number
    storageUrl?: StringFilter<"Document"> | string
    category?: EnumDocumentCategoryFilter<"Document"> | $Enums.DocumentCategory
    description?: StringNullableFilter<"Document"> | string | null
    isPublic?: BoolFilter<"Document"> | boolean
    virusScanStatus?: EnumVirusScanStatusFilter<"Document"> | $Enums.VirusScanStatus
    virusScanResult?: StringNullableFilter<"Document"> | string | null
    clientId?: StringNullableFilter<"Document"> | string | null
    dealId?: StringNullableFilter<"Document"> | string | null
    jobId?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    uploadedById?: StringFilter<"Document"> | string
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
    job?: XOR<JobNullableRelationFilter, JobWhereInput> | null
    uploadedBy?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    originalFilename?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    storageUrl?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    virusScanStatus?: SortOrder
    virusScanResult?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    jobId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    uploadedById?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    filename?: StringWithAggregatesFilter<"Document"> | string
    originalFilename?: StringWithAggregatesFilter<"Document"> | string
    mimeType?: StringWithAggregatesFilter<"Document"> | string
    fileSize?: IntWithAggregatesFilter<"Document"> | number
    storageUrl?: StringWithAggregatesFilter<"Document"> | string
    category?: EnumDocumentCategoryWithAggregatesFilter<"Document"> | $Enums.DocumentCategory
    description?: StringNullableWithAggregatesFilter<"Document"> | string | null
    isPublic?: BoolWithAggregatesFilter<"Document"> | boolean
    virusScanStatus?: EnumVirusScanStatusWithAggregatesFilter<"Document"> | $Enums.VirusScanStatus
    virusScanResult?: StringNullableWithAggregatesFilter<"Document"> | string | null
    clientId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    dealId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    jobId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    uploadedById?: StringWithAggregatesFilter<"Document"> | string
  }

  export type FormTemplateWhereInput = {
    AND?: FormTemplateWhereInput | FormTemplateWhereInput[]
    OR?: FormTemplateWhereInput[]
    NOT?: FormTemplateWhereInput | FormTemplateWhereInput[]
    id?: StringFilter<"FormTemplate"> | string
    name?: StringFilter<"FormTemplate"> | string
    description?: StringNullableFilter<"FormTemplate"> | string | null
    category?: EnumFormCategoryFilter<"FormTemplate"> | $Enums.FormCategory
    schema?: JsonFilter<"FormTemplate">
    isActive?: BoolFilter<"FormTemplate"> | boolean
    version?: IntFilter<"FormTemplate"> | number
    createdAt?: DateTimeFilter<"FormTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"FormTemplate"> | Date | string
    submissions?: FormSubmissionListRelationFilter
  }

  export type FormTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    schema?: SortOrder
    isActive?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    submissions?: FormSubmissionOrderByRelationAggregateInput
  }

  export type FormTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FormTemplateWhereInput | FormTemplateWhereInput[]
    OR?: FormTemplateWhereInput[]
    NOT?: FormTemplateWhereInput | FormTemplateWhereInput[]
    name?: StringFilter<"FormTemplate"> | string
    description?: StringNullableFilter<"FormTemplate"> | string | null
    category?: EnumFormCategoryFilter<"FormTemplate"> | $Enums.FormCategory
    schema?: JsonFilter<"FormTemplate">
    isActive?: BoolFilter<"FormTemplate"> | boolean
    version?: IntFilter<"FormTemplate"> | number
    createdAt?: DateTimeFilter<"FormTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"FormTemplate"> | Date | string
    submissions?: FormSubmissionListRelationFilter
  }, "id">

  export type FormTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    schema?: SortOrder
    isActive?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FormTemplateCountOrderByAggregateInput
    _avg?: FormTemplateAvgOrderByAggregateInput
    _max?: FormTemplateMaxOrderByAggregateInput
    _min?: FormTemplateMinOrderByAggregateInput
    _sum?: FormTemplateSumOrderByAggregateInput
  }

  export type FormTemplateScalarWhereWithAggregatesInput = {
    AND?: FormTemplateScalarWhereWithAggregatesInput | FormTemplateScalarWhereWithAggregatesInput[]
    OR?: FormTemplateScalarWhereWithAggregatesInput[]
    NOT?: FormTemplateScalarWhereWithAggregatesInput | FormTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FormTemplate"> | string
    name?: StringWithAggregatesFilter<"FormTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"FormTemplate"> | string | null
    category?: EnumFormCategoryWithAggregatesFilter<"FormTemplate"> | $Enums.FormCategory
    schema?: JsonWithAggregatesFilter<"FormTemplate">
    isActive?: BoolWithAggregatesFilter<"FormTemplate"> | boolean
    version?: IntWithAggregatesFilter<"FormTemplate"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FormTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FormTemplate"> | Date | string
  }

  export type FormSubmissionWhereInput = {
    AND?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    OR?: FormSubmissionWhereInput[]
    NOT?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    id?: StringFilter<"FormSubmission"> | string
    data?: JsonFilter<"FormSubmission">
    submissionSource?: EnumSubmissionSourceFilter<"FormSubmission"> | $Enums.SubmissionSource
    templateId?: StringFilter<"FormSubmission"> | string
    submittedById?: StringNullableFilter<"FormSubmission"> | string | null
    clientId?: StringNullableFilter<"FormSubmission"> | string | null
    jobId?: StringNullableFilter<"FormSubmission"> | string | null
    submittedAt?: DateTimeFilter<"FormSubmission"> | Date | string
    template?: XOR<FormTemplateRelationFilter, FormTemplateWhereInput>
    submittedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type FormSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    data?: SortOrder
    submissionSource?: SortOrder
    templateId?: SortOrder
    submittedById?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    jobId?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    template?: FormTemplateOrderByWithRelationInput
    submittedBy?: UserOrderByWithRelationInput
  }

  export type FormSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    OR?: FormSubmissionWhereInput[]
    NOT?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    data?: JsonFilter<"FormSubmission">
    submissionSource?: EnumSubmissionSourceFilter<"FormSubmission"> | $Enums.SubmissionSource
    templateId?: StringFilter<"FormSubmission"> | string
    submittedById?: StringNullableFilter<"FormSubmission"> | string | null
    clientId?: StringNullableFilter<"FormSubmission"> | string | null
    jobId?: StringNullableFilter<"FormSubmission"> | string | null
    submittedAt?: DateTimeFilter<"FormSubmission"> | Date | string
    template?: XOR<FormTemplateRelationFilter, FormTemplateWhereInput>
    submittedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type FormSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    data?: SortOrder
    submissionSource?: SortOrder
    templateId?: SortOrder
    submittedById?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    jobId?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    _count?: FormSubmissionCountOrderByAggregateInput
    _max?: FormSubmissionMaxOrderByAggregateInput
    _min?: FormSubmissionMinOrderByAggregateInput
  }

  export type FormSubmissionScalarWhereWithAggregatesInput = {
    AND?: FormSubmissionScalarWhereWithAggregatesInput | FormSubmissionScalarWhereWithAggregatesInput[]
    OR?: FormSubmissionScalarWhereWithAggregatesInput[]
    NOT?: FormSubmissionScalarWhereWithAggregatesInput | FormSubmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FormSubmission"> | string
    data?: JsonWithAggregatesFilter<"FormSubmission">
    submissionSource?: EnumSubmissionSourceWithAggregatesFilter<"FormSubmission"> | $Enums.SubmissionSource
    templateId?: StringWithAggregatesFilter<"FormSubmission"> | string
    submittedById?: StringNullableWithAggregatesFilter<"FormSubmission"> | string | null
    clientId?: StringNullableWithAggregatesFilter<"FormSubmission"> | string | null
    jobId?: StringNullableWithAggregatesFilter<"FormSubmission"> | string | null
    submittedAt?: DateTimeWithAggregatesFilter<"FormSubmission"> | Date | string
  }

  export type HandoverPackWhereInput = {
    AND?: HandoverPackWhereInput | HandoverPackWhereInput[]
    OR?: HandoverPackWhereInput[]
    NOT?: HandoverPackWhereInput | HandoverPackWhereInput[]
    id?: StringFilter<"HandoverPack"> | string
    title?: StringFilter<"HandoverPack"> | string
    description?: StringNullableFilter<"HandoverPack"> | string | null
    completionCertUrl?: StringNullableFilter<"HandoverPack"> | string | null
    warrantyDocsUrls?: StringNullableListFilter<"HandoverPack">
    finalPhotosUrls?: StringNullableListFilter<"HandoverPack">
    guidesIncluded?: StringNullableListFilter<"HandoverPack">
    isGenerated?: BoolFilter<"HandoverPack"> | boolean
    generatedAt?: DateTimeNullableFilter<"HandoverPack"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"HandoverPack"> | Date | string | null
    clientAccessedAt?: DateTimeNullableFilter<"HandoverPack"> | Date | string | null
    jobId?: StringFilter<"HandoverPack"> | string
    createdAt?: DateTimeFilter<"HandoverPack"> | Date | string
    updatedAt?: DateTimeFilter<"HandoverPack"> | Date | string
    job?: XOR<JobRelationFilter, JobWhereInput>
  }

  export type HandoverPackOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    completionCertUrl?: SortOrderInput | SortOrder
    warrantyDocsUrls?: SortOrder
    finalPhotosUrls?: SortOrder
    guidesIncluded?: SortOrder
    isGenerated?: SortOrder
    generatedAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    clientAccessedAt?: SortOrderInput | SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    job?: JobOrderByWithRelationInput
  }

  export type HandoverPackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jobId?: string
    AND?: HandoverPackWhereInput | HandoverPackWhereInput[]
    OR?: HandoverPackWhereInput[]
    NOT?: HandoverPackWhereInput | HandoverPackWhereInput[]
    title?: StringFilter<"HandoverPack"> | string
    description?: StringNullableFilter<"HandoverPack"> | string | null
    completionCertUrl?: StringNullableFilter<"HandoverPack"> | string | null
    warrantyDocsUrls?: StringNullableListFilter<"HandoverPack">
    finalPhotosUrls?: StringNullableListFilter<"HandoverPack">
    guidesIncluded?: StringNullableListFilter<"HandoverPack">
    isGenerated?: BoolFilter<"HandoverPack"> | boolean
    generatedAt?: DateTimeNullableFilter<"HandoverPack"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"HandoverPack"> | Date | string | null
    clientAccessedAt?: DateTimeNullableFilter<"HandoverPack"> | Date | string | null
    createdAt?: DateTimeFilter<"HandoverPack"> | Date | string
    updatedAt?: DateTimeFilter<"HandoverPack"> | Date | string
    job?: XOR<JobRelationFilter, JobWhereInput>
  }, "id" | "jobId">

  export type HandoverPackOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    completionCertUrl?: SortOrderInput | SortOrder
    warrantyDocsUrls?: SortOrder
    finalPhotosUrls?: SortOrder
    guidesIncluded?: SortOrder
    isGenerated?: SortOrder
    generatedAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    clientAccessedAt?: SortOrderInput | SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HandoverPackCountOrderByAggregateInput
    _max?: HandoverPackMaxOrderByAggregateInput
    _min?: HandoverPackMinOrderByAggregateInput
  }

  export type HandoverPackScalarWhereWithAggregatesInput = {
    AND?: HandoverPackScalarWhereWithAggregatesInput | HandoverPackScalarWhereWithAggregatesInput[]
    OR?: HandoverPackScalarWhereWithAggregatesInput[]
    NOT?: HandoverPackScalarWhereWithAggregatesInput | HandoverPackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HandoverPack"> | string
    title?: StringWithAggregatesFilter<"HandoverPack"> | string
    description?: StringNullableWithAggregatesFilter<"HandoverPack"> | string | null
    completionCertUrl?: StringNullableWithAggregatesFilter<"HandoverPack"> | string | null
    warrantyDocsUrls?: StringNullableListFilter<"HandoverPack">
    finalPhotosUrls?: StringNullableListFilter<"HandoverPack">
    guidesIncluded?: StringNullableListFilter<"HandoverPack">
    isGenerated?: BoolWithAggregatesFilter<"HandoverPack"> | boolean
    generatedAt?: DateTimeNullableWithAggregatesFilter<"HandoverPack"> | Date | string | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"HandoverPack"> | Date | string | null
    clientAccessedAt?: DateTimeNullableWithAggregatesFilter<"HandoverPack"> | Date | string | null
    jobId?: StringWithAggregatesFilter<"HandoverPack"> | string
    createdAt?: DateTimeWithAggregatesFilter<"HandoverPack"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HandoverPack"> | Date | string
  }

  export type GuideWhereInput = {
    AND?: GuideWhereInput | GuideWhereInput[]
    OR?: GuideWhereInput[]
    NOT?: GuideWhereInput | GuideWhereInput[]
    id?: StringFilter<"Guide"> | string
    title?: StringFilter<"Guide"> | string
    slug?: StringFilter<"Guide"> | string
    content?: StringFilter<"Guide"> | string
    category?: EnumGuideCategoryFilter<"Guide"> | $Enums.GuideCategory
    tags?: StringNullableListFilter<"Guide">
    isPublished?: BoolFilter<"Guide"> | boolean
    featured?: BoolFilter<"Guide"> | boolean
    metaDescription?: StringNullableFilter<"Guide"> | string | null
    createdAt?: DateTimeFilter<"Guide"> | Date | string
    updatedAt?: DateTimeFilter<"Guide"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Guide"> | Date | string | null
  }

  export type GuideOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    isPublished?: SortOrder
    featured?: SortOrder
    metaDescription?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
  }

  export type GuideWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: GuideWhereInput | GuideWhereInput[]
    OR?: GuideWhereInput[]
    NOT?: GuideWhereInput | GuideWhereInput[]
    title?: StringFilter<"Guide"> | string
    content?: StringFilter<"Guide"> | string
    category?: EnumGuideCategoryFilter<"Guide"> | $Enums.GuideCategory
    tags?: StringNullableListFilter<"Guide">
    isPublished?: BoolFilter<"Guide"> | boolean
    featured?: BoolFilter<"Guide"> | boolean
    metaDescription?: StringNullableFilter<"Guide"> | string | null
    createdAt?: DateTimeFilter<"Guide"> | Date | string
    updatedAt?: DateTimeFilter<"Guide"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Guide"> | Date | string | null
  }, "id" | "slug">

  export type GuideOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    isPublished?: SortOrder
    featured?: SortOrder
    metaDescription?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    _count?: GuideCountOrderByAggregateInput
    _max?: GuideMaxOrderByAggregateInput
    _min?: GuideMinOrderByAggregateInput
  }

  export type GuideScalarWhereWithAggregatesInput = {
    AND?: GuideScalarWhereWithAggregatesInput | GuideScalarWhereWithAggregatesInput[]
    OR?: GuideScalarWhereWithAggregatesInput[]
    NOT?: GuideScalarWhereWithAggregatesInput | GuideScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Guide"> | string
    title?: StringWithAggregatesFilter<"Guide"> | string
    slug?: StringWithAggregatesFilter<"Guide"> | string
    content?: StringWithAggregatesFilter<"Guide"> | string
    category?: EnumGuideCategoryWithAggregatesFilter<"Guide"> | $Enums.GuideCategory
    tags?: StringNullableListFilter<"Guide">
    isPublished?: BoolWithAggregatesFilter<"Guide"> | boolean
    featured?: BoolWithAggregatesFilter<"Guide"> | boolean
    metaDescription?: StringNullableWithAggregatesFilter<"Guide"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Guide"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Guide"> | Date | string
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Guide"> | Date | string | null
  }

  export type EmailJourneyWhereInput = {
    AND?: EmailJourneyWhereInput | EmailJourneyWhereInput[]
    OR?: EmailJourneyWhereInput[]
    NOT?: EmailJourneyWhereInput | EmailJourneyWhereInput[]
    id?: StringFilter<"EmailJourney"> | string
    name?: StringFilter<"EmailJourney"> | string
    description?: StringNullableFilter<"EmailJourney"> | string | null
    isActive?: BoolFilter<"EmailJourney"> | boolean
    triggerEvent?: EnumEmailTriggerFilter<"EmailJourney"> | $Enums.EmailTrigger
    triggerConditions?: JsonFilter<"EmailJourney">
    totalSent?: IntFilter<"EmailJourney"> | number
    totalOpened?: IntFilter<"EmailJourney"> | number
    totalClicked?: IntFilter<"EmailJourney"> | number
    createdAt?: DateTimeFilter<"EmailJourney"> | Date | string
    updatedAt?: DateTimeFilter<"EmailJourney"> | Date | string
    emailSequence?: EmailSequenceStepListRelationFilter
  }

  export type EmailJourneyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    triggerEvent?: SortOrder
    triggerConditions?: SortOrder
    totalSent?: SortOrder
    totalOpened?: SortOrder
    totalClicked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailSequence?: EmailSequenceStepOrderByRelationAggregateInput
  }

  export type EmailJourneyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailJourneyWhereInput | EmailJourneyWhereInput[]
    OR?: EmailJourneyWhereInput[]
    NOT?: EmailJourneyWhereInput | EmailJourneyWhereInput[]
    name?: StringFilter<"EmailJourney"> | string
    description?: StringNullableFilter<"EmailJourney"> | string | null
    isActive?: BoolFilter<"EmailJourney"> | boolean
    triggerEvent?: EnumEmailTriggerFilter<"EmailJourney"> | $Enums.EmailTrigger
    triggerConditions?: JsonFilter<"EmailJourney">
    totalSent?: IntFilter<"EmailJourney"> | number
    totalOpened?: IntFilter<"EmailJourney"> | number
    totalClicked?: IntFilter<"EmailJourney"> | number
    createdAt?: DateTimeFilter<"EmailJourney"> | Date | string
    updatedAt?: DateTimeFilter<"EmailJourney"> | Date | string
    emailSequence?: EmailSequenceStepListRelationFilter
  }, "id">

  export type EmailJourneyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    triggerEvent?: SortOrder
    triggerConditions?: SortOrder
    totalSent?: SortOrder
    totalOpened?: SortOrder
    totalClicked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailJourneyCountOrderByAggregateInput
    _avg?: EmailJourneyAvgOrderByAggregateInput
    _max?: EmailJourneyMaxOrderByAggregateInput
    _min?: EmailJourneyMinOrderByAggregateInput
    _sum?: EmailJourneySumOrderByAggregateInput
  }

  export type EmailJourneyScalarWhereWithAggregatesInput = {
    AND?: EmailJourneyScalarWhereWithAggregatesInput | EmailJourneyScalarWhereWithAggregatesInput[]
    OR?: EmailJourneyScalarWhereWithAggregatesInput[]
    NOT?: EmailJourneyScalarWhereWithAggregatesInput | EmailJourneyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailJourney"> | string
    name?: StringWithAggregatesFilter<"EmailJourney"> | string
    description?: StringNullableWithAggregatesFilter<"EmailJourney"> | string | null
    isActive?: BoolWithAggregatesFilter<"EmailJourney"> | boolean
    triggerEvent?: EnumEmailTriggerWithAggregatesFilter<"EmailJourney"> | $Enums.EmailTrigger
    triggerConditions?: JsonWithAggregatesFilter<"EmailJourney">
    totalSent?: IntWithAggregatesFilter<"EmailJourney"> | number
    totalOpened?: IntWithAggregatesFilter<"EmailJourney"> | number
    totalClicked?: IntWithAggregatesFilter<"EmailJourney"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EmailJourney"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailJourney"> | Date | string
  }

  export type EmailSequenceStepWhereInput = {
    AND?: EmailSequenceStepWhereInput | EmailSequenceStepWhereInput[]
    OR?: EmailSequenceStepWhereInput[]
    NOT?: EmailSequenceStepWhereInput | EmailSequenceStepWhereInput[]
    id?: StringFilter<"EmailSequenceStep"> | string
    stepNumber?: IntFilter<"EmailSequenceStep"> | number
    templateId?: StringFilter<"EmailSequenceStep"> | string
    delayDays?: IntFilter<"EmailSequenceStep"> | number
    delayHours?: IntFilter<"EmailSequenceStep"> | number
    sendConditions?: JsonFilter<"EmailSequenceStep">
    journeyId?: StringFilter<"EmailSequenceStep"> | string
    journey?: XOR<EmailJourneyRelationFilter, EmailJourneyWhereInput>
  }

  export type EmailSequenceStepOrderByWithRelationInput = {
    id?: SortOrder
    stepNumber?: SortOrder
    templateId?: SortOrder
    delayDays?: SortOrder
    delayHours?: SortOrder
    sendConditions?: SortOrder
    journeyId?: SortOrder
    journey?: EmailJourneyOrderByWithRelationInput
  }

  export type EmailSequenceStepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    journeyId_stepNumber?: EmailSequenceStepJourneyIdStepNumberCompoundUniqueInput
    AND?: EmailSequenceStepWhereInput | EmailSequenceStepWhereInput[]
    OR?: EmailSequenceStepWhereInput[]
    NOT?: EmailSequenceStepWhereInput | EmailSequenceStepWhereInput[]
    stepNumber?: IntFilter<"EmailSequenceStep"> | number
    templateId?: StringFilter<"EmailSequenceStep"> | string
    delayDays?: IntFilter<"EmailSequenceStep"> | number
    delayHours?: IntFilter<"EmailSequenceStep"> | number
    sendConditions?: JsonFilter<"EmailSequenceStep">
    journeyId?: StringFilter<"EmailSequenceStep"> | string
    journey?: XOR<EmailJourneyRelationFilter, EmailJourneyWhereInput>
  }, "id" | "journeyId_stepNumber">

  export type EmailSequenceStepOrderByWithAggregationInput = {
    id?: SortOrder
    stepNumber?: SortOrder
    templateId?: SortOrder
    delayDays?: SortOrder
    delayHours?: SortOrder
    sendConditions?: SortOrder
    journeyId?: SortOrder
    _count?: EmailSequenceStepCountOrderByAggregateInput
    _avg?: EmailSequenceStepAvgOrderByAggregateInput
    _max?: EmailSequenceStepMaxOrderByAggregateInput
    _min?: EmailSequenceStepMinOrderByAggregateInput
    _sum?: EmailSequenceStepSumOrderByAggregateInput
  }

  export type EmailSequenceStepScalarWhereWithAggregatesInput = {
    AND?: EmailSequenceStepScalarWhereWithAggregatesInput | EmailSequenceStepScalarWhereWithAggregatesInput[]
    OR?: EmailSequenceStepScalarWhereWithAggregatesInput[]
    NOT?: EmailSequenceStepScalarWhereWithAggregatesInput | EmailSequenceStepScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailSequenceStep"> | string
    stepNumber?: IntWithAggregatesFilter<"EmailSequenceStep"> | number
    templateId?: StringWithAggregatesFilter<"EmailSequenceStep"> | string
    delayDays?: IntWithAggregatesFilter<"EmailSequenceStep"> | number
    delayHours?: IntWithAggregatesFilter<"EmailSequenceStep"> | number
    sendConditions?: JsonWithAggregatesFilter<"EmailSequenceStep">
    journeyId?: StringWithAggregatesFilter<"EmailSequenceStep"> | string
  }

  export type WebhookWhereInput = {
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    id?: StringFilter<"Webhook"> | string
    name?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    events?: EnumWebhookEventNullableListFilter<"Webhook">
    secret?: StringNullableFilter<"Webhook"> | string | null
    isActive?: BoolFilter<"Webhook"> | boolean
    totalDeliveries?: IntFilter<"Webhook"> | number
    lastDeliveryAt?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    lastSuccessAt?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    lastFailureAt?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
    deliveries?: WebhookDeliveryListRelationFilter
  }

  export type WebhookOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    events?: SortOrder
    secret?: SortOrderInput | SortOrder
    isActive?: SortOrder
    totalDeliveries?: SortOrder
    lastDeliveryAt?: SortOrderInput | SortOrder
    lastSuccessAt?: SortOrderInput | SortOrder
    lastFailureAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deliveries?: WebhookDeliveryOrderByRelationAggregateInput
  }

  export type WebhookWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    name?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    events?: EnumWebhookEventNullableListFilter<"Webhook">
    secret?: StringNullableFilter<"Webhook"> | string | null
    isActive?: BoolFilter<"Webhook"> | boolean
    totalDeliveries?: IntFilter<"Webhook"> | number
    lastDeliveryAt?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    lastSuccessAt?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    lastFailureAt?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
    deliveries?: WebhookDeliveryListRelationFilter
  }, "id">

  export type WebhookOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    events?: SortOrder
    secret?: SortOrderInput | SortOrder
    isActive?: SortOrder
    totalDeliveries?: SortOrder
    lastDeliveryAt?: SortOrderInput | SortOrder
    lastSuccessAt?: SortOrderInput | SortOrder
    lastFailureAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WebhookCountOrderByAggregateInput
    _avg?: WebhookAvgOrderByAggregateInput
    _max?: WebhookMaxOrderByAggregateInput
    _min?: WebhookMinOrderByAggregateInput
    _sum?: WebhookSumOrderByAggregateInput
  }

  export type WebhookScalarWhereWithAggregatesInput = {
    AND?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    OR?: WebhookScalarWhereWithAggregatesInput[]
    NOT?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Webhook"> | string
    name?: StringWithAggregatesFilter<"Webhook"> | string
    url?: StringWithAggregatesFilter<"Webhook"> | string
    events?: EnumWebhookEventNullableListFilter<"Webhook">
    secret?: StringNullableWithAggregatesFilter<"Webhook"> | string | null
    isActive?: BoolWithAggregatesFilter<"Webhook"> | boolean
    totalDeliveries?: IntWithAggregatesFilter<"Webhook"> | number
    lastDeliveryAt?: DateTimeNullableWithAggregatesFilter<"Webhook"> | Date | string | null
    lastSuccessAt?: DateTimeNullableWithAggregatesFilter<"Webhook"> | Date | string | null
    lastFailureAt?: DateTimeNullableWithAggregatesFilter<"Webhook"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Webhook"> | Date | string
  }

  export type WebhookDeliveryWhereInput = {
    AND?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    OR?: WebhookDeliveryWhereInput[]
    NOT?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    id?: StringFilter<"WebhookDelivery"> | string
    eventType?: EnumWebhookEventFilter<"WebhookDelivery"> | $Enums.WebhookEvent
    payload?: JsonFilter<"WebhookDelivery">
    httpStatus?: IntNullableFilter<"WebhookDelivery"> | number | null
    responseBody?: StringNullableFilter<"WebhookDelivery"> | string | null
    errorMessage?: StringNullableFilter<"WebhookDelivery"> | string | null
    deliveryAttempts?: IntFilter<"WebhookDelivery"> | number
    deliveredAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
    webhookId?: StringFilter<"WebhookDelivery"> | string
    createdAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
    webhook?: XOR<WebhookRelationFilter, WebhookWhereInput>
  }

  export type WebhookDeliveryOrderByWithRelationInput = {
    id?: SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    httpStatus?: SortOrderInput | SortOrder
    responseBody?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    deliveryAttempts?: SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    webhookId?: SortOrder
    createdAt?: SortOrder
    webhook?: WebhookOrderByWithRelationInput
  }

  export type WebhookDeliveryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    OR?: WebhookDeliveryWhereInput[]
    NOT?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    eventType?: EnumWebhookEventFilter<"WebhookDelivery"> | $Enums.WebhookEvent
    payload?: JsonFilter<"WebhookDelivery">
    httpStatus?: IntNullableFilter<"WebhookDelivery"> | number | null
    responseBody?: StringNullableFilter<"WebhookDelivery"> | string | null
    errorMessage?: StringNullableFilter<"WebhookDelivery"> | string | null
    deliveryAttempts?: IntFilter<"WebhookDelivery"> | number
    deliveredAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
    webhookId?: StringFilter<"WebhookDelivery"> | string
    createdAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
    webhook?: XOR<WebhookRelationFilter, WebhookWhereInput>
  }, "id">

  export type WebhookDeliveryOrderByWithAggregationInput = {
    id?: SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    httpStatus?: SortOrderInput | SortOrder
    responseBody?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    deliveryAttempts?: SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    webhookId?: SortOrder
    createdAt?: SortOrder
    _count?: WebhookDeliveryCountOrderByAggregateInput
    _avg?: WebhookDeliveryAvgOrderByAggregateInput
    _max?: WebhookDeliveryMaxOrderByAggregateInput
    _min?: WebhookDeliveryMinOrderByAggregateInput
    _sum?: WebhookDeliverySumOrderByAggregateInput
  }

  export type WebhookDeliveryScalarWhereWithAggregatesInput = {
    AND?: WebhookDeliveryScalarWhereWithAggregatesInput | WebhookDeliveryScalarWhereWithAggregatesInput[]
    OR?: WebhookDeliveryScalarWhereWithAggregatesInput[]
    NOT?: WebhookDeliveryScalarWhereWithAggregatesInput | WebhookDeliveryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebhookDelivery"> | string
    eventType?: EnumWebhookEventWithAggregatesFilter<"WebhookDelivery"> | $Enums.WebhookEvent
    payload?: JsonWithAggregatesFilter<"WebhookDelivery">
    httpStatus?: IntNullableWithAggregatesFilter<"WebhookDelivery"> | number | null
    responseBody?: StringNullableWithAggregatesFilter<"WebhookDelivery"> | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"WebhookDelivery"> | string | null
    deliveryAttempts?: IntWithAggregatesFilter<"WebhookDelivery"> | number
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"WebhookDelivery"> | Date | string | null
    webhookId?: StringWithAggregatesFilter<"WebhookDelivery"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WebhookDelivery"> | Date | string
  }

  export type EventLogWhereInput = {
    AND?: EventLogWhereInput | EventLogWhereInput[]
    OR?: EventLogWhereInput[]
    NOT?: EventLogWhereInput | EventLogWhereInput[]
    id?: StringFilter<"EventLog"> | string
    eventType?: StringFilter<"EventLog"> | string
    entityType?: StringFilter<"EventLog"> | string
    entityId?: StringFilter<"EventLog"> | string
    changes?: JsonFilter<"EventLog">
    metadata?: JsonFilter<"EventLog">
    ipAddress?: StringNullableFilter<"EventLog"> | string | null
    userAgent?: StringNullableFilter<"EventLog"> | string | null
    userId?: StringNullableFilter<"EventLog"> | string | null
    occurredAt?: DateTimeFilter<"EventLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type EventLogOrderByWithRelationInput = {
    id?: SortOrder
    eventType?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrder
    metadata?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    occurredAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type EventLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventLogWhereInput | EventLogWhereInput[]
    OR?: EventLogWhereInput[]
    NOT?: EventLogWhereInput | EventLogWhereInput[]
    eventType?: StringFilter<"EventLog"> | string
    entityType?: StringFilter<"EventLog"> | string
    entityId?: StringFilter<"EventLog"> | string
    changes?: JsonFilter<"EventLog">
    metadata?: JsonFilter<"EventLog">
    ipAddress?: StringNullableFilter<"EventLog"> | string | null
    userAgent?: StringNullableFilter<"EventLog"> | string | null
    userId?: StringNullableFilter<"EventLog"> | string | null
    occurredAt?: DateTimeFilter<"EventLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type EventLogOrderByWithAggregationInput = {
    id?: SortOrder
    eventType?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrder
    metadata?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    occurredAt?: SortOrder
    _count?: EventLogCountOrderByAggregateInput
    _max?: EventLogMaxOrderByAggregateInput
    _min?: EventLogMinOrderByAggregateInput
  }

  export type EventLogScalarWhereWithAggregatesInput = {
    AND?: EventLogScalarWhereWithAggregatesInput | EventLogScalarWhereWithAggregatesInput[]
    OR?: EventLogScalarWhereWithAggregatesInput[]
    NOT?: EventLogScalarWhereWithAggregatesInput | EventLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventLog"> | string
    eventType?: StringWithAggregatesFilter<"EventLog"> | string
    entityType?: StringWithAggregatesFilter<"EventLog"> | string
    entityId?: StringWithAggregatesFilter<"EventLog"> | string
    changes?: JsonWithAggregatesFilter<"EventLog">
    metadata?: JsonWithAggregatesFilter<"EventLog">
    ipAddress?: StringNullableWithAggregatesFilter<"EventLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"EventLog"> | string | null
    userId?: StringNullableWithAggregatesFilter<"EventLog"> | string | null
    occurredAt?: DateTimeWithAggregatesFilter<"EventLog"> | Date | string
  }

  export type IntegrationWhereInput = {
    AND?: IntegrationWhereInput | IntegrationWhereInput[]
    OR?: IntegrationWhereInput[]
    NOT?: IntegrationWhereInput | IntegrationWhereInput[]
    id?: StringFilter<"Integration"> | string
    name?: StringFilter<"Integration"> | string
    type?: EnumIntegrationTypeFilter<"Integration"> | $Enums.IntegrationType
    config?: JsonFilter<"Integration">
    isActive?: BoolFilter<"Integration"> | boolean
    lastSyncAt?: DateTimeNullableFilter<"Integration"> | Date | string | null
    nextSyncAt?: DateTimeNullableFilter<"Integration"> | Date | string | null
    syncErrors?: JsonFilter<"Integration">
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
  }

  export type IntegrationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    config?: SortOrder
    isActive?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    nextSyncAt?: SortOrderInput | SortOrder
    syncErrors?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IntegrationWhereInput | IntegrationWhereInput[]
    OR?: IntegrationWhereInput[]
    NOT?: IntegrationWhereInput | IntegrationWhereInput[]
    name?: StringFilter<"Integration"> | string
    type?: EnumIntegrationTypeFilter<"Integration"> | $Enums.IntegrationType
    config?: JsonFilter<"Integration">
    isActive?: BoolFilter<"Integration"> | boolean
    lastSyncAt?: DateTimeNullableFilter<"Integration"> | Date | string | null
    nextSyncAt?: DateTimeNullableFilter<"Integration"> | Date | string | null
    syncErrors?: JsonFilter<"Integration">
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
  }, "id">

  export type IntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    config?: SortOrder
    isActive?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    nextSyncAt?: SortOrderInput | SortOrder
    syncErrors?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntegrationCountOrderByAggregateInput
    _max?: IntegrationMaxOrderByAggregateInput
    _min?: IntegrationMinOrderByAggregateInput
  }

  export type IntegrationScalarWhereWithAggregatesInput = {
    AND?: IntegrationScalarWhereWithAggregatesInput | IntegrationScalarWhereWithAggregatesInput[]
    OR?: IntegrationScalarWhereWithAggregatesInput[]
    NOT?: IntegrationScalarWhereWithAggregatesInput | IntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Integration"> | string
    name?: StringWithAggregatesFilter<"Integration"> | string
    type?: EnumIntegrationTypeWithAggregatesFilter<"Integration"> | $Enums.IntegrationType
    config?: JsonWithAggregatesFilter<"Integration">
    isActive?: BoolWithAggregatesFilter<"Integration"> | boolean
    lastSyncAt?: DateTimeNullableWithAggregatesFilter<"Integration"> | Date | string | null
    nextSyncAt?: DateTimeNullableWithAggregatesFilter<"Integration"> | Date | string | null
    syncErrors?: JsonWithAggregatesFilter<"Integration">
    createdAt?: DateTimeWithAggregatesFilter<"Integration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Integration"> | Date | string
  }

  export type MergeQueueWhereInput = {
    AND?: MergeQueueWhereInput | MergeQueueWhereInput[]
    OR?: MergeQueueWhereInput[]
    NOT?: MergeQueueWhereInput | MergeQueueWhereInput[]
    id?: StringFilter<"MergeQueue"> | string
    entityType?: StringFilter<"MergeQueue"> | string
    primaryEntityId?: StringFilter<"MergeQueue"> | string
    duplicateEntityId?: StringFilter<"MergeQueue"> | string
    status?: EnumMergeStatusFilter<"MergeQueue"> | $Enums.MergeStatus
    mergeRules?: JsonFilter<"MergeQueue">
    reviewedById?: StringNullableFilter<"MergeQueue"> | string | null
    reviewedAt?: DateTimeNullableFilter<"MergeQueue"> | Date | string | null
    mergedAt?: DateTimeNullableFilter<"MergeQueue"> | Date | string | null
    createdAt?: DateTimeFilter<"MergeQueue"> | Date | string
    reviewedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type MergeQueueOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    primaryEntityId?: SortOrder
    duplicateEntityId?: SortOrder
    status?: SortOrder
    mergeRules?: SortOrder
    reviewedById?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    mergedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    reviewedBy?: UserOrderByWithRelationInput
  }

  export type MergeQueueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MergeQueueWhereInput | MergeQueueWhereInput[]
    OR?: MergeQueueWhereInput[]
    NOT?: MergeQueueWhereInput | MergeQueueWhereInput[]
    entityType?: StringFilter<"MergeQueue"> | string
    primaryEntityId?: StringFilter<"MergeQueue"> | string
    duplicateEntityId?: StringFilter<"MergeQueue"> | string
    status?: EnumMergeStatusFilter<"MergeQueue"> | $Enums.MergeStatus
    mergeRules?: JsonFilter<"MergeQueue">
    reviewedById?: StringNullableFilter<"MergeQueue"> | string | null
    reviewedAt?: DateTimeNullableFilter<"MergeQueue"> | Date | string | null
    mergedAt?: DateTimeNullableFilter<"MergeQueue"> | Date | string | null
    createdAt?: DateTimeFilter<"MergeQueue"> | Date | string
    reviewedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type MergeQueueOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    primaryEntityId?: SortOrder
    duplicateEntityId?: SortOrder
    status?: SortOrder
    mergeRules?: SortOrder
    reviewedById?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    mergedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MergeQueueCountOrderByAggregateInput
    _max?: MergeQueueMaxOrderByAggregateInput
    _min?: MergeQueueMinOrderByAggregateInput
  }

  export type MergeQueueScalarWhereWithAggregatesInput = {
    AND?: MergeQueueScalarWhereWithAggregatesInput | MergeQueueScalarWhereWithAggregatesInput[]
    OR?: MergeQueueScalarWhereWithAggregatesInput[]
    NOT?: MergeQueueScalarWhereWithAggregatesInput | MergeQueueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MergeQueue"> | string
    entityType?: StringWithAggregatesFilter<"MergeQueue"> | string
    primaryEntityId?: StringWithAggregatesFilter<"MergeQueue"> | string
    duplicateEntityId?: StringWithAggregatesFilter<"MergeQueue"> | string
    status?: EnumMergeStatusWithAggregatesFilter<"MergeQueue"> | $Enums.MergeStatus
    mergeRules?: JsonWithAggregatesFilter<"MergeQueue">
    reviewedById?: StringNullableWithAggregatesFilter<"MergeQueue"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"MergeQueue"> | Date | string | null
    mergedAt?: DateTimeNullableWithAggregatesFilter<"MergeQueue"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MergeQueue"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatedByInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionCreateNestedManyWithoutDesignerInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentCreateNestedManyWithoutAuthorInput
    snagReports?: SnagCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutDesignerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientUncheckedCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobUncheckedCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput
    snagReports?: SnagUncheckedCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogUncheckedCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUncheckedUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUncheckedUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUncheckedUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUncheckedUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientCreateInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedClientsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedClientsInput
    owner: UserCreateNestedOneWithoutOwnedClientsInput
    contacts?: ContactCreateNestedManyWithoutClientInput
    leads?: LeadCreateNestedManyWithoutClientInput
    deals?: DealCreateNestedManyWithoutClientInput
    rooms?: RoomCreateNestedManyWithoutClientInput
    jobs?: JobCreateNestedManyWithoutClientInput
    activities?: ActivityCreateNestedManyWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    appointments?: AppointmentCreateNestedManyWithoutClientInput
    moodboards?: MoodboardCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownerId: string
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    leads?: LeadUncheckedCreateNestedManyWithoutClientInput
    deals?: DealUncheckedCreateNestedManyWithoutClientInput
    rooms?: RoomUncheckedCreateNestedManyWithoutClientInput
    jobs?: JobUncheckedCreateNestedManyWithoutClientInput
    activities?: ActivityUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClientInput
    moodboards?: MoodboardUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedClientsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedClientsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedClientsNestedInput
    contacts?: ContactUpdateManyWithoutClientNestedInput
    leads?: LeadUpdateManyWithoutClientNestedInput
    deals?: DealUpdateManyWithoutClientNestedInput
    rooms?: RoomUpdateManyWithoutClientNestedInput
    jobs?: JobUpdateManyWithoutClientNestedInput
    activities?: ActivityUpdateManyWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUpdateManyWithoutClientNestedInput
    moodboards?: MoodboardUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    leads?: LeadUncheckedUpdateManyWithoutClientNestedInput
    deals?: DealUncheckedUpdateManyWithoutClientNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutClientNestedInput
    jobs?: JobUncheckedUpdateManyWithoutClientNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClientNestedInput
    moodboards?: MoodboardUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownerId: string
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    jobTitle?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    client: ClientCreateNestedOneWithoutContactsInput
    activities?: ActivityCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    jobTitle?: string | null
    isPrimary?: boolean
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutContactsNestedInput
    activities?: ActivityUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    jobTitle?: string | null
    isPrimary?: boolean
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeadCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    client: ClientCreateNestedOneWithoutLeadsInput
    owner: UserCreateNestedOneWithoutOwnedLeadsInput
    deal?: DealCreateNestedOneWithoutLeadInput
    activities?: ActivityCreateNestedManyWithoutLeadInput
    tasks?: TaskCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    clientId: string
    ownerId: string
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutLeadInput
    tasks?: TaskUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutLeadsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedLeadsNestedInput
    deal?: DealUpdateOneWithoutLeadNestedInput
    activities?: ActivityUpdateManyWithoutLeadNestedInput
    tasks?: TaskUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutLeadNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    clientId: string
    ownerId: string
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
  }

  export type LeadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DealCreateInput = {
    id?: string
    title: string
    description?: string | null
    value: Decimal | DecimalJsLike | number | string
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    stage: PipelineStageCreateNestedOneWithoutDealsInput
    client: ClientCreateNestedOneWithoutDealsInput
    owner: UserCreateNestedOneWithoutOwnedDealsInput
    lead?: LeadCreateNestedOneWithoutDealInput
    job?: JobCreateNestedOneWithoutDealInput
    activities?: ActivityCreateNestedManyWithoutDealInput
    tasks?: TaskCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    value: Decimal | DecimalJsLike | number | string
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    stageId: string
    clientId: string
    ownerId: string
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    lead?: LeadUncheckedCreateNestedOneWithoutDealInput
    activities?: ActivityUncheckedCreateNestedManyWithoutDealInput
    tasks?: TaskUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: PipelineStageUpdateOneRequiredWithoutDealsNestedInput
    client?: ClientUpdateOneRequiredWithoutDealsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedDealsNestedInput
    lead?: LeadUpdateOneWithoutDealNestedInput
    job?: JobUpdateOneWithoutDealNestedInput
    activities?: ActivityUpdateManyWithoutDealNestedInput
    tasks?: TaskUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stageId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    lead?: LeadUncheckedUpdateOneWithoutDealNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutDealNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    value: Decimal | DecimalJsLike | number | string
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    stageId: string
    clientId: string
    ownerId: string
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
  }

  export type DealUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DealUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stageId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PipelineStageCreateInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    probability?: number
    isClosedWon?: boolean
    isClosedLost?: boolean
    autoTasks?: JsonNullValueInput | InputJsonValue
    autoEmails?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deals?: DealCreateNestedManyWithoutStageInput
  }

  export type PipelineStageUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    probability?: number
    isClosedWon?: boolean
    isClosedLost?: boolean
    autoTasks?: JsonNullValueInput | InputJsonValue
    autoEmails?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deals?: DealUncheckedCreateNestedManyWithoutStageInput
  }

  export type PipelineStageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    isClosedWon?: BoolFieldUpdateOperationsInput | boolean
    isClosedLost?: BoolFieldUpdateOperationsInput | boolean
    autoTasks?: JsonNullValueInput | InputJsonValue
    autoEmails?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deals?: DealUpdateManyWithoutStageNestedInput
  }

  export type PipelineStageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    isClosedWon?: BoolFieldUpdateOperationsInput | boolean
    isClosedLost?: BoolFieldUpdateOperationsInput | boolean
    autoTasks?: JsonNullValueInput | InputJsonValue
    autoEmails?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deals?: DealUncheckedUpdateManyWithoutStageNestedInput
  }

  export type PipelineStageCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    probability?: number
    isClosedWon?: boolean
    isClosedLost?: boolean
    autoTasks?: JsonNullValueInput | InputJsonValue
    autoEmails?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PipelineStageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    isClosedWon?: BoolFieldUpdateOperationsInput | boolean
    isClosedLost?: BoolFieldUpdateOperationsInput | boolean
    autoTasks?: JsonNullValueInput | InputJsonValue
    autoEmails?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineStageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    isClosedWon?: BoolFieldUpdateOperationsInput | boolean
    isClosedLost?: BoolFieldUpdateOperationsInput | boolean
    autoTasks?: JsonNullValueInput | InputJsonValue
    autoEmails?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    description?: string | null
    direction?: $Enums.Direction | null
    duration?: number | null
    outcome?: string | null
    emailMessageId?: string | null
    callRecordingUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutActivitiesInput
    client?: ClientCreateNestedOneWithoutActivitiesInput
    contact?: ContactCreateNestedOneWithoutActivitiesInput
    lead?: LeadCreateNestedOneWithoutActivitiesInput
    deal?: DealCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    description?: string | null
    direction?: $Enums.Direction | null
    duration?: number | null
    outcome?: string | null
    userId: string
    clientId?: string | null
    contactId?: string | null
    leadId?: string | null
    dealId?: string | null
    emailMessageId?: string | null
    callRecordingUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: NullableEnumDirectionFieldUpdateOperationsInput | $Enums.Direction | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    emailMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    callRecordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput
    client?: ClientUpdateOneWithoutActivitiesNestedInput
    contact?: ContactUpdateOneWithoutActivitiesNestedInput
    lead?: LeadUpdateOneWithoutActivitiesNestedInput
    deal?: DealUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: NullableEnumDirectionFieldUpdateOperationsInput | $Enums.Direction | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    emailMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    callRecordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActivityCreateManyInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    description?: string | null
    direction?: $Enums.Direction | null
    duration?: number | null
    outcome?: string | null
    userId: string
    clientId?: string | null
    contactId?: string | null
    leadId?: string | null
    dealId?: string | null
    emailMessageId?: string | null
    callRecordingUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: NullableEnumDirectionFieldUpdateOperationsInput | $Enums.Direction | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    emailMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    callRecordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: NullableEnumDirectionFieldUpdateOperationsInput | $Enums.Direction | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    emailMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    callRecordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    clientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignee: UserCreateNestedOneWithoutAssignedTasksInput
    createdBy: UserCreateNestedOneWithoutCreatedTasksInput
    lead?: LeadCreateNestedOneWithoutTasksInput
    deal?: DealCreateNestedOneWithoutTasksInput
    job?: JobCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    assigneeId: string
    createdById: string
    clientId?: string | null
    leadId?: string | null
    dealId?: string | null
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignee?: UserUpdateOneRequiredWithoutAssignedTasksNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTasksNestedInput
    lead?: LeadUpdateOneWithoutTasksNestedInput
    deal?: DealUpdateOneWithoutTasksNestedInput
    job?: JobUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    assigneeId: string
    createdById: string
    clientId?: string | null
    leadId?: string | null
    dealId?: string | null
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    meetingUrl?: string | null
    status?: $Enums.AppointmentStatus
    outlookEventId?: string | null
    calendarSynced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAppointmentsInput
    client: ClientCreateNestedOneWithoutAppointmentsInput
    job?: JobCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    meetingUrl?: string | null
    status?: $Enums.AppointmentStatus
    userId: string
    clientId: string
    jobId?: string | null
    outlookEventId?: string | null
    calendarSynced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    outlookEventId?: NullableStringFieldUpdateOperationsInput | string | null
    calendarSynced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    client?: ClientUpdateOneRequiredWithoutAppointmentsNestedInput
    job?: JobUpdateOneWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    userId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    outlookEventId?: NullableStringFieldUpdateOperationsInput | string | null
    calendarSynced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    meetingUrl?: string | null
    status?: $Enums.AppointmentStatus
    userId: string
    clientId: string
    jobId?: string | null
    outlookEventId?: string | null
    calendarSynced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    outlookEventId?: NullableStringFieldUpdateOperationsInput | string | null
    calendarSynced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    userId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    outlookEventId?: NullableStringFieldUpdateOperationsInput | string | null
    calendarSynced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomCreateInput = {
    id?: string
    name: string
    type: $Enums.RoomType
    length?: number | null
    width?: number | null
    height?: number | null
    currentCondition?: string | null
    accessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutRoomsInput
    jobs?: JobCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.RoomType
    length?: number | null
    width?: number | null
    height?: number | null
    currentCondition?: string | null
    accessNotes?: string | null
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    length?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    currentCondition?: NullableStringFieldUpdateOperationsInput | string | null
    accessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutRoomsNestedInput
    jobs?: JobUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    length?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    currentCondition?: NullableStringFieldUpdateOperationsInput | string | null
    accessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomCreateManyInput = {
    id?: string
    name: string
    type: $Enums.RoomType
    length?: number | null
    width?: number | null
    height?: number | null
    currentCondition?: string | null
    accessNotes?: string | null
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    length?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    currentCondition?: NullableStringFieldUpdateOperationsInput | string | null
    accessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    length?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    currentCondition?: NullableStringFieldUpdateOperationsInput | string | null
    accessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobCreateInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutJobsInput
    room: RoomCreateNestedOneWithoutJobsInput
    deal?: DealCreateNestedOneWithoutJobInput
    installerCompany?: InstallerCompanyCreateNestedOneWithoutJobsInput
    designer?: UserCreateNestedOneWithoutDesignerJobsInput
    tasks?: TaskCreateNestedManyWithoutJobInput
    appointments?: AppointmentCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionCreateNestedManyWithoutJobInput
    snags?: SnagCreateNestedManyWithoutJobInput
    documents?: DocumentCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemCreateNestedManyWithoutJobInput
    moodboards?: MoodboardCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    clientId: string
    roomId: string
    dealId?: string | null
    installerCompanyId?: string | null
    designerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deal?: DealUncheckedCreateNestedOneWithoutJobInput
    tasks?: TaskUncheckedCreateNestedManyWithoutJobInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutJobInput
    snags?: SnagUncheckedCreateNestedManyWithoutJobInput
    documents?: DocumentUncheckedCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemUncheckedCreateNestedManyWithoutJobInput
    moodboards?: MoodboardUncheckedCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutJobsNestedInput
    room?: RoomUpdateOneRequiredWithoutJobsNestedInput
    deal?: DealUpdateOneWithoutJobNestedInput
    installerCompany?: InstallerCompanyUpdateOneWithoutJobsNestedInput
    designer?: UserUpdateOneWithoutDesignerJobsNestedInput
    tasks?: TaskUpdateManyWithoutJobNestedInput
    appointments?: AppointmentUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUpdateManyWithoutJobNestedInput
    snags?: SnagUpdateManyWithoutJobNestedInput
    documents?: DocumentUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    installerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    designerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUncheckedUpdateOneWithoutJobNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutJobNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutJobNestedInput
    snags?: SnagUncheckedUpdateManyWithoutJobNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUncheckedUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUncheckedUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobCreateManyInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    clientId: string
    roomId: string
    dealId?: string | null
    installerCompanyId?: string | null
    designerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    installerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    designerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobDayLogCreateInput = {
    id?: string
    date: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    lunchStart?: Date | string | null
    lunchEnd?: Date | string | null
    checkInLatitude?: Decimal | DecimalJsLike | number | string | null
    checkInLongitude?: Decimal | DecimalJsLike | number | string | null
    checkInAddress?: string | null
    workCompleted?: string | null
    materialsUsed?: string | null
    issuesEncountered?: string | null
    startFormData?: NullableJsonNullValueInput | InputJsonValue
    dailyFormData?: NullableJsonNullValueInput | InputJsonValue
    endFormData?: NullableJsonNullValueInput | InputJsonValue
    photos?: JobDayLogCreatephotosInput | string[]
    isCompliant?: boolean
    complianceNotes?: string | null
    syncStatus?: $Enums.SyncStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutJobDayLogsInput
    job: JobCreateNestedOneWithoutJobDayLogsInput
  }

  export type JobDayLogUncheckedCreateInput = {
    id?: string
    date: Date | string
    userId: string
    jobId: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    lunchStart?: Date | string | null
    lunchEnd?: Date | string | null
    checkInLatitude?: Decimal | DecimalJsLike | number | string | null
    checkInLongitude?: Decimal | DecimalJsLike | number | string | null
    checkInAddress?: string | null
    workCompleted?: string | null
    materialsUsed?: string | null
    issuesEncountered?: string | null
    startFormData?: NullableJsonNullValueInput | InputJsonValue
    dailyFormData?: NullableJsonNullValueInput | InputJsonValue
    endFormData?: NullableJsonNullValueInput | InputJsonValue
    photos?: JobDayLogCreatephotosInput | string[]
    isCompliant?: boolean
    complianceNotes?: string | null
    syncStatus?: $Enums.SyncStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobDayLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lunchStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lunchEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInLatitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    checkInLongitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    checkInAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workCompleted?: NullableStringFieldUpdateOperationsInput | string | null
    materialsUsed?: NullableStringFieldUpdateOperationsInput | string | null
    issuesEncountered?: NullableStringFieldUpdateOperationsInput | string | null
    startFormData?: NullableJsonNullValueInput | InputJsonValue
    dailyFormData?: NullableJsonNullValueInput | InputJsonValue
    endFormData?: NullableJsonNullValueInput | InputJsonValue
    photos?: JobDayLogUpdatephotosInput | string[]
    isCompliant?: BoolFieldUpdateOperationsInput | boolean
    complianceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutJobDayLogsNestedInput
    job?: JobUpdateOneRequiredWithoutJobDayLogsNestedInput
  }

  export type JobDayLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lunchStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lunchEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInLatitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    checkInLongitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    checkInAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workCompleted?: NullableStringFieldUpdateOperationsInput | string | null
    materialsUsed?: NullableStringFieldUpdateOperationsInput | string | null
    issuesEncountered?: NullableStringFieldUpdateOperationsInput | string | null
    startFormData?: NullableJsonNullValueInput | InputJsonValue
    dailyFormData?: NullableJsonNullValueInput | InputJsonValue
    endFormData?: NullableJsonNullValueInput | InputJsonValue
    photos?: JobDayLogUpdatephotosInput | string[]
    isCompliant?: BoolFieldUpdateOperationsInput | boolean
    complianceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobDayLogCreateManyInput = {
    id?: string
    date: Date | string
    userId: string
    jobId: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    lunchStart?: Date | string | null
    lunchEnd?: Date | string | null
    checkInLatitude?: Decimal | DecimalJsLike | number | string | null
    checkInLongitude?: Decimal | DecimalJsLike | number | string | null
    checkInAddress?: string | null
    workCompleted?: string | null
    materialsUsed?: string | null
    issuesEncountered?: string | null
    startFormData?: NullableJsonNullValueInput | InputJsonValue
    dailyFormData?: NullableJsonNullValueInput | InputJsonValue
    endFormData?: NullableJsonNullValueInput | InputJsonValue
    photos?: JobDayLogCreatephotosInput | string[]
    isCompliant?: boolean
    complianceNotes?: string | null
    syncStatus?: $Enums.SyncStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobDayLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lunchStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lunchEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInLatitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    checkInLongitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    checkInAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workCompleted?: NullableStringFieldUpdateOperationsInput | string | null
    materialsUsed?: NullableStringFieldUpdateOperationsInput | string | null
    issuesEncountered?: NullableStringFieldUpdateOperationsInput | string | null
    startFormData?: NullableJsonNullValueInput | InputJsonValue
    dailyFormData?: NullableJsonNullValueInput | InputJsonValue
    endFormData?: NullableJsonNullValueInput | InputJsonValue
    photos?: JobDayLogUpdatephotosInput | string[]
    isCompliant?: BoolFieldUpdateOperationsInput | boolean
    complianceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobDayLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lunchStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lunchEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInLatitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    checkInLongitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    checkInAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workCompleted?: NullableStringFieldUpdateOperationsInput | string | null
    materialsUsed?: NullableStringFieldUpdateOperationsInput | string | null
    issuesEncountered?: NullableStringFieldUpdateOperationsInput | string | null
    startFormData?: NullableJsonNullValueInput | InputJsonValue
    dailyFormData?: NullableJsonNullValueInput | InputJsonValue
    endFormData?: NullableJsonNullValueInput | InputJsonValue
    photos?: JobDayLogUpdatephotosInput | string[]
    isCompliant?: BoolFieldUpdateOperationsInput | boolean
    complianceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstallerCompanyCreateInput = {
    id?: string
    name: string
    contactEmail: string
    contactPhone: string
    address?: string | null
    insuranceExpiry?: Date | string | null
    dbsExpiry?: Date | string | null
    contractSigned?: boolean
    contractSignedAt?: Date | string | null
    isActive?: boolean
    isSuspended?: boolean
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutInstallerCompaniesInput
    teamMembers?: InstallerTeamMemberCreateNestedManyWithoutCompanyInput
    jobs?: JobCreateNestedManyWithoutInstallerCompanyInput
  }

  export type InstallerCompanyUncheckedCreateInput = {
    id?: string
    name: string
    contactEmail: string
    contactPhone: string
    address?: string | null
    insuranceExpiry?: Date | string | null
    dbsExpiry?: Date | string | null
    contractSigned?: boolean
    contractSignedAt?: Date | string | null
    isActive?: boolean
    isSuspended?: boolean
    suspensionReason?: string | null
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMembers?: InstallerTeamMemberUncheckedCreateNestedManyWithoutCompanyInput
    jobs?: JobUncheckedCreateNestedManyWithoutInstallerCompanyInput
  }

  export type InstallerCompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dbsExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractSigned?: BoolFieldUpdateOperationsInput | boolean
    contractSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutInstallerCompaniesNestedInput
    teamMembers?: InstallerTeamMemberUpdateManyWithoutCompanyNestedInput
    jobs?: JobUpdateManyWithoutInstallerCompanyNestedInput
  }

  export type InstallerCompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dbsExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractSigned?: BoolFieldUpdateOperationsInput | boolean
    contractSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMembers?: InstallerTeamMemberUncheckedUpdateManyWithoutCompanyNestedInput
    jobs?: JobUncheckedUpdateManyWithoutInstallerCompanyNestedInput
  }

  export type InstallerCompanyCreateManyInput = {
    id?: string
    name: string
    contactEmail: string
    contactPhone: string
    address?: string | null
    insuranceExpiry?: Date | string | null
    dbsExpiry?: Date | string | null
    contractSigned?: boolean
    contractSignedAt?: Date | string | null
    isActive?: boolean
    isSuspended?: boolean
    suspensionReason?: string | null
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstallerCompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dbsExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractSigned?: BoolFieldUpdateOperationsInput | boolean
    contractSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstallerCompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dbsExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractSigned?: BoolFieldUpdateOperationsInput | boolean
    contractSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstallerTeamMemberCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    dbsExpiry?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: InstallerCompanyCreateNestedOneWithoutTeamMembersInput
  }

  export type InstallerTeamMemberUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    dbsExpiry?: Date | string | null
    isActive?: boolean
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstallerTeamMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dbsExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: InstallerCompanyUpdateOneRequiredWithoutTeamMembersNestedInput
  }

  export type InstallerTeamMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dbsExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstallerTeamMemberCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    dbsExpiry?: Date | string | null
    isActive?: boolean
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstallerTeamMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dbsExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstallerTeamMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dbsExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignVersionCreateInput = {
    id?: string
    version?: number
    title: string
    description?: string | null
    status?: $Enums.DesignStatus
    renderUrls?: DesignVersionCreaterenderUrlsInput | string[]
    planUrls?: DesignVersionCreateplanUrlsInput | string[]
    specSheetUrl?: string | null
    isClientVisible?: boolean
    clientViewedAt?: Date | string | null
    clientApprovedAt?: Date | string | null
    clientFeedback?: string | null
    isFinal?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    job: JobCreateNestedOneWithoutDesignVersionsInput
    designer: UserCreateNestedOneWithoutDesignVersionsInput
    clashTickets?: DesignClashTicketCreateNestedManyWithoutDesignVersionInput
  }

  export type DesignVersionUncheckedCreateInput = {
    id?: string
    version?: number
    title: string
    description?: string | null
    status?: $Enums.DesignStatus
    renderUrls?: DesignVersionCreaterenderUrlsInput | string[]
    planUrls?: DesignVersionCreateplanUrlsInput | string[]
    specSheetUrl?: string | null
    isClientVisible?: boolean
    clientViewedAt?: Date | string | null
    clientApprovedAt?: Date | string | null
    clientFeedback?: string | null
    jobId: string
    designerId: string
    isFinal?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clashTickets?: DesignClashTicketUncheckedCreateNestedManyWithoutDesignVersionInput
  }

  export type DesignVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDesignStatusFieldUpdateOperationsInput | $Enums.DesignStatus
    renderUrls?: DesignVersionUpdaterenderUrlsInput | string[]
    planUrls?: DesignVersionUpdateplanUrlsInput | string[]
    specSheetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutDesignVersionsNestedInput
    designer?: UserUpdateOneRequiredWithoutDesignVersionsNestedInput
    clashTickets?: DesignClashTicketUpdateManyWithoutDesignVersionNestedInput
  }

  export type DesignVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDesignStatusFieldUpdateOperationsInput | $Enums.DesignStatus
    renderUrls?: DesignVersionUpdaterenderUrlsInput | string[]
    planUrls?: DesignVersionUpdateplanUrlsInput | string[]
    specSheetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: StringFieldUpdateOperationsInput | string
    designerId?: StringFieldUpdateOperationsInput | string
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clashTickets?: DesignClashTicketUncheckedUpdateManyWithoutDesignVersionNestedInput
  }

  export type DesignVersionCreateManyInput = {
    id?: string
    version?: number
    title: string
    description?: string | null
    status?: $Enums.DesignStatus
    renderUrls?: DesignVersionCreaterenderUrlsInput | string[]
    planUrls?: DesignVersionCreateplanUrlsInput | string[]
    specSheetUrl?: string | null
    isClientVisible?: boolean
    clientViewedAt?: Date | string | null
    clientApprovedAt?: Date | string | null
    clientFeedback?: string | null
    jobId: string
    designerId: string
    isFinal?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDesignStatusFieldUpdateOperationsInput | $Enums.DesignStatus
    renderUrls?: DesignVersionUpdaterenderUrlsInput | string[]
    planUrls?: DesignVersionUpdateplanUrlsInput | string[]
    specSheetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDesignStatusFieldUpdateOperationsInput | $Enums.DesignStatus
    renderUrls?: DesignVersionUpdaterenderUrlsInput | string[]
    planUrls?: DesignVersionUpdateplanUrlsInput | string[]
    specSheetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: StringFieldUpdateOperationsInput | string
    designerId?: StringFieldUpdateOperationsInput | string
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignClashTicketCreateInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ClashStatus
    priority?: $Enums.Priority
    photoUrls?: DesignClashTicketCreatephotoUrlsInput | string[]
    resolution?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    designVersion: DesignVersionCreateNestedOneWithoutClashTicketsInput
    reportedBy: UserCreateNestedOneWithoutClashReportsInput
    assignedTo?: UserCreateNestedOneWithoutClashAssignmentsInput
  }

  export type DesignClashTicketUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ClashStatus
    priority?: $Enums.Priority
    photoUrls?: DesignClashTicketCreatephotoUrlsInput | string[]
    resolution?: string | null
    resolvedAt?: Date | string | null
    designVersionId: string
    reportedById: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignClashTicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumClashStatusFieldUpdateOperationsInput | $Enums.ClashStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    photoUrls?: DesignClashTicketUpdatephotoUrlsInput | string[]
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    designVersion?: DesignVersionUpdateOneRequiredWithoutClashTicketsNestedInput
    reportedBy?: UserUpdateOneRequiredWithoutClashReportsNestedInput
    assignedTo?: UserUpdateOneWithoutClashAssignmentsNestedInput
  }

  export type DesignClashTicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumClashStatusFieldUpdateOperationsInput | $Enums.ClashStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    photoUrls?: DesignClashTicketUpdatephotoUrlsInput | string[]
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designVersionId?: StringFieldUpdateOperationsInput | string
    reportedById?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignClashTicketCreateManyInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ClashStatus
    priority?: $Enums.Priority
    photoUrls?: DesignClashTicketCreatephotoUrlsInput | string[]
    resolution?: string | null
    resolvedAt?: Date | string | null
    designVersionId: string
    reportedById: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignClashTicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumClashStatusFieldUpdateOperationsInput | $Enums.ClashStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    photoUrls?: DesignClashTicketUpdatephotoUrlsInput | string[]
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignClashTicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumClashStatusFieldUpdateOperationsInput | $Enums.ClashStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    photoUrls?: DesignClashTicketUpdatephotoUrlsInput | string[]
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designVersionId?: StringFieldUpdateOperationsInput | string
    reportedById?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodboardCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.MoodboardStatus
    isClientVisible?: boolean
    clientLastViewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutMoodboardsInput
    job?: JobCreateNestedOneWithoutMoodboardsInput
    items?: MoodboardItemCreateNestedManyWithoutMoodboardInput
  }

  export type MoodboardUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.MoodboardStatus
    clientId: string
    jobId?: string | null
    isClientVisible?: boolean
    clientLastViewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: MoodboardItemUncheckedCreateNestedManyWithoutMoodboardInput
  }

  export type MoodboardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMoodboardStatusFieldUpdateOperationsInput | $Enums.MoodboardStatus
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientLastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutMoodboardsNestedInput
    job?: JobUpdateOneWithoutMoodboardsNestedInput
    items?: MoodboardItemUpdateManyWithoutMoodboardNestedInput
  }

  export type MoodboardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMoodboardStatusFieldUpdateOperationsInput | $Enums.MoodboardStatus
    clientId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientLastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: MoodboardItemUncheckedUpdateManyWithoutMoodboardNestedInput
  }

  export type MoodboardCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.MoodboardStatus
    clientId: string
    jobId?: string | null
    isClientVisible?: boolean
    clientLastViewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MoodboardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMoodboardStatusFieldUpdateOperationsInput | $Enums.MoodboardStatus
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientLastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodboardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMoodboardStatusFieldUpdateOperationsInput | $Enums.MoodboardStatus
    clientId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientLastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodboardItemCreateInput = {
    id?: string
    title?: string | null
    description?: string | null
    imageUrl: string
    sourceUrl?: string | null
    category?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clientComments?: MoodboardCommentCreateNestedManyWithoutItemInput
    moodboard: MoodboardCreateNestedOneWithoutItemsInput
  }

  export type MoodboardItemUncheckedCreateInput = {
    id?: string
    title?: string | null
    description?: string | null
    imageUrl: string
    sourceUrl?: string | null
    category?: string | null
    order?: number
    moodboardId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientComments?: MoodboardCommentUncheckedCreateNestedManyWithoutItemInput
  }

  export type MoodboardItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientComments?: MoodboardCommentUpdateManyWithoutItemNestedInput
    moodboard?: MoodboardUpdateOneRequiredWithoutItemsNestedInput
  }

  export type MoodboardItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    moodboardId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientComments?: MoodboardCommentUncheckedUpdateManyWithoutItemNestedInput
  }

  export type MoodboardItemCreateManyInput = {
    id?: string
    title?: string | null
    description?: string | null
    imageUrl: string
    sourceUrl?: string | null
    category?: string | null
    order?: number
    moodboardId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MoodboardItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodboardItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    moodboardId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodboardCommentCreateInput = {
    id?: string
    content: string
    xPosition: number
    yPosition: number
    authorName?: string | null
    createdAt?: Date | string
    author?: UserCreateNestedOneWithoutMoodboardCommentsInput
    item: MoodboardItemCreateNestedOneWithoutClientCommentsInput
  }

  export type MoodboardCommentUncheckedCreateInput = {
    id?: string
    content: string
    xPosition: number
    yPosition: number
    authorId?: string | null
    authorName?: string | null
    itemId: string
    createdAt?: Date | string
  }

  export type MoodboardCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    xPosition?: FloatFieldUpdateOperationsInput | number
    yPosition?: FloatFieldUpdateOperationsInput | number
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneWithoutMoodboardCommentsNestedInput
    item?: MoodboardItemUpdateOneRequiredWithoutClientCommentsNestedInput
  }

  export type MoodboardCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    xPosition?: FloatFieldUpdateOperationsInput | number
    yPosition?: FloatFieldUpdateOperationsInput | number
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodboardCommentCreateManyInput = {
    id?: string
    content: string
    xPosition: number
    yPosition: number
    authorId?: string | null
    authorName?: string | null
    itemId: string
    createdAt?: Date | string
  }

  export type MoodboardCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    xPosition?: FloatFieldUpdateOperationsInput | number
    yPosition?: FloatFieldUpdateOperationsInput | number
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodboardCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    xPosition?: FloatFieldUpdateOperationsInput | number
    yPosition?: FloatFieldUpdateOperationsInput | number
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedSpecItemCreateInput = {
    id?: string
    originalText: string
    parsedCategory?: string | null
    parsedBrand?: string | null
    parsedModel?: string | null
    parsedDescription?: string | null
    parsedQuantity?: number | null
    parsedPrice?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.SpecItemStatus
    notes?: string | null
    substitution?: string | null
    actualPrice?: Decimal | DecimalJsLike | number | string | null
    parseConfidence: number
    requiresReview?: boolean
    sourceDocumentId?: string | null
    sourcePage?: number | null
    sourceLineNumber?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    job: JobCreateNestedOneWithoutParsedSpecItemsInput
  }

  export type ParsedSpecItemUncheckedCreateInput = {
    id?: string
    originalText: string
    parsedCategory?: string | null
    parsedBrand?: string | null
    parsedModel?: string | null
    parsedDescription?: string | null
    parsedQuantity?: number | null
    parsedPrice?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.SpecItemStatus
    notes?: string | null
    substitution?: string | null
    actualPrice?: Decimal | DecimalJsLike | number | string | null
    parseConfidence: number
    requiresReview?: boolean
    jobId: string
    sourceDocumentId?: string | null
    sourcePage?: number | null
    sourceLineNumber?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParsedSpecItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    parsedCategory?: NullableStringFieldUpdateOperationsInput | string | null
    parsedBrand?: NullableStringFieldUpdateOperationsInput | string | null
    parsedModel?: NullableStringFieldUpdateOperationsInput | string | null
    parsedDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parsedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    parsedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumSpecItemStatusFieldUpdateOperationsInput | $Enums.SpecItemStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    substitution?: NullableStringFieldUpdateOperationsInput | string | null
    actualPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    parseConfidence?: FloatFieldUpdateOperationsInput | number
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    sourceDocumentId?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePage?: NullableIntFieldUpdateOperationsInput | number | null
    sourceLineNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutParsedSpecItemsNestedInput
  }

  export type ParsedSpecItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    parsedCategory?: NullableStringFieldUpdateOperationsInput | string | null
    parsedBrand?: NullableStringFieldUpdateOperationsInput | string | null
    parsedModel?: NullableStringFieldUpdateOperationsInput | string | null
    parsedDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parsedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    parsedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumSpecItemStatusFieldUpdateOperationsInput | $Enums.SpecItemStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    substitution?: NullableStringFieldUpdateOperationsInput | string | null
    actualPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    parseConfidence?: FloatFieldUpdateOperationsInput | number
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    jobId?: StringFieldUpdateOperationsInput | string
    sourceDocumentId?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePage?: NullableIntFieldUpdateOperationsInput | number | null
    sourceLineNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedSpecItemCreateManyInput = {
    id?: string
    originalText: string
    parsedCategory?: string | null
    parsedBrand?: string | null
    parsedModel?: string | null
    parsedDescription?: string | null
    parsedQuantity?: number | null
    parsedPrice?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.SpecItemStatus
    notes?: string | null
    substitution?: string | null
    actualPrice?: Decimal | DecimalJsLike | number | string | null
    parseConfidence: number
    requiresReview?: boolean
    jobId: string
    sourceDocumentId?: string | null
    sourcePage?: number | null
    sourceLineNumber?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParsedSpecItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    parsedCategory?: NullableStringFieldUpdateOperationsInput | string | null
    parsedBrand?: NullableStringFieldUpdateOperationsInput | string | null
    parsedModel?: NullableStringFieldUpdateOperationsInput | string | null
    parsedDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parsedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    parsedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumSpecItemStatusFieldUpdateOperationsInput | $Enums.SpecItemStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    substitution?: NullableStringFieldUpdateOperationsInput | string | null
    actualPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    parseConfidence?: FloatFieldUpdateOperationsInput | number
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    sourceDocumentId?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePage?: NullableIntFieldUpdateOperationsInput | number | null
    sourceLineNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedSpecItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    parsedCategory?: NullableStringFieldUpdateOperationsInput | string | null
    parsedBrand?: NullableStringFieldUpdateOperationsInput | string | null
    parsedModel?: NullableStringFieldUpdateOperationsInput | string | null
    parsedDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parsedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    parsedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumSpecItemStatusFieldUpdateOperationsInput | $Enums.SpecItemStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    substitution?: NullableStringFieldUpdateOperationsInput | string | null
    actualPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    parseConfidence?: FloatFieldUpdateOperationsInput | number
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    jobId?: StringFieldUpdateOperationsInput | string
    sourceDocumentId?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePage?: NullableIntFieldUpdateOperationsInput | number | null
    sourceLineNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnagCreateInput = {
    id?: string
    title: string
    description: string
    category: $Enums.SnagCategory
    severity?: $Enums.Priority
    status?: $Enums.SnagStatus
    photoUrls?: SnagCreatephotoUrlsInput | string[]
    isClientVisible?: boolean
    clientNotified?: boolean
    resolution?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    job: JobCreateNestedOneWithoutSnagsInput
    reportedBy: UserCreateNestedOneWithoutSnagReportsInput
    assignedTo?: UserCreateNestedOneWithoutSnagAssignmentsInput
  }

  export type SnagUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    category: $Enums.SnagCategory
    severity?: $Enums.Priority
    status?: $Enums.SnagStatus
    photoUrls?: SnagCreatephotoUrlsInput | string[]
    isClientVisible?: boolean
    clientNotified?: boolean
    resolution?: string | null
    resolvedAt?: Date | string | null
    jobId: string
    reportedById: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SnagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumSnagCategoryFieldUpdateOperationsInput | $Enums.SnagCategory
    severity?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumSnagStatusFieldUpdateOperationsInput | $Enums.SnagStatus
    photoUrls?: SnagUpdatephotoUrlsInput | string[]
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientNotified?: BoolFieldUpdateOperationsInput | boolean
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutSnagsNestedInput
    reportedBy?: UserUpdateOneRequiredWithoutSnagReportsNestedInput
    assignedTo?: UserUpdateOneWithoutSnagAssignmentsNestedInput
  }

  export type SnagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumSnagCategoryFieldUpdateOperationsInput | $Enums.SnagCategory
    severity?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumSnagStatusFieldUpdateOperationsInput | $Enums.SnagStatus
    photoUrls?: SnagUpdatephotoUrlsInput | string[]
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientNotified?: BoolFieldUpdateOperationsInput | boolean
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobId?: StringFieldUpdateOperationsInput | string
    reportedById?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnagCreateManyInput = {
    id?: string
    title: string
    description: string
    category: $Enums.SnagCategory
    severity?: $Enums.Priority
    status?: $Enums.SnagStatus
    photoUrls?: SnagCreatephotoUrlsInput | string[]
    isClientVisible?: boolean
    clientNotified?: boolean
    resolution?: string | null
    resolvedAt?: Date | string | null
    jobId: string
    reportedById: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SnagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumSnagCategoryFieldUpdateOperationsInput | $Enums.SnagCategory
    severity?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumSnagStatusFieldUpdateOperationsInput | $Enums.SnagStatus
    photoUrls?: SnagUpdatephotoUrlsInput | string[]
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientNotified?: BoolFieldUpdateOperationsInput | boolean
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumSnagCategoryFieldUpdateOperationsInput | $Enums.SnagCategory
    severity?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumSnagStatusFieldUpdateOperationsInput | $Enums.SnagStatus
    photoUrls?: SnagUpdatephotoUrlsInput | string[]
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientNotified?: BoolFieldUpdateOperationsInput | boolean
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobId?: StringFieldUpdateOperationsInput | string
    reportedById?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    filename: string
    originalFilename: string
    mimeType: string
    fileSize: number
    storageUrl: string
    category: $Enums.DocumentCategory
    description?: string | null
    isPublic?: boolean
    virusScanStatus?: $Enums.VirusScanStatus
    virusScanResult?: string | null
    createdAt?: Date | string
    client?: ClientCreateNestedOneWithoutDocumentsInput
    deal?: DealCreateNestedOneWithoutDocumentsInput
    job?: JobCreateNestedOneWithoutDocumentsInput
    uploadedBy: UserCreateNestedOneWithoutUploadedDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    filename: string
    originalFilename: string
    mimeType: string
    fileSize: number
    storageUrl: string
    category: $Enums.DocumentCategory
    description?: string | null
    isPublic?: boolean
    virusScanStatus?: $Enums.VirusScanStatus
    virusScanResult?: string | null
    clientId?: string | null
    dealId?: string | null
    jobId?: string | null
    createdAt?: Date | string
    uploadedById: string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    virusScanStatus?: EnumVirusScanStatusFieldUpdateOperationsInput | $Enums.VirusScanStatus
    virusScanResult?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutDocumentsNestedInput
    deal?: DealUpdateOneWithoutDocumentsNestedInput
    job?: JobUpdateOneWithoutDocumentsNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    virusScanStatus?: EnumVirusScanStatusFieldUpdateOperationsInput | $Enums.VirusScanStatus
    virusScanResult?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    filename: string
    originalFilename: string
    mimeType: string
    fileSize: number
    storageUrl: string
    category: $Enums.DocumentCategory
    description?: string | null
    isPublic?: boolean
    virusScanStatus?: $Enums.VirusScanStatus
    virusScanResult?: string | null
    clientId?: string | null
    dealId?: string | null
    jobId?: string | null
    createdAt?: Date | string
    uploadedById: string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    virusScanStatus?: EnumVirusScanStatusFieldUpdateOperationsInput | $Enums.VirusScanStatus
    virusScanResult?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    virusScanStatus?: EnumVirusScanStatusFieldUpdateOperationsInput | $Enums.VirusScanStatus
    virusScanResult?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type FormTemplateCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.FormCategory
    schema: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    submissions?: FormSubmissionCreateNestedManyWithoutTemplateInput
  }

  export type FormTemplateUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.FormCategory
    schema: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    submissions?: FormSubmissionUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type FormTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumFormCategoryFieldUpdateOperationsInput | $Enums.FormCategory
    schema?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissions?: FormSubmissionUpdateManyWithoutTemplateNestedInput
  }

  export type FormTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumFormCategoryFieldUpdateOperationsInput | $Enums.FormCategory
    schema?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissions?: FormSubmissionUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type FormTemplateCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.FormCategory
    schema: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumFormCategoryFieldUpdateOperationsInput | $Enums.FormCategory
    schema?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumFormCategoryFieldUpdateOperationsInput | $Enums.FormCategory
    schema?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionCreateInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    submissionSource?: $Enums.SubmissionSource
    clientId?: string | null
    jobId?: string | null
    submittedAt?: Date | string
    template: FormTemplateCreateNestedOneWithoutSubmissionsInput
    submittedBy?: UserCreateNestedOneWithoutFormSubmissionsInput
  }

  export type FormSubmissionUncheckedCreateInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    submissionSource?: $Enums.SubmissionSource
    templateId: string
    submittedById?: string | null
    clientId?: string | null
    jobId?: string | null
    submittedAt?: Date | string
  }

  export type FormSubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    submissionSource?: EnumSubmissionSourceFieldUpdateOperationsInput | $Enums.SubmissionSource
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: FormTemplateUpdateOneRequiredWithoutSubmissionsNestedInput
    submittedBy?: UserUpdateOneWithoutFormSubmissionsNestedInput
  }

  export type FormSubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    submissionSource?: EnumSubmissionSourceFieldUpdateOperationsInput | $Enums.SubmissionSource
    templateId?: StringFieldUpdateOperationsInput | string
    submittedById?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionCreateManyInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    submissionSource?: $Enums.SubmissionSource
    templateId: string
    submittedById?: string | null
    clientId?: string | null
    jobId?: string | null
    submittedAt?: Date | string
  }

  export type FormSubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    submissionSource?: EnumSubmissionSourceFieldUpdateOperationsInput | $Enums.SubmissionSource
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    submissionSource?: EnumSubmissionSourceFieldUpdateOperationsInput | $Enums.SubmissionSource
    templateId?: StringFieldUpdateOperationsInput | string
    submittedById?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HandoverPackCreateInput = {
    id?: string
    title: string
    description?: string | null
    completionCertUrl?: string | null
    warrantyDocsUrls?: HandoverPackCreatewarrantyDocsUrlsInput | string[]
    finalPhotosUrls?: HandoverPackCreatefinalPhotosUrlsInput | string[]
    guidesIncluded?: HandoverPackCreateguidesIncludedInput | string[]
    isGenerated?: boolean
    generatedAt?: Date | string | null
    deliveredAt?: Date | string | null
    clientAccessedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    job: JobCreateNestedOneWithoutHandoverPacksInput
  }

  export type HandoverPackUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    completionCertUrl?: string | null
    warrantyDocsUrls?: HandoverPackCreatewarrantyDocsUrlsInput | string[]
    finalPhotosUrls?: HandoverPackCreatefinalPhotosUrlsInput | string[]
    guidesIncluded?: HandoverPackCreateguidesIncludedInput | string[]
    isGenerated?: boolean
    generatedAt?: Date | string | null
    deliveredAt?: Date | string | null
    clientAccessedAt?: Date | string | null
    jobId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HandoverPackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    completionCertUrl?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyDocsUrls?: HandoverPackUpdatewarrantyDocsUrlsInput | string[]
    finalPhotosUrls?: HandoverPackUpdatefinalPhotosUrlsInput | string[]
    guidesIncluded?: HandoverPackUpdateguidesIncludedInput | string[]
    isGenerated?: BoolFieldUpdateOperationsInput | boolean
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutHandoverPacksNestedInput
  }

  export type HandoverPackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    completionCertUrl?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyDocsUrls?: HandoverPackUpdatewarrantyDocsUrlsInput | string[]
    finalPhotosUrls?: HandoverPackUpdatefinalPhotosUrlsInput | string[]
    guidesIncluded?: HandoverPackUpdateguidesIncludedInput | string[]
    isGenerated?: BoolFieldUpdateOperationsInput | boolean
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HandoverPackCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    completionCertUrl?: string | null
    warrantyDocsUrls?: HandoverPackCreatewarrantyDocsUrlsInput | string[]
    finalPhotosUrls?: HandoverPackCreatefinalPhotosUrlsInput | string[]
    guidesIncluded?: HandoverPackCreateguidesIncludedInput | string[]
    isGenerated?: boolean
    generatedAt?: Date | string | null
    deliveredAt?: Date | string | null
    clientAccessedAt?: Date | string | null
    jobId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HandoverPackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    completionCertUrl?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyDocsUrls?: HandoverPackUpdatewarrantyDocsUrlsInput | string[]
    finalPhotosUrls?: HandoverPackUpdatefinalPhotosUrlsInput | string[]
    guidesIncluded?: HandoverPackUpdateguidesIncludedInput | string[]
    isGenerated?: BoolFieldUpdateOperationsInput | boolean
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HandoverPackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    completionCertUrl?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyDocsUrls?: HandoverPackUpdatewarrantyDocsUrlsInput | string[]
    finalPhotosUrls?: HandoverPackUpdatefinalPhotosUrlsInput | string[]
    guidesIncluded?: HandoverPackUpdateguidesIncludedInput | string[]
    isGenerated?: BoolFieldUpdateOperationsInput | boolean
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuideCreateInput = {
    id?: string
    title: string
    slug: string
    content: string
    category: $Enums.GuideCategory
    tags?: GuideCreatetagsInput | string[]
    isPublished?: boolean
    featured?: boolean
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
  }

  export type GuideUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    content: string
    category: $Enums.GuideCategory
    tags?: GuideCreatetagsInput | string[]
    isPublished?: boolean
    featured?: boolean
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
  }

  export type GuideUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: EnumGuideCategoryFieldUpdateOperationsInput | $Enums.GuideCategory
    tags?: GuideUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    featured?: BoolFieldUpdateOperationsInput | boolean
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GuideUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: EnumGuideCategoryFieldUpdateOperationsInput | $Enums.GuideCategory
    tags?: GuideUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    featured?: BoolFieldUpdateOperationsInput | boolean
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GuideCreateManyInput = {
    id?: string
    title: string
    slug: string
    content: string
    category: $Enums.GuideCategory
    tags?: GuideCreatetagsInput | string[]
    isPublished?: boolean
    featured?: boolean
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
  }

  export type GuideUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: EnumGuideCategoryFieldUpdateOperationsInput | $Enums.GuideCategory
    tags?: GuideUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    featured?: BoolFieldUpdateOperationsInput | boolean
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GuideUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: EnumGuideCategoryFieldUpdateOperationsInput | $Enums.GuideCategory
    tags?: GuideUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    featured?: BoolFieldUpdateOperationsInput | boolean
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailJourneyCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    triggerEvent: $Enums.EmailTrigger
    triggerConditions?: JsonNullValueInput | InputJsonValue
    totalSent?: number
    totalOpened?: number
    totalClicked?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailSequence?: EmailSequenceStepCreateNestedManyWithoutJourneyInput
  }

  export type EmailJourneyUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    triggerEvent: $Enums.EmailTrigger
    triggerConditions?: JsonNullValueInput | InputJsonValue
    totalSent?: number
    totalOpened?: number
    totalClicked?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailSequence?: EmailSequenceStepUncheckedCreateNestedManyWithoutJourneyInput
  }

  export type EmailJourneyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    triggerEvent?: EnumEmailTriggerFieldUpdateOperationsInput | $Enums.EmailTrigger
    triggerConditions?: JsonNullValueInput | InputJsonValue
    totalSent?: IntFieldUpdateOperationsInput | number
    totalOpened?: IntFieldUpdateOperationsInput | number
    totalClicked?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailSequence?: EmailSequenceStepUpdateManyWithoutJourneyNestedInput
  }

  export type EmailJourneyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    triggerEvent?: EnumEmailTriggerFieldUpdateOperationsInput | $Enums.EmailTrigger
    triggerConditions?: JsonNullValueInput | InputJsonValue
    totalSent?: IntFieldUpdateOperationsInput | number
    totalOpened?: IntFieldUpdateOperationsInput | number
    totalClicked?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailSequence?: EmailSequenceStepUncheckedUpdateManyWithoutJourneyNestedInput
  }

  export type EmailJourneyCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    triggerEvent: $Enums.EmailTrigger
    triggerConditions?: JsonNullValueInput | InputJsonValue
    totalSent?: number
    totalOpened?: number
    totalClicked?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailJourneyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    triggerEvent?: EnumEmailTriggerFieldUpdateOperationsInput | $Enums.EmailTrigger
    triggerConditions?: JsonNullValueInput | InputJsonValue
    totalSent?: IntFieldUpdateOperationsInput | number
    totalOpened?: IntFieldUpdateOperationsInput | number
    totalClicked?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailJourneyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    triggerEvent?: EnumEmailTriggerFieldUpdateOperationsInput | $Enums.EmailTrigger
    triggerConditions?: JsonNullValueInput | InputJsonValue
    totalSent?: IntFieldUpdateOperationsInput | number
    totalOpened?: IntFieldUpdateOperationsInput | number
    totalClicked?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSequenceStepCreateInput = {
    id?: string
    stepNumber: number
    templateId: string
    delayDays?: number
    delayHours?: number
    sendConditions?: JsonNullValueInput | InputJsonValue
    journey: EmailJourneyCreateNestedOneWithoutEmailSequenceInput
  }

  export type EmailSequenceStepUncheckedCreateInput = {
    id?: string
    stepNumber: number
    templateId: string
    delayDays?: number
    delayHours?: number
    sendConditions?: JsonNullValueInput | InputJsonValue
    journeyId: string
  }

  export type EmailSequenceStepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    templateId?: StringFieldUpdateOperationsInput | string
    delayDays?: IntFieldUpdateOperationsInput | number
    delayHours?: IntFieldUpdateOperationsInput | number
    sendConditions?: JsonNullValueInput | InputJsonValue
    journey?: EmailJourneyUpdateOneRequiredWithoutEmailSequenceNestedInput
  }

  export type EmailSequenceStepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    templateId?: StringFieldUpdateOperationsInput | string
    delayDays?: IntFieldUpdateOperationsInput | number
    delayHours?: IntFieldUpdateOperationsInput | number
    sendConditions?: JsonNullValueInput | InputJsonValue
    journeyId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailSequenceStepCreateManyInput = {
    id?: string
    stepNumber: number
    templateId: string
    delayDays?: number
    delayHours?: number
    sendConditions?: JsonNullValueInput | InputJsonValue
    journeyId: string
  }

  export type EmailSequenceStepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    templateId?: StringFieldUpdateOperationsInput | string
    delayDays?: IntFieldUpdateOperationsInput | number
    delayHours?: IntFieldUpdateOperationsInput | number
    sendConditions?: JsonNullValueInput | InputJsonValue
  }

  export type EmailSequenceStepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    templateId?: StringFieldUpdateOperationsInput | string
    delayDays?: IntFieldUpdateOperationsInput | number
    delayHours?: IntFieldUpdateOperationsInput | number
    sendConditions?: JsonNullValueInput | InputJsonValue
    journeyId?: StringFieldUpdateOperationsInput | string
  }

  export type WebhookCreateInput = {
    id?: string
    name: string
    url: string
    events?: WebhookCreateeventsInput | $Enums.WebhookEvent[]
    secret?: string | null
    isActive?: boolean
    totalDeliveries?: number
    lastDeliveryAt?: Date | string | null
    lastSuccessAt?: Date | string | null
    lastFailureAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: WebhookDeliveryCreateNestedManyWithoutWebhookInput
  }

  export type WebhookUncheckedCreateInput = {
    id?: string
    name: string
    url: string
    events?: WebhookCreateeventsInput | $Enums.WebhookEvent[]
    secret?: string | null
    isActive?: boolean
    totalDeliveries?: number
    lastDeliveryAt?: Date | string | null
    lastSuccessAt?: Date | string | null
    lastFailureAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutWebhookInput
  }

  export type WebhookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | $Enums.WebhookEvent[]
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    lastDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailureAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: WebhookDeliveryUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | $Enums.WebhookEvent[]
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    lastDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailureAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: WebhookDeliveryUncheckedUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookCreateManyInput = {
    id?: string
    name: string
    url: string
    events?: WebhookCreateeventsInput | $Enums.WebhookEvent[]
    secret?: string | null
    isActive?: boolean
    totalDeliveries?: number
    lastDeliveryAt?: Date | string | null
    lastSuccessAt?: Date | string | null
    lastFailureAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | $Enums.WebhookEvent[]
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    lastDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailureAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | $Enums.WebhookEvent[]
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    lastDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailureAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryCreateInput = {
    id?: string
    eventType: $Enums.WebhookEvent
    payload: JsonNullValueInput | InputJsonValue
    httpStatus?: number | null
    responseBody?: string | null
    errorMessage?: string | null
    deliveryAttempts?: number
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    webhook: WebhookCreateNestedOneWithoutDeliveriesInput
  }

  export type WebhookDeliveryUncheckedCreateInput = {
    id?: string
    eventType: $Enums.WebhookEvent
    payload: JsonNullValueInput | InputJsonValue
    httpStatus?: number | null
    responseBody?: string | null
    errorMessage?: string | null
    deliveryAttempts?: number
    deliveredAt?: Date | string | null
    webhookId: string
    createdAt?: Date | string
  }

  export type WebhookDeliveryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWebhookEventFieldUpdateOperationsInput | $Enums.WebhookEvent
    payload?: JsonNullValueInput | InputJsonValue
    httpStatus?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAttempts?: IntFieldUpdateOperationsInput | number
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    webhook?: WebhookUpdateOneRequiredWithoutDeliveriesNestedInput
  }

  export type WebhookDeliveryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWebhookEventFieldUpdateOperationsInput | $Enums.WebhookEvent
    payload?: JsonNullValueInput | InputJsonValue
    httpStatus?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAttempts?: IntFieldUpdateOperationsInput | number
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webhookId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryCreateManyInput = {
    id?: string
    eventType: $Enums.WebhookEvent
    payload: JsonNullValueInput | InputJsonValue
    httpStatus?: number | null
    responseBody?: string | null
    errorMessage?: string | null
    deliveryAttempts?: number
    deliveredAt?: Date | string | null
    webhookId: string
    createdAt?: Date | string
  }

  export type WebhookDeliveryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWebhookEventFieldUpdateOperationsInput | $Enums.WebhookEvent
    payload?: JsonNullValueInput | InputJsonValue
    httpStatus?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAttempts?: IntFieldUpdateOperationsInput | number
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWebhookEventFieldUpdateOperationsInput | $Enums.WebhookEvent
    payload?: JsonNullValueInput | InputJsonValue
    httpStatus?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAttempts?: IntFieldUpdateOperationsInput | number
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webhookId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventLogCreateInput = {
    id?: string
    eventType: string
    entityType: string
    entityId: string
    changes: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    occurredAt?: Date | string
    user?: UserCreateNestedOneWithoutEventLogsInput
  }

  export type EventLogUncheckedCreateInput = {
    id?: string
    eventType: string
    entityType: string
    entityId: string
    changes: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    userId?: string | null
    occurredAt?: Date | string
  }

  export type EventLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEventLogsNestedInput
  }

  export type EventLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventLogCreateManyInput = {
    id?: string
    eventType: string
    entityType: string
    entityId: string
    changes: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    userId?: string | null
    occurredAt?: Date | string
  }

  export type EventLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCreateInput = {
    id?: string
    name: string
    type: $Enums.IntegrationType
    config?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastSyncAt?: Date | string | null
    nextSyncAt?: Date | string | null
    syncErrors?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.IntegrationType
    config?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastSyncAt?: Date | string | null
    nextSyncAt?: Date | string | null
    syncErrors?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncErrors?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncErrors?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCreateManyInput = {
    id?: string
    name: string
    type: $Enums.IntegrationType
    config?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastSyncAt?: Date | string | null
    nextSyncAt?: Date | string | null
    syncErrors?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncErrors?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncErrors?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MergeQueueCreateInput = {
    id?: string
    entityType: string
    primaryEntityId: string
    duplicateEntityId: string
    status?: $Enums.MergeStatus
    mergeRules: JsonNullValueInput | InputJsonValue
    reviewedAt?: Date | string | null
    mergedAt?: Date | string | null
    createdAt?: Date | string
    reviewedBy?: UserCreateNestedOneWithoutMergeReviewsInput
  }

  export type MergeQueueUncheckedCreateInput = {
    id?: string
    entityType: string
    primaryEntityId: string
    duplicateEntityId: string
    status?: $Enums.MergeStatus
    mergeRules: JsonNullValueInput | InputJsonValue
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    mergedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MergeQueueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    primaryEntityId?: StringFieldUpdateOperationsInput | string
    duplicateEntityId?: StringFieldUpdateOperationsInput | string
    status?: EnumMergeStatusFieldUpdateOperationsInput | $Enums.MergeStatus
    mergeRules?: JsonNullValueInput | InputJsonValue
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mergedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: UserUpdateOneWithoutMergeReviewsNestedInput
  }

  export type MergeQueueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    primaryEntityId?: StringFieldUpdateOperationsInput | string
    duplicateEntityId?: StringFieldUpdateOperationsInput | string
    status?: EnumMergeStatusFieldUpdateOperationsInput | $Enums.MergeStatus
    mergeRules?: JsonNullValueInput | InputJsonValue
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mergedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MergeQueueCreateManyInput = {
    id?: string
    entityType: string
    primaryEntityId: string
    duplicateEntityId: string
    status?: $Enums.MergeStatus
    mergeRules: JsonNullValueInput | InputJsonValue
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    mergedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MergeQueueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    primaryEntityId?: StringFieldUpdateOperationsInput | string
    duplicateEntityId?: StringFieldUpdateOperationsInput | string
    status?: EnumMergeStatusFieldUpdateOperationsInput | $Enums.MergeStatus
    mergeRules?: JsonNullValueInput | InputJsonValue
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mergedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MergeQueueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    primaryEntityId?: StringFieldUpdateOperationsInput | string
    duplicateEntityId?: StringFieldUpdateOperationsInput | string
    status?: EnumMergeStatusFieldUpdateOperationsInput | $Enums.MergeStatus
    mergeRules?: JsonNullValueInput | InputJsonValue
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mergedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ClientListRelationFilter = {
    every?: ClientWhereInput
    some?: ClientWhereInput
    none?: ClientWhereInput
  }

  export type LeadListRelationFilter = {
    every?: LeadWhereInput
    some?: LeadWhereInput
    none?: LeadWhereInput
  }

  export type DealListRelationFilter = {
    every?: DealWhereInput
    some?: DealWhereInput
    none?: DealWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type JobDayLogListRelationFilter = {
    every?: JobDayLogWhereInput
    some?: JobDayLogWhereInput
    none?: JobDayLogWhereInput
  }

  export type DesignVersionListRelationFilter = {
    every?: DesignVersionWhereInput
    some?: DesignVersionWhereInput
    none?: DesignVersionWhereInput
  }

  export type JobListRelationFilter = {
    every?: JobWhereInput
    some?: JobWhereInput
    none?: JobWhereInput
  }

  export type InstallerCompanyListRelationFilter = {
    every?: InstallerCompanyWhereInput
    some?: InstallerCompanyWhereInput
    none?: InstallerCompanyWhereInput
  }

  export type DesignClashTicketListRelationFilter = {
    every?: DesignClashTicketWhereInput
    some?: DesignClashTicketWhereInput
    none?: DesignClashTicketWhereInput
  }

  export type MoodboardCommentListRelationFilter = {
    every?: MoodboardCommentWhereInput
    some?: MoodboardCommentWhereInput
    none?: MoodboardCommentWhereInput
  }

  export type SnagListRelationFilter = {
    every?: SnagWhereInput
    some?: SnagWhereInput
    none?: SnagWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type FormSubmissionListRelationFilter = {
    every?: FormSubmissionWhereInput
    some?: FormSubmissionWhereInput
    none?: FormSubmissionWhereInput
  }

  export type EventLogListRelationFilter = {
    every?: EventLogWhereInput
    some?: EventLogWhereInput
    none?: EventLogWhereInput
  }

  export type MergeQueueListRelationFilter = {
    every?: MergeQueueWhereInput
    some?: MergeQueueWhereInput
    none?: MergeQueueWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DealOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobDayLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DesignVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstallerCompanyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DesignClashTicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MoodboardCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SnagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MergeQueueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    emailVerifiedAt?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorEnabled?: SortOrder
    avatarUrl?: SortOrder
    timezone?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    emailVerifiedAt?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorEnabled?: SortOrder
    avatarUrl?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    emailVerifiedAt?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorEnabled?: SortOrder
    avatarUrl?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumClientTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClientTypeFilter<$PrismaModel> | $Enums.ClientType
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type RoomListRelationFilter = {
    every?: RoomWhereInput
    some?: RoomWhereInput
    none?: RoomWhereInput
  }

  export type MoodboardListRelationFilter = {
    every?: MoodboardWhereInput
    some?: MoodboardWhereInput
    none?: MoodboardWhereInput
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MoodboardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    mobile?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    county?: SortOrder
    postcode?: SortOrder
    country?: SortOrder
    clientType?: SortOrder
    leadSource?: SortOrder
    referralSource?: SortOrder
    portalKey?: SortOrder
    portalLastAccessAt?: SortOrder
    marketingConsent?: SortOrder
    marketingConsentDate?: SortOrder
    emailConsent?: SortOrder
    smsConsent?: SortOrder
    callRecordingConsent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    ownerId?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    mobile?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    county?: SortOrder
    postcode?: SortOrder
    country?: SortOrder
    clientType?: SortOrder
    leadSource?: SortOrder
    referralSource?: SortOrder
    portalKey?: SortOrder
    portalLastAccessAt?: SortOrder
    marketingConsent?: SortOrder
    marketingConsentDate?: SortOrder
    emailConsent?: SortOrder
    smsConsent?: SortOrder
    callRecordingConsent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    ownerId?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    mobile?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    county?: SortOrder
    postcode?: SortOrder
    country?: SortOrder
    clientType?: SortOrder
    leadSource?: SortOrder
    referralSource?: SortOrder
    portalKey?: SortOrder
    portalLastAccessAt?: SortOrder
    marketingConsent?: SortOrder
    marketingConsentDate?: SortOrder
    emailConsent?: SortOrder
    smsConsent?: SortOrder
    callRecordingConsent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    ownerId?: SortOrder
  }

  export type EnumClientTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClientTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClientType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientTypeFilter<$PrismaModel>
    _max?: NestedEnumClientTypeFilter<$PrismaModel>
  }

  export type ClientRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    mobile?: SortOrder
    jobTitle?: SortOrder
    isPrimary?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    mobile?: SortOrder
    jobTitle?: SortOrder
    isPrimary?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    mobile?: SortOrder
    jobTitle?: SortOrder
    isPrimary?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type EnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DealNullableRelationFilter = {
    is?: DealWhereInput | null
    isNot?: DealWhereInput | null
  }

  export type LeadCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    estimatedValue?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrder
    source?: SortOrder
    campaign?: SortOrder
    medium?: SortOrder
    firstResponseAt?: SortOrder
    responseTime?: SortOrder
    clientId?: SortOrder
    ownerId?: SortOrder
    dealId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type LeadAvgOrderByAggregateInput = {
    estimatedValue?: SortOrder
    probability?: SortOrder
    responseTime?: SortOrder
  }

  export type LeadMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    estimatedValue?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrder
    source?: SortOrder
    campaign?: SortOrder
    medium?: SortOrder
    firstResponseAt?: SortOrder
    responseTime?: SortOrder
    clientId?: SortOrder
    ownerId?: SortOrder
    dealId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type LeadMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    estimatedValue?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrder
    source?: SortOrder
    campaign?: SortOrder
    medium?: SortOrder
    firstResponseAt?: SortOrder
    responseTime?: SortOrder
    clientId?: SortOrder
    ownerId?: SortOrder
    dealId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type LeadSumOrderByAggregateInput = {
    estimatedValue?: SortOrder
    probability?: SortOrder
    responseTime?: SortOrder
  }

  export type EnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type PipelineStageRelationFilter = {
    is?: PipelineStageWhereInput
    isNot?: PipelineStageWhereInput
  }

  export type LeadNullableRelationFilter = {
    is?: LeadWhereInput | null
    isNot?: LeadWhereInput | null
  }

  export type JobNullableRelationFilter = {
    is?: JobWhereInput | null
    isNot?: JobWhereInput | null
  }

  export type DealCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    value?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrder
    actualCloseDate?: SortOrder
    stageId?: SortOrder
    clientId?: SortOrder
    ownerId?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type DealAvgOrderByAggregateInput = {
    value?: SortOrder
    probability?: SortOrder
  }

  export type DealMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    value?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrder
    actualCloseDate?: SortOrder
    stageId?: SortOrder
    clientId?: SortOrder
    ownerId?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type DealMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    value?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrder
    actualCloseDate?: SortOrder
    stageId?: SortOrder
    clientId?: SortOrder
    ownerId?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type DealSumOrderByAggregateInput = {
    value?: SortOrder
    probability?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type PipelineStageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    probability?: SortOrder
    isClosedWon?: SortOrder
    isClosedLost?: SortOrder
    autoTasks?: SortOrder
    autoEmails?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PipelineStageAvgOrderByAggregateInput = {
    order?: SortOrder
    probability?: SortOrder
  }

  export type PipelineStageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    probability?: SortOrder
    isClosedWon?: SortOrder
    isClosedLost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PipelineStageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    probability?: SortOrder
    isClosedWon?: SortOrder
    isClosedLost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PipelineStageSumOrderByAggregateInput = {
    order?: SortOrder
    probability?: SortOrder
  }

  export type EnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type EnumDirectionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Direction | EnumDirectionFieldRefInput<$PrismaModel> | null
    in?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDirectionNullableFilter<$PrismaModel> | $Enums.Direction | null
  }

  export type ClientNullableRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type ContactNullableRelationFilter = {
    is?: ContactWhereInput | null
    isNot?: ContactWhereInput | null
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    direction?: SortOrder
    duration?: SortOrder
    outcome?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    contactId?: SortOrder
    leadId?: SortOrder
    dealId?: SortOrder
    emailMessageId?: SortOrder
    callRecordingUrl?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    scheduledAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ActivityAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    direction?: SortOrder
    duration?: SortOrder
    outcome?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    contactId?: SortOrder
    leadId?: SortOrder
    dealId?: SortOrder
    emailMessageId?: SortOrder
    callRecordingUrl?: SortOrder
    createdAt?: SortOrder
    scheduledAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    direction?: SortOrder
    duration?: SortOrder
    outcome?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    contactId?: SortOrder
    leadId?: SortOrder
    dealId?: SortOrder
    emailMessageId?: SortOrder
    callRecordingUrl?: SortOrder
    createdAt?: SortOrder
    scheduledAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ActivitySumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type EnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type EnumDirectionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Direction | EnumDirectionFieldRefInput<$PrismaModel> | null
    in?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDirectionNullableWithAggregatesFilter<$PrismaModel> | $Enums.Direction | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDirectionNullableFilter<$PrismaModel>
    _max?: NestedEnumDirectionNullableFilter<$PrismaModel>
  }

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    assigneeId?: SortOrder
    createdById?: SortOrder
    clientId?: SortOrder
    leadId?: SortOrder
    dealId?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    assigneeId?: SortOrder
    createdById?: SortOrder
    clientId?: SortOrder
    leadId?: SortOrder
    dealId?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    assigneeId?: SortOrder
    createdById?: SortOrder
    clientId?: SortOrder
    leadId?: SortOrder
    dealId?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type EnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrder
    meetingUrl?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    jobId?: SortOrder
    outlookEventId?: SortOrder
    calendarSynced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrder
    meetingUrl?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    jobId?: SortOrder
    outlookEventId?: SortOrder
    calendarSynced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrder
    meetingUrl?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    jobId?: SortOrder
    outlookEventId?: SortOrder
    calendarSynced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type EnumRoomTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomType | EnumRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoomType[] | ListEnumRoomTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomType[] | ListEnumRoomTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomTypeFilter<$PrismaModel> | $Enums.RoomType
  }

  export type RoomCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    currentCondition?: SortOrder
    accessNotes?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomAvgOrderByAggregateInput = {
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type RoomMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    currentCondition?: SortOrder
    accessNotes?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    currentCondition?: SortOrder
    accessNotes?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomSumOrderByAggregateInput = {
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type EnumRoomTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomType | EnumRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoomType[] | ListEnumRoomTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomType[] | ListEnumRoomTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoomType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomTypeFilter<$PrismaModel>
    _max?: NestedEnumRoomTypeFilter<$PrismaModel>
  }

  export type EnumJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusFilter<$PrismaModel> | $Enums.JobStatus
  }

  export type RoomRelationFilter = {
    is?: RoomWhereInput
    isNot?: RoomWhereInput
  }

  export type InstallerCompanyNullableRelationFilter = {
    is?: InstallerCompanyWhereInput | null
    isNot?: InstallerCompanyWhereInput | null
  }

  export type ParsedSpecItemListRelationFilter = {
    every?: ParsedSpecItemWhereInput
    some?: ParsedSpecItemWhereInput
    none?: ParsedSpecItemWhereInput
  }

  export type HandoverPackListRelationFilter = {
    every?: HandoverPackWhereInput
    some?: HandoverPackWhereInput
    none?: HandoverPackWhereInput
  }

  export type ParsedSpecItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HandoverPackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobCountOrderByAggregateInput = {
    id?: SortOrder
    jobNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    quotedDate?: SortOrder
    surveyDate?: SortOrder
    designDate?: SortOrder
    startDate?: SortOrder
    expectedEndDate?: SortOrder
    actualEndDate?: SortOrder
    quotedValue?: SortOrder
    finalValue?: SortOrder
    depositAmount?: SortOrder
    depositPaid?: SortOrder
    designFeePaid?: SortOrder
    balancePaid?: SortOrder
    clientId?: SortOrder
    roomId?: SortOrder
    dealId?: SortOrder
    installerCompanyId?: SortOrder
    designerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobAvgOrderByAggregateInput = {
    quotedValue?: SortOrder
    finalValue?: SortOrder
    depositAmount?: SortOrder
  }

  export type JobMaxOrderByAggregateInput = {
    id?: SortOrder
    jobNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    quotedDate?: SortOrder
    surveyDate?: SortOrder
    designDate?: SortOrder
    startDate?: SortOrder
    expectedEndDate?: SortOrder
    actualEndDate?: SortOrder
    quotedValue?: SortOrder
    finalValue?: SortOrder
    depositAmount?: SortOrder
    depositPaid?: SortOrder
    designFeePaid?: SortOrder
    balancePaid?: SortOrder
    clientId?: SortOrder
    roomId?: SortOrder
    dealId?: SortOrder
    installerCompanyId?: SortOrder
    designerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobMinOrderByAggregateInput = {
    id?: SortOrder
    jobNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    quotedDate?: SortOrder
    surveyDate?: SortOrder
    designDate?: SortOrder
    startDate?: SortOrder
    expectedEndDate?: SortOrder
    actualEndDate?: SortOrder
    quotedValue?: SortOrder
    finalValue?: SortOrder
    depositAmount?: SortOrder
    depositPaid?: SortOrder
    designFeePaid?: SortOrder
    balancePaid?: SortOrder
    clientId?: SortOrder
    roomId?: SortOrder
    dealId?: SortOrder
    installerCompanyId?: SortOrder
    designerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobSumOrderByAggregateInput = {
    quotedValue?: SortOrder
    finalValue?: SortOrder
    depositAmount?: SortOrder
  }

  export type EnumJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobStatusFilter<$PrismaModel>
    _max?: NestedEnumJobStatusFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumSyncStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusFilter<$PrismaModel> | $Enums.SyncStatus
  }

  export type JobRelationFilter = {
    is?: JobWhereInput
    isNot?: JobWhereInput
  }

  export type JobDayLogUserIdJobIdDateCompoundUniqueInput = {
    userId: string
    jobId: string
    date: Date | string
  }

  export type JobDayLogCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    jobId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    lunchStart?: SortOrder
    lunchEnd?: SortOrder
    checkInLatitude?: SortOrder
    checkInLongitude?: SortOrder
    checkInAddress?: SortOrder
    workCompleted?: SortOrder
    materialsUsed?: SortOrder
    issuesEncountered?: SortOrder
    startFormData?: SortOrder
    dailyFormData?: SortOrder
    endFormData?: SortOrder
    photos?: SortOrder
    isCompliant?: SortOrder
    complianceNotes?: SortOrder
    syncStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobDayLogAvgOrderByAggregateInput = {
    checkInLatitude?: SortOrder
    checkInLongitude?: SortOrder
  }

  export type JobDayLogMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    jobId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    lunchStart?: SortOrder
    lunchEnd?: SortOrder
    checkInLatitude?: SortOrder
    checkInLongitude?: SortOrder
    checkInAddress?: SortOrder
    workCompleted?: SortOrder
    materialsUsed?: SortOrder
    issuesEncountered?: SortOrder
    isCompliant?: SortOrder
    complianceNotes?: SortOrder
    syncStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobDayLogMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    jobId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    lunchStart?: SortOrder
    lunchEnd?: SortOrder
    checkInLatitude?: SortOrder
    checkInLongitude?: SortOrder
    checkInAddress?: SortOrder
    workCompleted?: SortOrder
    materialsUsed?: SortOrder
    issuesEncountered?: SortOrder
    isCompliant?: SortOrder
    complianceNotes?: SortOrder
    syncStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobDayLogSumOrderByAggregateInput = {
    checkInLatitude?: SortOrder
    checkInLongitude?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumSyncStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusWithAggregatesFilter<$PrismaModel> | $Enums.SyncStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncStatusFilter<$PrismaModel>
    _max?: NestedEnumSyncStatusFilter<$PrismaModel>
  }

  export type InstallerTeamMemberListRelationFilter = {
    every?: InstallerTeamMemberWhereInput
    some?: InstallerTeamMemberWhereInput
    none?: InstallerTeamMemberWhereInput
  }

  export type InstallerTeamMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstallerCompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    address?: SortOrder
    insuranceExpiry?: SortOrder
    dbsExpiry?: SortOrder
    contractSigned?: SortOrder
    contractSignedAt?: SortOrder
    isActive?: SortOrder
    isSuspended?: SortOrder
    suspensionReason?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstallerCompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    address?: SortOrder
    insuranceExpiry?: SortOrder
    dbsExpiry?: SortOrder
    contractSigned?: SortOrder
    contractSignedAt?: SortOrder
    isActive?: SortOrder
    isSuspended?: SortOrder
    suspensionReason?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstallerCompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    address?: SortOrder
    insuranceExpiry?: SortOrder
    dbsExpiry?: SortOrder
    contractSigned?: SortOrder
    contractSignedAt?: SortOrder
    isActive?: SortOrder
    isSuspended?: SortOrder
    suspensionReason?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstallerCompanyRelationFilter = {
    is?: InstallerCompanyWhereInput
    isNot?: InstallerCompanyWhereInput
  }

  export type InstallerTeamMemberCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    dbsExpiry?: SortOrder
    isActive?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstallerTeamMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    dbsExpiry?: SortOrder
    isActive?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstallerTeamMemberMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    dbsExpiry?: SortOrder
    isActive?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDesignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DesignStatus | EnumDesignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DesignStatus[] | ListEnumDesignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DesignStatus[] | ListEnumDesignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDesignStatusFilter<$PrismaModel> | $Enums.DesignStatus
  }

  export type DesignVersionCountOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    renderUrls?: SortOrder
    planUrls?: SortOrder
    specSheetUrl?: SortOrder
    isClientVisible?: SortOrder
    clientViewedAt?: SortOrder
    clientApprovedAt?: SortOrder
    clientFeedback?: SortOrder
    jobId?: SortOrder
    designerId?: SortOrder
    isFinal?: SortOrder
    lockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DesignVersionAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type DesignVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    specSheetUrl?: SortOrder
    isClientVisible?: SortOrder
    clientViewedAt?: SortOrder
    clientApprovedAt?: SortOrder
    clientFeedback?: SortOrder
    jobId?: SortOrder
    designerId?: SortOrder
    isFinal?: SortOrder
    lockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DesignVersionMinOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    specSheetUrl?: SortOrder
    isClientVisible?: SortOrder
    clientViewedAt?: SortOrder
    clientApprovedAt?: SortOrder
    clientFeedback?: SortOrder
    jobId?: SortOrder
    designerId?: SortOrder
    isFinal?: SortOrder
    lockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DesignVersionSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumDesignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DesignStatus | EnumDesignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DesignStatus[] | ListEnumDesignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DesignStatus[] | ListEnumDesignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDesignStatusWithAggregatesFilter<$PrismaModel> | $Enums.DesignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDesignStatusFilter<$PrismaModel>
    _max?: NestedEnumDesignStatusFilter<$PrismaModel>
  }

  export type EnumClashStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ClashStatus | EnumClashStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClashStatus[] | ListEnumClashStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClashStatus[] | ListEnumClashStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClashStatusFilter<$PrismaModel> | $Enums.ClashStatus
  }

  export type DesignVersionRelationFilter = {
    is?: DesignVersionWhereInput
    isNot?: DesignVersionWhereInput
  }

  export type DesignClashTicketCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    photoUrls?: SortOrder
    resolution?: SortOrder
    resolvedAt?: SortOrder
    designVersionId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DesignClashTicketMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    resolution?: SortOrder
    resolvedAt?: SortOrder
    designVersionId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DesignClashTicketMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    resolution?: SortOrder
    resolvedAt?: SortOrder
    designVersionId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumClashStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClashStatus | EnumClashStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClashStatus[] | ListEnumClashStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClashStatus[] | ListEnumClashStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClashStatusWithAggregatesFilter<$PrismaModel> | $Enums.ClashStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClashStatusFilter<$PrismaModel>
    _max?: NestedEnumClashStatusFilter<$PrismaModel>
  }

  export type EnumMoodboardStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MoodboardStatus | EnumMoodboardStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MoodboardStatus[] | ListEnumMoodboardStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MoodboardStatus[] | ListEnumMoodboardStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMoodboardStatusFilter<$PrismaModel> | $Enums.MoodboardStatus
  }

  export type MoodboardItemListRelationFilter = {
    every?: MoodboardItemWhereInput
    some?: MoodboardItemWhereInput
    none?: MoodboardItemWhereInput
  }

  export type MoodboardItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MoodboardCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    clientId?: SortOrder
    jobId?: SortOrder
    isClientVisible?: SortOrder
    clientLastViewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MoodboardMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    clientId?: SortOrder
    jobId?: SortOrder
    isClientVisible?: SortOrder
    clientLastViewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MoodboardMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    clientId?: SortOrder
    jobId?: SortOrder
    isClientVisible?: SortOrder
    clientLastViewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMoodboardStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MoodboardStatus | EnumMoodboardStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MoodboardStatus[] | ListEnumMoodboardStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MoodboardStatus[] | ListEnumMoodboardStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMoodboardStatusWithAggregatesFilter<$PrismaModel> | $Enums.MoodboardStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMoodboardStatusFilter<$PrismaModel>
    _max?: NestedEnumMoodboardStatusFilter<$PrismaModel>
  }

  export type MoodboardRelationFilter = {
    is?: MoodboardWhereInput
    isNot?: MoodboardWhereInput
  }

  export type MoodboardItemCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    sourceUrl?: SortOrder
    category?: SortOrder
    order?: SortOrder
    moodboardId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MoodboardItemAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type MoodboardItemMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    sourceUrl?: SortOrder
    category?: SortOrder
    order?: SortOrder
    moodboardId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MoodboardItemMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    sourceUrl?: SortOrder
    category?: SortOrder
    order?: SortOrder
    moodboardId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MoodboardItemSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type MoodboardItemRelationFilter = {
    is?: MoodboardItemWhereInput
    isNot?: MoodboardItemWhereInput
  }

  export type MoodboardCommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    xPosition?: SortOrder
    yPosition?: SortOrder
    authorId?: SortOrder
    authorName?: SortOrder
    itemId?: SortOrder
    createdAt?: SortOrder
  }

  export type MoodboardCommentAvgOrderByAggregateInput = {
    xPosition?: SortOrder
    yPosition?: SortOrder
  }

  export type MoodboardCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    xPosition?: SortOrder
    yPosition?: SortOrder
    authorId?: SortOrder
    authorName?: SortOrder
    itemId?: SortOrder
    createdAt?: SortOrder
  }

  export type MoodboardCommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    xPosition?: SortOrder
    yPosition?: SortOrder
    authorId?: SortOrder
    authorName?: SortOrder
    itemId?: SortOrder
    createdAt?: SortOrder
  }

  export type MoodboardCommentSumOrderByAggregateInput = {
    xPosition?: SortOrder
    yPosition?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumSpecItemStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SpecItemStatus | EnumSpecItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SpecItemStatus[] | ListEnumSpecItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpecItemStatus[] | ListEnumSpecItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSpecItemStatusFilter<$PrismaModel> | $Enums.SpecItemStatus
  }

  export type ParsedSpecItemCountOrderByAggregateInput = {
    id?: SortOrder
    originalText?: SortOrder
    parsedCategory?: SortOrder
    parsedBrand?: SortOrder
    parsedModel?: SortOrder
    parsedDescription?: SortOrder
    parsedQuantity?: SortOrder
    parsedPrice?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    substitution?: SortOrder
    actualPrice?: SortOrder
    parseConfidence?: SortOrder
    requiresReview?: SortOrder
    jobId?: SortOrder
    sourceDocumentId?: SortOrder
    sourcePage?: SortOrder
    sourceLineNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParsedSpecItemAvgOrderByAggregateInput = {
    parsedQuantity?: SortOrder
    parsedPrice?: SortOrder
    actualPrice?: SortOrder
    parseConfidence?: SortOrder
    sourcePage?: SortOrder
    sourceLineNumber?: SortOrder
  }

  export type ParsedSpecItemMaxOrderByAggregateInput = {
    id?: SortOrder
    originalText?: SortOrder
    parsedCategory?: SortOrder
    parsedBrand?: SortOrder
    parsedModel?: SortOrder
    parsedDescription?: SortOrder
    parsedQuantity?: SortOrder
    parsedPrice?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    substitution?: SortOrder
    actualPrice?: SortOrder
    parseConfidence?: SortOrder
    requiresReview?: SortOrder
    jobId?: SortOrder
    sourceDocumentId?: SortOrder
    sourcePage?: SortOrder
    sourceLineNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParsedSpecItemMinOrderByAggregateInput = {
    id?: SortOrder
    originalText?: SortOrder
    parsedCategory?: SortOrder
    parsedBrand?: SortOrder
    parsedModel?: SortOrder
    parsedDescription?: SortOrder
    parsedQuantity?: SortOrder
    parsedPrice?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    substitution?: SortOrder
    actualPrice?: SortOrder
    parseConfidence?: SortOrder
    requiresReview?: SortOrder
    jobId?: SortOrder
    sourceDocumentId?: SortOrder
    sourcePage?: SortOrder
    sourceLineNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParsedSpecItemSumOrderByAggregateInput = {
    parsedQuantity?: SortOrder
    parsedPrice?: SortOrder
    actualPrice?: SortOrder
    parseConfidence?: SortOrder
    sourcePage?: SortOrder
    sourceLineNumber?: SortOrder
  }

  export type EnumSpecItemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SpecItemStatus | EnumSpecItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SpecItemStatus[] | ListEnumSpecItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpecItemStatus[] | ListEnumSpecItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSpecItemStatusWithAggregatesFilter<$PrismaModel> | $Enums.SpecItemStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSpecItemStatusFilter<$PrismaModel>
    _max?: NestedEnumSpecItemStatusFilter<$PrismaModel>
  }

  export type EnumSnagCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.SnagCategory | EnumSnagCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SnagCategory[] | ListEnumSnagCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SnagCategory[] | ListEnumSnagCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSnagCategoryFilter<$PrismaModel> | $Enums.SnagCategory
  }

  export type EnumSnagStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SnagStatus | EnumSnagStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SnagStatus[] | ListEnumSnagStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SnagStatus[] | ListEnumSnagStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSnagStatusFilter<$PrismaModel> | $Enums.SnagStatus
  }

  export type SnagCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    photoUrls?: SortOrder
    isClientVisible?: SortOrder
    clientNotified?: SortOrder
    resolution?: SortOrder
    resolvedAt?: SortOrder
    jobId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SnagMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    isClientVisible?: SortOrder
    clientNotified?: SortOrder
    resolution?: SortOrder
    resolvedAt?: SortOrder
    jobId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SnagMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    isClientVisible?: SortOrder
    clientNotified?: SortOrder
    resolution?: SortOrder
    resolvedAt?: SortOrder
    jobId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSnagCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SnagCategory | EnumSnagCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SnagCategory[] | ListEnumSnagCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SnagCategory[] | ListEnumSnagCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSnagCategoryWithAggregatesFilter<$PrismaModel> | $Enums.SnagCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSnagCategoryFilter<$PrismaModel>
    _max?: NestedEnumSnagCategoryFilter<$PrismaModel>
  }

  export type EnumSnagStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SnagStatus | EnumSnagStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SnagStatus[] | ListEnumSnagStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SnagStatus[] | ListEnumSnagStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSnagStatusWithAggregatesFilter<$PrismaModel> | $Enums.SnagStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSnagStatusFilter<$PrismaModel>
    _max?: NestedEnumSnagStatusFilter<$PrismaModel>
  }

  export type EnumDocumentCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentCategory | EnumDocumentCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentCategory[] | ListEnumDocumentCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentCategory[] | ListEnumDocumentCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentCategoryFilter<$PrismaModel> | $Enums.DocumentCategory
  }

  export type EnumVirusScanStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VirusScanStatus | EnumVirusScanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VirusScanStatus[] | ListEnumVirusScanStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VirusScanStatus[] | ListEnumVirusScanStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVirusScanStatusFilter<$PrismaModel> | $Enums.VirusScanStatus
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalFilename?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    storageUrl?: SortOrder
    category?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    virusScanStatus?: SortOrder
    virusScanResult?: SortOrder
    clientId?: SortOrder
    dealId?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    uploadedById?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalFilename?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    storageUrl?: SortOrder
    category?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    virusScanStatus?: SortOrder
    virusScanResult?: SortOrder
    clientId?: SortOrder
    dealId?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    uploadedById?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalFilename?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    storageUrl?: SortOrder
    category?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    virusScanStatus?: SortOrder
    virusScanResult?: SortOrder
    clientId?: SortOrder
    dealId?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    uploadedById?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type EnumDocumentCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentCategory | EnumDocumentCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentCategory[] | ListEnumDocumentCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentCategory[] | ListEnumDocumentCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentCategoryWithAggregatesFilter<$PrismaModel> | $Enums.DocumentCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentCategoryFilter<$PrismaModel>
    _max?: NestedEnumDocumentCategoryFilter<$PrismaModel>
  }

  export type EnumVirusScanStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VirusScanStatus | EnumVirusScanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VirusScanStatus[] | ListEnumVirusScanStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VirusScanStatus[] | ListEnumVirusScanStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVirusScanStatusWithAggregatesFilter<$PrismaModel> | $Enums.VirusScanStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVirusScanStatusFilter<$PrismaModel>
    _max?: NestedEnumVirusScanStatusFilter<$PrismaModel>
  }

  export type EnumFormCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FormCategory | EnumFormCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FormCategory[] | ListEnumFormCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormCategory[] | ListEnumFormCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFormCategoryFilter<$PrismaModel> | $Enums.FormCategory
  }

  export type FormTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    schema?: SortOrder
    isActive?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormTemplateAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type FormTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormTemplateSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumFormCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FormCategory | EnumFormCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FormCategory[] | ListEnumFormCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormCategory[] | ListEnumFormCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFormCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FormCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFormCategoryFilter<$PrismaModel>
    _max?: NestedEnumFormCategoryFilter<$PrismaModel>
  }

  export type EnumSubmissionSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionSource | EnumSubmissionSourceFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionSource[] | ListEnumSubmissionSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionSource[] | ListEnumSubmissionSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionSourceFilter<$PrismaModel> | $Enums.SubmissionSource
  }

  export type FormTemplateRelationFilter = {
    is?: FormTemplateWhereInput
    isNot?: FormTemplateWhereInput
  }

  export type FormSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    data?: SortOrder
    submissionSource?: SortOrder
    templateId?: SortOrder
    submittedById?: SortOrder
    clientId?: SortOrder
    jobId?: SortOrder
    submittedAt?: SortOrder
  }

  export type FormSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    submissionSource?: SortOrder
    templateId?: SortOrder
    submittedById?: SortOrder
    clientId?: SortOrder
    jobId?: SortOrder
    submittedAt?: SortOrder
  }

  export type FormSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    submissionSource?: SortOrder
    templateId?: SortOrder
    submittedById?: SortOrder
    clientId?: SortOrder
    jobId?: SortOrder
    submittedAt?: SortOrder
  }

  export type EnumSubmissionSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionSource | EnumSubmissionSourceFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionSource[] | ListEnumSubmissionSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionSource[] | ListEnumSubmissionSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionSourceWithAggregatesFilter<$PrismaModel> | $Enums.SubmissionSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubmissionSourceFilter<$PrismaModel>
    _max?: NestedEnumSubmissionSourceFilter<$PrismaModel>
  }

  export type HandoverPackCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    completionCertUrl?: SortOrder
    warrantyDocsUrls?: SortOrder
    finalPhotosUrls?: SortOrder
    guidesIncluded?: SortOrder
    isGenerated?: SortOrder
    generatedAt?: SortOrder
    deliveredAt?: SortOrder
    clientAccessedAt?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HandoverPackMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    completionCertUrl?: SortOrder
    isGenerated?: SortOrder
    generatedAt?: SortOrder
    deliveredAt?: SortOrder
    clientAccessedAt?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HandoverPackMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    completionCertUrl?: SortOrder
    isGenerated?: SortOrder
    generatedAt?: SortOrder
    deliveredAt?: SortOrder
    clientAccessedAt?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumGuideCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.GuideCategory | EnumGuideCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.GuideCategory[] | ListEnumGuideCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.GuideCategory[] | ListEnumGuideCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumGuideCategoryFilter<$PrismaModel> | $Enums.GuideCategory
  }

  export type GuideCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    isPublished?: SortOrder
    featured?: SortOrder
    metaDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
  }

  export type GuideMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    category?: SortOrder
    isPublished?: SortOrder
    featured?: SortOrder
    metaDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
  }

  export type GuideMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    category?: SortOrder
    isPublished?: SortOrder
    featured?: SortOrder
    metaDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
  }

  export type EnumGuideCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GuideCategory | EnumGuideCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.GuideCategory[] | ListEnumGuideCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.GuideCategory[] | ListEnumGuideCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumGuideCategoryWithAggregatesFilter<$PrismaModel> | $Enums.GuideCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGuideCategoryFilter<$PrismaModel>
    _max?: NestedEnumGuideCategoryFilter<$PrismaModel>
  }

  export type EnumEmailTriggerFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailTrigger | EnumEmailTriggerFieldRefInput<$PrismaModel>
    in?: $Enums.EmailTrigger[] | ListEnumEmailTriggerFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailTrigger[] | ListEnumEmailTriggerFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailTriggerFilter<$PrismaModel> | $Enums.EmailTrigger
  }

  export type EmailSequenceStepListRelationFilter = {
    every?: EmailSequenceStepWhereInput
    some?: EmailSequenceStepWhereInput
    none?: EmailSequenceStepWhereInput
  }

  export type EmailSequenceStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailJourneyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    triggerEvent?: SortOrder
    triggerConditions?: SortOrder
    totalSent?: SortOrder
    totalOpened?: SortOrder
    totalClicked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailJourneyAvgOrderByAggregateInput = {
    totalSent?: SortOrder
    totalOpened?: SortOrder
    totalClicked?: SortOrder
  }

  export type EmailJourneyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    triggerEvent?: SortOrder
    totalSent?: SortOrder
    totalOpened?: SortOrder
    totalClicked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailJourneyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    triggerEvent?: SortOrder
    totalSent?: SortOrder
    totalOpened?: SortOrder
    totalClicked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailJourneySumOrderByAggregateInput = {
    totalSent?: SortOrder
    totalOpened?: SortOrder
    totalClicked?: SortOrder
  }

  export type EnumEmailTriggerWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailTrigger | EnumEmailTriggerFieldRefInput<$PrismaModel>
    in?: $Enums.EmailTrigger[] | ListEnumEmailTriggerFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailTrigger[] | ListEnumEmailTriggerFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailTriggerWithAggregatesFilter<$PrismaModel> | $Enums.EmailTrigger
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmailTriggerFilter<$PrismaModel>
    _max?: NestedEnumEmailTriggerFilter<$PrismaModel>
  }

  export type EmailJourneyRelationFilter = {
    is?: EmailJourneyWhereInput
    isNot?: EmailJourneyWhereInput
  }

  export type EmailSequenceStepJourneyIdStepNumberCompoundUniqueInput = {
    journeyId: string
    stepNumber: number
  }

  export type EmailSequenceStepCountOrderByAggregateInput = {
    id?: SortOrder
    stepNumber?: SortOrder
    templateId?: SortOrder
    delayDays?: SortOrder
    delayHours?: SortOrder
    sendConditions?: SortOrder
    journeyId?: SortOrder
  }

  export type EmailSequenceStepAvgOrderByAggregateInput = {
    stepNumber?: SortOrder
    delayDays?: SortOrder
    delayHours?: SortOrder
  }

  export type EmailSequenceStepMaxOrderByAggregateInput = {
    id?: SortOrder
    stepNumber?: SortOrder
    templateId?: SortOrder
    delayDays?: SortOrder
    delayHours?: SortOrder
    journeyId?: SortOrder
  }

  export type EmailSequenceStepMinOrderByAggregateInput = {
    id?: SortOrder
    stepNumber?: SortOrder
    templateId?: SortOrder
    delayDays?: SortOrder
    delayHours?: SortOrder
    journeyId?: SortOrder
  }

  export type EmailSequenceStepSumOrderByAggregateInput = {
    stepNumber?: SortOrder
    delayDays?: SortOrder
    delayHours?: SortOrder
  }

  export type EnumWebhookEventNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.WebhookEvent[] | ListEnumWebhookEventFieldRefInput<$PrismaModel> | null
    has?: $Enums.WebhookEvent | EnumWebhookEventFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.WebhookEvent[] | ListEnumWebhookEventFieldRefInput<$PrismaModel>
    hasSome?: $Enums.WebhookEvent[] | ListEnumWebhookEventFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type WebhookDeliveryListRelationFilter = {
    every?: WebhookDeliveryWhereInput
    some?: WebhookDeliveryWhereInput
    none?: WebhookDeliveryWhereInput
  }

  export type WebhookDeliveryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebhookCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    events?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    totalDeliveries?: SortOrder
    lastDeliveryAt?: SortOrder
    lastSuccessAt?: SortOrder
    lastFailureAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookAvgOrderByAggregateInput = {
    totalDeliveries?: SortOrder
  }

  export type WebhookMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    totalDeliveries?: SortOrder
    lastDeliveryAt?: SortOrder
    lastSuccessAt?: SortOrder
    lastFailureAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    totalDeliveries?: SortOrder
    lastDeliveryAt?: SortOrder
    lastSuccessAt?: SortOrder
    lastFailureAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookSumOrderByAggregateInput = {
    totalDeliveries?: SortOrder
  }

  export type EnumWebhookEventFilter<$PrismaModel = never> = {
    equals?: $Enums.WebhookEvent | EnumWebhookEventFieldRefInput<$PrismaModel>
    in?: $Enums.WebhookEvent[] | ListEnumWebhookEventFieldRefInput<$PrismaModel>
    notIn?: $Enums.WebhookEvent[] | ListEnumWebhookEventFieldRefInput<$PrismaModel>
    not?: NestedEnumWebhookEventFilter<$PrismaModel> | $Enums.WebhookEvent
  }

  export type WebhookRelationFilter = {
    is?: WebhookWhereInput
    isNot?: WebhookWhereInput
  }

  export type WebhookDeliveryCountOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    httpStatus?: SortOrder
    responseBody?: SortOrder
    errorMessage?: SortOrder
    deliveryAttempts?: SortOrder
    deliveredAt?: SortOrder
    webhookId?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookDeliveryAvgOrderByAggregateInput = {
    httpStatus?: SortOrder
    deliveryAttempts?: SortOrder
  }

  export type WebhookDeliveryMaxOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    httpStatus?: SortOrder
    responseBody?: SortOrder
    errorMessage?: SortOrder
    deliveryAttempts?: SortOrder
    deliveredAt?: SortOrder
    webhookId?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookDeliveryMinOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    httpStatus?: SortOrder
    responseBody?: SortOrder
    errorMessage?: SortOrder
    deliveryAttempts?: SortOrder
    deliveredAt?: SortOrder
    webhookId?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookDeliverySumOrderByAggregateInput = {
    httpStatus?: SortOrder
    deliveryAttempts?: SortOrder
  }

  export type EnumWebhookEventWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WebhookEvent | EnumWebhookEventFieldRefInput<$PrismaModel>
    in?: $Enums.WebhookEvent[] | ListEnumWebhookEventFieldRefInput<$PrismaModel>
    notIn?: $Enums.WebhookEvent[] | ListEnumWebhookEventFieldRefInput<$PrismaModel>
    not?: NestedEnumWebhookEventWithAggregatesFilter<$PrismaModel> | $Enums.WebhookEvent
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWebhookEventFilter<$PrismaModel>
    _max?: NestedEnumWebhookEventFilter<$PrismaModel>
  }

  export type EventLogCountOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrder
    metadata?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
    occurredAt?: SortOrder
  }

  export type EventLogMaxOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
    occurredAt?: SortOrder
  }

  export type EventLogMinOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
    occurredAt?: SortOrder
  }

  export type EnumIntegrationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationType | EnumIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationTypeFilter<$PrismaModel> | $Enums.IntegrationType
  }

  export type IntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    config?: SortOrder
    isActive?: SortOrder
    lastSyncAt?: SortOrder
    nextSyncAt?: SortOrder
    syncErrors?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    lastSyncAt?: SortOrder
    nextSyncAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    lastSyncAt?: SortOrder
    nextSyncAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumIntegrationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationType | EnumIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationTypeWithAggregatesFilter<$PrismaModel> | $Enums.IntegrationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIntegrationTypeFilter<$PrismaModel>
    _max?: NestedEnumIntegrationTypeFilter<$PrismaModel>
  }

  export type EnumMergeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MergeStatus | EnumMergeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MergeStatus[] | ListEnumMergeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MergeStatus[] | ListEnumMergeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMergeStatusFilter<$PrismaModel> | $Enums.MergeStatus
  }

  export type MergeQueueCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    primaryEntityId?: SortOrder
    duplicateEntityId?: SortOrder
    status?: SortOrder
    mergeRules?: SortOrder
    reviewedById?: SortOrder
    reviewedAt?: SortOrder
    mergedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MergeQueueMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    primaryEntityId?: SortOrder
    duplicateEntityId?: SortOrder
    status?: SortOrder
    reviewedById?: SortOrder
    reviewedAt?: SortOrder
    mergedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MergeQueueMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    primaryEntityId?: SortOrder
    duplicateEntityId?: SortOrder
    status?: SortOrder
    reviewedById?: SortOrder
    reviewedAt?: SortOrder
    mergedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumMergeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MergeStatus | EnumMergeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MergeStatus[] | ListEnumMergeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MergeStatus[] | ListEnumMergeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMergeStatusWithAggregatesFilter<$PrismaModel> | $Enums.MergeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMergeStatusFilter<$PrismaModel>
    _max?: NestedEnumMergeStatusFilter<$PrismaModel>
  }

  export type UserCreateNestedOneWithoutCreatedUsersInput = {
    create?: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedUsersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdatedUsersInput = {
    create?: XOR<UserCreateWithoutUpdatedUsersInput, UserUncheckedCreateWithoutUpdatedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedUsersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<UserCreateWithoutUpdatedByInput, UserUncheckedCreateWithoutUpdatedByInput> | UserCreateWithoutUpdatedByInput[] | UserUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedByInput | UserCreateOrConnectWithoutUpdatedByInput[]
    createMany?: UserCreateManyUpdatedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ClientCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ClientCreateWithoutOwnerInput, ClientUncheckedCreateWithoutOwnerInput> | ClientCreateWithoutOwnerInput[] | ClientUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutOwnerInput | ClientCreateOrConnectWithoutOwnerInput[]
    createMany?: ClientCreateManyOwnerInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type LeadCreateNestedManyWithoutOwnerInput = {
    create?: XOR<LeadCreateWithoutOwnerInput, LeadUncheckedCreateWithoutOwnerInput> | LeadCreateWithoutOwnerInput[] | LeadUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutOwnerInput | LeadCreateOrConnectWithoutOwnerInput[]
    createMany?: LeadCreateManyOwnerInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type DealCreateNestedManyWithoutOwnerInput = {
    create?: XOR<DealCreateWithoutOwnerInput, DealUncheckedCreateWithoutOwnerInput> | DealCreateWithoutOwnerInput[] | DealUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: DealCreateOrConnectWithoutOwnerInput | DealCreateOrConnectWithoutOwnerInput[]
    createMany?: DealCreateManyOwnerInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TaskCreateWithoutCreatedByInput, TaskUncheckedCreateWithoutCreatedByInput> | TaskCreateWithoutCreatedByInput[] | TaskUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatedByInput | TaskCreateOrConnectWithoutCreatedByInput[]
    createMany?: TaskCreateManyCreatedByInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutUserInput = {
    create?: XOR<AppointmentCreateWithoutUserInput, AppointmentUncheckedCreateWithoutUserInput> | AppointmentCreateWithoutUserInput[] | AppointmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserInput | AppointmentCreateOrConnectWithoutUserInput[]
    createMany?: AppointmentCreateManyUserInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type JobDayLogCreateNestedManyWithoutUserInput = {
    create?: XOR<JobDayLogCreateWithoutUserInput, JobDayLogUncheckedCreateWithoutUserInput> | JobDayLogCreateWithoutUserInput[] | JobDayLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobDayLogCreateOrConnectWithoutUserInput | JobDayLogCreateOrConnectWithoutUserInput[]
    createMany?: JobDayLogCreateManyUserInputEnvelope
    connect?: JobDayLogWhereUniqueInput | JobDayLogWhereUniqueInput[]
  }

  export type DesignVersionCreateNestedManyWithoutDesignerInput = {
    create?: XOR<DesignVersionCreateWithoutDesignerInput, DesignVersionUncheckedCreateWithoutDesignerInput> | DesignVersionCreateWithoutDesignerInput[] | DesignVersionUncheckedCreateWithoutDesignerInput[]
    connectOrCreate?: DesignVersionCreateOrConnectWithoutDesignerInput | DesignVersionCreateOrConnectWithoutDesignerInput[]
    createMany?: DesignVersionCreateManyDesignerInputEnvelope
    connect?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
  }

  export type ClientCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ClientCreateWithoutCreatedByInput, ClientUncheckedCreateWithoutCreatedByInput> | ClientCreateWithoutCreatedByInput[] | ClientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutCreatedByInput | ClientCreateOrConnectWithoutCreatedByInput[]
    createMany?: ClientCreateManyCreatedByInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type ClientCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<ClientCreateWithoutUpdatedByInput, ClientUncheckedCreateWithoutUpdatedByInput> | ClientCreateWithoutUpdatedByInput[] | ClientUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutUpdatedByInput | ClientCreateOrConnectWithoutUpdatedByInput[]
    createMany?: ClientCreateManyUpdatedByInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type JobCreateNestedManyWithoutDesignerInput = {
    create?: XOR<JobCreateWithoutDesignerInput, JobUncheckedCreateWithoutDesignerInput> | JobCreateWithoutDesignerInput[] | JobUncheckedCreateWithoutDesignerInput[]
    connectOrCreate?: JobCreateOrConnectWithoutDesignerInput | JobCreateOrConnectWithoutDesignerInput[]
    createMany?: JobCreateManyDesignerInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type InstallerCompanyCreateNestedManyWithoutOwnerInput = {
    create?: XOR<InstallerCompanyCreateWithoutOwnerInput, InstallerCompanyUncheckedCreateWithoutOwnerInput> | InstallerCompanyCreateWithoutOwnerInput[] | InstallerCompanyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: InstallerCompanyCreateOrConnectWithoutOwnerInput | InstallerCompanyCreateOrConnectWithoutOwnerInput[]
    createMany?: InstallerCompanyCreateManyOwnerInputEnvelope
    connect?: InstallerCompanyWhereUniqueInput | InstallerCompanyWhereUniqueInput[]
  }

  export type DesignClashTicketCreateNestedManyWithoutReportedByInput = {
    create?: XOR<DesignClashTicketCreateWithoutReportedByInput, DesignClashTicketUncheckedCreateWithoutReportedByInput> | DesignClashTicketCreateWithoutReportedByInput[] | DesignClashTicketUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: DesignClashTicketCreateOrConnectWithoutReportedByInput | DesignClashTicketCreateOrConnectWithoutReportedByInput[]
    createMany?: DesignClashTicketCreateManyReportedByInputEnvelope
    connect?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
  }

  export type DesignClashTicketCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<DesignClashTicketCreateWithoutAssignedToInput, DesignClashTicketUncheckedCreateWithoutAssignedToInput> | DesignClashTicketCreateWithoutAssignedToInput[] | DesignClashTicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: DesignClashTicketCreateOrConnectWithoutAssignedToInput | DesignClashTicketCreateOrConnectWithoutAssignedToInput[]
    createMany?: DesignClashTicketCreateManyAssignedToInputEnvelope
    connect?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
  }

  export type MoodboardCommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<MoodboardCommentCreateWithoutAuthorInput, MoodboardCommentUncheckedCreateWithoutAuthorInput> | MoodboardCommentCreateWithoutAuthorInput[] | MoodboardCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: MoodboardCommentCreateOrConnectWithoutAuthorInput | MoodboardCommentCreateOrConnectWithoutAuthorInput[]
    createMany?: MoodboardCommentCreateManyAuthorInputEnvelope
    connect?: MoodboardCommentWhereUniqueInput | MoodboardCommentWhereUniqueInput[]
  }

  export type SnagCreateNestedManyWithoutReportedByInput = {
    create?: XOR<SnagCreateWithoutReportedByInput, SnagUncheckedCreateWithoutReportedByInput> | SnagCreateWithoutReportedByInput[] | SnagUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: SnagCreateOrConnectWithoutReportedByInput | SnagCreateOrConnectWithoutReportedByInput[]
    createMany?: SnagCreateManyReportedByInputEnvelope
    connect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
  }

  export type SnagCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<SnagCreateWithoutAssignedToInput, SnagUncheckedCreateWithoutAssignedToInput> | SnagCreateWithoutAssignedToInput[] | SnagUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: SnagCreateOrConnectWithoutAssignedToInput | SnagCreateOrConnectWithoutAssignedToInput[]
    createMany?: SnagCreateManyAssignedToInputEnvelope
    connect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput> | DocumentCreateWithoutUploadedByInput[] | DocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploadedByInput | DocumentCreateOrConnectWithoutUploadedByInput[]
    createMany?: DocumentCreateManyUploadedByInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type FormSubmissionCreateNestedManyWithoutSubmittedByInput = {
    create?: XOR<FormSubmissionCreateWithoutSubmittedByInput, FormSubmissionUncheckedCreateWithoutSubmittedByInput> | FormSubmissionCreateWithoutSubmittedByInput[] | FormSubmissionUncheckedCreateWithoutSubmittedByInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutSubmittedByInput | FormSubmissionCreateOrConnectWithoutSubmittedByInput[]
    createMany?: FormSubmissionCreateManySubmittedByInputEnvelope
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
  }

  export type EventLogCreateNestedManyWithoutUserInput = {
    create?: XOR<EventLogCreateWithoutUserInput, EventLogUncheckedCreateWithoutUserInput> | EventLogCreateWithoutUserInput[] | EventLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventLogCreateOrConnectWithoutUserInput | EventLogCreateOrConnectWithoutUserInput[]
    createMany?: EventLogCreateManyUserInputEnvelope
    connect?: EventLogWhereUniqueInput | EventLogWhereUniqueInput[]
  }

  export type MergeQueueCreateNestedManyWithoutReviewedByInput = {
    create?: XOR<MergeQueueCreateWithoutReviewedByInput, MergeQueueUncheckedCreateWithoutReviewedByInput> | MergeQueueCreateWithoutReviewedByInput[] | MergeQueueUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: MergeQueueCreateOrConnectWithoutReviewedByInput | MergeQueueCreateOrConnectWithoutReviewedByInput[]
    createMany?: MergeQueueCreateManyReviewedByInputEnvelope
    connect?: MergeQueueWhereUniqueInput | MergeQueueWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<UserCreateWithoutUpdatedByInput, UserUncheckedCreateWithoutUpdatedByInput> | UserCreateWithoutUpdatedByInput[] | UserUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedByInput | UserCreateOrConnectWithoutUpdatedByInput[]
    createMany?: UserCreateManyUpdatedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ClientCreateWithoutOwnerInput, ClientUncheckedCreateWithoutOwnerInput> | ClientCreateWithoutOwnerInput[] | ClientUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutOwnerInput | ClientCreateOrConnectWithoutOwnerInput[]
    createMany?: ClientCreateManyOwnerInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<LeadCreateWithoutOwnerInput, LeadUncheckedCreateWithoutOwnerInput> | LeadCreateWithoutOwnerInput[] | LeadUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutOwnerInput | LeadCreateOrConnectWithoutOwnerInput[]
    createMany?: LeadCreateManyOwnerInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type DealUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<DealCreateWithoutOwnerInput, DealUncheckedCreateWithoutOwnerInput> | DealCreateWithoutOwnerInput[] | DealUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: DealCreateOrConnectWithoutOwnerInput | DealCreateOrConnectWithoutOwnerInput[]
    createMany?: DealCreateManyOwnerInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TaskCreateWithoutCreatedByInput, TaskUncheckedCreateWithoutCreatedByInput> | TaskCreateWithoutCreatedByInput[] | TaskUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatedByInput | TaskCreateOrConnectWithoutCreatedByInput[]
    createMany?: TaskCreateManyCreatedByInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AppointmentCreateWithoutUserInput, AppointmentUncheckedCreateWithoutUserInput> | AppointmentCreateWithoutUserInput[] | AppointmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserInput | AppointmentCreateOrConnectWithoutUserInput[]
    createMany?: AppointmentCreateManyUserInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type JobDayLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<JobDayLogCreateWithoutUserInput, JobDayLogUncheckedCreateWithoutUserInput> | JobDayLogCreateWithoutUserInput[] | JobDayLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobDayLogCreateOrConnectWithoutUserInput | JobDayLogCreateOrConnectWithoutUserInput[]
    createMany?: JobDayLogCreateManyUserInputEnvelope
    connect?: JobDayLogWhereUniqueInput | JobDayLogWhereUniqueInput[]
  }

  export type DesignVersionUncheckedCreateNestedManyWithoutDesignerInput = {
    create?: XOR<DesignVersionCreateWithoutDesignerInput, DesignVersionUncheckedCreateWithoutDesignerInput> | DesignVersionCreateWithoutDesignerInput[] | DesignVersionUncheckedCreateWithoutDesignerInput[]
    connectOrCreate?: DesignVersionCreateOrConnectWithoutDesignerInput | DesignVersionCreateOrConnectWithoutDesignerInput[]
    createMany?: DesignVersionCreateManyDesignerInputEnvelope
    connect?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ClientCreateWithoutCreatedByInput, ClientUncheckedCreateWithoutCreatedByInput> | ClientCreateWithoutCreatedByInput[] | ClientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutCreatedByInput | ClientCreateOrConnectWithoutCreatedByInput[]
    createMany?: ClientCreateManyCreatedByInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<ClientCreateWithoutUpdatedByInput, ClientUncheckedCreateWithoutUpdatedByInput> | ClientCreateWithoutUpdatedByInput[] | ClientUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutUpdatedByInput | ClientCreateOrConnectWithoutUpdatedByInput[]
    createMany?: ClientCreateManyUpdatedByInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type JobUncheckedCreateNestedManyWithoutDesignerInput = {
    create?: XOR<JobCreateWithoutDesignerInput, JobUncheckedCreateWithoutDesignerInput> | JobCreateWithoutDesignerInput[] | JobUncheckedCreateWithoutDesignerInput[]
    connectOrCreate?: JobCreateOrConnectWithoutDesignerInput | JobCreateOrConnectWithoutDesignerInput[]
    createMany?: JobCreateManyDesignerInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<InstallerCompanyCreateWithoutOwnerInput, InstallerCompanyUncheckedCreateWithoutOwnerInput> | InstallerCompanyCreateWithoutOwnerInput[] | InstallerCompanyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: InstallerCompanyCreateOrConnectWithoutOwnerInput | InstallerCompanyCreateOrConnectWithoutOwnerInput[]
    createMany?: InstallerCompanyCreateManyOwnerInputEnvelope
    connect?: InstallerCompanyWhereUniqueInput | InstallerCompanyWhereUniqueInput[]
  }

  export type DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput = {
    create?: XOR<DesignClashTicketCreateWithoutReportedByInput, DesignClashTicketUncheckedCreateWithoutReportedByInput> | DesignClashTicketCreateWithoutReportedByInput[] | DesignClashTicketUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: DesignClashTicketCreateOrConnectWithoutReportedByInput | DesignClashTicketCreateOrConnectWithoutReportedByInput[]
    createMany?: DesignClashTicketCreateManyReportedByInputEnvelope
    connect?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
  }

  export type DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<DesignClashTicketCreateWithoutAssignedToInput, DesignClashTicketUncheckedCreateWithoutAssignedToInput> | DesignClashTicketCreateWithoutAssignedToInput[] | DesignClashTicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: DesignClashTicketCreateOrConnectWithoutAssignedToInput | DesignClashTicketCreateOrConnectWithoutAssignedToInput[]
    createMany?: DesignClashTicketCreateManyAssignedToInputEnvelope
    connect?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
  }

  export type MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<MoodboardCommentCreateWithoutAuthorInput, MoodboardCommentUncheckedCreateWithoutAuthorInput> | MoodboardCommentCreateWithoutAuthorInput[] | MoodboardCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: MoodboardCommentCreateOrConnectWithoutAuthorInput | MoodboardCommentCreateOrConnectWithoutAuthorInput[]
    createMany?: MoodboardCommentCreateManyAuthorInputEnvelope
    connect?: MoodboardCommentWhereUniqueInput | MoodboardCommentWhereUniqueInput[]
  }

  export type SnagUncheckedCreateNestedManyWithoutReportedByInput = {
    create?: XOR<SnagCreateWithoutReportedByInput, SnagUncheckedCreateWithoutReportedByInput> | SnagCreateWithoutReportedByInput[] | SnagUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: SnagCreateOrConnectWithoutReportedByInput | SnagCreateOrConnectWithoutReportedByInput[]
    createMany?: SnagCreateManyReportedByInputEnvelope
    connect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
  }

  export type SnagUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<SnagCreateWithoutAssignedToInput, SnagUncheckedCreateWithoutAssignedToInput> | SnagCreateWithoutAssignedToInput[] | SnagUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: SnagCreateOrConnectWithoutAssignedToInput | SnagCreateOrConnectWithoutAssignedToInput[]
    createMany?: SnagCreateManyAssignedToInputEnvelope
    connect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput> | DocumentCreateWithoutUploadedByInput[] | DocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploadedByInput | DocumentCreateOrConnectWithoutUploadedByInput[]
    createMany?: DocumentCreateManyUploadedByInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput = {
    create?: XOR<FormSubmissionCreateWithoutSubmittedByInput, FormSubmissionUncheckedCreateWithoutSubmittedByInput> | FormSubmissionCreateWithoutSubmittedByInput[] | FormSubmissionUncheckedCreateWithoutSubmittedByInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutSubmittedByInput | FormSubmissionCreateOrConnectWithoutSubmittedByInput[]
    createMany?: FormSubmissionCreateManySubmittedByInputEnvelope
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
  }

  export type EventLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EventLogCreateWithoutUserInput, EventLogUncheckedCreateWithoutUserInput> | EventLogCreateWithoutUserInput[] | EventLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventLogCreateOrConnectWithoutUserInput | EventLogCreateOrConnectWithoutUserInput[]
    createMany?: EventLogCreateManyUserInputEnvelope
    connect?: EventLogWhereUniqueInput | EventLogWhereUniqueInput[]
  }

  export type MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput = {
    create?: XOR<MergeQueueCreateWithoutReviewedByInput, MergeQueueUncheckedCreateWithoutReviewedByInput> | MergeQueueCreateWithoutReviewedByInput[] | MergeQueueUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: MergeQueueCreateOrConnectWithoutReviewedByInput | MergeQueueCreateOrConnectWithoutReviewedByInput[]
    createMany?: MergeQueueCreateManyReviewedByInputEnvelope
    connect?: MergeQueueWhereUniqueInput | MergeQueueWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneWithoutCreatedUsersNestedInput = {
    create?: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedUsersInput
    upsert?: UserUpsertWithoutCreatedUsersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedUsersInput, UserUpdateWithoutCreatedUsersInput>, UserUncheckedUpdateWithoutCreatedUsersInput>
  }

  export type UserUpdateOneWithoutUpdatedUsersNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedUsersInput, UserUncheckedCreateWithoutUpdatedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedUsersInput
    upsert?: UserUpsertWithoutUpdatedUsersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedUsersInput, UserUpdateWithoutUpdatedUsersInput>, UserUncheckedUpdateWithoutUpdatedUsersInput>
  }

  export type UserUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCreatedByInput | UserUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCreatedByInput | UserUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCreatedByInput | UserUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedByInput, UserUncheckedCreateWithoutUpdatedByInput> | UserCreateWithoutUpdatedByInput[] | UserUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedByInput | UserCreateOrConnectWithoutUpdatedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutUpdatedByInput | UserUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: UserCreateManyUpdatedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutUpdatedByInput | UserUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutUpdatedByInput | UserUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ClientUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ClientCreateWithoutOwnerInput, ClientUncheckedCreateWithoutOwnerInput> | ClientCreateWithoutOwnerInput[] | ClientUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutOwnerInput | ClientCreateOrConnectWithoutOwnerInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutOwnerInput | ClientUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ClientCreateManyOwnerInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutOwnerInput | ClientUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutOwnerInput | ClientUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type LeadUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<LeadCreateWithoutOwnerInput, LeadUncheckedCreateWithoutOwnerInput> | LeadCreateWithoutOwnerInput[] | LeadUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutOwnerInput | LeadCreateOrConnectWithoutOwnerInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutOwnerInput | LeadUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: LeadCreateManyOwnerInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutOwnerInput | LeadUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutOwnerInput | LeadUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type DealUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<DealCreateWithoutOwnerInput, DealUncheckedCreateWithoutOwnerInput> | DealCreateWithoutOwnerInput[] | DealUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: DealCreateOrConnectWithoutOwnerInput | DealCreateOrConnectWithoutOwnerInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutOwnerInput | DealUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: DealCreateManyOwnerInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutOwnerInput | DealUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: DealUpdateManyWithWhereWithoutOwnerInput | DealUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAssigneeInput | TaskUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAssigneeInput | TaskUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAssigneeInput | TaskUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TaskCreateWithoutCreatedByInput, TaskUncheckedCreateWithoutCreatedByInput> | TaskCreateWithoutCreatedByInput[] | TaskUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatedByInput | TaskCreateOrConnectWithoutCreatedByInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCreatedByInput | TaskUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TaskCreateManyCreatedByInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCreatedByInput | TaskUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCreatedByInput | TaskUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutUserInput | ActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutUserInput | ActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutUserInput | ActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<AppointmentCreateWithoutUserInput, AppointmentUncheckedCreateWithoutUserInput> | AppointmentCreateWithoutUserInput[] | AppointmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserInput | AppointmentCreateOrConnectWithoutUserInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutUserInput | AppointmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AppointmentCreateManyUserInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutUserInput | AppointmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutUserInput | AppointmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type JobDayLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<JobDayLogCreateWithoutUserInput, JobDayLogUncheckedCreateWithoutUserInput> | JobDayLogCreateWithoutUserInput[] | JobDayLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobDayLogCreateOrConnectWithoutUserInput | JobDayLogCreateOrConnectWithoutUserInput[]
    upsert?: JobDayLogUpsertWithWhereUniqueWithoutUserInput | JobDayLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JobDayLogCreateManyUserInputEnvelope
    set?: JobDayLogWhereUniqueInput | JobDayLogWhereUniqueInput[]
    disconnect?: JobDayLogWhereUniqueInput | JobDayLogWhereUniqueInput[]
    delete?: JobDayLogWhereUniqueInput | JobDayLogWhereUniqueInput[]
    connect?: JobDayLogWhereUniqueInput | JobDayLogWhereUniqueInput[]
    update?: JobDayLogUpdateWithWhereUniqueWithoutUserInput | JobDayLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JobDayLogUpdateManyWithWhereWithoutUserInput | JobDayLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JobDayLogScalarWhereInput | JobDayLogScalarWhereInput[]
  }

  export type DesignVersionUpdateManyWithoutDesignerNestedInput = {
    create?: XOR<DesignVersionCreateWithoutDesignerInput, DesignVersionUncheckedCreateWithoutDesignerInput> | DesignVersionCreateWithoutDesignerInput[] | DesignVersionUncheckedCreateWithoutDesignerInput[]
    connectOrCreate?: DesignVersionCreateOrConnectWithoutDesignerInput | DesignVersionCreateOrConnectWithoutDesignerInput[]
    upsert?: DesignVersionUpsertWithWhereUniqueWithoutDesignerInput | DesignVersionUpsertWithWhereUniqueWithoutDesignerInput[]
    createMany?: DesignVersionCreateManyDesignerInputEnvelope
    set?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
    disconnect?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
    delete?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
    connect?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
    update?: DesignVersionUpdateWithWhereUniqueWithoutDesignerInput | DesignVersionUpdateWithWhereUniqueWithoutDesignerInput[]
    updateMany?: DesignVersionUpdateManyWithWhereWithoutDesignerInput | DesignVersionUpdateManyWithWhereWithoutDesignerInput[]
    deleteMany?: DesignVersionScalarWhereInput | DesignVersionScalarWhereInput[]
  }

  export type ClientUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ClientCreateWithoutCreatedByInput, ClientUncheckedCreateWithoutCreatedByInput> | ClientCreateWithoutCreatedByInput[] | ClientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutCreatedByInput | ClientCreateOrConnectWithoutCreatedByInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutCreatedByInput | ClientUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ClientCreateManyCreatedByInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutCreatedByInput | ClientUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutCreatedByInput | ClientUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type ClientUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<ClientCreateWithoutUpdatedByInput, ClientUncheckedCreateWithoutUpdatedByInput> | ClientCreateWithoutUpdatedByInput[] | ClientUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutUpdatedByInput | ClientCreateOrConnectWithoutUpdatedByInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutUpdatedByInput | ClientUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: ClientCreateManyUpdatedByInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutUpdatedByInput | ClientUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutUpdatedByInput | ClientUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type JobUpdateManyWithoutDesignerNestedInput = {
    create?: XOR<JobCreateWithoutDesignerInput, JobUncheckedCreateWithoutDesignerInput> | JobCreateWithoutDesignerInput[] | JobUncheckedCreateWithoutDesignerInput[]
    connectOrCreate?: JobCreateOrConnectWithoutDesignerInput | JobCreateOrConnectWithoutDesignerInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutDesignerInput | JobUpsertWithWhereUniqueWithoutDesignerInput[]
    createMany?: JobCreateManyDesignerInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutDesignerInput | JobUpdateWithWhereUniqueWithoutDesignerInput[]
    updateMany?: JobUpdateManyWithWhereWithoutDesignerInput | JobUpdateManyWithWhereWithoutDesignerInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type InstallerCompanyUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<InstallerCompanyCreateWithoutOwnerInput, InstallerCompanyUncheckedCreateWithoutOwnerInput> | InstallerCompanyCreateWithoutOwnerInput[] | InstallerCompanyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: InstallerCompanyCreateOrConnectWithoutOwnerInput | InstallerCompanyCreateOrConnectWithoutOwnerInput[]
    upsert?: InstallerCompanyUpsertWithWhereUniqueWithoutOwnerInput | InstallerCompanyUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: InstallerCompanyCreateManyOwnerInputEnvelope
    set?: InstallerCompanyWhereUniqueInput | InstallerCompanyWhereUniqueInput[]
    disconnect?: InstallerCompanyWhereUniqueInput | InstallerCompanyWhereUniqueInput[]
    delete?: InstallerCompanyWhereUniqueInput | InstallerCompanyWhereUniqueInput[]
    connect?: InstallerCompanyWhereUniqueInput | InstallerCompanyWhereUniqueInput[]
    update?: InstallerCompanyUpdateWithWhereUniqueWithoutOwnerInput | InstallerCompanyUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: InstallerCompanyUpdateManyWithWhereWithoutOwnerInput | InstallerCompanyUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: InstallerCompanyScalarWhereInput | InstallerCompanyScalarWhereInput[]
  }

  export type DesignClashTicketUpdateManyWithoutReportedByNestedInput = {
    create?: XOR<DesignClashTicketCreateWithoutReportedByInput, DesignClashTicketUncheckedCreateWithoutReportedByInput> | DesignClashTicketCreateWithoutReportedByInput[] | DesignClashTicketUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: DesignClashTicketCreateOrConnectWithoutReportedByInput | DesignClashTicketCreateOrConnectWithoutReportedByInput[]
    upsert?: DesignClashTicketUpsertWithWhereUniqueWithoutReportedByInput | DesignClashTicketUpsertWithWhereUniqueWithoutReportedByInput[]
    createMany?: DesignClashTicketCreateManyReportedByInputEnvelope
    set?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
    disconnect?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
    delete?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
    connect?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
    update?: DesignClashTicketUpdateWithWhereUniqueWithoutReportedByInput | DesignClashTicketUpdateWithWhereUniqueWithoutReportedByInput[]
    updateMany?: DesignClashTicketUpdateManyWithWhereWithoutReportedByInput | DesignClashTicketUpdateManyWithWhereWithoutReportedByInput[]
    deleteMany?: DesignClashTicketScalarWhereInput | DesignClashTicketScalarWhereInput[]
  }

  export type DesignClashTicketUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<DesignClashTicketCreateWithoutAssignedToInput, DesignClashTicketUncheckedCreateWithoutAssignedToInput> | DesignClashTicketCreateWithoutAssignedToInput[] | DesignClashTicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: DesignClashTicketCreateOrConnectWithoutAssignedToInput | DesignClashTicketCreateOrConnectWithoutAssignedToInput[]
    upsert?: DesignClashTicketUpsertWithWhereUniqueWithoutAssignedToInput | DesignClashTicketUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: DesignClashTicketCreateManyAssignedToInputEnvelope
    set?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
    disconnect?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
    delete?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
    connect?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
    update?: DesignClashTicketUpdateWithWhereUniqueWithoutAssignedToInput | DesignClashTicketUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: DesignClashTicketUpdateManyWithWhereWithoutAssignedToInput | DesignClashTicketUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: DesignClashTicketScalarWhereInput | DesignClashTicketScalarWhereInput[]
  }

  export type MoodboardCommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<MoodboardCommentCreateWithoutAuthorInput, MoodboardCommentUncheckedCreateWithoutAuthorInput> | MoodboardCommentCreateWithoutAuthorInput[] | MoodboardCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: MoodboardCommentCreateOrConnectWithoutAuthorInput | MoodboardCommentCreateOrConnectWithoutAuthorInput[]
    upsert?: MoodboardCommentUpsertWithWhereUniqueWithoutAuthorInput | MoodboardCommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: MoodboardCommentCreateManyAuthorInputEnvelope
    set?: MoodboardCommentWhereUniqueInput | MoodboardCommentWhereUniqueInput[]
    disconnect?: MoodboardCommentWhereUniqueInput | MoodboardCommentWhereUniqueInput[]
    delete?: MoodboardCommentWhereUniqueInput | MoodboardCommentWhereUniqueInput[]
    connect?: MoodboardCommentWhereUniqueInput | MoodboardCommentWhereUniqueInput[]
    update?: MoodboardCommentUpdateWithWhereUniqueWithoutAuthorInput | MoodboardCommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: MoodboardCommentUpdateManyWithWhereWithoutAuthorInput | MoodboardCommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: MoodboardCommentScalarWhereInput | MoodboardCommentScalarWhereInput[]
  }

  export type SnagUpdateManyWithoutReportedByNestedInput = {
    create?: XOR<SnagCreateWithoutReportedByInput, SnagUncheckedCreateWithoutReportedByInput> | SnagCreateWithoutReportedByInput[] | SnagUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: SnagCreateOrConnectWithoutReportedByInput | SnagCreateOrConnectWithoutReportedByInput[]
    upsert?: SnagUpsertWithWhereUniqueWithoutReportedByInput | SnagUpsertWithWhereUniqueWithoutReportedByInput[]
    createMany?: SnagCreateManyReportedByInputEnvelope
    set?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    disconnect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    delete?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    connect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    update?: SnagUpdateWithWhereUniqueWithoutReportedByInput | SnagUpdateWithWhereUniqueWithoutReportedByInput[]
    updateMany?: SnagUpdateManyWithWhereWithoutReportedByInput | SnagUpdateManyWithWhereWithoutReportedByInput[]
    deleteMany?: SnagScalarWhereInput | SnagScalarWhereInput[]
  }

  export type SnagUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<SnagCreateWithoutAssignedToInput, SnagUncheckedCreateWithoutAssignedToInput> | SnagCreateWithoutAssignedToInput[] | SnagUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: SnagCreateOrConnectWithoutAssignedToInput | SnagCreateOrConnectWithoutAssignedToInput[]
    upsert?: SnagUpsertWithWhereUniqueWithoutAssignedToInput | SnagUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: SnagCreateManyAssignedToInputEnvelope
    set?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    disconnect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    delete?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    connect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    update?: SnagUpdateWithWhereUniqueWithoutAssignedToInput | SnagUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: SnagUpdateManyWithWhereWithoutAssignedToInput | SnagUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: SnagScalarWhereInput | SnagScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput> | DocumentCreateWithoutUploadedByInput[] | DocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploadedByInput | DocumentCreateOrConnectWithoutUploadedByInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUploadedByInput | DocumentUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: DocumentCreateManyUploadedByInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUploadedByInput | DocumentUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUploadedByInput | DocumentUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type FormSubmissionUpdateManyWithoutSubmittedByNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutSubmittedByInput, FormSubmissionUncheckedCreateWithoutSubmittedByInput> | FormSubmissionCreateWithoutSubmittedByInput[] | FormSubmissionUncheckedCreateWithoutSubmittedByInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutSubmittedByInput | FormSubmissionCreateOrConnectWithoutSubmittedByInput[]
    upsert?: FormSubmissionUpsertWithWhereUniqueWithoutSubmittedByInput | FormSubmissionUpsertWithWhereUniqueWithoutSubmittedByInput[]
    createMany?: FormSubmissionCreateManySubmittedByInputEnvelope
    set?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    disconnect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    delete?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    update?: FormSubmissionUpdateWithWhereUniqueWithoutSubmittedByInput | FormSubmissionUpdateWithWhereUniqueWithoutSubmittedByInput[]
    updateMany?: FormSubmissionUpdateManyWithWhereWithoutSubmittedByInput | FormSubmissionUpdateManyWithWhereWithoutSubmittedByInput[]
    deleteMany?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
  }

  export type EventLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventLogCreateWithoutUserInput, EventLogUncheckedCreateWithoutUserInput> | EventLogCreateWithoutUserInput[] | EventLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventLogCreateOrConnectWithoutUserInput | EventLogCreateOrConnectWithoutUserInput[]
    upsert?: EventLogUpsertWithWhereUniqueWithoutUserInput | EventLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventLogCreateManyUserInputEnvelope
    set?: EventLogWhereUniqueInput | EventLogWhereUniqueInput[]
    disconnect?: EventLogWhereUniqueInput | EventLogWhereUniqueInput[]
    delete?: EventLogWhereUniqueInput | EventLogWhereUniqueInput[]
    connect?: EventLogWhereUniqueInput | EventLogWhereUniqueInput[]
    update?: EventLogUpdateWithWhereUniqueWithoutUserInput | EventLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventLogUpdateManyWithWhereWithoutUserInput | EventLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventLogScalarWhereInput | EventLogScalarWhereInput[]
  }

  export type MergeQueueUpdateManyWithoutReviewedByNestedInput = {
    create?: XOR<MergeQueueCreateWithoutReviewedByInput, MergeQueueUncheckedCreateWithoutReviewedByInput> | MergeQueueCreateWithoutReviewedByInput[] | MergeQueueUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: MergeQueueCreateOrConnectWithoutReviewedByInput | MergeQueueCreateOrConnectWithoutReviewedByInput[]
    upsert?: MergeQueueUpsertWithWhereUniqueWithoutReviewedByInput | MergeQueueUpsertWithWhereUniqueWithoutReviewedByInput[]
    createMany?: MergeQueueCreateManyReviewedByInputEnvelope
    set?: MergeQueueWhereUniqueInput | MergeQueueWhereUniqueInput[]
    disconnect?: MergeQueueWhereUniqueInput | MergeQueueWhereUniqueInput[]
    delete?: MergeQueueWhereUniqueInput | MergeQueueWhereUniqueInput[]
    connect?: MergeQueueWhereUniqueInput | MergeQueueWhereUniqueInput[]
    update?: MergeQueueUpdateWithWhereUniqueWithoutReviewedByInput | MergeQueueUpdateWithWhereUniqueWithoutReviewedByInput[]
    updateMany?: MergeQueueUpdateManyWithWhereWithoutReviewedByInput | MergeQueueUpdateManyWithWhereWithoutReviewedByInput[]
    deleteMany?: MergeQueueScalarWhereInput | MergeQueueScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCreatedByInput | UserUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCreatedByInput | UserUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCreatedByInput | UserUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedByInput, UserUncheckedCreateWithoutUpdatedByInput> | UserCreateWithoutUpdatedByInput[] | UserUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedByInput | UserCreateOrConnectWithoutUpdatedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutUpdatedByInput | UserUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: UserCreateManyUpdatedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutUpdatedByInput | UserUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutUpdatedByInput | UserUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ClientUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ClientCreateWithoutOwnerInput, ClientUncheckedCreateWithoutOwnerInput> | ClientCreateWithoutOwnerInput[] | ClientUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutOwnerInput | ClientCreateOrConnectWithoutOwnerInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutOwnerInput | ClientUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ClientCreateManyOwnerInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutOwnerInput | ClientUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutOwnerInput | ClientUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type LeadUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<LeadCreateWithoutOwnerInput, LeadUncheckedCreateWithoutOwnerInput> | LeadCreateWithoutOwnerInput[] | LeadUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutOwnerInput | LeadCreateOrConnectWithoutOwnerInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutOwnerInput | LeadUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: LeadCreateManyOwnerInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutOwnerInput | LeadUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutOwnerInput | LeadUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type DealUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<DealCreateWithoutOwnerInput, DealUncheckedCreateWithoutOwnerInput> | DealCreateWithoutOwnerInput[] | DealUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: DealCreateOrConnectWithoutOwnerInput | DealCreateOrConnectWithoutOwnerInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutOwnerInput | DealUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: DealCreateManyOwnerInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutOwnerInput | DealUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: DealUpdateManyWithWhereWithoutOwnerInput | DealUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAssigneeInput | TaskUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAssigneeInput | TaskUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAssigneeInput | TaskUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TaskCreateWithoutCreatedByInput, TaskUncheckedCreateWithoutCreatedByInput> | TaskCreateWithoutCreatedByInput[] | TaskUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatedByInput | TaskCreateOrConnectWithoutCreatedByInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCreatedByInput | TaskUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TaskCreateManyCreatedByInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCreatedByInput | TaskUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCreatedByInput | TaskUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutUserInput | ActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutUserInput | ActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutUserInput | ActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AppointmentCreateWithoutUserInput, AppointmentUncheckedCreateWithoutUserInput> | AppointmentCreateWithoutUserInput[] | AppointmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserInput | AppointmentCreateOrConnectWithoutUserInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutUserInput | AppointmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AppointmentCreateManyUserInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutUserInput | AppointmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutUserInput | AppointmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type JobDayLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<JobDayLogCreateWithoutUserInput, JobDayLogUncheckedCreateWithoutUserInput> | JobDayLogCreateWithoutUserInput[] | JobDayLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobDayLogCreateOrConnectWithoutUserInput | JobDayLogCreateOrConnectWithoutUserInput[]
    upsert?: JobDayLogUpsertWithWhereUniqueWithoutUserInput | JobDayLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JobDayLogCreateManyUserInputEnvelope
    set?: JobDayLogWhereUniqueInput | JobDayLogWhereUniqueInput[]
    disconnect?: JobDayLogWhereUniqueInput | JobDayLogWhereUniqueInput[]
    delete?: JobDayLogWhereUniqueInput | JobDayLogWhereUniqueInput[]
    connect?: JobDayLogWhereUniqueInput | JobDayLogWhereUniqueInput[]
    update?: JobDayLogUpdateWithWhereUniqueWithoutUserInput | JobDayLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JobDayLogUpdateManyWithWhereWithoutUserInput | JobDayLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JobDayLogScalarWhereInput | JobDayLogScalarWhereInput[]
  }

  export type DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput = {
    create?: XOR<DesignVersionCreateWithoutDesignerInput, DesignVersionUncheckedCreateWithoutDesignerInput> | DesignVersionCreateWithoutDesignerInput[] | DesignVersionUncheckedCreateWithoutDesignerInput[]
    connectOrCreate?: DesignVersionCreateOrConnectWithoutDesignerInput | DesignVersionCreateOrConnectWithoutDesignerInput[]
    upsert?: DesignVersionUpsertWithWhereUniqueWithoutDesignerInput | DesignVersionUpsertWithWhereUniqueWithoutDesignerInput[]
    createMany?: DesignVersionCreateManyDesignerInputEnvelope
    set?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
    disconnect?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
    delete?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
    connect?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
    update?: DesignVersionUpdateWithWhereUniqueWithoutDesignerInput | DesignVersionUpdateWithWhereUniqueWithoutDesignerInput[]
    updateMany?: DesignVersionUpdateManyWithWhereWithoutDesignerInput | DesignVersionUpdateManyWithWhereWithoutDesignerInput[]
    deleteMany?: DesignVersionScalarWhereInput | DesignVersionScalarWhereInput[]
  }

  export type ClientUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ClientCreateWithoutCreatedByInput, ClientUncheckedCreateWithoutCreatedByInput> | ClientCreateWithoutCreatedByInput[] | ClientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutCreatedByInput | ClientCreateOrConnectWithoutCreatedByInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutCreatedByInput | ClientUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ClientCreateManyCreatedByInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutCreatedByInput | ClientUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutCreatedByInput | ClientUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type ClientUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<ClientCreateWithoutUpdatedByInput, ClientUncheckedCreateWithoutUpdatedByInput> | ClientCreateWithoutUpdatedByInput[] | ClientUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutUpdatedByInput | ClientCreateOrConnectWithoutUpdatedByInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutUpdatedByInput | ClientUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: ClientCreateManyUpdatedByInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutUpdatedByInput | ClientUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutUpdatedByInput | ClientUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type JobUncheckedUpdateManyWithoutDesignerNestedInput = {
    create?: XOR<JobCreateWithoutDesignerInput, JobUncheckedCreateWithoutDesignerInput> | JobCreateWithoutDesignerInput[] | JobUncheckedCreateWithoutDesignerInput[]
    connectOrCreate?: JobCreateOrConnectWithoutDesignerInput | JobCreateOrConnectWithoutDesignerInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutDesignerInput | JobUpsertWithWhereUniqueWithoutDesignerInput[]
    createMany?: JobCreateManyDesignerInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutDesignerInput | JobUpdateWithWhereUniqueWithoutDesignerInput[]
    updateMany?: JobUpdateManyWithWhereWithoutDesignerInput | JobUpdateManyWithWhereWithoutDesignerInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<InstallerCompanyCreateWithoutOwnerInput, InstallerCompanyUncheckedCreateWithoutOwnerInput> | InstallerCompanyCreateWithoutOwnerInput[] | InstallerCompanyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: InstallerCompanyCreateOrConnectWithoutOwnerInput | InstallerCompanyCreateOrConnectWithoutOwnerInput[]
    upsert?: InstallerCompanyUpsertWithWhereUniqueWithoutOwnerInput | InstallerCompanyUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: InstallerCompanyCreateManyOwnerInputEnvelope
    set?: InstallerCompanyWhereUniqueInput | InstallerCompanyWhereUniqueInput[]
    disconnect?: InstallerCompanyWhereUniqueInput | InstallerCompanyWhereUniqueInput[]
    delete?: InstallerCompanyWhereUniqueInput | InstallerCompanyWhereUniqueInput[]
    connect?: InstallerCompanyWhereUniqueInput | InstallerCompanyWhereUniqueInput[]
    update?: InstallerCompanyUpdateWithWhereUniqueWithoutOwnerInput | InstallerCompanyUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: InstallerCompanyUpdateManyWithWhereWithoutOwnerInput | InstallerCompanyUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: InstallerCompanyScalarWhereInput | InstallerCompanyScalarWhereInput[]
  }

  export type DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput = {
    create?: XOR<DesignClashTicketCreateWithoutReportedByInput, DesignClashTicketUncheckedCreateWithoutReportedByInput> | DesignClashTicketCreateWithoutReportedByInput[] | DesignClashTicketUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: DesignClashTicketCreateOrConnectWithoutReportedByInput | DesignClashTicketCreateOrConnectWithoutReportedByInput[]
    upsert?: DesignClashTicketUpsertWithWhereUniqueWithoutReportedByInput | DesignClashTicketUpsertWithWhereUniqueWithoutReportedByInput[]
    createMany?: DesignClashTicketCreateManyReportedByInputEnvelope
    set?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
    disconnect?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
    delete?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
    connect?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
    update?: DesignClashTicketUpdateWithWhereUniqueWithoutReportedByInput | DesignClashTicketUpdateWithWhereUniqueWithoutReportedByInput[]
    updateMany?: DesignClashTicketUpdateManyWithWhereWithoutReportedByInput | DesignClashTicketUpdateManyWithWhereWithoutReportedByInput[]
    deleteMany?: DesignClashTicketScalarWhereInput | DesignClashTicketScalarWhereInput[]
  }

  export type DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<DesignClashTicketCreateWithoutAssignedToInput, DesignClashTicketUncheckedCreateWithoutAssignedToInput> | DesignClashTicketCreateWithoutAssignedToInput[] | DesignClashTicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: DesignClashTicketCreateOrConnectWithoutAssignedToInput | DesignClashTicketCreateOrConnectWithoutAssignedToInput[]
    upsert?: DesignClashTicketUpsertWithWhereUniqueWithoutAssignedToInput | DesignClashTicketUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: DesignClashTicketCreateManyAssignedToInputEnvelope
    set?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
    disconnect?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
    delete?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
    connect?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
    update?: DesignClashTicketUpdateWithWhereUniqueWithoutAssignedToInput | DesignClashTicketUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: DesignClashTicketUpdateManyWithWhereWithoutAssignedToInput | DesignClashTicketUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: DesignClashTicketScalarWhereInput | DesignClashTicketScalarWhereInput[]
  }

  export type MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<MoodboardCommentCreateWithoutAuthorInput, MoodboardCommentUncheckedCreateWithoutAuthorInput> | MoodboardCommentCreateWithoutAuthorInput[] | MoodboardCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: MoodboardCommentCreateOrConnectWithoutAuthorInput | MoodboardCommentCreateOrConnectWithoutAuthorInput[]
    upsert?: MoodboardCommentUpsertWithWhereUniqueWithoutAuthorInput | MoodboardCommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: MoodboardCommentCreateManyAuthorInputEnvelope
    set?: MoodboardCommentWhereUniqueInput | MoodboardCommentWhereUniqueInput[]
    disconnect?: MoodboardCommentWhereUniqueInput | MoodboardCommentWhereUniqueInput[]
    delete?: MoodboardCommentWhereUniqueInput | MoodboardCommentWhereUniqueInput[]
    connect?: MoodboardCommentWhereUniqueInput | MoodboardCommentWhereUniqueInput[]
    update?: MoodboardCommentUpdateWithWhereUniqueWithoutAuthorInput | MoodboardCommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: MoodboardCommentUpdateManyWithWhereWithoutAuthorInput | MoodboardCommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: MoodboardCommentScalarWhereInput | MoodboardCommentScalarWhereInput[]
  }

  export type SnagUncheckedUpdateManyWithoutReportedByNestedInput = {
    create?: XOR<SnagCreateWithoutReportedByInput, SnagUncheckedCreateWithoutReportedByInput> | SnagCreateWithoutReportedByInput[] | SnagUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: SnagCreateOrConnectWithoutReportedByInput | SnagCreateOrConnectWithoutReportedByInput[]
    upsert?: SnagUpsertWithWhereUniqueWithoutReportedByInput | SnagUpsertWithWhereUniqueWithoutReportedByInput[]
    createMany?: SnagCreateManyReportedByInputEnvelope
    set?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    disconnect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    delete?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    connect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    update?: SnagUpdateWithWhereUniqueWithoutReportedByInput | SnagUpdateWithWhereUniqueWithoutReportedByInput[]
    updateMany?: SnagUpdateManyWithWhereWithoutReportedByInput | SnagUpdateManyWithWhereWithoutReportedByInput[]
    deleteMany?: SnagScalarWhereInput | SnagScalarWhereInput[]
  }

  export type SnagUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<SnagCreateWithoutAssignedToInput, SnagUncheckedCreateWithoutAssignedToInput> | SnagCreateWithoutAssignedToInput[] | SnagUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: SnagCreateOrConnectWithoutAssignedToInput | SnagCreateOrConnectWithoutAssignedToInput[]
    upsert?: SnagUpsertWithWhereUniqueWithoutAssignedToInput | SnagUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: SnagCreateManyAssignedToInputEnvelope
    set?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    disconnect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    delete?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    connect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    update?: SnagUpdateWithWhereUniqueWithoutAssignedToInput | SnagUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: SnagUpdateManyWithWhereWithoutAssignedToInput | SnagUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: SnagScalarWhereInput | SnagScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput> | DocumentCreateWithoutUploadedByInput[] | DocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploadedByInput | DocumentCreateOrConnectWithoutUploadedByInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUploadedByInput | DocumentUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: DocumentCreateManyUploadedByInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUploadedByInput | DocumentUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUploadedByInput | DocumentUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutSubmittedByInput, FormSubmissionUncheckedCreateWithoutSubmittedByInput> | FormSubmissionCreateWithoutSubmittedByInput[] | FormSubmissionUncheckedCreateWithoutSubmittedByInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutSubmittedByInput | FormSubmissionCreateOrConnectWithoutSubmittedByInput[]
    upsert?: FormSubmissionUpsertWithWhereUniqueWithoutSubmittedByInput | FormSubmissionUpsertWithWhereUniqueWithoutSubmittedByInput[]
    createMany?: FormSubmissionCreateManySubmittedByInputEnvelope
    set?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    disconnect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    delete?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    update?: FormSubmissionUpdateWithWhereUniqueWithoutSubmittedByInput | FormSubmissionUpdateWithWhereUniqueWithoutSubmittedByInput[]
    updateMany?: FormSubmissionUpdateManyWithWhereWithoutSubmittedByInput | FormSubmissionUpdateManyWithWhereWithoutSubmittedByInput[]
    deleteMany?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
  }

  export type EventLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventLogCreateWithoutUserInput, EventLogUncheckedCreateWithoutUserInput> | EventLogCreateWithoutUserInput[] | EventLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventLogCreateOrConnectWithoutUserInput | EventLogCreateOrConnectWithoutUserInput[]
    upsert?: EventLogUpsertWithWhereUniqueWithoutUserInput | EventLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventLogCreateManyUserInputEnvelope
    set?: EventLogWhereUniqueInput | EventLogWhereUniqueInput[]
    disconnect?: EventLogWhereUniqueInput | EventLogWhereUniqueInput[]
    delete?: EventLogWhereUniqueInput | EventLogWhereUniqueInput[]
    connect?: EventLogWhereUniqueInput | EventLogWhereUniqueInput[]
    update?: EventLogUpdateWithWhereUniqueWithoutUserInput | EventLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventLogUpdateManyWithWhereWithoutUserInput | EventLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventLogScalarWhereInput | EventLogScalarWhereInput[]
  }

  export type MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput = {
    create?: XOR<MergeQueueCreateWithoutReviewedByInput, MergeQueueUncheckedCreateWithoutReviewedByInput> | MergeQueueCreateWithoutReviewedByInput[] | MergeQueueUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: MergeQueueCreateOrConnectWithoutReviewedByInput | MergeQueueCreateOrConnectWithoutReviewedByInput[]
    upsert?: MergeQueueUpsertWithWhereUniqueWithoutReviewedByInput | MergeQueueUpsertWithWhereUniqueWithoutReviewedByInput[]
    createMany?: MergeQueueCreateManyReviewedByInputEnvelope
    set?: MergeQueueWhereUniqueInput | MergeQueueWhereUniqueInput[]
    disconnect?: MergeQueueWhereUniqueInput | MergeQueueWhereUniqueInput[]
    delete?: MergeQueueWhereUniqueInput | MergeQueueWhereUniqueInput[]
    connect?: MergeQueueWhereUniqueInput | MergeQueueWhereUniqueInput[]
    update?: MergeQueueUpdateWithWhereUniqueWithoutReviewedByInput | MergeQueueUpdateWithWhereUniqueWithoutReviewedByInput[]
    updateMany?: MergeQueueUpdateManyWithWhereWithoutReviewedByInput | MergeQueueUpdateManyWithWhereWithoutReviewedByInput[]
    deleteMany?: MergeQueueScalarWhereInput | MergeQueueScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCreatedClientsInput = {
    create?: XOR<UserCreateWithoutCreatedClientsInput, UserUncheckedCreateWithoutCreatedClientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedClientsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdatedClientsInput = {
    create?: XOR<UserCreateWithoutUpdatedClientsInput, UserUncheckedCreateWithoutUpdatedClientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedClientsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOwnedClientsInput = {
    create?: XOR<UserCreateWithoutOwnedClientsInput, UserUncheckedCreateWithoutOwnedClientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedClientsInput
    connect?: UserWhereUniqueInput
  }

  export type ContactCreateNestedManyWithoutClientInput = {
    create?: XOR<ContactCreateWithoutClientInput, ContactUncheckedCreateWithoutClientInput> | ContactCreateWithoutClientInput[] | ContactUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutClientInput | ContactCreateOrConnectWithoutClientInput[]
    createMany?: ContactCreateManyClientInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type LeadCreateNestedManyWithoutClientInput = {
    create?: XOR<LeadCreateWithoutClientInput, LeadUncheckedCreateWithoutClientInput> | LeadCreateWithoutClientInput[] | LeadUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutClientInput | LeadCreateOrConnectWithoutClientInput[]
    createMany?: LeadCreateManyClientInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type DealCreateNestedManyWithoutClientInput = {
    create?: XOR<DealCreateWithoutClientInput, DealUncheckedCreateWithoutClientInput> | DealCreateWithoutClientInput[] | DealUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DealCreateOrConnectWithoutClientInput | DealCreateOrConnectWithoutClientInput[]
    createMany?: DealCreateManyClientInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type RoomCreateNestedManyWithoutClientInput = {
    create?: XOR<RoomCreateWithoutClientInput, RoomUncheckedCreateWithoutClientInput> | RoomCreateWithoutClientInput[] | RoomUncheckedCreateWithoutClientInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutClientInput | RoomCreateOrConnectWithoutClientInput[]
    createMany?: RoomCreateManyClientInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type JobCreateNestedManyWithoutClientInput = {
    create?: XOR<JobCreateWithoutClientInput, JobUncheckedCreateWithoutClientInput> | JobCreateWithoutClientInput[] | JobUncheckedCreateWithoutClientInput[]
    connectOrCreate?: JobCreateOrConnectWithoutClientInput | JobCreateOrConnectWithoutClientInput[]
    createMany?: JobCreateManyClientInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutClientInput = {
    create?: XOR<ActivityCreateWithoutClientInput, ActivityUncheckedCreateWithoutClientInput> | ActivityCreateWithoutClientInput[] | ActivityUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutClientInput | ActivityCreateOrConnectWithoutClientInput[]
    createMany?: ActivityCreateManyClientInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutClientInput = {
    create?: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput> | DocumentCreateWithoutClientInput[] | DocumentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClientInput | DocumentCreateOrConnectWithoutClientInput[]
    createMany?: DocumentCreateManyClientInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutClientInput = {
    create?: XOR<AppointmentCreateWithoutClientInput, AppointmentUncheckedCreateWithoutClientInput> | AppointmentCreateWithoutClientInput[] | AppointmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutClientInput | AppointmentCreateOrConnectWithoutClientInput[]
    createMany?: AppointmentCreateManyClientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type MoodboardCreateNestedManyWithoutClientInput = {
    create?: XOR<MoodboardCreateWithoutClientInput, MoodboardUncheckedCreateWithoutClientInput> | MoodboardCreateWithoutClientInput[] | MoodboardUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MoodboardCreateOrConnectWithoutClientInput | MoodboardCreateOrConnectWithoutClientInput[]
    createMany?: MoodboardCreateManyClientInputEnvelope
    connect?: MoodboardWhereUniqueInput | MoodboardWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ContactCreateWithoutClientInput, ContactUncheckedCreateWithoutClientInput> | ContactCreateWithoutClientInput[] | ContactUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutClientInput | ContactCreateOrConnectWithoutClientInput[]
    createMany?: ContactCreateManyClientInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<LeadCreateWithoutClientInput, LeadUncheckedCreateWithoutClientInput> | LeadCreateWithoutClientInput[] | LeadUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutClientInput | LeadCreateOrConnectWithoutClientInput[]
    createMany?: LeadCreateManyClientInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type DealUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<DealCreateWithoutClientInput, DealUncheckedCreateWithoutClientInput> | DealCreateWithoutClientInput[] | DealUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DealCreateOrConnectWithoutClientInput | DealCreateOrConnectWithoutClientInput[]
    createMany?: DealCreateManyClientInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<RoomCreateWithoutClientInput, RoomUncheckedCreateWithoutClientInput> | RoomCreateWithoutClientInput[] | RoomUncheckedCreateWithoutClientInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutClientInput | RoomCreateOrConnectWithoutClientInput[]
    createMany?: RoomCreateManyClientInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type JobUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<JobCreateWithoutClientInput, JobUncheckedCreateWithoutClientInput> | JobCreateWithoutClientInput[] | JobUncheckedCreateWithoutClientInput[]
    connectOrCreate?: JobCreateOrConnectWithoutClientInput | JobCreateOrConnectWithoutClientInput[]
    createMany?: JobCreateManyClientInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ActivityCreateWithoutClientInput, ActivityUncheckedCreateWithoutClientInput> | ActivityCreateWithoutClientInput[] | ActivityUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutClientInput | ActivityCreateOrConnectWithoutClientInput[]
    createMany?: ActivityCreateManyClientInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput> | DocumentCreateWithoutClientInput[] | DocumentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClientInput | DocumentCreateOrConnectWithoutClientInput[]
    createMany?: DocumentCreateManyClientInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<AppointmentCreateWithoutClientInput, AppointmentUncheckedCreateWithoutClientInput> | AppointmentCreateWithoutClientInput[] | AppointmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutClientInput | AppointmentCreateOrConnectWithoutClientInput[]
    createMany?: AppointmentCreateManyClientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type MoodboardUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<MoodboardCreateWithoutClientInput, MoodboardUncheckedCreateWithoutClientInput> | MoodboardCreateWithoutClientInput[] | MoodboardUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MoodboardCreateOrConnectWithoutClientInput | MoodboardCreateOrConnectWithoutClientInput[]
    createMany?: MoodboardCreateManyClientInputEnvelope
    connect?: MoodboardWhereUniqueInput | MoodboardWhereUniqueInput[]
  }

  export type EnumClientTypeFieldUpdateOperationsInput = {
    set?: $Enums.ClientType
  }

  export type UserUpdateOneWithoutCreatedClientsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedClientsInput, UserUncheckedCreateWithoutCreatedClientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedClientsInput
    upsert?: UserUpsertWithoutCreatedClientsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedClientsInput, UserUpdateWithoutCreatedClientsInput>, UserUncheckedUpdateWithoutCreatedClientsInput>
  }

  export type UserUpdateOneWithoutUpdatedClientsNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedClientsInput, UserUncheckedCreateWithoutUpdatedClientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedClientsInput
    upsert?: UserUpsertWithoutUpdatedClientsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedClientsInput, UserUpdateWithoutUpdatedClientsInput>, UserUncheckedUpdateWithoutUpdatedClientsInput>
  }

  export type UserUpdateOneRequiredWithoutOwnedClientsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedClientsInput, UserUncheckedCreateWithoutOwnedClientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedClientsInput
    upsert?: UserUpsertWithoutOwnedClientsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedClientsInput, UserUpdateWithoutOwnedClientsInput>, UserUncheckedUpdateWithoutOwnedClientsInput>
  }

  export type ContactUpdateManyWithoutClientNestedInput = {
    create?: XOR<ContactCreateWithoutClientInput, ContactUncheckedCreateWithoutClientInput> | ContactCreateWithoutClientInput[] | ContactUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutClientInput | ContactCreateOrConnectWithoutClientInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutClientInput | ContactUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ContactCreateManyClientInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutClientInput | ContactUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutClientInput | ContactUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type LeadUpdateManyWithoutClientNestedInput = {
    create?: XOR<LeadCreateWithoutClientInput, LeadUncheckedCreateWithoutClientInput> | LeadCreateWithoutClientInput[] | LeadUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutClientInput | LeadCreateOrConnectWithoutClientInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutClientInput | LeadUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: LeadCreateManyClientInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutClientInput | LeadUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutClientInput | LeadUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type DealUpdateManyWithoutClientNestedInput = {
    create?: XOR<DealCreateWithoutClientInput, DealUncheckedCreateWithoutClientInput> | DealCreateWithoutClientInput[] | DealUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DealCreateOrConnectWithoutClientInput | DealCreateOrConnectWithoutClientInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutClientInput | DealUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: DealCreateManyClientInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutClientInput | DealUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: DealUpdateManyWithWhereWithoutClientInput | DealUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type RoomUpdateManyWithoutClientNestedInput = {
    create?: XOR<RoomCreateWithoutClientInput, RoomUncheckedCreateWithoutClientInput> | RoomCreateWithoutClientInput[] | RoomUncheckedCreateWithoutClientInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutClientInput | RoomCreateOrConnectWithoutClientInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutClientInput | RoomUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: RoomCreateManyClientInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutClientInput | RoomUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutClientInput | RoomUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type JobUpdateManyWithoutClientNestedInput = {
    create?: XOR<JobCreateWithoutClientInput, JobUncheckedCreateWithoutClientInput> | JobCreateWithoutClientInput[] | JobUncheckedCreateWithoutClientInput[]
    connectOrCreate?: JobCreateOrConnectWithoutClientInput | JobCreateOrConnectWithoutClientInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutClientInput | JobUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: JobCreateManyClientInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutClientInput | JobUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: JobUpdateManyWithWhereWithoutClientInput | JobUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutClientNestedInput = {
    create?: XOR<ActivityCreateWithoutClientInput, ActivityUncheckedCreateWithoutClientInput> | ActivityCreateWithoutClientInput[] | ActivityUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutClientInput | ActivityCreateOrConnectWithoutClientInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutClientInput | ActivityUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ActivityCreateManyClientInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutClientInput | ActivityUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutClientInput | ActivityUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutClientNestedInput = {
    create?: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput> | DocumentCreateWithoutClientInput[] | DocumentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClientInput | DocumentCreateOrConnectWithoutClientInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutClientInput | DocumentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: DocumentCreateManyClientInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutClientInput | DocumentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutClientInput | DocumentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutClientNestedInput = {
    create?: XOR<AppointmentCreateWithoutClientInput, AppointmentUncheckedCreateWithoutClientInput> | AppointmentCreateWithoutClientInput[] | AppointmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutClientInput | AppointmentCreateOrConnectWithoutClientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutClientInput | AppointmentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AppointmentCreateManyClientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutClientInput | AppointmentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutClientInput | AppointmentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type MoodboardUpdateManyWithoutClientNestedInput = {
    create?: XOR<MoodboardCreateWithoutClientInput, MoodboardUncheckedCreateWithoutClientInput> | MoodboardCreateWithoutClientInput[] | MoodboardUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MoodboardCreateOrConnectWithoutClientInput | MoodboardCreateOrConnectWithoutClientInput[]
    upsert?: MoodboardUpsertWithWhereUniqueWithoutClientInput | MoodboardUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: MoodboardCreateManyClientInputEnvelope
    set?: MoodboardWhereUniqueInput | MoodboardWhereUniqueInput[]
    disconnect?: MoodboardWhereUniqueInput | MoodboardWhereUniqueInput[]
    delete?: MoodboardWhereUniqueInput | MoodboardWhereUniqueInput[]
    connect?: MoodboardWhereUniqueInput | MoodboardWhereUniqueInput[]
    update?: MoodboardUpdateWithWhereUniqueWithoutClientInput | MoodboardUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: MoodboardUpdateManyWithWhereWithoutClientInput | MoodboardUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: MoodboardScalarWhereInput | MoodboardScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ContactCreateWithoutClientInput, ContactUncheckedCreateWithoutClientInput> | ContactCreateWithoutClientInput[] | ContactUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutClientInput | ContactCreateOrConnectWithoutClientInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutClientInput | ContactUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ContactCreateManyClientInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutClientInput | ContactUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutClientInput | ContactUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type LeadUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<LeadCreateWithoutClientInput, LeadUncheckedCreateWithoutClientInput> | LeadCreateWithoutClientInput[] | LeadUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutClientInput | LeadCreateOrConnectWithoutClientInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutClientInput | LeadUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: LeadCreateManyClientInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutClientInput | LeadUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutClientInput | LeadUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type DealUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<DealCreateWithoutClientInput, DealUncheckedCreateWithoutClientInput> | DealCreateWithoutClientInput[] | DealUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DealCreateOrConnectWithoutClientInput | DealCreateOrConnectWithoutClientInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutClientInput | DealUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: DealCreateManyClientInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutClientInput | DealUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: DealUpdateManyWithWhereWithoutClientInput | DealUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<RoomCreateWithoutClientInput, RoomUncheckedCreateWithoutClientInput> | RoomCreateWithoutClientInput[] | RoomUncheckedCreateWithoutClientInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutClientInput | RoomCreateOrConnectWithoutClientInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutClientInput | RoomUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: RoomCreateManyClientInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutClientInput | RoomUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutClientInput | RoomUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type JobUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<JobCreateWithoutClientInput, JobUncheckedCreateWithoutClientInput> | JobCreateWithoutClientInput[] | JobUncheckedCreateWithoutClientInput[]
    connectOrCreate?: JobCreateOrConnectWithoutClientInput | JobCreateOrConnectWithoutClientInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutClientInput | JobUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: JobCreateManyClientInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutClientInput | JobUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: JobUpdateManyWithWhereWithoutClientInput | JobUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ActivityCreateWithoutClientInput, ActivityUncheckedCreateWithoutClientInput> | ActivityCreateWithoutClientInput[] | ActivityUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutClientInput | ActivityCreateOrConnectWithoutClientInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutClientInput | ActivityUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ActivityCreateManyClientInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutClientInput | ActivityUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutClientInput | ActivityUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput> | DocumentCreateWithoutClientInput[] | DocumentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClientInput | DocumentCreateOrConnectWithoutClientInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutClientInput | DocumentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: DocumentCreateManyClientInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutClientInput | DocumentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutClientInput | DocumentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<AppointmentCreateWithoutClientInput, AppointmentUncheckedCreateWithoutClientInput> | AppointmentCreateWithoutClientInput[] | AppointmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutClientInput | AppointmentCreateOrConnectWithoutClientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutClientInput | AppointmentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AppointmentCreateManyClientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutClientInput | AppointmentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutClientInput | AppointmentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type MoodboardUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<MoodboardCreateWithoutClientInput, MoodboardUncheckedCreateWithoutClientInput> | MoodboardCreateWithoutClientInput[] | MoodboardUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MoodboardCreateOrConnectWithoutClientInput | MoodboardCreateOrConnectWithoutClientInput[]
    upsert?: MoodboardUpsertWithWhereUniqueWithoutClientInput | MoodboardUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: MoodboardCreateManyClientInputEnvelope
    set?: MoodboardWhereUniqueInput | MoodboardWhereUniqueInput[]
    disconnect?: MoodboardWhereUniqueInput | MoodboardWhereUniqueInput[]
    delete?: MoodboardWhereUniqueInput | MoodboardWhereUniqueInput[]
    connect?: MoodboardWhereUniqueInput | MoodboardWhereUniqueInput[]
    update?: MoodboardUpdateWithWhereUniqueWithoutClientInput | MoodboardUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: MoodboardUpdateManyWithWhereWithoutClientInput | MoodboardUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: MoodboardScalarWhereInput | MoodboardScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutContactsInput = {
    create?: XOR<ClientCreateWithoutContactsInput, ClientUncheckedCreateWithoutContactsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutContactsInput
    connect?: ClientWhereUniqueInput
  }

  export type ActivityCreateNestedManyWithoutContactInput = {
    create?: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput> | ActivityCreateWithoutContactInput[] | ActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutContactInput | ActivityCreateOrConnectWithoutContactInput[]
    createMany?: ActivityCreateManyContactInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput> | ActivityCreateWithoutContactInput[] | ActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutContactInput | ActivityCreateOrConnectWithoutContactInput[]
    createMany?: ActivityCreateManyContactInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ClientUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<ClientCreateWithoutContactsInput, ClientUncheckedCreateWithoutContactsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutContactsInput
    upsert?: ClientUpsertWithoutContactsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutContactsInput, ClientUpdateWithoutContactsInput>, ClientUncheckedUpdateWithoutContactsInput>
  }

  export type ActivityUpdateManyWithoutContactNestedInput = {
    create?: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput> | ActivityCreateWithoutContactInput[] | ActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutContactInput | ActivityCreateOrConnectWithoutContactInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutContactInput | ActivityUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ActivityCreateManyContactInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutContactInput | ActivityUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutContactInput | ActivityUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput> | ActivityCreateWithoutContactInput[] | ActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutContactInput | ActivityCreateOrConnectWithoutContactInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutContactInput | ActivityUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ActivityCreateManyContactInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutContactInput | ActivityUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutContactInput | ActivityUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutLeadsInput = {
    create?: XOR<ClientCreateWithoutLeadsInput, ClientUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutLeadsInput
    connect?: ClientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOwnedLeadsInput = {
    create?: XOR<UserCreateWithoutOwnedLeadsInput, UserUncheckedCreateWithoutOwnedLeadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedLeadsInput
    connect?: UserWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutLeadInput = {
    create?: XOR<DealCreateWithoutLeadInput, DealUncheckedCreateWithoutLeadInput>
    connectOrCreate?: DealCreateOrConnectWithoutLeadInput
    connect?: DealWhereUniqueInput
  }

  export type ActivityCreateNestedManyWithoutLeadInput = {
    create?: XOR<ActivityCreateWithoutLeadInput, ActivityUncheckedCreateWithoutLeadInput> | ActivityCreateWithoutLeadInput[] | ActivityUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutLeadInput | ActivityCreateOrConnectWithoutLeadInput[]
    createMany?: ActivityCreateManyLeadInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutLeadInput = {
    create?: XOR<TaskCreateWithoutLeadInput, TaskUncheckedCreateWithoutLeadInput> | TaskCreateWithoutLeadInput[] | TaskUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutLeadInput | TaskCreateOrConnectWithoutLeadInput[]
    createMany?: TaskCreateManyLeadInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<ActivityCreateWithoutLeadInput, ActivityUncheckedCreateWithoutLeadInput> | ActivityCreateWithoutLeadInput[] | ActivityUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutLeadInput | ActivityCreateOrConnectWithoutLeadInput[]
    createMany?: ActivityCreateManyLeadInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<TaskCreateWithoutLeadInput, TaskUncheckedCreateWithoutLeadInput> | TaskCreateWithoutLeadInput[] | TaskUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutLeadInput | TaskCreateOrConnectWithoutLeadInput[]
    createMany?: TaskCreateManyLeadInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type EnumLeadStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeadStatus
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClientUpdateOneRequiredWithoutLeadsNestedInput = {
    create?: XOR<ClientCreateWithoutLeadsInput, ClientUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutLeadsInput
    upsert?: ClientUpsertWithoutLeadsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutLeadsInput, ClientUpdateWithoutLeadsInput>, ClientUncheckedUpdateWithoutLeadsInput>
  }

  export type UserUpdateOneRequiredWithoutOwnedLeadsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedLeadsInput, UserUncheckedCreateWithoutOwnedLeadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedLeadsInput
    upsert?: UserUpsertWithoutOwnedLeadsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedLeadsInput, UserUpdateWithoutOwnedLeadsInput>, UserUncheckedUpdateWithoutOwnedLeadsInput>
  }

  export type DealUpdateOneWithoutLeadNestedInput = {
    create?: XOR<DealCreateWithoutLeadInput, DealUncheckedCreateWithoutLeadInput>
    connectOrCreate?: DealCreateOrConnectWithoutLeadInput
    upsert?: DealUpsertWithoutLeadInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutLeadInput, DealUpdateWithoutLeadInput>, DealUncheckedUpdateWithoutLeadInput>
  }

  export type ActivityUpdateManyWithoutLeadNestedInput = {
    create?: XOR<ActivityCreateWithoutLeadInput, ActivityUncheckedCreateWithoutLeadInput> | ActivityCreateWithoutLeadInput[] | ActivityUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutLeadInput | ActivityCreateOrConnectWithoutLeadInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutLeadInput | ActivityUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: ActivityCreateManyLeadInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutLeadInput | ActivityUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutLeadInput | ActivityUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutLeadNestedInput = {
    create?: XOR<TaskCreateWithoutLeadInput, TaskUncheckedCreateWithoutLeadInput> | TaskCreateWithoutLeadInput[] | TaskUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutLeadInput | TaskCreateOrConnectWithoutLeadInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutLeadInput | TaskUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: TaskCreateManyLeadInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutLeadInput | TaskUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutLeadInput | TaskUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<ActivityCreateWithoutLeadInput, ActivityUncheckedCreateWithoutLeadInput> | ActivityCreateWithoutLeadInput[] | ActivityUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutLeadInput | ActivityCreateOrConnectWithoutLeadInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutLeadInput | ActivityUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: ActivityCreateManyLeadInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutLeadInput | ActivityUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutLeadInput | ActivityUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<TaskCreateWithoutLeadInput, TaskUncheckedCreateWithoutLeadInput> | TaskCreateWithoutLeadInput[] | TaskUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutLeadInput | TaskCreateOrConnectWithoutLeadInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutLeadInput | TaskUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: TaskCreateManyLeadInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutLeadInput | TaskUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutLeadInput | TaskUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type PipelineStageCreateNestedOneWithoutDealsInput = {
    create?: XOR<PipelineStageCreateWithoutDealsInput, PipelineStageUncheckedCreateWithoutDealsInput>
    connectOrCreate?: PipelineStageCreateOrConnectWithoutDealsInput
    connect?: PipelineStageWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutDealsInput = {
    create?: XOR<ClientCreateWithoutDealsInput, ClientUncheckedCreateWithoutDealsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutDealsInput
    connect?: ClientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOwnedDealsInput = {
    create?: XOR<UserCreateWithoutOwnedDealsInput, UserUncheckedCreateWithoutOwnedDealsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedDealsInput
    connect?: UserWhereUniqueInput
  }

  export type LeadCreateNestedOneWithoutDealInput = {
    create?: XOR<LeadCreateWithoutDealInput, LeadUncheckedCreateWithoutDealInput>
    connectOrCreate?: LeadCreateOrConnectWithoutDealInput
    connect?: LeadWhereUniqueInput
  }

  export type JobCreateNestedOneWithoutDealInput = {
    create?: XOR<JobCreateWithoutDealInput, JobUncheckedCreateWithoutDealInput>
    connectOrCreate?: JobCreateOrConnectWithoutDealInput
    connect?: JobWhereUniqueInput
  }

  export type ActivityCreateNestedManyWithoutDealInput = {
    create?: XOR<ActivityCreateWithoutDealInput, ActivityUncheckedCreateWithoutDealInput> | ActivityCreateWithoutDealInput[] | ActivityUncheckedCreateWithoutDealInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutDealInput | ActivityCreateOrConnectWithoutDealInput[]
    createMany?: ActivityCreateManyDealInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutDealInput = {
    create?: XOR<TaskCreateWithoutDealInput, TaskUncheckedCreateWithoutDealInput> | TaskCreateWithoutDealInput[] | TaskUncheckedCreateWithoutDealInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutDealInput | TaskCreateOrConnectWithoutDealInput[]
    createMany?: TaskCreateManyDealInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutDealInput = {
    create?: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput> | DocumentCreateWithoutDealInput[] | DocumentUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDealInput | DocumentCreateOrConnectWithoutDealInput[]
    createMany?: DocumentCreateManyDealInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedOneWithoutDealInput = {
    create?: XOR<LeadCreateWithoutDealInput, LeadUncheckedCreateWithoutDealInput>
    connectOrCreate?: LeadCreateOrConnectWithoutDealInput
    connect?: LeadWhereUniqueInput
  }

  export type ActivityUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<ActivityCreateWithoutDealInput, ActivityUncheckedCreateWithoutDealInput> | ActivityCreateWithoutDealInput[] | ActivityUncheckedCreateWithoutDealInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutDealInput | ActivityCreateOrConnectWithoutDealInput[]
    createMany?: ActivityCreateManyDealInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<TaskCreateWithoutDealInput, TaskUncheckedCreateWithoutDealInput> | TaskCreateWithoutDealInput[] | TaskUncheckedCreateWithoutDealInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutDealInput | TaskCreateOrConnectWithoutDealInput[]
    createMany?: TaskCreateManyDealInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput> | DocumentCreateWithoutDealInput[] | DocumentUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDealInput | DocumentCreateOrConnectWithoutDealInput[]
    createMany?: DocumentCreateManyDealInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type PipelineStageUpdateOneRequiredWithoutDealsNestedInput = {
    create?: XOR<PipelineStageCreateWithoutDealsInput, PipelineStageUncheckedCreateWithoutDealsInput>
    connectOrCreate?: PipelineStageCreateOrConnectWithoutDealsInput
    upsert?: PipelineStageUpsertWithoutDealsInput
    connect?: PipelineStageWhereUniqueInput
    update?: XOR<XOR<PipelineStageUpdateToOneWithWhereWithoutDealsInput, PipelineStageUpdateWithoutDealsInput>, PipelineStageUncheckedUpdateWithoutDealsInput>
  }

  export type ClientUpdateOneRequiredWithoutDealsNestedInput = {
    create?: XOR<ClientCreateWithoutDealsInput, ClientUncheckedCreateWithoutDealsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutDealsInput
    upsert?: ClientUpsertWithoutDealsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutDealsInput, ClientUpdateWithoutDealsInput>, ClientUncheckedUpdateWithoutDealsInput>
  }

  export type UserUpdateOneRequiredWithoutOwnedDealsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedDealsInput, UserUncheckedCreateWithoutOwnedDealsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedDealsInput
    upsert?: UserUpsertWithoutOwnedDealsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedDealsInput, UserUpdateWithoutOwnedDealsInput>, UserUncheckedUpdateWithoutOwnedDealsInput>
  }

  export type LeadUpdateOneWithoutDealNestedInput = {
    create?: XOR<LeadCreateWithoutDealInput, LeadUncheckedCreateWithoutDealInput>
    connectOrCreate?: LeadCreateOrConnectWithoutDealInput
    upsert?: LeadUpsertWithoutDealInput
    disconnect?: LeadWhereInput | boolean
    delete?: LeadWhereInput | boolean
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutDealInput, LeadUpdateWithoutDealInput>, LeadUncheckedUpdateWithoutDealInput>
  }

  export type JobUpdateOneWithoutDealNestedInput = {
    create?: XOR<JobCreateWithoutDealInput, JobUncheckedCreateWithoutDealInput>
    connectOrCreate?: JobCreateOrConnectWithoutDealInput
    upsert?: JobUpsertWithoutDealInput
    disconnect?: JobWhereInput | boolean
    delete?: JobWhereInput | boolean
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutDealInput, JobUpdateWithoutDealInput>, JobUncheckedUpdateWithoutDealInput>
  }

  export type ActivityUpdateManyWithoutDealNestedInput = {
    create?: XOR<ActivityCreateWithoutDealInput, ActivityUncheckedCreateWithoutDealInput> | ActivityCreateWithoutDealInput[] | ActivityUncheckedCreateWithoutDealInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutDealInput | ActivityCreateOrConnectWithoutDealInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutDealInput | ActivityUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: ActivityCreateManyDealInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutDealInput | ActivityUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutDealInput | ActivityUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutDealNestedInput = {
    create?: XOR<TaskCreateWithoutDealInput, TaskUncheckedCreateWithoutDealInput> | TaskCreateWithoutDealInput[] | TaskUncheckedCreateWithoutDealInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutDealInput | TaskCreateOrConnectWithoutDealInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutDealInput | TaskUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: TaskCreateManyDealInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutDealInput | TaskUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutDealInput | TaskUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutDealNestedInput = {
    create?: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput> | DocumentCreateWithoutDealInput[] | DocumentUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDealInput | DocumentCreateOrConnectWithoutDealInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutDealInput | DocumentUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: DocumentCreateManyDealInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutDealInput | DocumentUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutDealInput | DocumentUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type LeadUncheckedUpdateOneWithoutDealNestedInput = {
    create?: XOR<LeadCreateWithoutDealInput, LeadUncheckedCreateWithoutDealInput>
    connectOrCreate?: LeadCreateOrConnectWithoutDealInput
    upsert?: LeadUpsertWithoutDealInput
    disconnect?: LeadWhereInput | boolean
    delete?: LeadWhereInput | boolean
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutDealInput, LeadUpdateWithoutDealInput>, LeadUncheckedUpdateWithoutDealInput>
  }

  export type ActivityUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<ActivityCreateWithoutDealInput, ActivityUncheckedCreateWithoutDealInput> | ActivityCreateWithoutDealInput[] | ActivityUncheckedCreateWithoutDealInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutDealInput | ActivityCreateOrConnectWithoutDealInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutDealInput | ActivityUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: ActivityCreateManyDealInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutDealInput | ActivityUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutDealInput | ActivityUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<TaskCreateWithoutDealInput, TaskUncheckedCreateWithoutDealInput> | TaskCreateWithoutDealInput[] | TaskUncheckedCreateWithoutDealInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutDealInput | TaskCreateOrConnectWithoutDealInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutDealInput | TaskUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: TaskCreateManyDealInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutDealInput | TaskUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutDealInput | TaskUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput> | DocumentCreateWithoutDealInput[] | DocumentUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDealInput | DocumentCreateOrConnectWithoutDealInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutDealInput | DocumentUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: DocumentCreateManyDealInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutDealInput | DocumentUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutDealInput | DocumentUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DealCreateNestedManyWithoutStageInput = {
    create?: XOR<DealCreateWithoutStageInput, DealUncheckedCreateWithoutStageInput> | DealCreateWithoutStageInput[] | DealUncheckedCreateWithoutStageInput[]
    connectOrCreate?: DealCreateOrConnectWithoutStageInput | DealCreateOrConnectWithoutStageInput[]
    createMany?: DealCreateManyStageInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type DealUncheckedCreateNestedManyWithoutStageInput = {
    create?: XOR<DealCreateWithoutStageInput, DealUncheckedCreateWithoutStageInput> | DealCreateWithoutStageInput[] | DealUncheckedCreateWithoutStageInput[]
    connectOrCreate?: DealCreateOrConnectWithoutStageInput | DealCreateOrConnectWithoutStageInput[]
    createMany?: DealCreateManyStageInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type DealUpdateManyWithoutStageNestedInput = {
    create?: XOR<DealCreateWithoutStageInput, DealUncheckedCreateWithoutStageInput> | DealCreateWithoutStageInput[] | DealUncheckedCreateWithoutStageInput[]
    connectOrCreate?: DealCreateOrConnectWithoutStageInput | DealCreateOrConnectWithoutStageInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutStageInput | DealUpsertWithWhereUniqueWithoutStageInput[]
    createMany?: DealCreateManyStageInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutStageInput | DealUpdateWithWhereUniqueWithoutStageInput[]
    updateMany?: DealUpdateManyWithWhereWithoutStageInput | DealUpdateManyWithWhereWithoutStageInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type DealUncheckedUpdateManyWithoutStageNestedInput = {
    create?: XOR<DealCreateWithoutStageInput, DealUncheckedCreateWithoutStageInput> | DealCreateWithoutStageInput[] | DealUncheckedCreateWithoutStageInput[]
    connectOrCreate?: DealCreateOrConnectWithoutStageInput | DealCreateOrConnectWithoutStageInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutStageInput | DealUpsertWithWhereUniqueWithoutStageInput[]
    createMany?: DealCreateManyStageInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutStageInput | DealUpdateWithWhereUniqueWithoutStageInput[]
    updateMany?: DealUpdateManyWithWhereWithoutStageInput | DealUpdateManyWithWhereWithoutStageInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<ClientCreateWithoutActivitiesInput, ClientUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutActivitiesInput
    connect?: ClientWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<ContactCreateWithoutActivitiesInput, ContactUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutActivitiesInput
    connect?: ContactWhereUniqueInput
  }

  export type LeadCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<LeadCreateWithoutActivitiesInput, LeadUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: LeadCreateOrConnectWithoutActivitiesInput
    connect?: LeadWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<DealCreateWithoutActivitiesInput, DealUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: DealCreateOrConnectWithoutActivitiesInput
    connect?: DealWhereUniqueInput
  }

  export type EnumActivityTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActivityType
  }

  export type NullableEnumDirectionFieldUpdateOperationsInput = {
    set?: $Enums.Direction | null
  }

  export type UserUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    upsert?: UserUpsertWithoutActivitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivitiesInput, UserUpdateWithoutActivitiesInput>, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type ClientUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<ClientCreateWithoutActivitiesInput, ClientUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutActivitiesInput
    upsert?: ClientUpsertWithoutActivitiesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutActivitiesInput, ClientUpdateWithoutActivitiesInput>, ClientUncheckedUpdateWithoutActivitiesInput>
  }

  export type ContactUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<ContactCreateWithoutActivitiesInput, ContactUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutActivitiesInput
    upsert?: ContactUpsertWithoutActivitiesInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutActivitiesInput, ContactUpdateWithoutActivitiesInput>, ContactUncheckedUpdateWithoutActivitiesInput>
  }

  export type LeadUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<LeadCreateWithoutActivitiesInput, LeadUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: LeadCreateOrConnectWithoutActivitiesInput
    upsert?: LeadUpsertWithoutActivitiesInput
    disconnect?: LeadWhereInput | boolean
    delete?: LeadWhereInput | boolean
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutActivitiesInput, LeadUpdateWithoutActivitiesInput>, LeadUncheckedUpdateWithoutActivitiesInput>
  }

  export type DealUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<DealCreateWithoutActivitiesInput, DealUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: DealCreateOrConnectWithoutActivitiesInput
    upsert?: DealUpsertWithoutActivitiesInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutActivitiesInput, DealUpdateWithoutActivitiesInput>, DealUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserCreateNestedOneWithoutAssignedTasksInput = {
    create?: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTasksInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedTasksInput = {
    create?: XOR<UserCreateWithoutCreatedTasksInput, UserUncheckedCreateWithoutCreatedTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTasksInput
    connect?: UserWhereUniqueInput
  }

  export type LeadCreateNestedOneWithoutTasksInput = {
    create?: XOR<LeadCreateWithoutTasksInput, LeadUncheckedCreateWithoutTasksInput>
    connectOrCreate?: LeadCreateOrConnectWithoutTasksInput
    connect?: LeadWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutTasksInput = {
    create?: XOR<DealCreateWithoutTasksInput, DealUncheckedCreateWithoutTasksInput>
    connectOrCreate?: DealCreateOrConnectWithoutTasksInput
    connect?: DealWhereUniqueInput
  }

  export type JobCreateNestedOneWithoutTasksInput = {
    create?: XOR<JobCreateWithoutTasksInput, JobUncheckedCreateWithoutTasksInput>
    connectOrCreate?: JobCreateOrConnectWithoutTasksInput
    connect?: JobWhereUniqueInput
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus
  }

  export type UserUpdateOneRequiredWithoutAssignedTasksNestedInput = {
    create?: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTasksInput
    upsert?: UserUpsertWithoutAssignedTasksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedTasksInput, UserUpdateWithoutAssignedTasksInput>, UserUncheckedUpdateWithoutAssignedTasksInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedTasksNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTasksInput, UserUncheckedCreateWithoutCreatedTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTasksInput
    upsert?: UserUpsertWithoutCreatedTasksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedTasksInput, UserUpdateWithoutCreatedTasksInput>, UserUncheckedUpdateWithoutCreatedTasksInput>
  }

  export type LeadUpdateOneWithoutTasksNestedInput = {
    create?: XOR<LeadCreateWithoutTasksInput, LeadUncheckedCreateWithoutTasksInput>
    connectOrCreate?: LeadCreateOrConnectWithoutTasksInput
    upsert?: LeadUpsertWithoutTasksInput
    disconnect?: LeadWhereInput | boolean
    delete?: LeadWhereInput | boolean
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutTasksInput, LeadUpdateWithoutTasksInput>, LeadUncheckedUpdateWithoutTasksInput>
  }

  export type DealUpdateOneWithoutTasksNestedInput = {
    create?: XOR<DealCreateWithoutTasksInput, DealUncheckedCreateWithoutTasksInput>
    connectOrCreate?: DealCreateOrConnectWithoutTasksInput
    upsert?: DealUpsertWithoutTasksInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutTasksInput, DealUpdateWithoutTasksInput>, DealUncheckedUpdateWithoutTasksInput>
  }

  export type JobUpdateOneWithoutTasksNestedInput = {
    create?: XOR<JobCreateWithoutTasksInput, JobUncheckedCreateWithoutTasksInput>
    connectOrCreate?: JobCreateOrConnectWithoutTasksInput
    upsert?: JobUpsertWithoutTasksInput
    disconnect?: JobWhereInput | boolean
    delete?: JobWhereInput | boolean
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutTasksInput, JobUpdateWithoutTasksInput>, JobUncheckedUpdateWithoutTasksInput>
  }

  export type UserCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsInput
    connect?: UserWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<ClientCreateWithoutAppointmentsInput, ClientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAppointmentsInput
    connect?: ClientWhereUniqueInput
  }

  export type JobCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<JobCreateWithoutAppointmentsInput, JobUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: JobCreateOrConnectWithoutAppointmentsInput
    connect?: JobWhereUniqueInput
  }

  export type EnumAppointmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AppointmentStatus
  }

  export type UserUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsInput
    upsert?: UserUpsertWithoutAppointmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAppointmentsInput, UserUpdateWithoutAppointmentsInput>, UserUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ClientUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<ClientCreateWithoutAppointmentsInput, ClientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAppointmentsInput
    upsert?: ClientUpsertWithoutAppointmentsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutAppointmentsInput, ClientUpdateWithoutAppointmentsInput>, ClientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type JobUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<JobCreateWithoutAppointmentsInput, JobUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: JobCreateOrConnectWithoutAppointmentsInput
    upsert?: JobUpsertWithoutAppointmentsInput
    disconnect?: JobWhereInput | boolean
    delete?: JobWhereInput | boolean
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutAppointmentsInput, JobUpdateWithoutAppointmentsInput>, JobUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ClientCreateNestedOneWithoutRoomsInput = {
    create?: XOR<ClientCreateWithoutRoomsInput, ClientUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutRoomsInput
    connect?: ClientWhereUniqueInput
  }

  export type JobCreateNestedManyWithoutRoomInput = {
    create?: XOR<JobCreateWithoutRoomInput, JobUncheckedCreateWithoutRoomInput> | JobCreateWithoutRoomInput[] | JobUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: JobCreateOrConnectWithoutRoomInput | JobCreateOrConnectWithoutRoomInput[]
    createMany?: JobCreateManyRoomInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type JobUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<JobCreateWithoutRoomInput, JobUncheckedCreateWithoutRoomInput> | JobCreateWithoutRoomInput[] | JobUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: JobCreateOrConnectWithoutRoomInput | JobCreateOrConnectWithoutRoomInput[]
    createMany?: JobCreateManyRoomInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type EnumRoomTypeFieldUpdateOperationsInput = {
    set?: $Enums.RoomType
  }

  export type ClientUpdateOneRequiredWithoutRoomsNestedInput = {
    create?: XOR<ClientCreateWithoutRoomsInput, ClientUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutRoomsInput
    upsert?: ClientUpsertWithoutRoomsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutRoomsInput, ClientUpdateWithoutRoomsInput>, ClientUncheckedUpdateWithoutRoomsInput>
  }

  export type JobUpdateManyWithoutRoomNestedInput = {
    create?: XOR<JobCreateWithoutRoomInput, JobUncheckedCreateWithoutRoomInput> | JobCreateWithoutRoomInput[] | JobUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: JobCreateOrConnectWithoutRoomInput | JobCreateOrConnectWithoutRoomInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutRoomInput | JobUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: JobCreateManyRoomInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutRoomInput | JobUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: JobUpdateManyWithWhereWithoutRoomInput | JobUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type JobUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<JobCreateWithoutRoomInput, JobUncheckedCreateWithoutRoomInput> | JobCreateWithoutRoomInput[] | JobUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: JobCreateOrConnectWithoutRoomInput | JobCreateOrConnectWithoutRoomInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutRoomInput | JobUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: JobCreateManyRoomInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutRoomInput | JobUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: JobUpdateManyWithWhereWithoutRoomInput | JobUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutJobsInput = {
    create?: XOR<ClientCreateWithoutJobsInput, ClientUncheckedCreateWithoutJobsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutJobsInput
    connect?: ClientWhereUniqueInput
  }

  export type RoomCreateNestedOneWithoutJobsInput = {
    create?: XOR<RoomCreateWithoutJobsInput, RoomUncheckedCreateWithoutJobsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutJobsInput
    connect?: RoomWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutJobInput = {
    create?: XOR<DealCreateWithoutJobInput, DealUncheckedCreateWithoutJobInput>
    connectOrCreate?: DealCreateOrConnectWithoutJobInput
    connect?: DealWhereUniqueInput
  }

  export type InstallerCompanyCreateNestedOneWithoutJobsInput = {
    create?: XOR<InstallerCompanyCreateWithoutJobsInput, InstallerCompanyUncheckedCreateWithoutJobsInput>
    connectOrCreate?: InstallerCompanyCreateOrConnectWithoutJobsInput
    connect?: InstallerCompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDesignerJobsInput = {
    create?: XOR<UserCreateWithoutDesignerJobsInput, UserUncheckedCreateWithoutDesignerJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDesignerJobsInput
    connect?: UserWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutJobInput = {
    create?: XOR<TaskCreateWithoutJobInput, TaskUncheckedCreateWithoutJobInput> | TaskCreateWithoutJobInput[] | TaskUncheckedCreateWithoutJobInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutJobInput | TaskCreateOrConnectWithoutJobInput[]
    createMany?: TaskCreateManyJobInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutJobInput = {
    create?: XOR<AppointmentCreateWithoutJobInput, AppointmentUncheckedCreateWithoutJobInput> | AppointmentCreateWithoutJobInput[] | AppointmentUncheckedCreateWithoutJobInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutJobInput | AppointmentCreateOrConnectWithoutJobInput[]
    createMany?: AppointmentCreateManyJobInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type JobDayLogCreateNestedManyWithoutJobInput = {
    create?: XOR<JobDayLogCreateWithoutJobInput, JobDayLogUncheckedCreateWithoutJobInput> | JobDayLogCreateWithoutJobInput[] | JobDayLogUncheckedCreateWithoutJobInput[]
    connectOrCreate?: JobDayLogCreateOrConnectWithoutJobInput | JobDayLogCreateOrConnectWithoutJobInput[]
    createMany?: JobDayLogCreateManyJobInputEnvelope
    connect?: JobDayLogWhereUniqueInput | JobDayLogWhereUniqueInput[]
  }

  export type DesignVersionCreateNestedManyWithoutJobInput = {
    create?: XOR<DesignVersionCreateWithoutJobInput, DesignVersionUncheckedCreateWithoutJobInput> | DesignVersionCreateWithoutJobInput[] | DesignVersionUncheckedCreateWithoutJobInput[]
    connectOrCreate?: DesignVersionCreateOrConnectWithoutJobInput | DesignVersionCreateOrConnectWithoutJobInput[]
    createMany?: DesignVersionCreateManyJobInputEnvelope
    connect?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
  }

  export type SnagCreateNestedManyWithoutJobInput = {
    create?: XOR<SnagCreateWithoutJobInput, SnagUncheckedCreateWithoutJobInput> | SnagCreateWithoutJobInput[] | SnagUncheckedCreateWithoutJobInput[]
    connectOrCreate?: SnagCreateOrConnectWithoutJobInput | SnagCreateOrConnectWithoutJobInput[]
    createMany?: SnagCreateManyJobInputEnvelope
    connect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutJobInput = {
    create?: XOR<DocumentCreateWithoutJobInput, DocumentUncheckedCreateWithoutJobInput> | DocumentCreateWithoutJobInput[] | DocumentUncheckedCreateWithoutJobInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutJobInput | DocumentCreateOrConnectWithoutJobInput[]
    createMany?: DocumentCreateManyJobInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ParsedSpecItemCreateNestedManyWithoutJobInput = {
    create?: XOR<ParsedSpecItemCreateWithoutJobInput, ParsedSpecItemUncheckedCreateWithoutJobInput> | ParsedSpecItemCreateWithoutJobInput[] | ParsedSpecItemUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ParsedSpecItemCreateOrConnectWithoutJobInput | ParsedSpecItemCreateOrConnectWithoutJobInput[]
    createMany?: ParsedSpecItemCreateManyJobInputEnvelope
    connect?: ParsedSpecItemWhereUniqueInput | ParsedSpecItemWhereUniqueInput[]
  }

  export type MoodboardCreateNestedManyWithoutJobInput = {
    create?: XOR<MoodboardCreateWithoutJobInput, MoodboardUncheckedCreateWithoutJobInput> | MoodboardCreateWithoutJobInput[] | MoodboardUncheckedCreateWithoutJobInput[]
    connectOrCreate?: MoodboardCreateOrConnectWithoutJobInput | MoodboardCreateOrConnectWithoutJobInput[]
    createMany?: MoodboardCreateManyJobInputEnvelope
    connect?: MoodboardWhereUniqueInput | MoodboardWhereUniqueInput[]
  }

  export type HandoverPackCreateNestedManyWithoutJobInput = {
    create?: XOR<HandoverPackCreateWithoutJobInput, HandoverPackUncheckedCreateWithoutJobInput> | HandoverPackCreateWithoutJobInput[] | HandoverPackUncheckedCreateWithoutJobInput[]
    connectOrCreate?: HandoverPackCreateOrConnectWithoutJobInput | HandoverPackCreateOrConnectWithoutJobInput[]
    createMany?: HandoverPackCreateManyJobInputEnvelope
    connect?: HandoverPackWhereUniqueInput | HandoverPackWhereUniqueInput[]
  }

  export type DealUncheckedCreateNestedOneWithoutJobInput = {
    create?: XOR<DealCreateWithoutJobInput, DealUncheckedCreateWithoutJobInput>
    connectOrCreate?: DealCreateOrConnectWithoutJobInput
    connect?: DealWhereUniqueInput
  }

  export type TaskUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<TaskCreateWithoutJobInput, TaskUncheckedCreateWithoutJobInput> | TaskCreateWithoutJobInput[] | TaskUncheckedCreateWithoutJobInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutJobInput | TaskCreateOrConnectWithoutJobInput[]
    createMany?: TaskCreateManyJobInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<AppointmentCreateWithoutJobInput, AppointmentUncheckedCreateWithoutJobInput> | AppointmentCreateWithoutJobInput[] | AppointmentUncheckedCreateWithoutJobInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutJobInput | AppointmentCreateOrConnectWithoutJobInput[]
    createMany?: AppointmentCreateManyJobInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type JobDayLogUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<JobDayLogCreateWithoutJobInput, JobDayLogUncheckedCreateWithoutJobInput> | JobDayLogCreateWithoutJobInput[] | JobDayLogUncheckedCreateWithoutJobInput[]
    connectOrCreate?: JobDayLogCreateOrConnectWithoutJobInput | JobDayLogCreateOrConnectWithoutJobInput[]
    createMany?: JobDayLogCreateManyJobInputEnvelope
    connect?: JobDayLogWhereUniqueInput | JobDayLogWhereUniqueInput[]
  }

  export type DesignVersionUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<DesignVersionCreateWithoutJobInput, DesignVersionUncheckedCreateWithoutJobInput> | DesignVersionCreateWithoutJobInput[] | DesignVersionUncheckedCreateWithoutJobInput[]
    connectOrCreate?: DesignVersionCreateOrConnectWithoutJobInput | DesignVersionCreateOrConnectWithoutJobInput[]
    createMany?: DesignVersionCreateManyJobInputEnvelope
    connect?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
  }

  export type SnagUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<SnagCreateWithoutJobInput, SnagUncheckedCreateWithoutJobInput> | SnagCreateWithoutJobInput[] | SnagUncheckedCreateWithoutJobInput[]
    connectOrCreate?: SnagCreateOrConnectWithoutJobInput | SnagCreateOrConnectWithoutJobInput[]
    createMany?: SnagCreateManyJobInputEnvelope
    connect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<DocumentCreateWithoutJobInput, DocumentUncheckedCreateWithoutJobInput> | DocumentCreateWithoutJobInput[] | DocumentUncheckedCreateWithoutJobInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutJobInput | DocumentCreateOrConnectWithoutJobInput[]
    createMany?: DocumentCreateManyJobInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ParsedSpecItemUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<ParsedSpecItemCreateWithoutJobInput, ParsedSpecItemUncheckedCreateWithoutJobInput> | ParsedSpecItemCreateWithoutJobInput[] | ParsedSpecItemUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ParsedSpecItemCreateOrConnectWithoutJobInput | ParsedSpecItemCreateOrConnectWithoutJobInput[]
    createMany?: ParsedSpecItemCreateManyJobInputEnvelope
    connect?: ParsedSpecItemWhereUniqueInput | ParsedSpecItemWhereUniqueInput[]
  }

  export type MoodboardUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<MoodboardCreateWithoutJobInput, MoodboardUncheckedCreateWithoutJobInput> | MoodboardCreateWithoutJobInput[] | MoodboardUncheckedCreateWithoutJobInput[]
    connectOrCreate?: MoodboardCreateOrConnectWithoutJobInput | MoodboardCreateOrConnectWithoutJobInput[]
    createMany?: MoodboardCreateManyJobInputEnvelope
    connect?: MoodboardWhereUniqueInput | MoodboardWhereUniqueInput[]
  }

  export type HandoverPackUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<HandoverPackCreateWithoutJobInput, HandoverPackUncheckedCreateWithoutJobInput> | HandoverPackCreateWithoutJobInput[] | HandoverPackUncheckedCreateWithoutJobInput[]
    connectOrCreate?: HandoverPackCreateOrConnectWithoutJobInput | HandoverPackCreateOrConnectWithoutJobInput[]
    createMany?: HandoverPackCreateManyJobInputEnvelope
    connect?: HandoverPackWhereUniqueInput | HandoverPackWhereUniqueInput[]
  }

  export type EnumJobStatusFieldUpdateOperationsInput = {
    set?: $Enums.JobStatus
  }

  export type ClientUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<ClientCreateWithoutJobsInput, ClientUncheckedCreateWithoutJobsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutJobsInput
    upsert?: ClientUpsertWithoutJobsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutJobsInput, ClientUpdateWithoutJobsInput>, ClientUncheckedUpdateWithoutJobsInput>
  }

  export type RoomUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<RoomCreateWithoutJobsInput, RoomUncheckedCreateWithoutJobsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutJobsInput
    upsert?: RoomUpsertWithoutJobsInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutJobsInput, RoomUpdateWithoutJobsInput>, RoomUncheckedUpdateWithoutJobsInput>
  }

  export type DealUpdateOneWithoutJobNestedInput = {
    create?: XOR<DealCreateWithoutJobInput, DealUncheckedCreateWithoutJobInput>
    connectOrCreate?: DealCreateOrConnectWithoutJobInput
    upsert?: DealUpsertWithoutJobInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutJobInput, DealUpdateWithoutJobInput>, DealUncheckedUpdateWithoutJobInput>
  }

  export type InstallerCompanyUpdateOneWithoutJobsNestedInput = {
    create?: XOR<InstallerCompanyCreateWithoutJobsInput, InstallerCompanyUncheckedCreateWithoutJobsInput>
    connectOrCreate?: InstallerCompanyCreateOrConnectWithoutJobsInput
    upsert?: InstallerCompanyUpsertWithoutJobsInput
    disconnect?: InstallerCompanyWhereInput | boolean
    delete?: InstallerCompanyWhereInput | boolean
    connect?: InstallerCompanyWhereUniqueInput
    update?: XOR<XOR<InstallerCompanyUpdateToOneWithWhereWithoutJobsInput, InstallerCompanyUpdateWithoutJobsInput>, InstallerCompanyUncheckedUpdateWithoutJobsInput>
  }

  export type UserUpdateOneWithoutDesignerJobsNestedInput = {
    create?: XOR<UserCreateWithoutDesignerJobsInput, UserUncheckedCreateWithoutDesignerJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDesignerJobsInput
    upsert?: UserUpsertWithoutDesignerJobsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDesignerJobsInput, UserUpdateWithoutDesignerJobsInput>, UserUncheckedUpdateWithoutDesignerJobsInput>
  }

  export type TaskUpdateManyWithoutJobNestedInput = {
    create?: XOR<TaskCreateWithoutJobInput, TaskUncheckedCreateWithoutJobInput> | TaskCreateWithoutJobInput[] | TaskUncheckedCreateWithoutJobInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutJobInput | TaskCreateOrConnectWithoutJobInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutJobInput | TaskUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: TaskCreateManyJobInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutJobInput | TaskUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutJobInput | TaskUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutJobNestedInput = {
    create?: XOR<AppointmentCreateWithoutJobInput, AppointmentUncheckedCreateWithoutJobInput> | AppointmentCreateWithoutJobInput[] | AppointmentUncheckedCreateWithoutJobInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutJobInput | AppointmentCreateOrConnectWithoutJobInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutJobInput | AppointmentUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: AppointmentCreateManyJobInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutJobInput | AppointmentUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutJobInput | AppointmentUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type JobDayLogUpdateManyWithoutJobNestedInput = {
    create?: XOR<JobDayLogCreateWithoutJobInput, JobDayLogUncheckedCreateWithoutJobInput> | JobDayLogCreateWithoutJobInput[] | JobDayLogUncheckedCreateWithoutJobInput[]
    connectOrCreate?: JobDayLogCreateOrConnectWithoutJobInput | JobDayLogCreateOrConnectWithoutJobInput[]
    upsert?: JobDayLogUpsertWithWhereUniqueWithoutJobInput | JobDayLogUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: JobDayLogCreateManyJobInputEnvelope
    set?: JobDayLogWhereUniqueInput | JobDayLogWhereUniqueInput[]
    disconnect?: JobDayLogWhereUniqueInput | JobDayLogWhereUniqueInput[]
    delete?: JobDayLogWhereUniqueInput | JobDayLogWhereUniqueInput[]
    connect?: JobDayLogWhereUniqueInput | JobDayLogWhereUniqueInput[]
    update?: JobDayLogUpdateWithWhereUniqueWithoutJobInput | JobDayLogUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: JobDayLogUpdateManyWithWhereWithoutJobInput | JobDayLogUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: JobDayLogScalarWhereInput | JobDayLogScalarWhereInput[]
  }

  export type DesignVersionUpdateManyWithoutJobNestedInput = {
    create?: XOR<DesignVersionCreateWithoutJobInput, DesignVersionUncheckedCreateWithoutJobInput> | DesignVersionCreateWithoutJobInput[] | DesignVersionUncheckedCreateWithoutJobInput[]
    connectOrCreate?: DesignVersionCreateOrConnectWithoutJobInput | DesignVersionCreateOrConnectWithoutJobInput[]
    upsert?: DesignVersionUpsertWithWhereUniqueWithoutJobInput | DesignVersionUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: DesignVersionCreateManyJobInputEnvelope
    set?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
    disconnect?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
    delete?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
    connect?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
    update?: DesignVersionUpdateWithWhereUniqueWithoutJobInput | DesignVersionUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: DesignVersionUpdateManyWithWhereWithoutJobInput | DesignVersionUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: DesignVersionScalarWhereInput | DesignVersionScalarWhereInput[]
  }

  export type SnagUpdateManyWithoutJobNestedInput = {
    create?: XOR<SnagCreateWithoutJobInput, SnagUncheckedCreateWithoutJobInput> | SnagCreateWithoutJobInput[] | SnagUncheckedCreateWithoutJobInput[]
    connectOrCreate?: SnagCreateOrConnectWithoutJobInput | SnagCreateOrConnectWithoutJobInput[]
    upsert?: SnagUpsertWithWhereUniqueWithoutJobInput | SnagUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: SnagCreateManyJobInputEnvelope
    set?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    disconnect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    delete?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    connect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    update?: SnagUpdateWithWhereUniqueWithoutJobInput | SnagUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: SnagUpdateManyWithWhereWithoutJobInput | SnagUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: SnagScalarWhereInput | SnagScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutJobNestedInput = {
    create?: XOR<DocumentCreateWithoutJobInput, DocumentUncheckedCreateWithoutJobInput> | DocumentCreateWithoutJobInput[] | DocumentUncheckedCreateWithoutJobInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutJobInput | DocumentCreateOrConnectWithoutJobInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutJobInput | DocumentUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: DocumentCreateManyJobInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutJobInput | DocumentUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutJobInput | DocumentUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ParsedSpecItemUpdateManyWithoutJobNestedInput = {
    create?: XOR<ParsedSpecItemCreateWithoutJobInput, ParsedSpecItemUncheckedCreateWithoutJobInput> | ParsedSpecItemCreateWithoutJobInput[] | ParsedSpecItemUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ParsedSpecItemCreateOrConnectWithoutJobInput | ParsedSpecItemCreateOrConnectWithoutJobInput[]
    upsert?: ParsedSpecItemUpsertWithWhereUniqueWithoutJobInput | ParsedSpecItemUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: ParsedSpecItemCreateManyJobInputEnvelope
    set?: ParsedSpecItemWhereUniqueInput | ParsedSpecItemWhereUniqueInput[]
    disconnect?: ParsedSpecItemWhereUniqueInput | ParsedSpecItemWhereUniqueInput[]
    delete?: ParsedSpecItemWhereUniqueInput | ParsedSpecItemWhereUniqueInput[]
    connect?: ParsedSpecItemWhereUniqueInput | ParsedSpecItemWhereUniqueInput[]
    update?: ParsedSpecItemUpdateWithWhereUniqueWithoutJobInput | ParsedSpecItemUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: ParsedSpecItemUpdateManyWithWhereWithoutJobInput | ParsedSpecItemUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: ParsedSpecItemScalarWhereInput | ParsedSpecItemScalarWhereInput[]
  }

  export type MoodboardUpdateManyWithoutJobNestedInput = {
    create?: XOR<MoodboardCreateWithoutJobInput, MoodboardUncheckedCreateWithoutJobInput> | MoodboardCreateWithoutJobInput[] | MoodboardUncheckedCreateWithoutJobInput[]
    connectOrCreate?: MoodboardCreateOrConnectWithoutJobInput | MoodboardCreateOrConnectWithoutJobInput[]
    upsert?: MoodboardUpsertWithWhereUniqueWithoutJobInput | MoodboardUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: MoodboardCreateManyJobInputEnvelope
    set?: MoodboardWhereUniqueInput | MoodboardWhereUniqueInput[]
    disconnect?: MoodboardWhereUniqueInput | MoodboardWhereUniqueInput[]
    delete?: MoodboardWhereUniqueInput | MoodboardWhereUniqueInput[]
    connect?: MoodboardWhereUniqueInput | MoodboardWhereUniqueInput[]
    update?: MoodboardUpdateWithWhereUniqueWithoutJobInput | MoodboardUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: MoodboardUpdateManyWithWhereWithoutJobInput | MoodboardUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: MoodboardScalarWhereInput | MoodboardScalarWhereInput[]
  }

  export type HandoverPackUpdateManyWithoutJobNestedInput = {
    create?: XOR<HandoverPackCreateWithoutJobInput, HandoverPackUncheckedCreateWithoutJobInput> | HandoverPackCreateWithoutJobInput[] | HandoverPackUncheckedCreateWithoutJobInput[]
    connectOrCreate?: HandoverPackCreateOrConnectWithoutJobInput | HandoverPackCreateOrConnectWithoutJobInput[]
    upsert?: HandoverPackUpsertWithWhereUniqueWithoutJobInput | HandoverPackUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: HandoverPackCreateManyJobInputEnvelope
    set?: HandoverPackWhereUniqueInput | HandoverPackWhereUniqueInput[]
    disconnect?: HandoverPackWhereUniqueInput | HandoverPackWhereUniqueInput[]
    delete?: HandoverPackWhereUniqueInput | HandoverPackWhereUniqueInput[]
    connect?: HandoverPackWhereUniqueInput | HandoverPackWhereUniqueInput[]
    update?: HandoverPackUpdateWithWhereUniqueWithoutJobInput | HandoverPackUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: HandoverPackUpdateManyWithWhereWithoutJobInput | HandoverPackUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: HandoverPackScalarWhereInput | HandoverPackScalarWhereInput[]
  }

  export type DealUncheckedUpdateOneWithoutJobNestedInput = {
    create?: XOR<DealCreateWithoutJobInput, DealUncheckedCreateWithoutJobInput>
    connectOrCreate?: DealCreateOrConnectWithoutJobInput
    upsert?: DealUpsertWithoutJobInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutJobInput, DealUpdateWithoutJobInput>, DealUncheckedUpdateWithoutJobInput>
  }

  export type TaskUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<TaskCreateWithoutJobInput, TaskUncheckedCreateWithoutJobInput> | TaskCreateWithoutJobInput[] | TaskUncheckedCreateWithoutJobInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutJobInput | TaskCreateOrConnectWithoutJobInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutJobInput | TaskUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: TaskCreateManyJobInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutJobInput | TaskUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutJobInput | TaskUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<AppointmentCreateWithoutJobInput, AppointmentUncheckedCreateWithoutJobInput> | AppointmentCreateWithoutJobInput[] | AppointmentUncheckedCreateWithoutJobInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutJobInput | AppointmentCreateOrConnectWithoutJobInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutJobInput | AppointmentUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: AppointmentCreateManyJobInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutJobInput | AppointmentUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutJobInput | AppointmentUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type JobDayLogUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<JobDayLogCreateWithoutJobInput, JobDayLogUncheckedCreateWithoutJobInput> | JobDayLogCreateWithoutJobInput[] | JobDayLogUncheckedCreateWithoutJobInput[]
    connectOrCreate?: JobDayLogCreateOrConnectWithoutJobInput | JobDayLogCreateOrConnectWithoutJobInput[]
    upsert?: JobDayLogUpsertWithWhereUniqueWithoutJobInput | JobDayLogUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: JobDayLogCreateManyJobInputEnvelope
    set?: JobDayLogWhereUniqueInput | JobDayLogWhereUniqueInput[]
    disconnect?: JobDayLogWhereUniqueInput | JobDayLogWhereUniqueInput[]
    delete?: JobDayLogWhereUniqueInput | JobDayLogWhereUniqueInput[]
    connect?: JobDayLogWhereUniqueInput | JobDayLogWhereUniqueInput[]
    update?: JobDayLogUpdateWithWhereUniqueWithoutJobInput | JobDayLogUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: JobDayLogUpdateManyWithWhereWithoutJobInput | JobDayLogUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: JobDayLogScalarWhereInput | JobDayLogScalarWhereInput[]
  }

  export type DesignVersionUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<DesignVersionCreateWithoutJobInput, DesignVersionUncheckedCreateWithoutJobInput> | DesignVersionCreateWithoutJobInput[] | DesignVersionUncheckedCreateWithoutJobInput[]
    connectOrCreate?: DesignVersionCreateOrConnectWithoutJobInput | DesignVersionCreateOrConnectWithoutJobInput[]
    upsert?: DesignVersionUpsertWithWhereUniqueWithoutJobInput | DesignVersionUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: DesignVersionCreateManyJobInputEnvelope
    set?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
    disconnect?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
    delete?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
    connect?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
    update?: DesignVersionUpdateWithWhereUniqueWithoutJobInput | DesignVersionUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: DesignVersionUpdateManyWithWhereWithoutJobInput | DesignVersionUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: DesignVersionScalarWhereInput | DesignVersionScalarWhereInput[]
  }

  export type SnagUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<SnagCreateWithoutJobInput, SnagUncheckedCreateWithoutJobInput> | SnagCreateWithoutJobInput[] | SnagUncheckedCreateWithoutJobInput[]
    connectOrCreate?: SnagCreateOrConnectWithoutJobInput | SnagCreateOrConnectWithoutJobInput[]
    upsert?: SnagUpsertWithWhereUniqueWithoutJobInput | SnagUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: SnagCreateManyJobInputEnvelope
    set?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    disconnect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    delete?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    connect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    update?: SnagUpdateWithWhereUniqueWithoutJobInput | SnagUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: SnagUpdateManyWithWhereWithoutJobInput | SnagUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: SnagScalarWhereInput | SnagScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<DocumentCreateWithoutJobInput, DocumentUncheckedCreateWithoutJobInput> | DocumentCreateWithoutJobInput[] | DocumentUncheckedCreateWithoutJobInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutJobInput | DocumentCreateOrConnectWithoutJobInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutJobInput | DocumentUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: DocumentCreateManyJobInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutJobInput | DocumentUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutJobInput | DocumentUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ParsedSpecItemUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<ParsedSpecItemCreateWithoutJobInput, ParsedSpecItemUncheckedCreateWithoutJobInput> | ParsedSpecItemCreateWithoutJobInput[] | ParsedSpecItemUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ParsedSpecItemCreateOrConnectWithoutJobInput | ParsedSpecItemCreateOrConnectWithoutJobInput[]
    upsert?: ParsedSpecItemUpsertWithWhereUniqueWithoutJobInput | ParsedSpecItemUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: ParsedSpecItemCreateManyJobInputEnvelope
    set?: ParsedSpecItemWhereUniqueInput | ParsedSpecItemWhereUniqueInput[]
    disconnect?: ParsedSpecItemWhereUniqueInput | ParsedSpecItemWhereUniqueInput[]
    delete?: ParsedSpecItemWhereUniqueInput | ParsedSpecItemWhereUniqueInput[]
    connect?: ParsedSpecItemWhereUniqueInput | ParsedSpecItemWhereUniqueInput[]
    update?: ParsedSpecItemUpdateWithWhereUniqueWithoutJobInput | ParsedSpecItemUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: ParsedSpecItemUpdateManyWithWhereWithoutJobInput | ParsedSpecItemUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: ParsedSpecItemScalarWhereInput | ParsedSpecItemScalarWhereInput[]
  }

  export type MoodboardUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<MoodboardCreateWithoutJobInput, MoodboardUncheckedCreateWithoutJobInput> | MoodboardCreateWithoutJobInput[] | MoodboardUncheckedCreateWithoutJobInput[]
    connectOrCreate?: MoodboardCreateOrConnectWithoutJobInput | MoodboardCreateOrConnectWithoutJobInput[]
    upsert?: MoodboardUpsertWithWhereUniqueWithoutJobInput | MoodboardUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: MoodboardCreateManyJobInputEnvelope
    set?: MoodboardWhereUniqueInput | MoodboardWhereUniqueInput[]
    disconnect?: MoodboardWhereUniqueInput | MoodboardWhereUniqueInput[]
    delete?: MoodboardWhereUniqueInput | MoodboardWhereUniqueInput[]
    connect?: MoodboardWhereUniqueInput | MoodboardWhereUniqueInput[]
    update?: MoodboardUpdateWithWhereUniqueWithoutJobInput | MoodboardUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: MoodboardUpdateManyWithWhereWithoutJobInput | MoodboardUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: MoodboardScalarWhereInput | MoodboardScalarWhereInput[]
  }

  export type HandoverPackUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<HandoverPackCreateWithoutJobInput, HandoverPackUncheckedCreateWithoutJobInput> | HandoverPackCreateWithoutJobInput[] | HandoverPackUncheckedCreateWithoutJobInput[]
    connectOrCreate?: HandoverPackCreateOrConnectWithoutJobInput | HandoverPackCreateOrConnectWithoutJobInput[]
    upsert?: HandoverPackUpsertWithWhereUniqueWithoutJobInput | HandoverPackUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: HandoverPackCreateManyJobInputEnvelope
    set?: HandoverPackWhereUniqueInput | HandoverPackWhereUniqueInput[]
    disconnect?: HandoverPackWhereUniqueInput | HandoverPackWhereUniqueInput[]
    delete?: HandoverPackWhereUniqueInput | HandoverPackWhereUniqueInput[]
    connect?: HandoverPackWhereUniqueInput | HandoverPackWhereUniqueInput[]
    update?: HandoverPackUpdateWithWhereUniqueWithoutJobInput | HandoverPackUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: HandoverPackUpdateManyWithWhereWithoutJobInput | HandoverPackUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: HandoverPackScalarWhereInput | HandoverPackScalarWhereInput[]
  }

  export type JobDayLogCreatephotosInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutJobDayLogsInput = {
    create?: XOR<UserCreateWithoutJobDayLogsInput, UserUncheckedCreateWithoutJobDayLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutJobDayLogsInput
    connect?: UserWhereUniqueInput
  }

  export type JobCreateNestedOneWithoutJobDayLogsInput = {
    create?: XOR<JobCreateWithoutJobDayLogsInput, JobUncheckedCreateWithoutJobDayLogsInput>
    connectOrCreate?: JobCreateOrConnectWithoutJobDayLogsInput
    connect?: JobWhereUniqueInput
  }

  export type JobDayLogUpdatephotosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumSyncStatusFieldUpdateOperationsInput = {
    set?: $Enums.SyncStatus
  }

  export type UserUpdateOneRequiredWithoutJobDayLogsNestedInput = {
    create?: XOR<UserCreateWithoutJobDayLogsInput, UserUncheckedCreateWithoutJobDayLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutJobDayLogsInput
    upsert?: UserUpsertWithoutJobDayLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutJobDayLogsInput, UserUpdateWithoutJobDayLogsInput>, UserUncheckedUpdateWithoutJobDayLogsInput>
  }

  export type JobUpdateOneRequiredWithoutJobDayLogsNestedInput = {
    create?: XOR<JobCreateWithoutJobDayLogsInput, JobUncheckedCreateWithoutJobDayLogsInput>
    connectOrCreate?: JobCreateOrConnectWithoutJobDayLogsInput
    upsert?: JobUpsertWithoutJobDayLogsInput
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutJobDayLogsInput, JobUpdateWithoutJobDayLogsInput>, JobUncheckedUpdateWithoutJobDayLogsInput>
  }

  export type UserCreateNestedOneWithoutInstallerCompaniesInput = {
    create?: XOR<UserCreateWithoutInstallerCompaniesInput, UserUncheckedCreateWithoutInstallerCompaniesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstallerCompaniesInput
    connect?: UserWhereUniqueInput
  }

  export type InstallerTeamMemberCreateNestedManyWithoutCompanyInput = {
    create?: XOR<InstallerTeamMemberCreateWithoutCompanyInput, InstallerTeamMemberUncheckedCreateWithoutCompanyInput> | InstallerTeamMemberCreateWithoutCompanyInput[] | InstallerTeamMemberUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InstallerTeamMemberCreateOrConnectWithoutCompanyInput | InstallerTeamMemberCreateOrConnectWithoutCompanyInput[]
    createMany?: InstallerTeamMemberCreateManyCompanyInputEnvelope
    connect?: InstallerTeamMemberWhereUniqueInput | InstallerTeamMemberWhereUniqueInput[]
  }

  export type JobCreateNestedManyWithoutInstallerCompanyInput = {
    create?: XOR<JobCreateWithoutInstallerCompanyInput, JobUncheckedCreateWithoutInstallerCompanyInput> | JobCreateWithoutInstallerCompanyInput[] | JobUncheckedCreateWithoutInstallerCompanyInput[]
    connectOrCreate?: JobCreateOrConnectWithoutInstallerCompanyInput | JobCreateOrConnectWithoutInstallerCompanyInput[]
    createMany?: JobCreateManyInstallerCompanyInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type InstallerTeamMemberUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<InstallerTeamMemberCreateWithoutCompanyInput, InstallerTeamMemberUncheckedCreateWithoutCompanyInput> | InstallerTeamMemberCreateWithoutCompanyInput[] | InstallerTeamMemberUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InstallerTeamMemberCreateOrConnectWithoutCompanyInput | InstallerTeamMemberCreateOrConnectWithoutCompanyInput[]
    createMany?: InstallerTeamMemberCreateManyCompanyInputEnvelope
    connect?: InstallerTeamMemberWhereUniqueInput | InstallerTeamMemberWhereUniqueInput[]
  }

  export type JobUncheckedCreateNestedManyWithoutInstallerCompanyInput = {
    create?: XOR<JobCreateWithoutInstallerCompanyInput, JobUncheckedCreateWithoutInstallerCompanyInput> | JobCreateWithoutInstallerCompanyInput[] | JobUncheckedCreateWithoutInstallerCompanyInput[]
    connectOrCreate?: JobCreateOrConnectWithoutInstallerCompanyInput | JobCreateOrConnectWithoutInstallerCompanyInput[]
    createMany?: JobCreateManyInstallerCompanyInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutInstallerCompaniesNestedInput = {
    create?: XOR<UserCreateWithoutInstallerCompaniesInput, UserUncheckedCreateWithoutInstallerCompaniesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstallerCompaniesInput
    upsert?: UserUpsertWithoutInstallerCompaniesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInstallerCompaniesInput, UserUpdateWithoutInstallerCompaniesInput>, UserUncheckedUpdateWithoutInstallerCompaniesInput>
  }

  export type InstallerTeamMemberUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<InstallerTeamMemberCreateWithoutCompanyInput, InstallerTeamMemberUncheckedCreateWithoutCompanyInput> | InstallerTeamMemberCreateWithoutCompanyInput[] | InstallerTeamMemberUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InstallerTeamMemberCreateOrConnectWithoutCompanyInput | InstallerTeamMemberCreateOrConnectWithoutCompanyInput[]
    upsert?: InstallerTeamMemberUpsertWithWhereUniqueWithoutCompanyInput | InstallerTeamMemberUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: InstallerTeamMemberCreateManyCompanyInputEnvelope
    set?: InstallerTeamMemberWhereUniqueInput | InstallerTeamMemberWhereUniqueInput[]
    disconnect?: InstallerTeamMemberWhereUniqueInput | InstallerTeamMemberWhereUniqueInput[]
    delete?: InstallerTeamMemberWhereUniqueInput | InstallerTeamMemberWhereUniqueInput[]
    connect?: InstallerTeamMemberWhereUniqueInput | InstallerTeamMemberWhereUniqueInput[]
    update?: InstallerTeamMemberUpdateWithWhereUniqueWithoutCompanyInput | InstallerTeamMemberUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: InstallerTeamMemberUpdateManyWithWhereWithoutCompanyInput | InstallerTeamMemberUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: InstallerTeamMemberScalarWhereInput | InstallerTeamMemberScalarWhereInput[]
  }

  export type JobUpdateManyWithoutInstallerCompanyNestedInput = {
    create?: XOR<JobCreateWithoutInstallerCompanyInput, JobUncheckedCreateWithoutInstallerCompanyInput> | JobCreateWithoutInstallerCompanyInput[] | JobUncheckedCreateWithoutInstallerCompanyInput[]
    connectOrCreate?: JobCreateOrConnectWithoutInstallerCompanyInput | JobCreateOrConnectWithoutInstallerCompanyInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutInstallerCompanyInput | JobUpsertWithWhereUniqueWithoutInstallerCompanyInput[]
    createMany?: JobCreateManyInstallerCompanyInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutInstallerCompanyInput | JobUpdateWithWhereUniqueWithoutInstallerCompanyInput[]
    updateMany?: JobUpdateManyWithWhereWithoutInstallerCompanyInput | JobUpdateManyWithWhereWithoutInstallerCompanyInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type InstallerTeamMemberUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<InstallerTeamMemberCreateWithoutCompanyInput, InstallerTeamMemberUncheckedCreateWithoutCompanyInput> | InstallerTeamMemberCreateWithoutCompanyInput[] | InstallerTeamMemberUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InstallerTeamMemberCreateOrConnectWithoutCompanyInput | InstallerTeamMemberCreateOrConnectWithoutCompanyInput[]
    upsert?: InstallerTeamMemberUpsertWithWhereUniqueWithoutCompanyInput | InstallerTeamMemberUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: InstallerTeamMemberCreateManyCompanyInputEnvelope
    set?: InstallerTeamMemberWhereUniqueInput | InstallerTeamMemberWhereUniqueInput[]
    disconnect?: InstallerTeamMemberWhereUniqueInput | InstallerTeamMemberWhereUniqueInput[]
    delete?: InstallerTeamMemberWhereUniqueInput | InstallerTeamMemberWhereUniqueInput[]
    connect?: InstallerTeamMemberWhereUniqueInput | InstallerTeamMemberWhereUniqueInput[]
    update?: InstallerTeamMemberUpdateWithWhereUniqueWithoutCompanyInput | InstallerTeamMemberUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: InstallerTeamMemberUpdateManyWithWhereWithoutCompanyInput | InstallerTeamMemberUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: InstallerTeamMemberScalarWhereInput | InstallerTeamMemberScalarWhereInput[]
  }

  export type JobUncheckedUpdateManyWithoutInstallerCompanyNestedInput = {
    create?: XOR<JobCreateWithoutInstallerCompanyInput, JobUncheckedCreateWithoutInstallerCompanyInput> | JobCreateWithoutInstallerCompanyInput[] | JobUncheckedCreateWithoutInstallerCompanyInput[]
    connectOrCreate?: JobCreateOrConnectWithoutInstallerCompanyInput | JobCreateOrConnectWithoutInstallerCompanyInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutInstallerCompanyInput | JobUpsertWithWhereUniqueWithoutInstallerCompanyInput[]
    createMany?: JobCreateManyInstallerCompanyInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutInstallerCompanyInput | JobUpdateWithWhereUniqueWithoutInstallerCompanyInput[]
    updateMany?: JobUpdateManyWithWhereWithoutInstallerCompanyInput | JobUpdateManyWithWhereWithoutInstallerCompanyInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type InstallerCompanyCreateNestedOneWithoutTeamMembersInput = {
    create?: XOR<InstallerCompanyCreateWithoutTeamMembersInput, InstallerCompanyUncheckedCreateWithoutTeamMembersInput>
    connectOrCreate?: InstallerCompanyCreateOrConnectWithoutTeamMembersInput
    connect?: InstallerCompanyWhereUniqueInput
  }

  export type InstallerCompanyUpdateOneRequiredWithoutTeamMembersNestedInput = {
    create?: XOR<InstallerCompanyCreateWithoutTeamMembersInput, InstallerCompanyUncheckedCreateWithoutTeamMembersInput>
    connectOrCreate?: InstallerCompanyCreateOrConnectWithoutTeamMembersInput
    upsert?: InstallerCompanyUpsertWithoutTeamMembersInput
    connect?: InstallerCompanyWhereUniqueInput
    update?: XOR<XOR<InstallerCompanyUpdateToOneWithWhereWithoutTeamMembersInput, InstallerCompanyUpdateWithoutTeamMembersInput>, InstallerCompanyUncheckedUpdateWithoutTeamMembersInput>
  }

  export type DesignVersionCreaterenderUrlsInput = {
    set: string[]
  }

  export type DesignVersionCreateplanUrlsInput = {
    set: string[]
  }

  export type JobCreateNestedOneWithoutDesignVersionsInput = {
    create?: XOR<JobCreateWithoutDesignVersionsInput, JobUncheckedCreateWithoutDesignVersionsInput>
    connectOrCreate?: JobCreateOrConnectWithoutDesignVersionsInput
    connect?: JobWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDesignVersionsInput = {
    create?: XOR<UserCreateWithoutDesignVersionsInput, UserUncheckedCreateWithoutDesignVersionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDesignVersionsInput
    connect?: UserWhereUniqueInput
  }

  export type DesignClashTicketCreateNestedManyWithoutDesignVersionInput = {
    create?: XOR<DesignClashTicketCreateWithoutDesignVersionInput, DesignClashTicketUncheckedCreateWithoutDesignVersionInput> | DesignClashTicketCreateWithoutDesignVersionInput[] | DesignClashTicketUncheckedCreateWithoutDesignVersionInput[]
    connectOrCreate?: DesignClashTicketCreateOrConnectWithoutDesignVersionInput | DesignClashTicketCreateOrConnectWithoutDesignVersionInput[]
    createMany?: DesignClashTicketCreateManyDesignVersionInputEnvelope
    connect?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
  }

  export type DesignClashTicketUncheckedCreateNestedManyWithoutDesignVersionInput = {
    create?: XOR<DesignClashTicketCreateWithoutDesignVersionInput, DesignClashTicketUncheckedCreateWithoutDesignVersionInput> | DesignClashTicketCreateWithoutDesignVersionInput[] | DesignClashTicketUncheckedCreateWithoutDesignVersionInput[]
    connectOrCreate?: DesignClashTicketCreateOrConnectWithoutDesignVersionInput | DesignClashTicketCreateOrConnectWithoutDesignVersionInput[]
    createMany?: DesignClashTicketCreateManyDesignVersionInputEnvelope
    connect?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
  }

  export type EnumDesignStatusFieldUpdateOperationsInput = {
    set?: $Enums.DesignStatus
  }

  export type DesignVersionUpdaterenderUrlsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DesignVersionUpdateplanUrlsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type JobUpdateOneRequiredWithoutDesignVersionsNestedInput = {
    create?: XOR<JobCreateWithoutDesignVersionsInput, JobUncheckedCreateWithoutDesignVersionsInput>
    connectOrCreate?: JobCreateOrConnectWithoutDesignVersionsInput
    upsert?: JobUpsertWithoutDesignVersionsInput
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutDesignVersionsInput, JobUpdateWithoutDesignVersionsInput>, JobUncheckedUpdateWithoutDesignVersionsInput>
  }

  export type UserUpdateOneRequiredWithoutDesignVersionsNestedInput = {
    create?: XOR<UserCreateWithoutDesignVersionsInput, UserUncheckedCreateWithoutDesignVersionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDesignVersionsInput
    upsert?: UserUpsertWithoutDesignVersionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDesignVersionsInput, UserUpdateWithoutDesignVersionsInput>, UserUncheckedUpdateWithoutDesignVersionsInput>
  }

  export type DesignClashTicketUpdateManyWithoutDesignVersionNestedInput = {
    create?: XOR<DesignClashTicketCreateWithoutDesignVersionInput, DesignClashTicketUncheckedCreateWithoutDesignVersionInput> | DesignClashTicketCreateWithoutDesignVersionInput[] | DesignClashTicketUncheckedCreateWithoutDesignVersionInput[]
    connectOrCreate?: DesignClashTicketCreateOrConnectWithoutDesignVersionInput | DesignClashTicketCreateOrConnectWithoutDesignVersionInput[]
    upsert?: DesignClashTicketUpsertWithWhereUniqueWithoutDesignVersionInput | DesignClashTicketUpsertWithWhereUniqueWithoutDesignVersionInput[]
    createMany?: DesignClashTicketCreateManyDesignVersionInputEnvelope
    set?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
    disconnect?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
    delete?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
    connect?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
    update?: DesignClashTicketUpdateWithWhereUniqueWithoutDesignVersionInput | DesignClashTicketUpdateWithWhereUniqueWithoutDesignVersionInput[]
    updateMany?: DesignClashTicketUpdateManyWithWhereWithoutDesignVersionInput | DesignClashTicketUpdateManyWithWhereWithoutDesignVersionInput[]
    deleteMany?: DesignClashTicketScalarWhereInput | DesignClashTicketScalarWhereInput[]
  }

  export type DesignClashTicketUncheckedUpdateManyWithoutDesignVersionNestedInput = {
    create?: XOR<DesignClashTicketCreateWithoutDesignVersionInput, DesignClashTicketUncheckedCreateWithoutDesignVersionInput> | DesignClashTicketCreateWithoutDesignVersionInput[] | DesignClashTicketUncheckedCreateWithoutDesignVersionInput[]
    connectOrCreate?: DesignClashTicketCreateOrConnectWithoutDesignVersionInput | DesignClashTicketCreateOrConnectWithoutDesignVersionInput[]
    upsert?: DesignClashTicketUpsertWithWhereUniqueWithoutDesignVersionInput | DesignClashTicketUpsertWithWhereUniqueWithoutDesignVersionInput[]
    createMany?: DesignClashTicketCreateManyDesignVersionInputEnvelope
    set?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
    disconnect?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
    delete?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
    connect?: DesignClashTicketWhereUniqueInput | DesignClashTicketWhereUniqueInput[]
    update?: DesignClashTicketUpdateWithWhereUniqueWithoutDesignVersionInput | DesignClashTicketUpdateWithWhereUniqueWithoutDesignVersionInput[]
    updateMany?: DesignClashTicketUpdateManyWithWhereWithoutDesignVersionInput | DesignClashTicketUpdateManyWithWhereWithoutDesignVersionInput[]
    deleteMany?: DesignClashTicketScalarWhereInput | DesignClashTicketScalarWhereInput[]
  }

  export type DesignClashTicketCreatephotoUrlsInput = {
    set: string[]
  }

  export type DesignVersionCreateNestedOneWithoutClashTicketsInput = {
    create?: XOR<DesignVersionCreateWithoutClashTicketsInput, DesignVersionUncheckedCreateWithoutClashTicketsInput>
    connectOrCreate?: DesignVersionCreateOrConnectWithoutClashTicketsInput
    connect?: DesignVersionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClashReportsInput = {
    create?: XOR<UserCreateWithoutClashReportsInput, UserUncheckedCreateWithoutClashReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClashReportsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClashAssignmentsInput = {
    create?: XOR<UserCreateWithoutClashAssignmentsInput, UserUncheckedCreateWithoutClashAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClashAssignmentsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumClashStatusFieldUpdateOperationsInput = {
    set?: $Enums.ClashStatus
  }

  export type DesignClashTicketUpdatephotoUrlsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DesignVersionUpdateOneRequiredWithoutClashTicketsNestedInput = {
    create?: XOR<DesignVersionCreateWithoutClashTicketsInput, DesignVersionUncheckedCreateWithoutClashTicketsInput>
    connectOrCreate?: DesignVersionCreateOrConnectWithoutClashTicketsInput
    upsert?: DesignVersionUpsertWithoutClashTicketsInput
    connect?: DesignVersionWhereUniqueInput
    update?: XOR<XOR<DesignVersionUpdateToOneWithWhereWithoutClashTicketsInput, DesignVersionUpdateWithoutClashTicketsInput>, DesignVersionUncheckedUpdateWithoutClashTicketsInput>
  }

  export type UserUpdateOneRequiredWithoutClashReportsNestedInput = {
    create?: XOR<UserCreateWithoutClashReportsInput, UserUncheckedCreateWithoutClashReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClashReportsInput
    upsert?: UserUpsertWithoutClashReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClashReportsInput, UserUpdateWithoutClashReportsInput>, UserUncheckedUpdateWithoutClashReportsInput>
  }

  export type UserUpdateOneWithoutClashAssignmentsNestedInput = {
    create?: XOR<UserCreateWithoutClashAssignmentsInput, UserUncheckedCreateWithoutClashAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClashAssignmentsInput
    upsert?: UserUpsertWithoutClashAssignmentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClashAssignmentsInput, UserUpdateWithoutClashAssignmentsInput>, UserUncheckedUpdateWithoutClashAssignmentsInput>
  }

  export type ClientCreateNestedOneWithoutMoodboardsInput = {
    create?: XOR<ClientCreateWithoutMoodboardsInput, ClientUncheckedCreateWithoutMoodboardsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutMoodboardsInput
    connect?: ClientWhereUniqueInput
  }

  export type JobCreateNestedOneWithoutMoodboardsInput = {
    create?: XOR<JobCreateWithoutMoodboardsInput, JobUncheckedCreateWithoutMoodboardsInput>
    connectOrCreate?: JobCreateOrConnectWithoutMoodboardsInput
    connect?: JobWhereUniqueInput
  }

  export type MoodboardItemCreateNestedManyWithoutMoodboardInput = {
    create?: XOR<MoodboardItemCreateWithoutMoodboardInput, MoodboardItemUncheckedCreateWithoutMoodboardInput> | MoodboardItemCreateWithoutMoodboardInput[] | MoodboardItemUncheckedCreateWithoutMoodboardInput[]
    connectOrCreate?: MoodboardItemCreateOrConnectWithoutMoodboardInput | MoodboardItemCreateOrConnectWithoutMoodboardInput[]
    createMany?: MoodboardItemCreateManyMoodboardInputEnvelope
    connect?: MoodboardItemWhereUniqueInput | MoodboardItemWhereUniqueInput[]
  }

  export type MoodboardItemUncheckedCreateNestedManyWithoutMoodboardInput = {
    create?: XOR<MoodboardItemCreateWithoutMoodboardInput, MoodboardItemUncheckedCreateWithoutMoodboardInput> | MoodboardItemCreateWithoutMoodboardInput[] | MoodboardItemUncheckedCreateWithoutMoodboardInput[]
    connectOrCreate?: MoodboardItemCreateOrConnectWithoutMoodboardInput | MoodboardItemCreateOrConnectWithoutMoodboardInput[]
    createMany?: MoodboardItemCreateManyMoodboardInputEnvelope
    connect?: MoodboardItemWhereUniqueInput | MoodboardItemWhereUniqueInput[]
  }

  export type EnumMoodboardStatusFieldUpdateOperationsInput = {
    set?: $Enums.MoodboardStatus
  }

  export type ClientUpdateOneRequiredWithoutMoodboardsNestedInput = {
    create?: XOR<ClientCreateWithoutMoodboardsInput, ClientUncheckedCreateWithoutMoodboardsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutMoodboardsInput
    upsert?: ClientUpsertWithoutMoodboardsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutMoodboardsInput, ClientUpdateWithoutMoodboardsInput>, ClientUncheckedUpdateWithoutMoodboardsInput>
  }

  export type JobUpdateOneWithoutMoodboardsNestedInput = {
    create?: XOR<JobCreateWithoutMoodboardsInput, JobUncheckedCreateWithoutMoodboardsInput>
    connectOrCreate?: JobCreateOrConnectWithoutMoodboardsInput
    upsert?: JobUpsertWithoutMoodboardsInput
    disconnect?: JobWhereInput | boolean
    delete?: JobWhereInput | boolean
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutMoodboardsInput, JobUpdateWithoutMoodboardsInput>, JobUncheckedUpdateWithoutMoodboardsInput>
  }

  export type MoodboardItemUpdateManyWithoutMoodboardNestedInput = {
    create?: XOR<MoodboardItemCreateWithoutMoodboardInput, MoodboardItemUncheckedCreateWithoutMoodboardInput> | MoodboardItemCreateWithoutMoodboardInput[] | MoodboardItemUncheckedCreateWithoutMoodboardInput[]
    connectOrCreate?: MoodboardItemCreateOrConnectWithoutMoodboardInput | MoodboardItemCreateOrConnectWithoutMoodboardInput[]
    upsert?: MoodboardItemUpsertWithWhereUniqueWithoutMoodboardInput | MoodboardItemUpsertWithWhereUniqueWithoutMoodboardInput[]
    createMany?: MoodboardItemCreateManyMoodboardInputEnvelope
    set?: MoodboardItemWhereUniqueInput | MoodboardItemWhereUniqueInput[]
    disconnect?: MoodboardItemWhereUniqueInput | MoodboardItemWhereUniqueInput[]
    delete?: MoodboardItemWhereUniqueInput | MoodboardItemWhereUniqueInput[]
    connect?: MoodboardItemWhereUniqueInput | MoodboardItemWhereUniqueInput[]
    update?: MoodboardItemUpdateWithWhereUniqueWithoutMoodboardInput | MoodboardItemUpdateWithWhereUniqueWithoutMoodboardInput[]
    updateMany?: MoodboardItemUpdateManyWithWhereWithoutMoodboardInput | MoodboardItemUpdateManyWithWhereWithoutMoodboardInput[]
    deleteMany?: MoodboardItemScalarWhereInput | MoodboardItemScalarWhereInput[]
  }

  export type MoodboardItemUncheckedUpdateManyWithoutMoodboardNestedInput = {
    create?: XOR<MoodboardItemCreateWithoutMoodboardInput, MoodboardItemUncheckedCreateWithoutMoodboardInput> | MoodboardItemCreateWithoutMoodboardInput[] | MoodboardItemUncheckedCreateWithoutMoodboardInput[]
    connectOrCreate?: MoodboardItemCreateOrConnectWithoutMoodboardInput | MoodboardItemCreateOrConnectWithoutMoodboardInput[]
    upsert?: MoodboardItemUpsertWithWhereUniqueWithoutMoodboardInput | MoodboardItemUpsertWithWhereUniqueWithoutMoodboardInput[]
    createMany?: MoodboardItemCreateManyMoodboardInputEnvelope
    set?: MoodboardItemWhereUniqueInput | MoodboardItemWhereUniqueInput[]
    disconnect?: MoodboardItemWhereUniqueInput | MoodboardItemWhereUniqueInput[]
    delete?: MoodboardItemWhereUniqueInput | MoodboardItemWhereUniqueInput[]
    connect?: MoodboardItemWhereUniqueInput | MoodboardItemWhereUniqueInput[]
    update?: MoodboardItemUpdateWithWhereUniqueWithoutMoodboardInput | MoodboardItemUpdateWithWhereUniqueWithoutMoodboardInput[]
    updateMany?: MoodboardItemUpdateManyWithWhereWithoutMoodboardInput | MoodboardItemUpdateManyWithWhereWithoutMoodboardInput[]
    deleteMany?: MoodboardItemScalarWhereInput | MoodboardItemScalarWhereInput[]
  }

  export type MoodboardCommentCreateNestedManyWithoutItemInput = {
    create?: XOR<MoodboardCommentCreateWithoutItemInput, MoodboardCommentUncheckedCreateWithoutItemInput> | MoodboardCommentCreateWithoutItemInput[] | MoodboardCommentUncheckedCreateWithoutItemInput[]
    connectOrCreate?: MoodboardCommentCreateOrConnectWithoutItemInput | MoodboardCommentCreateOrConnectWithoutItemInput[]
    createMany?: MoodboardCommentCreateManyItemInputEnvelope
    connect?: MoodboardCommentWhereUniqueInput | MoodboardCommentWhereUniqueInput[]
  }

  export type MoodboardCreateNestedOneWithoutItemsInput = {
    create?: XOR<MoodboardCreateWithoutItemsInput, MoodboardUncheckedCreateWithoutItemsInput>
    connectOrCreate?: MoodboardCreateOrConnectWithoutItemsInput
    connect?: MoodboardWhereUniqueInput
  }

  export type MoodboardCommentUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<MoodboardCommentCreateWithoutItemInput, MoodboardCommentUncheckedCreateWithoutItemInput> | MoodboardCommentCreateWithoutItemInput[] | MoodboardCommentUncheckedCreateWithoutItemInput[]
    connectOrCreate?: MoodboardCommentCreateOrConnectWithoutItemInput | MoodboardCommentCreateOrConnectWithoutItemInput[]
    createMany?: MoodboardCommentCreateManyItemInputEnvelope
    connect?: MoodboardCommentWhereUniqueInput | MoodboardCommentWhereUniqueInput[]
  }

  export type MoodboardCommentUpdateManyWithoutItemNestedInput = {
    create?: XOR<MoodboardCommentCreateWithoutItemInput, MoodboardCommentUncheckedCreateWithoutItemInput> | MoodboardCommentCreateWithoutItemInput[] | MoodboardCommentUncheckedCreateWithoutItemInput[]
    connectOrCreate?: MoodboardCommentCreateOrConnectWithoutItemInput | MoodboardCommentCreateOrConnectWithoutItemInput[]
    upsert?: MoodboardCommentUpsertWithWhereUniqueWithoutItemInput | MoodboardCommentUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: MoodboardCommentCreateManyItemInputEnvelope
    set?: MoodboardCommentWhereUniqueInput | MoodboardCommentWhereUniqueInput[]
    disconnect?: MoodboardCommentWhereUniqueInput | MoodboardCommentWhereUniqueInput[]
    delete?: MoodboardCommentWhereUniqueInput | MoodboardCommentWhereUniqueInput[]
    connect?: MoodboardCommentWhereUniqueInput | MoodboardCommentWhereUniqueInput[]
    update?: MoodboardCommentUpdateWithWhereUniqueWithoutItemInput | MoodboardCommentUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: MoodboardCommentUpdateManyWithWhereWithoutItemInput | MoodboardCommentUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: MoodboardCommentScalarWhereInput | MoodboardCommentScalarWhereInput[]
  }

  export type MoodboardUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<MoodboardCreateWithoutItemsInput, MoodboardUncheckedCreateWithoutItemsInput>
    connectOrCreate?: MoodboardCreateOrConnectWithoutItemsInput
    upsert?: MoodboardUpsertWithoutItemsInput
    connect?: MoodboardWhereUniqueInput
    update?: XOR<XOR<MoodboardUpdateToOneWithWhereWithoutItemsInput, MoodboardUpdateWithoutItemsInput>, MoodboardUncheckedUpdateWithoutItemsInput>
  }

  export type MoodboardCommentUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<MoodboardCommentCreateWithoutItemInput, MoodboardCommentUncheckedCreateWithoutItemInput> | MoodboardCommentCreateWithoutItemInput[] | MoodboardCommentUncheckedCreateWithoutItemInput[]
    connectOrCreate?: MoodboardCommentCreateOrConnectWithoutItemInput | MoodboardCommentCreateOrConnectWithoutItemInput[]
    upsert?: MoodboardCommentUpsertWithWhereUniqueWithoutItemInput | MoodboardCommentUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: MoodboardCommentCreateManyItemInputEnvelope
    set?: MoodboardCommentWhereUniqueInput | MoodboardCommentWhereUniqueInput[]
    disconnect?: MoodboardCommentWhereUniqueInput | MoodboardCommentWhereUniqueInput[]
    delete?: MoodboardCommentWhereUniqueInput | MoodboardCommentWhereUniqueInput[]
    connect?: MoodboardCommentWhereUniqueInput | MoodboardCommentWhereUniqueInput[]
    update?: MoodboardCommentUpdateWithWhereUniqueWithoutItemInput | MoodboardCommentUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: MoodboardCommentUpdateManyWithWhereWithoutItemInput | MoodboardCommentUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: MoodboardCommentScalarWhereInput | MoodboardCommentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMoodboardCommentsInput = {
    create?: XOR<UserCreateWithoutMoodboardCommentsInput, UserUncheckedCreateWithoutMoodboardCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMoodboardCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type MoodboardItemCreateNestedOneWithoutClientCommentsInput = {
    create?: XOR<MoodboardItemCreateWithoutClientCommentsInput, MoodboardItemUncheckedCreateWithoutClientCommentsInput>
    connectOrCreate?: MoodboardItemCreateOrConnectWithoutClientCommentsInput
    connect?: MoodboardItemWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutMoodboardCommentsNestedInput = {
    create?: XOR<UserCreateWithoutMoodboardCommentsInput, UserUncheckedCreateWithoutMoodboardCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMoodboardCommentsInput
    upsert?: UserUpsertWithoutMoodboardCommentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMoodboardCommentsInput, UserUpdateWithoutMoodboardCommentsInput>, UserUncheckedUpdateWithoutMoodboardCommentsInput>
  }

  export type MoodboardItemUpdateOneRequiredWithoutClientCommentsNestedInput = {
    create?: XOR<MoodboardItemCreateWithoutClientCommentsInput, MoodboardItemUncheckedCreateWithoutClientCommentsInput>
    connectOrCreate?: MoodboardItemCreateOrConnectWithoutClientCommentsInput
    upsert?: MoodboardItemUpsertWithoutClientCommentsInput
    connect?: MoodboardItemWhereUniqueInput
    update?: XOR<XOR<MoodboardItemUpdateToOneWithWhereWithoutClientCommentsInput, MoodboardItemUpdateWithoutClientCommentsInput>, MoodboardItemUncheckedUpdateWithoutClientCommentsInput>
  }

  export type JobCreateNestedOneWithoutParsedSpecItemsInput = {
    create?: XOR<JobCreateWithoutParsedSpecItemsInput, JobUncheckedCreateWithoutParsedSpecItemsInput>
    connectOrCreate?: JobCreateOrConnectWithoutParsedSpecItemsInput
    connect?: JobWhereUniqueInput
  }

  export type EnumSpecItemStatusFieldUpdateOperationsInput = {
    set?: $Enums.SpecItemStatus
  }

  export type JobUpdateOneRequiredWithoutParsedSpecItemsNestedInput = {
    create?: XOR<JobCreateWithoutParsedSpecItemsInput, JobUncheckedCreateWithoutParsedSpecItemsInput>
    connectOrCreate?: JobCreateOrConnectWithoutParsedSpecItemsInput
    upsert?: JobUpsertWithoutParsedSpecItemsInput
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutParsedSpecItemsInput, JobUpdateWithoutParsedSpecItemsInput>, JobUncheckedUpdateWithoutParsedSpecItemsInput>
  }

  export type SnagCreatephotoUrlsInput = {
    set: string[]
  }

  export type JobCreateNestedOneWithoutSnagsInput = {
    create?: XOR<JobCreateWithoutSnagsInput, JobUncheckedCreateWithoutSnagsInput>
    connectOrCreate?: JobCreateOrConnectWithoutSnagsInput
    connect?: JobWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSnagReportsInput = {
    create?: XOR<UserCreateWithoutSnagReportsInput, UserUncheckedCreateWithoutSnagReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSnagReportsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSnagAssignmentsInput = {
    create?: XOR<UserCreateWithoutSnagAssignmentsInput, UserUncheckedCreateWithoutSnagAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSnagAssignmentsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSnagCategoryFieldUpdateOperationsInput = {
    set?: $Enums.SnagCategory
  }

  export type EnumSnagStatusFieldUpdateOperationsInput = {
    set?: $Enums.SnagStatus
  }

  export type SnagUpdatephotoUrlsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type JobUpdateOneRequiredWithoutSnagsNestedInput = {
    create?: XOR<JobCreateWithoutSnagsInput, JobUncheckedCreateWithoutSnagsInput>
    connectOrCreate?: JobCreateOrConnectWithoutSnagsInput
    upsert?: JobUpsertWithoutSnagsInput
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutSnagsInput, JobUpdateWithoutSnagsInput>, JobUncheckedUpdateWithoutSnagsInput>
  }

  export type UserUpdateOneRequiredWithoutSnagReportsNestedInput = {
    create?: XOR<UserCreateWithoutSnagReportsInput, UserUncheckedCreateWithoutSnagReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSnagReportsInput
    upsert?: UserUpsertWithoutSnagReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSnagReportsInput, UserUpdateWithoutSnagReportsInput>, UserUncheckedUpdateWithoutSnagReportsInput>
  }

  export type UserUpdateOneWithoutSnagAssignmentsNestedInput = {
    create?: XOR<UserCreateWithoutSnagAssignmentsInput, UserUncheckedCreateWithoutSnagAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSnagAssignmentsInput
    upsert?: UserUpsertWithoutSnagAssignmentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSnagAssignmentsInput, UserUpdateWithoutSnagAssignmentsInput>, UserUncheckedUpdateWithoutSnagAssignmentsInput>
  }

  export type ClientCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutDocumentsInput
    connect?: ClientWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<DealCreateWithoutDocumentsInput, DealUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: DealCreateOrConnectWithoutDocumentsInput
    connect?: DealWhereUniqueInput
  }

  export type JobCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<JobCreateWithoutDocumentsInput, JobUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: JobCreateOrConnectWithoutDocumentsInput
    connect?: JobWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUploadedDocumentsInput = {
    create?: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumDocumentCategoryFieldUpdateOperationsInput = {
    set?: $Enums.DocumentCategory
  }

  export type EnumVirusScanStatusFieldUpdateOperationsInput = {
    set?: $Enums.VirusScanStatus
  }

  export type ClientUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutDocumentsInput
    upsert?: ClientUpsertWithoutDocumentsInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutDocumentsInput, ClientUpdateWithoutDocumentsInput>, ClientUncheckedUpdateWithoutDocumentsInput>
  }

  export type DealUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<DealCreateWithoutDocumentsInput, DealUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: DealCreateOrConnectWithoutDocumentsInput
    upsert?: DealUpsertWithoutDocumentsInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutDocumentsInput, DealUpdateWithoutDocumentsInput>, DealUncheckedUpdateWithoutDocumentsInput>
  }

  export type JobUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<JobCreateWithoutDocumentsInput, JobUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: JobCreateOrConnectWithoutDocumentsInput
    upsert?: JobUpsertWithoutDocumentsInput
    disconnect?: JobWhereInput | boolean
    delete?: JobWhereInput | boolean
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutDocumentsInput, JobUpdateWithoutDocumentsInput>, JobUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedDocumentsInput
    upsert?: UserUpsertWithoutUploadedDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedDocumentsInput, UserUpdateWithoutUploadedDocumentsInput>, UserUncheckedUpdateWithoutUploadedDocumentsInput>
  }

  export type FormSubmissionCreateNestedManyWithoutTemplateInput = {
    create?: XOR<FormSubmissionCreateWithoutTemplateInput, FormSubmissionUncheckedCreateWithoutTemplateInput> | FormSubmissionCreateWithoutTemplateInput[] | FormSubmissionUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutTemplateInput | FormSubmissionCreateOrConnectWithoutTemplateInput[]
    createMany?: FormSubmissionCreateManyTemplateInputEnvelope
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
  }

  export type FormSubmissionUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<FormSubmissionCreateWithoutTemplateInput, FormSubmissionUncheckedCreateWithoutTemplateInput> | FormSubmissionCreateWithoutTemplateInput[] | FormSubmissionUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutTemplateInput | FormSubmissionCreateOrConnectWithoutTemplateInput[]
    createMany?: FormSubmissionCreateManyTemplateInputEnvelope
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
  }

  export type EnumFormCategoryFieldUpdateOperationsInput = {
    set?: $Enums.FormCategory
  }

  export type FormSubmissionUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutTemplateInput, FormSubmissionUncheckedCreateWithoutTemplateInput> | FormSubmissionCreateWithoutTemplateInput[] | FormSubmissionUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutTemplateInput | FormSubmissionCreateOrConnectWithoutTemplateInput[]
    upsert?: FormSubmissionUpsertWithWhereUniqueWithoutTemplateInput | FormSubmissionUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: FormSubmissionCreateManyTemplateInputEnvelope
    set?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    disconnect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    delete?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    update?: FormSubmissionUpdateWithWhereUniqueWithoutTemplateInput | FormSubmissionUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: FormSubmissionUpdateManyWithWhereWithoutTemplateInput | FormSubmissionUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
  }

  export type FormSubmissionUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutTemplateInput, FormSubmissionUncheckedCreateWithoutTemplateInput> | FormSubmissionCreateWithoutTemplateInput[] | FormSubmissionUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutTemplateInput | FormSubmissionCreateOrConnectWithoutTemplateInput[]
    upsert?: FormSubmissionUpsertWithWhereUniqueWithoutTemplateInput | FormSubmissionUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: FormSubmissionCreateManyTemplateInputEnvelope
    set?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    disconnect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    delete?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    update?: FormSubmissionUpdateWithWhereUniqueWithoutTemplateInput | FormSubmissionUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: FormSubmissionUpdateManyWithWhereWithoutTemplateInput | FormSubmissionUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
  }

  export type FormTemplateCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<FormTemplateCreateWithoutSubmissionsInput, FormTemplateUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: FormTemplateCreateOrConnectWithoutSubmissionsInput
    connect?: FormTemplateWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFormSubmissionsInput = {
    create?: XOR<UserCreateWithoutFormSubmissionsInput, UserUncheckedCreateWithoutFormSubmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFormSubmissionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSubmissionSourceFieldUpdateOperationsInput = {
    set?: $Enums.SubmissionSource
  }

  export type FormTemplateUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<FormTemplateCreateWithoutSubmissionsInput, FormTemplateUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: FormTemplateCreateOrConnectWithoutSubmissionsInput
    upsert?: FormTemplateUpsertWithoutSubmissionsInput
    connect?: FormTemplateWhereUniqueInput
    update?: XOR<XOR<FormTemplateUpdateToOneWithWhereWithoutSubmissionsInput, FormTemplateUpdateWithoutSubmissionsInput>, FormTemplateUncheckedUpdateWithoutSubmissionsInput>
  }

  export type UserUpdateOneWithoutFormSubmissionsNestedInput = {
    create?: XOR<UserCreateWithoutFormSubmissionsInput, UserUncheckedCreateWithoutFormSubmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFormSubmissionsInput
    upsert?: UserUpsertWithoutFormSubmissionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFormSubmissionsInput, UserUpdateWithoutFormSubmissionsInput>, UserUncheckedUpdateWithoutFormSubmissionsInput>
  }

  export type HandoverPackCreatewarrantyDocsUrlsInput = {
    set: string[]
  }

  export type HandoverPackCreatefinalPhotosUrlsInput = {
    set: string[]
  }

  export type HandoverPackCreateguidesIncludedInput = {
    set: string[]
  }

  export type JobCreateNestedOneWithoutHandoverPacksInput = {
    create?: XOR<JobCreateWithoutHandoverPacksInput, JobUncheckedCreateWithoutHandoverPacksInput>
    connectOrCreate?: JobCreateOrConnectWithoutHandoverPacksInput
    connect?: JobWhereUniqueInput
  }

  export type HandoverPackUpdatewarrantyDocsUrlsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type HandoverPackUpdatefinalPhotosUrlsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type HandoverPackUpdateguidesIncludedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type JobUpdateOneRequiredWithoutHandoverPacksNestedInput = {
    create?: XOR<JobCreateWithoutHandoverPacksInput, JobUncheckedCreateWithoutHandoverPacksInput>
    connectOrCreate?: JobCreateOrConnectWithoutHandoverPacksInput
    upsert?: JobUpsertWithoutHandoverPacksInput
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutHandoverPacksInput, JobUpdateWithoutHandoverPacksInput>, JobUncheckedUpdateWithoutHandoverPacksInput>
  }

  export type GuideCreatetagsInput = {
    set: string[]
  }

  export type EnumGuideCategoryFieldUpdateOperationsInput = {
    set?: $Enums.GuideCategory
  }

  export type GuideUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmailSequenceStepCreateNestedManyWithoutJourneyInput = {
    create?: XOR<EmailSequenceStepCreateWithoutJourneyInput, EmailSequenceStepUncheckedCreateWithoutJourneyInput> | EmailSequenceStepCreateWithoutJourneyInput[] | EmailSequenceStepUncheckedCreateWithoutJourneyInput[]
    connectOrCreate?: EmailSequenceStepCreateOrConnectWithoutJourneyInput | EmailSequenceStepCreateOrConnectWithoutJourneyInput[]
    createMany?: EmailSequenceStepCreateManyJourneyInputEnvelope
    connect?: EmailSequenceStepWhereUniqueInput | EmailSequenceStepWhereUniqueInput[]
  }

  export type EmailSequenceStepUncheckedCreateNestedManyWithoutJourneyInput = {
    create?: XOR<EmailSequenceStepCreateWithoutJourneyInput, EmailSequenceStepUncheckedCreateWithoutJourneyInput> | EmailSequenceStepCreateWithoutJourneyInput[] | EmailSequenceStepUncheckedCreateWithoutJourneyInput[]
    connectOrCreate?: EmailSequenceStepCreateOrConnectWithoutJourneyInput | EmailSequenceStepCreateOrConnectWithoutJourneyInput[]
    createMany?: EmailSequenceStepCreateManyJourneyInputEnvelope
    connect?: EmailSequenceStepWhereUniqueInput | EmailSequenceStepWhereUniqueInput[]
  }

  export type EnumEmailTriggerFieldUpdateOperationsInput = {
    set?: $Enums.EmailTrigger
  }

  export type EmailSequenceStepUpdateManyWithoutJourneyNestedInput = {
    create?: XOR<EmailSequenceStepCreateWithoutJourneyInput, EmailSequenceStepUncheckedCreateWithoutJourneyInput> | EmailSequenceStepCreateWithoutJourneyInput[] | EmailSequenceStepUncheckedCreateWithoutJourneyInput[]
    connectOrCreate?: EmailSequenceStepCreateOrConnectWithoutJourneyInput | EmailSequenceStepCreateOrConnectWithoutJourneyInput[]
    upsert?: EmailSequenceStepUpsertWithWhereUniqueWithoutJourneyInput | EmailSequenceStepUpsertWithWhereUniqueWithoutJourneyInput[]
    createMany?: EmailSequenceStepCreateManyJourneyInputEnvelope
    set?: EmailSequenceStepWhereUniqueInput | EmailSequenceStepWhereUniqueInput[]
    disconnect?: EmailSequenceStepWhereUniqueInput | EmailSequenceStepWhereUniqueInput[]
    delete?: EmailSequenceStepWhereUniqueInput | EmailSequenceStepWhereUniqueInput[]
    connect?: EmailSequenceStepWhereUniqueInput | EmailSequenceStepWhereUniqueInput[]
    update?: EmailSequenceStepUpdateWithWhereUniqueWithoutJourneyInput | EmailSequenceStepUpdateWithWhereUniqueWithoutJourneyInput[]
    updateMany?: EmailSequenceStepUpdateManyWithWhereWithoutJourneyInput | EmailSequenceStepUpdateManyWithWhereWithoutJourneyInput[]
    deleteMany?: EmailSequenceStepScalarWhereInput | EmailSequenceStepScalarWhereInput[]
  }

  export type EmailSequenceStepUncheckedUpdateManyWithoutJourneyNestedInput = {
    create?: XOR<EmailSequenceStepCreateWithoutJourneyInput, EmailSequenceStepUncheckedCreateWithoutJourneyInput> | EmailSequenceStepCreateWithoutJourneyInput[] | EmailSequenceStepUncheckedCreateWithoutJourneyInput[]
    connectOrCreate?: EmailSequenceStepCreateOrConnectWithoutJourneyInput | EmailSequenceStepCreateOrConnectWithoutJourneyInput[]
    upsert?: EmailSequenceStepUpsertWithWhereUniqueWithoutJourneyInput | EmailSequenceStepUpsertWithWhereUniqueWithoutJourneyInput[]
    createMany?: EmailSequenceStepCreateManyJourneyInputEnvelope
    set?: EmailSequenceStepWhereUniqueInput | EmailSequenceStepWhereUniqueInput[]
    disconnect?: EmailSequenceStepWhereUniqueInput | EmailSequenceStepWhereUniqueInput[]
    delete?: EmailSequenceStepWhereUniqueInput | EmailSequenceStepWhereUniqueInput[]
    connect?: EmailSequenceStepWhereUniqueInput | EmailSequenceStepWhereUniqueInput[]
    update?: EmailSequenceStepUpdateWithWhereUniqueWithoutJourneyInput | EmailSequenceStepUpdateWithWhereUniqueWithoutJourneyInput[]
    updateMany?: EmailSequenceStepUpdateManyWithWhereWithoutJourneyInput | EmailSequenceStepUpdateManyWithWhereWithoutJourneyInput[]
    deleteMany?: EmailSequenceStepScalarWhereInput | EmailSequenceStepScalarWhereInput[]
  }

  export type EmailJourneyCreateNestedOneWithoutEmailSequenceInput = {
    create?: XOR<EmailJourneyCreateWithoutEmailSequenceInput, EmailJourneyUncheckedCreateWithoutEmailSequenceInput>
    connectOrCreate?: EmailJourneyCreateOrConnectWithoutEmailSequenceInput
    connect?: EmailJourneyWhereUniqueInput
  }

  export type EmailJourneyUpdateOneRequiredWithoutEmailSequenceNestedInput = {
    create?: XOR<EmailJourneyCreateWithoutEmailSequenceInput, EmailJourneyUncheckedCreateWithoutEmailSequenceInput>
    connectOrCreate?: EmailJourneyCreateOrConnectWithoutEmailSequenceInput
    upsert?: EmailJourneyUpsertWithoutEmailSequenceInput
    connect?: EmailJourneyWhereUniqueInput
    update?: XOR<XOR<EmailJourneyUpdateToOneWithWhereWithoutEmailSequenceInput, EmailJourneyUpdateWithoutEmailSequenceInput>, EmailJourneyUncheckedUpdateWithoutEmailSequenceInput>
  }

  export type WebhookCreateeventsInput = {
    set: $Enums.WebhookEvent[]
  }

  export type WebhookDeliveryCreateNestedManyWithoutWebhookInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
  }

  export type WebhookDeliveryUncheckedCreateNestedManyWithoutWebhookInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
  }

  export type WebhookUpdateeventsInput = {
    set?: $Enums.WebhookEvent[]
    push?: $Enums.WebhookEvent | $Enums.WebhookEvent[]
  }

  export type WebhookDeliveryUpdateManyWithoutWebhookNestedInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    upsert?: WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    set?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    disconnect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    delete?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    update?: WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput[]
    updateMany?: WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput | WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput[]
    deleteMany?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
  }

  export type WebhookDeliveryUncheckedUpdateManyWithoutWebhookNestedInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    upsert?: WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    set?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    disconnect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    delete?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    update?: WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput[]
    updateMany?: WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput | WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput[]
    deleteMany?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
  }

  export type WebhookCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<WebhookCreateWithoutDeliveriesInput, WebhookUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: WebhookCreateOrConnectWithoutDeliveriesInput
    connect?: WebhookWhereUniqueInput
  }

  export type EnumWebhookEventFieldUpdateOperationsInput = {
    set?: $Enums.WebhookEvent
  }

  export type WebhookUpdateOneRequiredWithoutDeliveriesNestedInput = {
    create?: XOR<WebhookCreateWithoutDeliveriesInput, WebhookUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: WebhookCreateOrConnectWithoutDeliveriesInput
    upsert?: WebhookUpsertWithoutDeliveriesInput
    connect?: WebhookWhereUniqueInput
    update?: XOR<XOR<WebhookUpdateToOneWithWhereWithoutDeliveriesInput, WebhookUpdateWithoutDeliveriesInput>, WebhookUncheckedUpdateWithoutDeliveriesInput>
  }

  export type UserCreateNestedOneWithoutEventLogsInput = {
    create?: XOR<UserCreateWithoutEventLogsInput, UserUncheckedCreateWithoutEventLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutEventLogsNestedInput = {
    create?: XOR<UserCreateWithoutEventLogsInput, UserUncheckedCreateWithoutEventLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventLogsInput
    upsert?: UserUpsertWithoutEventLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventLogsInput, UserUpdateWithoutEventLogsInput>, UserUncheckedUpdateWithoutEventLogsInput>
  }

  export type EnumIntegrationTypeFieldUpdateOperationsInput = {
    set?: $Enums.IntegrationType
  }

  export type UserCreateNestedOneWithoutMergeReviewsInput = {
    create?: XOR<UserCreateWithoutMergeReviewsInput, UserUncheckedCreateWithoutMergeReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMergeReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumMergeStatusFieldUpdateOperationsInput = {
    set?: $Enums.MergeStatus
  }

  export type UserUpdateOneWithoutMergeReviewsNestedInput = {
    create?: XOR<UserCreateWithoutMergeReviewsInput, UserUncheckedCreateWithoutMergeReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMergeReviewsInput
    upsert?: UserUpsertWithoutMergeReviewsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMergeReviewsInput, UserUpdateWithoutMergeReviewsInput>, UserUncheckedUpdateWithoutMergeReviewsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumClientTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClientTypeFilter<$PrismaModel> | $Enums.ClientType
  }

  export type NestedEnumClientTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClientTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClientType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientTypeFilter<$PrismaModel>
    _max?: NestedEnumClientTypeFilter<$PrismaModel>
  }

  export type NestedEnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type NestedEnumDirectionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Direction | EnumDirectionFieldRefInput<$PrismaModel> | null
    in?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDirectionNullableFilter<$PrismaModel> | $Enums.Direction | null
  }

  export type NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type NestedEnumDirectionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Direction | EnumDirectionFieldRefInput<$PrismaModel> | null
    in?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDirectionNullableWithAggregatesFilter<$PrismaModel> | $Enums.Direction | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDirectionNullableFilter<$PrismaModel>
    _max?: NestedEnumDirectionNullableFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type NestedEnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumRoomTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomType | EnumRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoomType[] | ListEnumRoomTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomType[] | ListEnumRoomTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomTypeFilter<$PrismaModel> | $Enums.RoomType
  }

  export type NestedEnumRoomTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomType | EnumRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoomType[] | ListEnumRoomTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomType[] | ListEnumRoomTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoomType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomTypeFilter<$PrismaModel>
    _max?: NestedEnumRoomTypeFilter<$PrismaModel>
  }

  export type NestedEnumJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusFilter<$PrismaModel> | $Enums.JobStatus
  }

  export type NestedEnumJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobStatusFilter<$PrismaModel>
    _max?: NestedEnumJobStatusFilter<$PrismaModel>
  }

  export type NestedEnumSyncStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusFilter<$PrismaModel> | $Enums.SyncStatus
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumSyncStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusWithAggregatesFilter<$PrismaModel> | $Enums.SyncStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncStatusFilter<$PrismaModel>
    _max?: NestedEnumSyncStatusFilter<$PrismaModel>
  }

  export type NestedEnumDesignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DesignStatus | EnumDesignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DesignStatus[] | ListEnumDesignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DesignStatus[] | ListEnumDesignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDesignStatusFilter<$PrismaModel> | $Enums.DesignStatus
  }

  export type NestedEnumDesignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DesignStatus | EnumDesignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DesignStatus[] | ListEnumDesignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DesignStatus[] | ListEnumDesignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDesignStatusWithAggregatesFilter<$PrismaModel> | $Enums.DesignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDesignStatusFilter<$PrismaModel>
    _max?: NestedEnumDesignStatusFilter<$PrismaModel>
  }

  export type NestedEnumClashStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ClashStatus | EnumClashStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClashStatus[] | ListEnumClashStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClashStatus[] | ListEnumClashStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClashStatusFilter<$PrismaModel> | $Enums.ClashStatus
  }

  export type NestedEnumClashStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClashStatus | EnumClashStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClashStatus[] | ListEnumClashStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClashStatus[] | ListEnumClashStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClashStatusWithAggregatesFilter<$PrismaModel> | $Enums.ClashStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClashStatusFilter<$PrismaModel>
    _max?: NestedEnumClashStatusFilter<$PrismaModel>
  }

  export type NestedEnumMoodboardStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MoodboardStatus | EnumMoodboardStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MoodboardStatus[] | ListEnumMoodboardStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MoodboardStatus[] | ListEnumMoodboardStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMoodboardStatusFilter<$PrismaModel> | $Enums.MoodboardStatus
  }

  export type NestedEnumMoodboardStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MoodboardStatus | EnumMoodboardStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MoodboardStatus[] | ListEnumMoodboardStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MoodboardStatus[] | ListEnumMoodboardStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMoodboardStatusWithAggregatesFilter<$PrismaModel> | $Enums.MoodboardStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMoodboardStatusFilter<$PrismaModel>
    _max?: NestedEnumMoodboardStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumSpecItemStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SpecItemStatus | EnumSpecItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SpecItemStatus[] | ListEnumSpecItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpecItemStatus[] | ListEnumSpecItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSpecItemStatusFilter<$PrismaModel> | $Enums.SpecItemStatus
  }

  export type NestedEnumSpecItemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SpecItemStatus | EnumSpecItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SpecItemStatus[] | ListEnumSpecItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpecItemStatus[] | ListEnumSpecItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSpecItemStatusWithAggregatesFilter<$PrismaModel> | $Enums.SpecItemStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSpecItemStatusFilter<$PrismaModel>
    _max?: NestedEnumSpecItemStatusFilter<$PrismaModel>
  }

  export type NestedEnumSnagCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.SnagCategory | EnumSnagCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SnagCategory[] | ListEnumSnagCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SnagCategory[] | ListEnumSnagCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSnagCategoryFilter<$PrismaModel> | $Enums.SnagCategory
  }

  export type NestedEnumSnagStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SnagStatus | EnumSnagStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SnagStatus[] | ListEnumSnagStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SnagStatus[] | ListEnumSnagStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSnagStatusFilter<$PrismaModel> | $Enums.SnagStatus
  }

  export type NestedEnumSnagCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SnagCategory | EnumSnagCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SnagCategory[] | ListEnumSnagCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SnagCategory[] | ListEnumSnagCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSnagCategoryWithAggregatesFilter<$PrismaModel> | $Enums.SnagCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSnagCategoryFilter<$PrismaModel>
    _max?: NestedEnumSnagCategoryFilter<$PrismaModel>
  }

  export type NestedEnumSnagStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SnagStatus | EnumSnagStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SnagStatus[] | ListEnumSnagStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SnagStatus[] | ListEnumSnagStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSnagStatusWithAggregatesFilter<$PrismaModel> | $Enums.SnagStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSnagStatusFilter<$PrismaModel>
    _max?: NestedEnumSnagStatusFilter<$PrismaModel>
  }

  export type NestedEnumDocumentCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentCategory | EnumDocumentCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentCategory[] | ListEnumDocumentCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentCategory[] | ListEnumDocumentCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentCategoryFilter<$PrismaModel> | $Enums.DocumentCategory
  }

  export type NestedEnumVirusScanStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VirusScanStatus | EnumVirusScanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VirusScanStatus[] | ListEnumVirusScanStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VirusScanStatus[] | ListEnumVirusScanStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVirusScanStatusFilter<$PrismaModel> | $Enums.VirusScanStatus
  }

  export type NestedEnumDocumentCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentCategory | EnumDocumentCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentCategory[] | ListEnumDocumentCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentCategory[] | ListEnumDocumentCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentCategoryWithAggregatesFilter<$PrismaModel> | $Enums.DocumentCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentCategoryFilter<$PrismaModel>
    _max?: NestedEnumDocumentCategoryFilter<$PrismaModel>
  }

  export type NestedEnumVirusScanStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VirusScanStatus | EnumVirusScanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VirusScanStatus[] | ListEnumVirusScanStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VirusScanStatus[] | ListEnumVirusScanStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVirusScanStatusWithAggregatesFilter<$PrismaModel> | $Enums.VirusScanStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVirusScanStatusFilter<$PrismaModel>
    _max?: NestedEnumVirusScanStatusFilter<$PrismaModel>
  }

  export type NestedEnumFormCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FormCategory | EnumFormCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FormCategory[] | ListEnumFormCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormCategory[] | ListEnumFormCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFormCategoryFilter<$PrismaModel> | $Enums.FormCategory
  }

  export type NestedEnumFormCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FormCategory | EnumFormCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FormCategory[] | ListEnumFormCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormCategory[] | ListEnumFormCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFormCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FormCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFormCategoryFilter<$PrismaModel>
    _max?: NestedEnumFormCategoryFilter<$PrismaModel>
  }

  export type NestedEnumSubmissionSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionSource | EnumSubmissionSourceFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionSource[] | ListEnumSubmissionSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionSource[] | ListEnumSubmissionSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionSourceFilter<$PrismaModel> | $Enums.SubmissionSource
  }

  export type NestedEnumSubmissionSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionSource | EnumSubmissionSourceFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionSource[] | ListEnumSubmissionSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionSource[] | ListEnumSubmissionSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionSourceWithAggregatesFilter<$PrismaModel> | $Enums.SubmissionSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubmissionSourceFilter<$PrismaModel>
    _max?: NestedEnumSubmissionSourceFilter<$PrismaModel>
  }

  export type NestedEnumGuideCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.GuideCategory | EnumGuideCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.GuideCategory[] | ListEnumGuideCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.GuideCategory[] | ListEnumGuideCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumGuideCategoryFilter<$PrismaModel> | $Enums.GuideCategory
  }

  export type NestedEnumGuideCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GuideCategory | EnumGuideCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.GuideCategory[] | ListEnumGuideCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.GuideCategory[] | ListEnumGuideCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumGuideCategoryWithAggregatesFilter<$PrismaModel> | $Enums.GuideCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGuideCategoryFilter<$PrismaModel>
    _max?: NestedEnumGuideCategoryFilter<$PrismaModel>
  }

  export type NestedEnumEmailTriggerFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailTrigger | EnumEmailTriggerFieldRefInput<$PrismaModel>
    in?: $Enums.EmailTrigger[] | ListEnumEmailTriggerFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailTrigger[] | ListEnumEmailTriggerFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailTriggerFilter<$PrismaModel> | $Enums.EmailTrigger
  }

  export type NestedEnumEmailTriggerWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailTrigger | EnumEmailTriggerFieldRefInput<$PrismaModel>
    in?: $Enums.EmailTrigger[] | ListEnumEmailTriggerFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailTrigger[] | ListEnumEmailTriggerFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailTriggerWithAggregatesFilter<$PrismaModel> | $Enums.EmailTrigger
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmailTriggerFilter<$PrismaModel>
    _max?: NestedEnumEmailTriggerFilter<$PrismaModel>
  }

  export type NestedEnumWebhookEventFilter<$PrismaModel = never> = {
    equals?: $Enums.WebhookEvent | EnumWebhookEventFieldRefInput<$PrismaModel>
    in?: $Enums.WebhookEvent[] | ListEnumWebhookEventFieldRefInput<$PrismaModel>
    notIn?: $Enums.WebhookEvent[] | ListEnumWebhookEventFieldRefInput<$PrismaModel>
    not?: NestedEnumWebhookEventFilter<$PrismaModel> | $Enums.WebhookEvent
  }

  export type NestedEnumWebhookEventWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WebhookEvent | EnumWebhookEventFieldRefInput<$PrismaModel>
    in?: $Enums.WebhookEvent[] | ListEnumWebhookEventFieldRefInput<$PrismaModel>
    notIn?: $Enums.WebhookEvent[] | ListEnumWebhookEventFieldRefInput<$PrismaModel>
    not?: NestedEnumWebhookEventWithAggregatesFilter<$PrismaModel> | $Enums.WebhookEvent
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWebhookEventFilter<$PrismaModel>
    _max?: NestedEnumWebhookEventFilter<$PrismaModel>
  }

  export type NestedEnumIntegrationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationType | EnumIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationTypeFilter<$PrismaModel> | $Enums.IntegrationType
  }

  export type NestedEnumIntegrationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationType | EnumIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationTypeWithAggregatesFilter<$PrismaModel> | $Enums.IntegrationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIntegrationTypeFilter<$PrismaModel>
    _max?: NestedEnumIntegrationTypeFilter<$PrismaModel>
  }

  export type NestedEnumMergeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MergeStatus | EnumMergeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MergeStatus[] | ListEnumMergeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MergeStatus[] | ListEnumMergeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMergeStatusFilter<$PrismaModel> | $Enums.MergeStatus
  }

  export type NestedEnumMergeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MergeStatus | EnumMergeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MergeStatus[] | ListEnumMergeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MergeStatus[] | ListEnumMergeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMergeStatusWithAggregatesFilter<$PrismaModel> | $Enums.MergeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMergeStatusFilter<$PrismaModel>
    _max?: NestedEnumMergeStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutCreatedUsersInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatedByInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionCreateNestedManyWithoutDesignerInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentCreateNestedManyWithoutAuthorInput
    snagReports?: SnagCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateWithoutCreatedUsersInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutDesignerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientUncheckedCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobUncheckedCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput
    snagReports?: SnagUncheckedCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogUncheckedCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserCreateOrConnectWithoutCreatedUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
  }

  export type UserCreateWithoutUpdatedUsersInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    ownedClients?: ClientCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatedByInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionCreateNestedManyWithoutDesignerInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentCreateNestedManyWithoutAuthorInput
    snagReports?: SnagCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateWithoutUpdatedUsersInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    ownedClients?: ClientUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutDesignerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientUncheckedCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobUncheckedCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput
    snagReports?: SnagUncheckedCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogUncheckedCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserCreateOrConnectWithoutUpdatedUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedUsersInput, UserUncheckedCreateWithoutUpdatedUsersInput>
  }

  export type UserCreateWithoutCreatedByInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatedByInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionCreateNestedManyWithoutDesignerInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentCreateNestedManyWithoutAuthorInput
    snagReports?: SnagCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateWithoutCreatedByInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutDesignerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientUncheckedCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobUncheckedCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput
    snagReports?: SnagUncheckedCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogUncheckedCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserCreateOrConnectWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput>
  }

  export type UserCreateManyCreatedByInputEnvelope = {
    data: UserCreateManyCreatedByInput | UserCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutUpdatedByInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatedByInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionCreateNestedManyWithoutDesignerInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentCreateNestedManyWithoutAuthorInput
    snagReports?: SnagCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutDesignerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientUncheckedCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobUncheckedCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput
    snagReports?: SnagUncheckedCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogUncheckedCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserCreateOrConnectWithoutUpdatedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedByInput, UserUncheckedCreateWithoutUpdatedByInput>
  }

  export type UserCreateManyUpdatedByInputEnvelope = {
    data: UserCreateManyUpdatedByInput | UserCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type ClientCreateWithoutOwnerInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedClientsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedClientsInput
    contacts?: ContactCreateNestedManyWithoutClientInput
    leads?: LeadCreateNestedManyWithoutClientInput
    deals?: DealCreateNestedManyWithoutClientInput
    rooms?: RoomCreateNestedManyWithoutClientInput
    jobs?: JobCreateNestedManyWithoutClientInput
    activities?: ActivityCreateNestedManyWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    appointments?: AppointmentCreateNestedManyWithoutClientInput
    moodboards?: MoodboardCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutOwnerInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    leads?: LeadUncheckedCreateNestedManyWithoutClientInput
    deals?: DealUncheckedCreateNestedManyWithoutClientInput
    rooms?: RoomUncheckedCreateNestedManyWithoutClientInput
    jobs?: JobUncheckedCreateNestedManyWithoutClientInput
    activities?: ActivityUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClientInput
    moodboards?: MoodboardUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutOwnerInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutOwnerInput, ClientUncheckedCreateWithoutOwnerInput>
  }

  export type ClientCreateManyOwnerInputEnvelope = {
    data: ClientCreateManyOwnerInput | ClientCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type LeadCreateWithoutOwnerInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    client: ClientCreateNestedOneWithoutLeadsInput
    deal?: DealCreateNestedOneWithoutLeadInput
    activities?: ActivityCreateNestedManyWithoutLeadInput
    tasks?: TaskCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutOwnerInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    clientId: string
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutLeadInput
    tasks?: TaskUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutOwnerInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutOwnerInput, LeadUncheckedCreateWithoutOwnerInput>
  }

  export type LeadCreateManyOwnerInputEnvelope = {
    data: LeadCreateManyOwnerInput | LeadCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type DealCreateWithoutOwnerInput = {
    id?: string
    title: string
    description?: string | null
    value: Decimal | DecimalJsLike | number | string
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    stage: PipelineStageCreateNestedOneWithoutDealsInput
    client: ClientCreateNestedOneWithoutDealsInput
    lead?: LeadCreateNestedOneWithoutDealInput
    job?: JobCreateNestedOneWithoutDealInput
    activities?: ActivityCreateNestedManyWithoutDealInput
    tasks?: TaskCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutOwnerInput = {
    id?: string
    title: string
    description?: string | null
    value: Decimal | DecimalJsLike | number | string
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    stageId: string
    clientId: string
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    lead?: LeadUncheckedCreateNestedOneWithoutDealInput
    activities?: ActivityUncheckedCreateNestedManyWithoutDealInput
    tasks?: TaskUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutOwnerInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutOwnerInput, DealUncheckedCreateWithoutOwnerInput>
  }

  export type DealCreateManyOwnerInputEnvelope = {
    data: DealCreateManyOwnerInput | DealCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    clientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTasksInput
    lead?: LeadCreateNestedOneWithoutTasksInput
    deal?: DealCreateNestedOneWithoutTasksInput
    job?: JobCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdById: string
    clientId?: string | null
    leadId?: string | null
    dealId?: string | null
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutAssigneeInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput>
  }

  export type TaskCreateManyAssigneeInputEnvelope = {
    data: TaskCreateManyAssigneeInput | TaskCreateManyAssigneeInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    clientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignee: UserCreateNestedOneWithoutAssignedTasksInput
    lead?: LeadCreateNestedOneWithoutTasksInput
    deal?: DealCreateNestedOneWithoutTasksInput
    job?: JobCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    assigneeId: string
    clientId?: string | null
    leadId?: string | null
    dealId?: string | null
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutCreatedByInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCreatedByInput, TaskUncheckedCreateWithoutCreatedByInput>
  }

  export type TaskCreateManyCreatedByInputEnvelope = {
    data: TaskCreateManyCreatedByInput | TaskCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutUserInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    description?: string | null
    direction?: $Enums.Direction | null
    duration?: number | null
    outcome?: string | null
    emailMessageId?: string | null
    callRecordingUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    client?: ClientCreateNestedOneWithoutActivitiesInput
    contact?: ContactCreateNestedOneWithoutActivitiesInput
    lead?: LeadCreateNestedOneWithoutActivitiesInput
    deal?: DealCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    description?: string | null
    direction?: $Enums.Direction | null
    duration?: number | null
    outcome?: string | null
    clientId?: string | null
    contactId?: string | null
    leadId?: string | null
    dealId?: string | null
    emailMessageId?: string | null
    callRecordingUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type ActivityCreateOrConnectWithoutUserInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
  }

  export type ActivityCreateManyUserInputEnvelope = {
    data: ActivityCreateManyUserInput | ActivityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    meetingUrl?: string | null
    status?: $Enums.AppointmentStatus
    outlookEventId?: string | null
    calendarSynced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutAppointmentsInput
    job?: JobCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    meetingUrl?: string | null
    status?: $Enums.AppointmentStatus
    clientId: string
    jobId?: string | null
    outlookEventId?: string | null
    calendarSynced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentCreateOrConnectWithoutUserInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutUserInput, AppointmentUncheckedCreateWithoutUserInput>
  }

  export type AppointmentCreateManyUserInputEnvelope = {
    data: AppointmentCreateManyUserInput | AppointmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type JobDayLogCreateWithoutUserInput = {
    id?: string
    date: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    lunchStart?: Date | string | null
    lunchEnd?: Date | string | null
    checkInLatitude?: Decimal | DecimalJsLike | number | string | null
    checkInLongitude?: Decimal | DecimalJsLike | number | string | null
    checkInAddress?: string | null
    workCompleted?: string | null
    materialsUsed?: string | null
    issuesEncountered?: string | null
    startFormData?: NullableJsonNullValueInput | InputJsonValue
    dailyFormData?: NullableJsonNullValueInput | InputJsonValue
    endFormData?: NullableJsonNullValueInput | InputJsonValue
    photos?: JobDayLogCreatephotosInput | string[]
    isCompliant?: boolean
    complianceNotes?: string | null
    syncStatus?: $Enums.SyncStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    job: JobCreateNestedOneWithoutJobDayLogsInput
  }

  export type JobDayLogUncheckedCreateWithoutUserInput = {
    id?: string
    date: Date | string
    jobId: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    lunchStart?: Date | string | null
    lunchEnd?: Date | string | null
    checkInLatitude?: Decimal | DecimalJsLike | number | string | null
    checkInLongitude?: Decimal | DecimalJsLike | number | string | null
    checkInAddress?: string | null
    workCompleted?: string | null
    materialsUsed?: string | null
    issuesEncountered?: string | null
    startFormData?: NullableJsonNullValueInput | InputJsonValue
    dailyFormData?: NullableJsonNullValueInput | InputJsonValue
    endFormData?: NullableJsonNullValueInput | InputJsonValue
    photos?: JobDayLogCreatephotosInput | string[]
    isCompliant?: boolean
    complianceNotes?: string | null
    syncStatus?: $Enums.SyncStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobDayLogCreateOrConnectWithoutUserInput = {
    where: JobDayLogWhereUniqueInput
    create: XOR<JobDayLogCreateWithoutUserInput, JobDayLogUncheckedCreateWithoutUserInput>
  }

  export type JobDayLogCreateManyUserInputEnvelope = {
    data: JobDayLogCreateManyUserInput | JobDayLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DesignVersionCreateWithoutDesignerInput = {
    id?: string
    version?: number
    title: string
    description?: string | null
    status?: $Enums.DesignStatus
    renderUrls?: DesignVersionCreaterenderUrlsInput | string[]
    planUrls?: DesignVersionCreateplanUrlsInput | string[]
    specSheetUrl?: string | null
    isClientVisible?: boolean
    clientViewedAt?: Date | string | null
    clientApprovedAt?: Date | string | null
    clientFeedback?: string | null
    isFinal?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    job: JobCreateNestedOneWithoutDesignVersionsInput
    clashTickets?: DesignClashTicketCreateNestedManyWithoutDesignVersionInput
  }

  export type DesignVersionUncheckedCreateWithoutDesignerInput = {
    id?: string
    version?: number
    title: string
    description?: string | null
    status?: $Enums.DesignStatus
    renderUrls?: DesignVersionCreaterenderUrlsInput | string[]
    planUrls?: DesignVersionCreateplanUrlsInput | string[]
    specSheetUrl?: string | null
    isClientVisible?: boolean
    clientViewedAt?: Date | string | null
    clientApprovedAt?: Date | string | null
    clientFeedback?: string | null
    jobId: string
    isFinal?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clashTickets?: DesignClashTicketUncheckedCreateNestedManyWithoutDesignVersionInput
  }

  export type DesignVersionCreateOrConnectWithoutDesignerInput = {
    where: DesignVersionWhereUniqueInput
    create: XOR<DesignVersionCreateWithoutDesignerInput, DesignVersionUncheckedCreateWithoutDesignerInput>
  }

  export type DesignVersionCreateManyDesignerInputEnvelope = {
    data: DesignVersionCreateManyDesignerInput | DesignVersionCreateManyDesignerInput[]
    skipDuplicates?: boolean
  }

  export type ClientCreateWithoutCreatedByInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: UserCreateNestedOneWithoutUpdatedClientsInput
    owner: UserCreateNestedOneWithoutOwnedClientsInput
    contacts?: ContactCreateNestedManyWithoutClientInput
    leads?: LeadCreateNestedManyWithoutClientInput
    deals?: DealCreateNestedManyWithoutClientInput
    rooms?: RoomCreateNestedManyWithoutClientInput
    jobs?: JobCreateNestedManyWithoutClientInput
    activities?: ActivityCreateNestedManyWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    appointments?: AppointmentCreateNestedManyWithoutClientInput
    moodboards?: MoodboardCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutCreatedByInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: string | null
    ownerId: string
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    leads?: LeadUncheckedCreateNestedManyWithoutClientInput
    deals?: DealUncheckedCreateNestedManyWithoutClientInput
    rooms?: RoomUncheckedCreateNestedManyWithoutClientInput
    jobs?: JobUncheckedCreateNestedManyWithoutClientInput
    activities?: ActivityUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClientInput
    moodboards?: MoodboardUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutCreatedByInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutCreatedByInput, ClientUncheckedCreateWithoutCreatedByInput>
  }

  export type ClientCreateManyCreatedByInputEnvelope = {
    data: ClientCreateManyCreatedByInput | ClientCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ClientCreateWithoutUpdatedByInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedClientsInput
    owner: UserCreateNestedOneWithoutOwnedClientsInput
    contacts?: ContactCreateNestedManyWithoutClientInput
    leads?: LeadCreateNestedManyWithoutClientInput
    deals?: DealCreateNestedManyWithoutClientInput
    rooms?: RoomCreateNestedManyWithoutClientInput
    jobs?: JobCreateNestedManyWithoutClientInput
    activities?: ActivityCreateNestedManyWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    appointments?: AppointmentCreateNestedManyWithoutClientInput
    moodboards?: MoodboardCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    ownerId: string
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    leads?: LeadUncheckedCreateNestedManyWithoutClientInput
    deals?: DealUncheckedCreateNestedManyWithoutClientInput
    rooms?: RoomUncheckedCreateNestedManyWithoutClientInput
    jobs?: JobUncheckedCreateNestedManyWithoutClientInput
    activities?: ActivityUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClientInput
    moodboards?: MoodboardUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutUpdatedByInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutUpdatedByInput, ClientUncheckedCreateWithoutUpdatedByInput>
  }

  export type ClientCreateManyUpdatedByInputEnvelope = {
    data: ClientCreateManyUpdatedByInput | ClientCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type JobCreateWithoutDesignerInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutJobsInput
    room: RoomCreateNestedOneWithoutJobsInput
    deal?: DealCreateNestedOneWithoutJobInput
    installerCompany?: InstallerCompanyCreateNestedOneWithoutJobsInput
    tasks?: TaskCreateNestedManyWithoutJobInput
    appointments?: AppointmentCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionCreateNestedManyWithoutJobInput
    snags?: SnagCreateNestedManyWithoutJobInput
    documents?: DocumentCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemCreateNestedManyWithoutJobInput
    moodboards?: MoodboardCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutDesignerInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    clientId: string
    roomId: string
    dealId?: string | null
    installerCompanyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deal?: DealUncheckedCreateNestedOneWithoutJobInput
    tasks?: TaskUncheckedCreateNestedManyWithoutJobInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutJobInput
    snags?: SnagUncheckedCreateNestedManyWithoutJobInput
    documents?: DocumentUncheckedCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemUncheckedCreateNestedManyWithoutJobInput
    moodboards?: MoodboardUncheckedCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutDesignerInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutDesignerInput, JobUncheckedCreateWithoutDesignerInput>
  }

  export type JobCreateManyDesignerInputEnvelope = {
    data: JobCreateManyDesignerInput | JobCreateManyDesignerInput[]
    skipDuplicates?: boolean
  }

  export type InstallerCompanyCreateWithoutOwnerInput = {
    id?: string
    name: string
    contactEmail: string
    contactPhone: string
    address?: string | null
    insuranceExpiry?: Date | string | null
    dbsExpiry?: Date | string | null
    contractSigned?: boolean
    contractSignedAt?: Date | string | null
    isActive?: boolean
    isSuspended?: boolean
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMembers?: InstallerTeamMemberCreateNestedManyWithoutCompanyInput
    jobs?: JobCreateNestedManyWithoutInstallerCompanyInput
  }

  export type InstallerCompanyUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    contactEmail: string
    contactPhone: string
    address?: string | null
    insuranceExpiry?: Date | string | null
    dbsExpiry?: Date | string | null
    contractSigned?: boolean
    contractSignedAt?: Date | string | null
    isActive?: boolean
    isSuspended?: boolean
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMembers?: InstallerTeamMemberUncheckedCreateNestedManyWithoutCompanyInput
    jobs?: JobUncheckedCreateNestedManyWithoutInstallerCompanyInput
  }

  export type InstallerCompanyCreateOrConnectWithoutOwnerInput = {
    where: InstallerCompanyWhereUniqueInput
    create: XOR<InstallerCompanyCreateWithoutOwnerInput, InstallerCompanyUncheckedCreateWithoutOwnerInput>
  }

  export type InstallerCompanyCreateManyOwnerInputEnvelope = {
    data: InstallerCompanyCreateManyOwnerInput | InstallerCompanyCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type DesignClashTicketCreateWithoutReportedByInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ClashStatus
    priority?: $Enums.Priority
    photoUrls?: DesignClashTicketCreatephotoUrlsInput | string[]
    resolution?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    designVersion: DesignVersionCreateNestedOneWithoutClashTicketsInput
    assignedTo?: UserCreateNestedOneWithoutClashAssignmentsInput
  }

  export type DesignClashTicketUncheckedCreateWithoutReportedByInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ClashStatus
    priority?: $Enums.Priority
    photoUrls?: DesignClashTicketCreatephotoUrlsInput | string[]
    resolution?: string | null
    resolvedAt?: Date | string | null
    designVersionId: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignClashTicketCreateOrConnectWithoutReportedByInput = {
    where: DesignClashTicketWhereUniqueInput
    create: XOR<DesignClashTicketCreateWithoutReportedByInput, DesignClashTicketUncheckedCreateWithoutReportedByInput>
  }

  export type DesignClashTicketCreateManyReportedByInputEnvelope = {
    data: DesignClashTicketCreateManyReportedByInput | DesignClashTicketCreateManyReportedByInput[]
    skipDuplicates?: boolean
  }

  export type DesignClashTicketCreateWithoutAssignedToInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ClashStatus
    priority?: $Enums.Priority
    photoUrls?: DesignClashTicketCreatephotoUrlsInput | string[]
    resolution?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    designVersion: DesignVersionCreateNestedOneWithoutClashTicketsInput
    reportedBy: UserCreateNestedOneWithoutClashReportsInput
  }

  export type DesignClashTicketUncheckedCreateWithoutAssignedToInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ClashStatus
    priority?: $Enums.Priority
    photoUrls?: DesignClashTicketCreatephotoUrlsInput | string[]
    resolution?: string | null
    resolvedAt?: Date | string | null
    designVersionId: string
    reportedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignClashTicketCreateOrConnectWithoutAssignedToInput = {
    where: DesignClashTicketWhereUniqueInput
    create: XOR<DesignClashTicketCreateWithoutAssignedToInput, DesignClashTicketUncheckedCreateWithoutAssignedToInput>
  }

  export type DesignClashTicketCreateManyAssignedToInputEnvelope = {
    data: DesignClashTicketCreateManyAssignedToInput | DesignClashTicketCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type MoodboardCommentCreateWithoutAuthorInput = {
    id?: string
    content: string
    xPosition: number
    yPosition: number
    authorName?: string | null
    createdAt?: Date | string
    item: MoodboardItemCreateNestedOneWithoutClientCommentsInput
  }

  export type MoodboardCommentUncheckedCreateWithoutAuthorInput = {
    id?: string
    content: string
    xPosition: number
    yPosition: number
    authorName?: string | null
    itemId: string
    createdAt?: Date | string
  }

  export type MoodboardCommentCreateOrConnectWithoutAuthorInput = {
    where: MoodboardCommentWhereUniqueInput
    create: XOR<MoodboardCommentCreateWithoutAuthorInput, MoodboardCommentUncheckedCreateWithoutAuthorInput>
  }

  export type MoodboardCommentCreateManyAuthorInputEnvelope = {
    data: MoodboardCommentCreateManyAuthorInput | MoodboardCommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type SnagCreateWithoutReportedByInput = {
    id?: string
    title: string
    description: string
    category: $Enums.SnagCategory
    severity?: $Enums.Priority
    status?: $Enums.SnagStatus
    photoUrls?: SnagCreatephotoUrlsInput | string[]
    isClientVisible?: boolean
    clientNotified?: boolean
    resolution?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    job: JobCreateNestedOneWithoutSnagsInput
    assignedTo?: UserCreateNestedOneWithoutSnagAssignmentsInput
  }

  export type SnagUncheckedCreateWithoutReportedByInput = {
    id?: string
    title: string
    description: string
    category: $Enums.SnagCategory
    severity?: $Enums.Priority
    status?: $Enums.SnagStatus
    photoUrls?: SnagCreatephotoUrlsInput | string[]
    isClientVisible?: boolean
    clientNotified?: boolean
    resolution?: string | null
    resolvedAt?: Date | string | null
    jobId: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SnagCreateOrConnectWithoutReportedByInput = {
    where: SnagWhereUniqueInput
    create: XOR<SnagCreateWithoutReportedByInput, SnagUncheckedCreateWithoutReportedByInput>
  }

  export type SnagCreateManyReportedByInputEnvelope = {
    data: SnagCreateManyReportedByInput | SnagCreateManyReportedByInput[]
    skipDuplicates?: boolean
  }

  export type SnagCreateWithoutAssignedToInput = {
    id?: string
    title: string
    description: string
    category: $Enums.SnagCategory
    severity?: $Enums.Priority
    status?: $Enums.SnagStatus
    photoUrls?: SnagCreatephotoUrlsInput | string[]
    isClientVisible?: boolean
    clientNotified?: boolean
    resolution?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    job: JobCreateNestedOneWithoutSnagsInput
    reportedBy: UserCreateNestedOneWithoutSnagReportsInput
  }

  export type SnagUncheckedCreateWithoutAssignedToInput = {
    id?: string
    title: string
    description: string
    category: $Enums.SnagCategory
    severity?: $Enums.Priority
    status?: $Enums.SnagStatus
    photoUrls?: SnagCreatephotoUrlsInput | string[]
    isClientVisible?: boolean
    clientNotified?: boolean
    resolution?: string | null
    resolvedAt?: Date | string | null
    jobId: string
    reportedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SnagCreateOrConnectWithoutAssignedToInput = {
    where: SnagWhereUniqueInput
    create: XOR<SnagCreateWithoutAssignedToInput, SnagUncheckedCreateWithoutAssignedToInput>
  }

  export type SnagCreateManyAssignedToInputEnvelope = {
    data: SnagCreateManyAssignedToInput | SnagCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutUploadedByInput = {
    id?: string
    filename: string
    originalFilename: string
    mimeType: string
    fileSize: number
    storageUrl: string
    category: $Enums.DocumentCategory
    description?: string | null
    isPublic?: boolean
    virusScanStatus?: $Enums.VirusScanStatus
    virusScanResult?: string | null
    createdAt?: Date | string
    client?: ClientCreateNestedOneWithoutDocumentsInput
    deal?: DealCreateNestedOneWithoutDocumentsInput
    job?: JobCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutUploadedByInput = {
    id?: string
    filename: string
    originalFilename: string
    mimeType: string
    fileSize: number
    storageUrl: string
    category: $Enums.DocumentCategory
    description?: string | null
    isPublic?: boolean
    virusScanStatus?: $Enums.VirusScanStatus
    virusScanResult?: string | null
    clientId?: string | null
    dealId?: string | null
    jobId?: string | null
    createdAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutUploadedByInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput>
  }

  export type DocumentCreateManyUploadedByInputEnvelope = {
    data: DocumentCreateManyUploadedByInput | DocumentCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type FormSubmissionCreateWithoutSubmittedByInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    submissionSource?: $Enums.SubmissionSource
    clientId?: string | null
    jobId?: string | null
    submittedAt?: Date | string
    template: FormTemplateCreateNestedOneWithoutSubmissionsInput
  }

  export type FormSubmissionUncheckedCreateWithoutSubmittedByInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    submissionSource?: $Enums.SubmissionSource
    templateId: string
    clientId?: string | null
    jobId?: string | null
    submittedAt?: Date | string
  }

  export type FormSubmissionCreateOrConnectWithoutSubmittedByInput = {
    where: FormSubmissionWhereUniqueInput
    create: XOR<FormSubmissionCreateWithoutSubmittedByInput, FormSubmissionUncheckedCreateWithoutSubmittedByInput>
  }

  export type FormSubmissionCreateManySubmittedByInputEnvelope = {
    data: FormSubmissionCreateManySubmittedByInput | FormSubmissionCreateManySubmittedByInput[]
    skipDuplicates?: boolean
  }

  export type EventLogCreateWithoutUserInput = {
    id?: string
    eventType: string
    entityType: string
    entityId: string
    changes: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    occurredAt?: Date | string
  }

  export type EventLogUncheckedCreateWithoutUserInput = {
    id?: string
    eventType: string
    entityType: string
    entityId: string
    changes: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    occurredAt?: Date | string
  }

  export type EventLogCreateOrConnectWithoutUserInput = {
    where: EventLogWhereUniqueInput
    create: XOR<EventLogCreateWithoutUserInput, EventLogUncheckedCreateWithoutUserInput>
  }

  export type EventLogCreateManyUserInputEnvelope = {
    data: EventLogCreateManyUserInput | EventLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MergeQueueCreateWithoutReviewedByInput = {
    id?: string
    entityType: string
    primaryEntityId: string
    duplicateEntityId: string
    status?: $Enums.MergeStatus
    mergeRules: JsonNullValueInput | InputJsonValue
    reviewedAt?: Date | string | null
    mergedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MergeQueueUncheckedCreateWithoutReviewedByInput = {
    id?: string
    entityType: string
    primaryEntityId: string
    duplicateEntityId: string
    status?: $Enums.MergeStatus
    mergeRules: JsonNullValueInput | InputJsonValue
    reviewedAt?: Date | string | null
    mergedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MergeQueueCreateOrConnectWithoutReviewedByInput = {
    where: MergeQueueWhereUniqueInput
    create: XOR<MergeQueueCreateWithoutReviewedByInput, MergeQueueUncheckedCreateWithoutReviewedByInput>
  }

  export type MergeQueueCreateManyReviewedByInputEnvelope = {
    data: MergeQueueCreateManyReviewedByInput | MergeQueueCreateManyReviewedByInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedUsersInput = {
    update: XOR<UserUpdateWithoutCreatedUsersInput, UserUncheckedUpdateWithoutCreatedUsersInput>
    create: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedUsersInput, UserUncheckedUpdateWithoutCreatedUsersInput>
  }

  export type UserUpdateWithoutCreatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUncheckedUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUncheckedUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUncheckedUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUncheckedUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUpsertWithoutUpdatedUsersInput = {
    update: XOR<UserUpdateWithoutUpdatedUsersInput, UserUncheckedUpdateWithoutUpdatedUsersInput>
    create: XOR<UserCreateWithoutUpdatedUsersInput, UserUncheckedCreateWithoutUpdatedUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedUsersInput, UserUncheckedUpdateWithoutUpdatedUsersInput>
  }

  export type UserUpdateWithoutUpdatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    ownedClients?: ClientUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    ownedClients?: ClientUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUncheckedUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUncheckedUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUncheckedUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUncheckedUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCreatedByInput, UserUncheckedUpdateWithoutCreatedByInput>
    create: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCreatedByInput, UserUncheckedUpdateWithoutCreatedByInput>
  }

  export type UserUpdateManyWithWhereWithoutCreatedByInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    avatarUrl?: StringNullableFilter<"User"> | string | null
    timezone?: StringFilter<"User"> | string
    preferences?: JsonFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdById?: StringNullableFilter<"User"> | string | null
    updatedById?: StringNullableFilter<"User"> | string | null
  }

  export type UserUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutUpdatedByInput, UserUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<UserCreateWithoutUpdatedByInput, UserUncheckedCreateWithoutUpdatedByInput>
  }

  export type UserUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutUpdatedByInput, UserUncheckedUpdateWithoutUpdatedByInput>
  }

  export type UserUpdateManyWithWhereWithoutUpdatedByInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type ClientUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutOwnerInput, ClientUncheckedUpdateWithoutOwnerInput>
    create: XOR<ClientCreateWithoutOwnerInput, ClientUncheckedCreateWithoutOwnerInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutOwnerInput, ClientUncheckedUpdateWithoutOwnerInput>
  }

  export type ClientUpdateManyWithWhereWithoutOwnerInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ClientScalarWhereInput = {
    AND?: ClientScalarWhereInput | ClientScalarWhereInput[]
    OR?: ClientScalarWhereInput[]
    NOT?: ClientScalarWhereInput | ClientScalarWhereInput[]
    id?: StringFilter<"Client"> | string
    companyName?: StringNullableFilter<"Client"> | string | null
    firstName?: StringFilter<"Client"> | string
    lastName?: StringFilter<"Client"> | string
    email?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    mobile?: StringNullableFilter<"Client"> | string | null
    addressLine1?: StringNullableFilter<"Client"> | string | null
    addressLine2?: StringNullableFilter<"Client"> | string | null
    city?: StringNullableFilter<"Client"> | string | null
    county?: StringNullableFilter<"Client"> | string | null
    postcode?: StringNullableFilter<"Client"> | string | null
    country?: StringFilter<"Client"> | string
    clientType?: EnumClientTypeFilter<"Client"> | $Enums.ClientType
    leadSource?: StringNullableFilter<"Client"> | string | null
    referralSource?: StringNullableFilter<"Client"> | string | null
    portalKey?: StringNullableFilter<"Client"> | string | null
    portalLastAccessAt?: DateTimeNullableFilter<"Client"> | Date | string | null
    marketingConsent?: BoolFilter<"Client"> | boolean
    marketingConsentDate?: DateTimeNullableFilter<"Client"> | Date | string | null
    emailConsent?: BoolFilter<"Client"> | boolean
    smsConsent?: BoolFilter<"Client"> | boolean
    callRecordingConsent?: BoolFilter<"Client"> | boolean
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    createdById?: StringNullableFilter<"Client"> | string | null
    updatedById?: StringNullableFilter<"Client"> | string | null
    ownerId?: StringFilter<"Client"> | string
  }

  export type LeadUpsertWithWhereUniqueWithoutOwnerInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutOwnerInput, LeadUncheckedUpdateWithoutOwnerInput>
    create: XOR<LeadCreateWithoutOwnerInput, LeadUncheckedCreateWithoutOwnerInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutOwnerInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutOwnerInput, LeadUncheckedUpdateWithoutOwnerInput>
  }

  export type LeadUpdateManyWithWhereWithoutOwnerInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutOwnerInput>
  }

  export type LeadScalarWhereInput = {
    AND?: LeadScalarWhereInput | LeadScalarWhereInput[]
    OR?: LeadScalarWhereInput[]
    NOT?: LeadScalarWhereInput | LeadScalarWhereInput[]
    id?: StringFilter<"Lead"> | string
    title?: StringFilter<"Lead"> | string
    description?: StringNullableFilter<"Lead"> | string | null
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    priority?: EnumPriorityFilter<"Lead"> | $Enums.Priority
    estimatedValue?: DecimalNullableFilter<"Lead"> | Decimal | DecimalJsLike | number | string | null
    probability?: IntFilter<"Lead"> | number
    expectedCloseDate?: DateTimeNullableFilter<"Lead"> | Date | string | null
    source?: StringNullableFilter<"Lead"> | string | null
    campaign?: StringNullableFilter<"Lead"> | string | null
    medium?: StringNullableFilter<"Lead"> | string | null
    firstResponseAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    responseTime?: IntNullableFilter<"Lead"> | number | null
    clientId?: StringFilter<"Lead"> | string
    ownerId?: StringFilter<"Lead"> | string
    dealId?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    createdById?: StringNullableFilter<"Lead"> | string | null
    updatedById?: StringNullableFilter<"Lead"> | string | null
  }

  export type DealUpsertWithWhereUniqueWithoutOwnerInput = {
    where: DealWhereUniqueInput
    update: XOR<DealUpdateWithoutOwnerInput, DealUncheckedUpdateWithoutOwnerInput>
    create: XOR<DealCreateWithoutOwnerInput, DealUncheckedCreateWithoutOwnerInput>
  }

  export type DealUpdateWithWhereUniqueWithoutOwnerInput = {
    where: DealWhereUniqueInput
    data: XOR<DealUpdateWithoutOwnerInput, DealUncheckedUpdateWithoutOwnerInput>
  }

  export type DealUpdateManyWithWhereWithoutOwnerInput = {
    where: DealScalarWhereInput
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyWithoutOwnerInput>
  }

  export type DealScalarWhereInput = {
    AND?: DealScalarWhereInput | DealScalarWhereInput[]
    OR?: DealScalarWhereInput[]
    NOT?: DealScalarWhereInput | DealScalarWhereInput[]
    id?: StringFilter<"Deal"> | string
    title?: StringFilter<"Deal"> | string
    description?: StringNullableFilter<"Deal"> | string | null
    value?: DecimalFilter<"Deal"> | Decimal | DecimalJsLike | number | string
    probability?: IntFilter<"Deal"> | number
    expectedCloseDate?: DateTimeNullableFilter<"Deal"> | Date | string | null
    actualCloseDate?: DateTimeNullableFilter<"Deal"> | Date | string | null
    stageId?: StringFilter<"Deal"> | string
    clientId?: StringFilter<"Deal"> | string
    ownerId?: StringFilter<"Deal"> | string
    jobId?: StringNullableFilter<"Deal"> | string | null
    createdAt?: DateTimeFilter<"Deal"> | Date | string
    updatedAt?: DateTimeFilter<"Deal"> | Date | string
    createdById?: StringNullableFilter<"Deal"> | string | null
    updatedById?: StringNullableFilter<"Deal"> | string | null
  }

  export type TaskUpsertWithWhereUniqueWithoutAssigneeInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutAssigneeInput, TaskUncheckedUpdateWithoutAssigneeInput>
    create: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutAssigneeInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutAssigneeInput, TaskUncheckedUpdateWithoutAssigneeInput>
  }

  export type TaskUpdateManyWithWhereWithoutAssigneeInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutAssigneeInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    priority?: EnumPriorityFilter<"Task"> | $Enums.Priority
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    assigneeId?: StringFilter<"Task"> | string
    createdById?: StringFilter<"Task"> | string
    clientId?: StringNullableFilter<"Task"> | string | null
    leadId?: StringNullableFilter<"Task"> | string | null
    dealId?: StringNullableFilter<"Task"> | string | null
    jobId?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutCreatedByInput, TaskUncheckedUpdateWithoutCreatedByInput>
    create: XOR<TaskCreateWithoutCreatedByInput, TaskUncheckedCreateWithoutCreatedByInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutCreatedByInput, TaskUncheckedUpdateWithoutCreatedByInput>
  }

  export type TaskUpdateManyWithWhereWithoutCreatedByInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ActivityUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutUserInput, ActivityUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutUserInput, ActivityUncheckedUpdateWithoutUserInput>
  }

  export type ActivityUpdateManyWithWhereWithoutUserInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutUserInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    OR?: ActivityScalarWhereInput[]
    NOT?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    id?: StringFilter<"Activity"> | string
    type?: EnumActivityTypeFilter<"Activity"> | $Enums.ActivityType
    title?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    direction?: EnumDirectionNullableFilter<"Activity"> | $Enums.Direction | null
    duration?: IntNullableFilter<"Activity"> | number | null
    outcome?: StringNullableFilter<"Activity"> | string | null
    userId?: StringFilter<"Activity"> | string
    clientId?: StringNullableFilter<"Activity"> | string | null
    contactId?: StringNullableFilter<"Activity"> | string | null
    leadId?: StringNullableFilter<"Activity"> | string | null
    dealId?: StringNullableFilter<"Activity"> | string | null
    emailMessageId?: StringNullableFilter<"Activity"> | string | null
    callRecordingUrl?: StringNullableFilter<"Activity"> | string | null
    metadata?: JsonFilter<"Activity">
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    scheduledAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
  }

  export type AppointmentUpsertWithWhereUniqueWithoutUserInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutUserInput, AppointmentUncheckedUpdateWithoutUserInput>
    create: XOR<AppointmentCreateWithoutUserInput, AppointmentUncheckedCreateWithoutUserInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutUserInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutUserInput, AppointmentUncheckedUpdateWithoutUserInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutUserInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutUserInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: StringFilter<"Appointment"> | string
    title?: StringFilter<"Appointment"> | string
    description?: StringNullableFilter<"Appointment"> | string | null
    startTime?: DateTimeFilter<"Appointment"> | Date | string
    endTime?: DateTimeFilter<"Appointment"> | Date | string
    location?: StringNullableFilter<"Appointment"> | string | null
    meetingUrl?: StringNullableFilter<"Appointment"> | string | null
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    userId?: StringFilter<"Appointment"> | string
    clientId?: StringFilter<"Appointment"> | string
    jobId?: StringNullableFilter<"Appointment"> | string | null
    outlookEventId?: StringNullableFilter<"Appointment"> | string | null
    calendarSynced?: BoolFilter<"Appointment"> | boolean
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
  }

  export type JobDayLogUpsertWithWhereUniqueWithoutUserInput = {
    where: JobDayLogWhereUniqueInput
    update: XOR<JobDayLogUpdateWithoutUserInput, JobDayLogUncheckedUpdateWithoutUserInput>
    create: XOR<JobDayLogCreateWithoutUserInput, JobDayLogUncheckedCreateWithoutUserInput>
  }

  export type JobDayLogUpdateWithWhereUniqueWithoutUserInput = {
    where: JobDayLogWhereUniqueInput
    data: XOR<JobDayLogUpdateWithoutUserInput, JobDayLogUncheckedUpdateWithoutUserInput>
  }

  export type JobDayLogUpdateManyWithWhereWithoutUserInput = {
    where: JobDayLogScalarWhereInput
    data: XOR<JobDayLogUpdateManyMutationInput, JobDayLogUncheckedUpdateManyWithoutUserInput>
  }

  export type JobDayLogScalarWhereInput = {
    AND?: JobDayLogScalarWhereInput | JobDayLogScalarWhereInput[]
    OR?: JobDayLogScalarWhereInput[]
    NOT?: JobDayLogScalarWhereInput | JobDayLogScalarWhereInput[]
    id?: StringFilter<"JobDayLog"> | string
    date?: DateTimeFilter<"JobDayLog"> | Date | string
    userId?: StringFilter<"JobDayLog"> | string
    jobId?: StringFilter<"JobDayLog"> | string
    startTime?: DateTimeNullableFilter<"JobDayLog"> | Date | string | null
    endTime?: DateTimeNullableFilter<"JobDayLog"> | Date | string | null
    lunchStart?: DateTimeNullableFilter<"JobDayLog"> | Date | string | null
    lunchEnd?: DateTimeNullableFilter<"JobDayLog"> | Date | string | null
    checkInLatitude?: DecimalNullableFilter<"JobDayLog"> | Decimal | DecimalJsLike | number | string | null
    checkInLongitude?: DecimalNullableFilter<"JobDayLog"> | Decimal | DecimalJsLike | number | string | null
    checkInAddress?: StringNullableFilter<"JobDayLog"> | string | null
    workCompleted?: StringNullableFilter<"JobDayLog"> | string | null
    materialsUsed?: StringNullableFilter<"JobDayLog"> | string | null
    issuesEncountered?: StringNullableFilter<"JobDayLog"> | string | null
    startFormData?: JsonNullableFilter<"JobDayLog">
    dailyFormData?: JsonNullableFilter<"JobDayLog">
    endFormData?: JsonNullableFilter<"JobDayLog">
    photos?: StringNullableListFilter<"JobDayLog">
    isCompliant?: BoolFilter<"JobDayLog"> | boolean
    complianceNotes?: StringNullableFilter<"JobDayLog"> | string | null
    syncStatus?: EnumSyncStatusFilter<"JobDayLog"> | $Enums.SyncStatus
    createdAt?: DateTimeFilter<"JobDayLog"> | Date | string
    updatedAt?: DateTimeFilter<"JobDayLog"> | Date | string
  }

  export type DesignVersionUpsertWithWhereUniqueWithoutDesignerInput = {
    where: DesignVersionWhereUniqueInput
    update: XOR<DesignVersionUpdateWithoutDesignerInput, DesignVersionUncheckedUpdateWithoutDesignerInput>
    create: XOR<DesignVersionCreateWithoutDesignerInput, DesignVersionUncheckedCreateWithoutDesignerInput>
  }

  export type DesignVersionUpdateWithWhereUniqueWithoutDesignerInput = {
    where: DesignVersionWhereUniqueInput
    data: XOR<DesignVersionUpdateWithoutDesignerInput, DesignVersionUncheckedUpdateWithoutDesignerInput>
  }

  export type DesignVersionUpdateManyWithWhereWithoutDesignerInput = {
    where: DesignVersionScalarWhereInput
    data: XOR<DesignVersionUpdateManyMutationInput, DesignVersionUncheckedUpdateManyWithoutDesignerInput>
  }

  export type DesignVersionScalarWhereInput = {
    AND?: DesignVersionScalarWhereInput | DesignVersionScalarWhereInput[]
    OR?: DesignVersionScalarWhereInput[]
    NOT?: DesignVersionScalarWhereInput | DesignVersionScalarWhereInput[]
    id?: StringFilter<"DesignVersion"> | string
    version?: IntFilter<"DesignVersion"> | number
    title?: StringFilter<"DesignVersion"> | string
    description?: StringNullableFilter<"DesignVersion"> | string | null
    status?: EnumDesignStatusFilter<"DesignVersion"> | $Enums.DesignStatus
    renderUrls?: StringNullableListFilter<"DesignVersion">
    planUrls?: StringNullableListFilter<"DesignVersion">
    specSheetUrl?: StringNullableFilter<"DesignVersion"> | string | null
    isClientVisible?: BoolFilter<"DesignVersion"> | boolean
    clientViewedAt?: DateTimeNullableFilter<"DesignVersion"> | Date | string | null
    clientApprovedAt?: DateTimeNullableFilter<"DesignVersion"> | Date | string | null
    clientFeedback?: StringNullableFilter<"DesignVersion"> | string | null
    jobId?: StringFilter<"DesignVersion"> | string
    designerId?: StringFilter<"DesignVersion"> | string
    isFinal?: BoolFilter<"DesignVersion"> | boolean
    lockedAt?: DateTimeNullableFilter<"DesignVersion"> | Date | string | null
    createdAt?: DateTimeFilter<"DesignVersion"> | Date | string
    updatedAt?: DateTimeFilter<"DesignVersion"> | Date | string
  }

  export type ClientUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutCreatedByInput, ClientUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ClientCreateWithoutCreatedByInput, ClientUncheckedCreateWithoutCreatedByInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutCreatedByInput, ClientUncheckedUpdateWithoutCreatedByInput>
  }

  export type ClientUpdateManyWithWhereWithoutCreatedByInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ClientUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutUpdatedByInput, ClientUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<ClientCreateWithoutUpdatedByInput, ClientUncheckedCreateWithoutUpdatedByInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutUpdatedByInput, ClientUncheckedUpdateWithoutUpdatedByInput>
  }

  export type ClientUpdateManyWithWhereWithoutUpdatedByInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type JobUpsertWithWhereUniqueWithoutDesignerInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutDesignerInput, JobUncheckedUpdateWithoutDesignerInput>
    create: XOR<JobCreateWithoutDesignerInput, JobUncheckedCreateWithoutDesignerInput>
  }

  export type JobUpdateWithWhereUniqueWithoutDesignerInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutDesignerInput, JobUncheckedUpdateWithoutDesignerInput>
  }

  export type JobUpdateManyWithWhereWithoutDesignerInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutDesignerInput>
  }

  export type JobScalarWhereInput = {
    AND?: JobScalarWhereInput | JobScalarWhereInput[]
    OR?: JobScalarWhereInput[]
    NOT?: JobScalarWhereInput | JobScalarWhereInput[]
    id?: StringFilter<"Job"> | string
    jobNumber?: StringFilter<"Job"> | string
    title?: StringFilter<"Job"> | string
    description?: StringNullableFilter<"Job"> | string | null
    status?: EnumJobStatusFilter<"Job"> | $Enums.JobStatus
    quotedDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    surveyDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    designDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    startDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    expectedEndDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    actualEndDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    quotedValue?: DecimalNullableFilter<"Job"> | Decimal | DecimalJsLike | number | string | null
    finalValue?: DecimalNullableFilter<"Job"> | Decimal | DecimalJsLike | number | string | null
    depositAmount?: DecimalNullableFilter<"Job"> | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFilter<"Job"> | boolean
    designFeePaid?: BoolFilter<"Job"> | boolean
    balancePaid?: BoolFilter<"Job"> | boolean
    clientId?: StringFilter<"Job"> | string
    roomId?: StringFilter<"Job"> | string
    dealId?: StringNullableFilter<"Job"> | string | null
    installerCompanyId?: StringNullableFilter<"Job"> | string | null
    designerId?: StringNullableFilter<"Job"> | string | null
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
  }

  export type InstallerCompanyUpsertWithWhereUniqueWithoutOwnerInput = {
    where: InstallerCompanyWhereUniqueInput
    update: XOR<InstallerCompanyUpdateWithoutOwnerInput, InstallerCompanyUncheckedUpdateWithoutOwnerInput>
    create: XOR<InstallerCompanyCreateWithoutOwnerInput, InstallerCompanyUncheckedCreateWithoutOwnerInput>
  }

  export type InstallerCompanyUpdateWithWhereUniqueWithoutOwnerInput = {
    where: InstallerCompanyWhereUniqueInput
    data: XOR<InstallerCompanyUpdateWithoutOwnerInput, InstallerCompanyUncheckedUpdateWithoutOwnerInput>
  }

  export type InstallerCompanyUpdateManyWithWhereWithoutOwnerInput = {
    where: InstallerCompanyScalarWhereInput
    data: XOR<InstallerCompanyUpdateManyMutationInput, InstallerCompanyUncheckedUpdateManyWithoutOwnerInput>
  }

  export type InstallerCompanyScalarWhereInput = {
    AND?: InstallerCompanyScalarWhereInput | InstallerCompanyScalarWhereInput[]
    OR?: InstallerCompanyScalarWhereInput[]
    NOT?: InstallerCompanyScalarWhereInput | InstallerCompanyScalarWhereInput[]
    id?: StringFilter<"InstallerCompany"> | string
    name?: StringFilter<"InstallerCompany"> | string
    contactEmail?: StringFilter<"InstallerCompany"> | string
    contactPhone?: StringFilter<"InstallerCompany"> | string
    address?: StringNullableFilter<"InstallerCompany"> | string | null
    insuranceExpiry?: DateTimeNullableFilter<"InstallerCompany"> | Date | string | null
    dbsExpiry?: DateTimeNullableFilter<"InstallerCompany"> | Date | string | null
    contractSigned?: BoolFilter<"InstallerCompany"> | boolean
    contractSignedAt?: DateTimeNullableFilter<"InstallerCompany"> | Date | string | null
    isActive?: BoolFilter<"InstallerCompany"> | boolean
    isSuspended?: BoolFilter<"InstallerCompany"> | boolean
    suspensionReason?: StringNullableFilter<"InstallerCompany"> | string | null
    ownerId?: StringNullableFilter<"InstallerCompany"> | string | null
    createdAt?: DateTimeFilter<"InstallerCompany"> | Date | string
    updatedAt?: DateTimeFilter<"InstallerCompany"> | Date | string
  }

  export type DesignClashTicketUpsertWithWhereUniqueWithoutReportedByInput = {
    where: DesignClashTicketWhereUniqueInput
    update: XOR<DesignClashTicketUpdateWithoutReportedByInput, DesignClashTicketUncheckedUpdateWithoutReportedByInput>
    create: XOR<DesignClashTicketCreateWithoutReportedByInput, DesignClashTicketUncheckedCreateWithoutReportedByInput>
  }

  export type DesignClashTicketUpdateWithWhereUniqueWithoutReportedByInput = {
    where: DesignClashTicketWhereUniqueInput
    data: XOR<DesignClashTicketUpdateWithoutReportedByInput, DesignClashTicketUncheckedUpdateWithoutReportedByInput>
  }

  export type DesignClashTicketUpdateManyWithWhereWithoutReportedByInput = {
    where: DesignClashTicketScalarWhereInput
    data: XOR<DesignClashTicketUpdateManyMutationInput, DesignClashTicketUncheckedUpdateManyWithoutReportedByInput>
  }

  export type DesignClashTicketScalarWhereInput = {
    AND?: DesignClashTicketScalarWhereInput | DesignClashTicketScalarWhereInput[]
    OR?: DesignClashTicketScalarWhereInput[]
    NOT?: DesignClashTicketScalarWhereInput | DesignClashTicketScalarWhereInput[]
    id?: StringFilter<"DesignClashTicket"> | string
    title?: StringFilter<"DesignClashTicket"> | string
    description?: StringFilter<"DesignClashTicket"> | string
    status?: EnumClashStatusFilter<"DesignClashTicket"> | $Enums.ClashStatus
    priority?: EnumPriorityFilter<"DesignClashTicket"> | $Enums.Priority
    photoUrls?: StringNullableListFilter<"DesignClashTicket">
    resolution?: StringNullableFilter<"DesignClashTicket"> | string | null
    resolvedAt?: DateTimeNullableFilter<"DesignClashTicket"> | Date | string | null
    designVersionId?: StringFilter<"DesignClashTicket"> | string
    reportedById?: StringFilter<"DesignClashTicket"> | string
    assignedToId?: StringNullableFilter<"DesignClashTicket"> | string | null
    createdAt?: DateTimeFilter<"DesignClashTicket"> | Date | string
    updatedAt?: DateTimeFilter<"DesignClashTicket"> | Date | string
  }

  export type DesignClashTicketUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: DesignClashTicketWhereUniqueInput
    update: XOR<DesignClashTicketUpdateWithoutAssignedToInput, DesignClashTicketUncheckedUpdateWithoutAssignedToInput>
    create: XOR<DesignClashTicketCreateWithoutAssignedToInput, DesignClashTicketUncheckedCreateWithoutAssignedToInput>
  }

  export type DesignClashTicketUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: DesignClashTicketWhereUniqueInput
    data: XOR<DesignClashTicketUpdateWithoutAssignedToInput, DesignClashTicketUncheckedUpdateWithoutAssignedToInput>
  }

  export type DesignClashTicketUpdateManyWithWhereWithoutAssignedToInput = {
    where: DesignClashTicketScalarWhereInput
    data: XOR<DesignClashTicketUpdateManyMutationInput, DesignClashTicketUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type MoodboardCommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: MoodboardCommentWhereUniqueInput
    update: XOR<MoodboardCommentUpdateWithoutAuthorInput, MoodboardCommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<MoodboardCommentCreateWithoutAuthorInput, MoodboardCommentUncheckedCreateWithoutAuthorInput>
  }

  export type MoodboardCommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: MoodboardCommentWhereUniqueInput
    data: XOR<MoodboardCommentUpdateWithoutAuthorInput, MoodboardCommentUncheckedUpdateWithoutAuthorInput>
  }

  export type MoodboardCommentUpdateManyWithWhereWithoutAuthorInput = {
    where: MoodboardCommentScalarWhereInput
    data: XOR<MoodboardCommentUpdateManyMutationInput, MoodboardCommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type MoodboardCommentScalarWhereInput = {
    AND?: MoodboardCommentScalarWhereInput | MoodboardCommentScalarWhereInput[]
    OR?: MoodboardCommentScalarWhereInput[]
    NOT?: MoodboardCommentScalarWhereInput | MoodboardCommentScalarWhereInput[]
    id?: StringFilter<"MoodboardComment"> | string
    content?: StringFilter<"MoodboardComment"> | string
    xPosition?: FloatFilter<"MoodboardComment"> | number
    yPosition?: FloatFilter<"MoodboardComment"> | number
    authorId?: StringNullableFilter<"MoodboardComment"> | string | null
    authorName?: StringNullableFilter<"MoodboardComment"> | string | null
    itemId?: StringFilter<"MoodboardComment"> | string
    createdAt?: DateTimeFilter<"MoodboardComment"> | Date | string
  }

  export type SnagUpsertWithWhereUniqueWithoutReportedByInput = {
    where: SnagWhereUniqueInput
    update: XOR<SnagUpdateWithoutReportedByInput, SnagUncheckedUpdateWithoutReportedByInput>
    create: XOR<SnagCreateWithoutReportedByInput, SnagUncheckedCreateWithoutReportedByInput>
  }

  export type SnagUpdateWithWhereUniqueWithoutReportedByInput = {
    where: SnagWhereUniqueInput
    data: XOR<SnagUpdateWithoutReportedByInput, SnagUncheckedUpdateWithoutReportedByInput>
  }

  export type SnagUpdateManyWithWhereWithoutReportedByInput = {
    where: SnagScalarWhereInput
    data: XOR<SnagUpdateManyMutationInput, SnagUncheckedUpdateManyWithoutReportedByInput>
  }

  export type SnagScalarWhereInput = {
    AND?: SnagScalarWhereInput | SnagScalarWhereInput[]
    OR?: SnagScalarWhereInput[]
    NOT?: SnagScalarWhereInput | SnagScalarWhereInput[]
    id?: StringFilter<"Snag"> | string
    title?: StringFilter<"Snag"> | string
    description?: StringFilter<"Snag"> | string
    category?: EnumSnagCategoryFilter<"Snag"> | $Enums.SnagCategory
    severity?: EnumPriorityFilter<"Snag"> | $Enums.Priority
    status?: EnumSnagStatusFilter<"Snag"> | $Enums.SnagStatus
    photoUrls?: StringNullableListFilter<"Snag">
    isClientVisible?: BoolFilter<"Snag"> | boolean
    clientNotified?: BoolFilter<"Snag"> | boolean
    resolution?: StringNullableFilter<"Snag"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Snag"> | Date | string | null
    jobId?: StringFilter<"Snag"> | string
    reportedById?: StringFilter<"Snag"> | string
    assignedToId?: StringNullableFilter<"Snag"> | string | null
    createdAt?: DateTimeFilter<"Snag"> | Date | string
    updatedAt?: DateTimeFilter<"Snag"> | Date | string
  }

  export type SnagUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: SnagWhereUniqueInput
    update: XOR<SnagUpdateWithoutAssignedToInput, SnagUncheckedUpdateWithoutAssignedToInput>
    create: XOR<SnagCreateWithoutAssignedToInput, SnagUncheckedCreateWithoutAssignedToInput>
  }

  export type SnagUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: SnagWhereUniqueInput
    data: XOR<SnagUpdateWithoutAssignedToInput, SnagUncheckedUpdateWithoutAssignedToInput>
  }

  export type SnagUpdateManyWithWhereWithoutAssignedToInput = {
    where: SnagScalarWhereInput
    data: XOR<SnagUpdateManyMutationInput, SnagUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutUploadedByInput, DocumentUncheckedUpdateWithoutUploadedByInput>
    create: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutUploadedByInput, DocumentUncheckedUpdateWithoutUploadedByInput>
  }

  export type DocumentUpdateManyWithWhereWithoutUploadedByInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    filename?: StringFilter<"Document"> | string
    originalFilename?: StringFilter<"Document"> | string
    mimeType?: StringFilter<"Document"> | string
    fileSize?: IntFilter<"Document"> | number
    storageUrl?: StringFilter<"Document"> | string
    category?: EnumDocumentCategoryFilter<"Document"> | $Enums.DocumentCategory
    description?: StringNullableFilter<"Document"> | string | null
    isPublic?: BoolFilter<"Document"> | boolean
    virusScanStatus?: EnumVirusScanStatusFilter<"Document"> | $Enums.VirusScanStatus
    virusScanResult?: StringNullableFilter<"Document"> | string | null
    clientId?: StringNullableFilter<"Document"> | string | null
    dealId?: StringNullableFilter<"Document"> | string | null
    jobId?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    uploadedById?: StringFilter<"Document"> | string
  }

  export type FormSubmissionUpsertWithWhereUniqueWithoutSubmittedByInput = {
    where: FormSubmissionWhereUniqueInput
    update: XOR<FormSubmissionUpdateWithoutSubmittedByInput, FormSubmissionUncheckedUpdateWithoutSubmittedByInput>
    create: XOR<FormSubmissionCreateWithoutSubmittedByInput, FormSubmissionUncheckedCreateWithoutSubmittedByInput>
  }

  export type FormSubmissionUpdateWithWhereUniqueWithoutSubmittedByInput = {
    where: FormSubmissionWhereUniqueInput
    data: XOR<FormSubmissionUpdateWithoutSubmittedByInput, FormSubmissionUncheckedUpdateWithoutSubmittedByInput>
  }

  export type FormSubmissionUpdateManyWithWhereWithoutSubmittedByInput = {
    where: FormSubmissionScalarWhereInput
    data: XOR<FormSubmissionUpdateManyMutationInput, FormSubmissionUncheckedUpdateManyWithoutSubmittedByInput>
  }

  export type FormSubmissionScalarWhereInput = {
    AND?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
    OR?: FormSubmissionScalarWhereInput[]
    NOT?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
    id?: StringFilter<"FormSubmission"> | string
    data?: JsonFilter<"FormSubmission">
    submissionSource?: EnumSubmissionSourceFilter<"FormSubmission"> | $Enums.SubmissionSource
    templateId?: StringFilter<"FormSubmission"> | string
    submittedById?: StringNullableFilter<"FormSubmission"> | string | null
    clientId?: StringNullableFilter<"FormSubmission"> | string | null
    jobId?: StringNullableFilter<"FormSubmission"> | string | null
    submittedAt?: DateTimeFilter<"FormSubmission"> | Date | string
  }

  export type EventLogUpsertWithWhereUniqueWithoutUserInput = {
    where: EventLogWhereUniqueInput
    update: XOR<EventLogUpdateWithoutUserInput, EventLogUncheckedUpdateWithoutUserInput>
    create: XOR<EventLogCreateWithoutUserInput, EventLogUncheckedCreateWithoutUserInput>
  }

  export type EventLogUpdateWithWhereUniqueWithoutUserInput = {
    where: EventLogWhereUniqueInput
    data: XOR<EventLogUpdateWithoutUserInput, EventLogUncheckedUpdateWithoutUserInput>
  }

  export type EventLogUpdateManyWithWhereWithoutUserInput = {
    where: EventLogScalarWhereInput
    data: XOR<EventLogUpdateManyMutationInput, EventLogUncheckedUpdateManyWithoutUserInput>
  }

  export type EventLogScalarWhereInput = {
    AND?: EventLogScalarWhereInput | EventLogScalarWhereInput[]
    OR?: EventLogScalarWhereInput[]
    NOT?: EventLogScalarWhereInput | EventLogScalarWhereInput[]
    id?: StringFilter<"EventLog"> | string
    eventType?: StringFilter<"EventLog"> | string
    entityType?: StringFilter<"EventLog"> | string
    entityId?: StringFilter<"EventLog"> | string
    changes?: JsonFilter<"EventLog">
    metadata?: JsonFilter<"EventLog">
    ipAddress?: StringNullableFilter<"EventLog"> | string | null
    userAgent?: StringNullableFilter<"EventLog"> | string | null
    userId?: StringNullableFilter<"EventLog"> | string | null
    occurredAt?: DateTimeFilter<"EventLog"> | Date | string
  }

  export type MergeQueueUpsertWithWhereUniqueWithoutReviewedByInput = {
    where: MergeQueueWhereUniqueInput
    update: XOR<MergeQueueUpdateWithoutReviewedByInput, MergeQueueUncheckedUpdateWithoutReviewedByInput>
    create: XOR<MergeQueueCreateWithoutReviewedByInput, MergeQueueUncheckedCreateWithoutReviewedByInput>
  }

  export type MergeQueueUpdateWithWhereUniqueWithoutReviewedByInput = {
    where: MergeQueueWhereUniqueInput
    data: XOR<MergeQueueUpdateWithoutReviewedByInput, MergeQueueUncheckedUpdateWithoutReviewedByInput>
  }

  export type MergeQueueUpdateManyWithWhereWithoutReviewedByInput = {
    where: MergeQueueScalarWhereInput
    data: XOR<MergeQueueUpdateManyMutationInput, MergeQueueUncheckedUpdateManyWithoutReviewedByInput>
  }

  export type MergeQueueScalarWhereInput = {
    AND?: MergeQueueScalarWhereInput | MergeQueueScalarWhereInput[]
    OR?: MergeQueueScalarWhereInput[]
    NOT?: MergeQueueScalarWhereInput | MergeQueueScalarWhereInput[]
    id?: StringFilter<"MergeQueue"> | string
    entityType?: StringFilter<"MergeQueue"> | string
    primaryEntityId?: StringFilter<"MergeQueue"> | string
    duplicateEntityId?: StringFilter<"MergeQueue"> | string
    status?: EnumMergeStatusFilter<"MergeQueue"> | $Enums.MergeStatus
    mergeRules?: JsonFilter<"MergeQueue">
    reviewedById?: StringNullableFilter<"MergeQueue"> | string | null
    reviewedAt?: DateTimeNullableFilter<"MergeQueue"> | Date | string | null
    mergedAt?: DateTimeNullableFilter<"MergeQueue"> | Date | string | null
    createdAt?: DateTimeFilter<"MergeQueue"> | Date | string
  }

  export type UserCreateWithoutCreatedClientsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatedByInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionCreateNestedManyWithoutDesignerInput
    updatedClients?: ClientCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentCreateNestedManyWithoutAuthorInput
    snagReports?: SnagCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateWithoutCreatedClientsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutDesignerInput
    updatedClients?: ClientUncheckedCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobUncheckedCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput
    snagReports?: SnagUncheckedCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogUncheckedCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserCreateOrConnectWithoutCreatedClientsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedClientsInput, UserUncheckedCreateWithoutCreatedClientsInput>
  }

  export type UserCreateWithoutUpdatedClientsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatedByInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionCreateNestedManyWithoutDesignerInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    designerJobs?: JobCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentCreateNestedManyWithoutAuthorInput
    snagReports?: SnagCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateWithoutUpdatedClientsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutDesignerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    designerJobs?: JobUncheckedCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput
    snagReports?: SnagUncheckedCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogUncheckedCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserCreateOrConnectWithoutUpdatedClientsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedClientsInput, UserUncheckedCreateWithoutUpdatedClientsInput>
  }

  export type UserCreateWithoutOwnedClientsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatedByInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionCreateNestedManyWithoutDesignerInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentCreateNestedManyWithoutAuthorInput
    snagReports?: SnagCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateWithoutOwnedClientsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutDesignerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientUncheckedCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobUncheckedCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput
    snagReports?: SnagUncheckedCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogUncheckedCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserCreateOrConnectWithoutOwnedClientsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedClientsInput, UserUncheckedCreateWithoutOwnedClientsInput>
  }

  export type ContactCreateWithoutClientInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    jobTitle?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutClientInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    jobTitle?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutClientInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutClientInput, ContactUncheckedCreateWithoutClientInput>
  }

  export type ContactCreateManyClientInputEnvelope = {
    data: ContactCreateManyClientInput | ContactCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type LeadCreateWithoutClientInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    owner: UserCreateNestedOneWithoutOwnedLeadsInput
    deal?: DealCreateNestedOneWithoutLeadInput
    activities?: ActivityCreateNestedManyWithoutLeadInput
    tasks?: TaskCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutClientInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    ownerId: string
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutLeadInput
    tasks?: TaskUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutClientInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutClientInput, LeadUncheckedCreateWithoutClientInput>
  }

  export type LeadCreateManyClientInputEnvelope = {
    data: LeadCreateManyClientInput | LeadCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type DealCreateWithoutClientInput = {
    id?: string
    title: string
    description?: string | null
    value: Decimal | DecimalJsLike | number | string
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    stage: PipelineStageCreateNestedOneWithoutDealsInput
    owner: UserCreateNestedOneWithoutOwnedDealsInput
    lead?: LeadCreateNestedOneWithoutDealInput
    job?: JobCreateNestedOneWithoutDealInput
    activities?: ActivityCreateNestedManyWithoutDealInput
    tasks?: TaskCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutClientInput = {
    id?: string
    title: string
    description?: string | null
    value: Decimal | DecimalJsLike | number | string
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    stageId: string
    ownerId: string
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    lead?: LeadUncheckedCreateNestedOneWithoutDealInput
    activities?: ActivityUncheckedCreateNestedManyWithoutDealInput
    tasks?: TaskUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutClientInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutClientInput, DealUncheckedCreateWithoutClientInput>
  }

  export type DealCreateManyClientInputEnvelope = {
    data: DealCreateManyClientInput | DealCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type RoomCreateWithoutClientInput = {
    id?: string
    name: string
    type: $Enums.RoomType
    length?: number | null
    width?: number | null
    height?: number | null
    currentCondition?: string | null
    accessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutClientInput = {
    id?: string
    name: string
    type: $Enums.RoomType
    length?: number | null
    width?: number | null
    height?: number | null
    currentCondition?: string | null
    accessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutClientInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutClientInput, RoomUncheckedCreateWithoutClientInput>
  }

  export type RoomCreateManyClientInputEnvelope = {
    data: RoomCreateManyClientInput | RoomCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type JobCreateWithoutClientInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    room: RoomCreateNestedOneWithoutJobsInput
    deal?: DealCreateNestedOneWithoutJobInput
    installerCompany?: InstallerCompanyCreateNestedOneWithoutJobsInput
    designer?: UserCreateNestedOneWithoutDesignerJobsInput
    tasks?: TaskCreateNestedManyWithoutJobInput
    appointments?: AppointmentCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionCreateNestedManyWithoutJobInput
    snags?: SnagCreateNestedManyWithoutJobInput
    documents?: DocumentCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemCreateNestedManyWithoutJobInput
    moodboards?: MoodboardCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutClientInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    roomId: string
    dealId?: string | null
    installerCompanyId?: string | null
    designerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deal?: DealUncheckedCreateNestedOneWithoutJobInput
    tasks?: TaskUncheckedCreateNestedManyWithoutJobInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutJobInput
    snags?: SnagUncheckedCreateNestedManyWithoutJobInput
    documents?: DocumentUncheckedCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemUncheckedCreateNestedManyWithoutJobInput
    moodboards?: MoodboardUncheckedCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutClientInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutClientInput, JobUncheckedCreateWithoutClientInput>
  }

  export type JobCreateManyClientInputEnvelope = {
    data: JobCreateManyClientInput | JobCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutClientInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    description?: string | null
    direction?: $Enums.Direction | null
    duration?: number | null
    outcome?: string | null
    emailMessageId?: string | null
    callRecordingUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutActivitiesInput
    contact?: ContactCreateNestedOneWithoutActivitiesInput
    lead?: LeadCreateNestedOneWithoutActivitiesInput
    deal?: DealCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutClientInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    description?: string | null
    direction?: $Enums.Direction | null
    duration?: number | null
    outcome?: string | null
    userId: string
    contactId?: string | null
    leadId?: string | null
    dealId?: string | null
    emailMessageId?: string | null
    callRecordingUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type ActivityCreateOrConnectWithoutClientInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutClientInput, ActivityUncheckedCreateWithoutClientInput>
  }

  export type ActivityCreateManyClientInputEnvelope = {
    data: ActivityCreateManyClientInput | ActivityCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutClientInput = {
    id?: string
    filename: string
    originalFilename: string
    mimeType: string
    fileSize: number
    storageUrl: string
    category: $Enums.DocumentCategory
    description?: string | null
    isPublic?: boolean
    virusScanStatus?: $Enums.VirusScanStatus
    virusScanResult?: string | null
    createdAt?: Date | string
    deal?: DealCreateNestedOneWithoutDocumentsInput
    job?: JobCreateNestedOneWithoutDocumentsInput
    uploadedBy: UserCreateNestedOneWithoutUploadedDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutClientInput = {
    id?: string
    filename: string
    originalFilename: string
    mimeType: string
    fileSize: number
    storageUrl: string
    category: $Enums.DocumentCategory
    description?: string | null
    isPublic?: boolean
    virusScanStatus?: $Enums.VirusScanStatus
    virusScanResult?: string | null
    dealId?: string | null
    jobId?: string | null
    createdAt?: Date | string
    uploadedById: string
  }

  export type DocumentCreateOrConnectWithoutClientInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput>
  }

  export type DocumentCreateManyClientInputEnvelope = {
    data: DocumentCreateManyClientInput | DocumentCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutClientInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    meetingUrl?: string | null
    status?: $Enums.AppointmentStatus
    outlookEventId?: string | null
    calendarSynced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAppointmentsInput
    job?: JobCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutClientInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    meetingUrl?: string | null
    status?: $Enums.AppointmentStatus
    userId: string
    jobId?: string | null
    outlookEventId?: string | null
    calendarSynced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentCreateOrConnectWithoutClientInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutClientInput, AppointmentUncheckedCreateWithoutClientInput>
  }

  export type AppointmentCreateManyClientInputEnvelope = {
    data: AppointmentCreateManyClientInput | AppointmentCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type MoodboardCreateWithoutClientInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.MoodboardStatus
    isClientVisible?: boolean
    clientLastViewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    job?: JobCreateNestedOneWithoutMoodboardsInput
    items?: MoodboardItemCreateNestedManyWithoutMoodboardInput
  }

  export type MoodboardUncheckedCreateWithoutClientInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.MoodboardStatus
    jobId?: string | null
    isClientVisible?: boolean
    clientLastViewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: MoodboardItemUncheckedCreateNestedManyWithoutMoodboardInput
  }

  export type MoodboardCreateOrConnectWithoutClientInput = {
    where: MoodboardWhereUniqueInput
    create: XOR<MoodboardCreateWithoutClientInput, MoodboardUncheckedCreateWithoutClientInput>
  }

  export type MoodboardCreateManyClientInputEnvelope = {
    data: MoodboardCreateManyClientInput | MoodboardCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedClientsInput = {
    update: XOR<UserUpdateWithoutCreatedClientsInput, UserUncheckedUpdateWithoutCreatedClientsInput>
    create: XOR<UserCreateWithoutCreatedClientsInput, UserUncheckedCreateWithoutCreatedClientsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedClientsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedClientsInput, UserUncheckedUpdateWithoutCreatedClientsInput>
  }

  export type UserUpdateWithoutCreatedClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUpdateManyWithoutDesignerNestedInput
    updatedClients?: ClientUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput
    updatedClients?: ClientUncheckedUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUncheckedUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUncheckedUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUncheckedUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUpsertWithoutUpdatedClientsInput = {
    update: XOR<UserUpdateWithoutUpdatedClientsInput, UserUncheckedUpdateWithoutUpdatedClientsInput>
    create: XOR<UserCreateWithoutUpdatedClientsInput, UserUncheckedCreateWithoutUpdatedClientsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedClientsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedClientsInput, UserUncheckedUpdateWithoutUpdatedClientsInput>
  }

  export type UserUpdateWithoutUpdatedClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    designerJobs?: JobUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    designerJobs?: JobUncheckedUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUncheckedUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUncheckedUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUpsertWithoutOwnedClientsInput = {
    update: XOR<UserUpdateWithoutOwnedClientsInput, UserUncheckedUpdateWithoutOwnedClientsInput>
    create: XOR<UserCreateWithoutOwnedClientsInput, UserUncheckedCreateWithoutOwnedClientsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedClientsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedClientsInput, UserUncheckedUpdateWithoutOwnedClientsInput>
  }

  export type UserUpdateWithoutOwnedClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUncheckedUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUncheckedUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUncheckedUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUncheckedUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type ContactUpsertWithWhereUniqueWithoutClientInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutClientInput, ContactUncheckedUpdateWithoutClientInput>
    create: XOR<ContactCreateWithoutClientInput, ContactUncheckedCreateWithoutClientInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutClientInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutClientInput, ContactUncheckedUpdateWithoutClientInput>
  }

  export type ContactUpdateManyWithWhereWithoutClientInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutClientInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: StringFilter<"Contact"> | string
    firstName?: StringFilter<"Contact"> | string
    lastName?: StringFilter<"Contact"> | string
    email?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    mobile?: StringNullableFilter<"Contact"> | string | null
    jobTitle?: StringNullableFilter<"Contact"> | string | null
    isPrimary?: BoolFilter<"Contact"> | boolean
    clientId?: StringFilter<"Contact"> | string
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    createdById?: StringNullableFilter<"Contact"> | string | null
    updatedById?: StringNullableFilter<"Contact"> | string | null
  }

  export type LeadUpsertWithWhereUniqueWithoutClientInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutClientInput, LeadUncheckedUpdateWithoutClientInput>
    create: XOR<LeadCreateWithoutClientInput, LeadUncheckedCreateWithoutClientInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutClientInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutClientInput, LeadUncheckedUpdateWithoutClientInput>
  }

  export type LeadUpdateManyWithWhereWithoutClientInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutClientInput>
  }

  export type DealUpsertWithWhereUniqueWithoutClientInput = {
    where: DealWhereUniqueInput
    update: XOR<DealUpdateWithoutClientInput, DealUncheckedUpdateWithoutClientInput>
    create: XOR<DealCreateWithoutClientInput, DealUncheckedCreateWithoutClientInput>
  }

  export type DealUpdateWithWhereUniqueWithoutClientInput = {
    where: DealWhereUniqueInput
    data: XOR<DealUpdateWithoutClientInput, DealUncheckedUpdateWithoutClientInput>
  }

  export type DealUpdateManyWithWhereWithoutClientInput = {
    where: DealScalarWhereInput
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyWithoutClientInput>
  }

  export type RoomUpsertWithWhereUniqueWithoutClientInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutClientInput, RoomUncheckedUpdateWithoutClientInput>
    create: XOR<RoomCreateWithoutClientInput, RoomUncheckedCreateWithoutClientInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutClientInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutClientInput, RoomUncheckedUpdateWithoutClientInput>
  }

  export type RoomUpdateManyWithWhereWithoutClientInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutClientInput>
  }

  export type RoomScalarWhereInput = {
    AND?: RoomScalarWhereInput | RoomScalarWhereInput[]
    OR?: RoomScalarWhereInput[]
    NOT?: RoomScalarWhereInput | RoomScalarWhereInput[]
    id?: StringFilter<"Room"> | string
    name?: StringFilter<"Room"> | string
    type?: EnumRoomTypeFilter<"Room"> | $Enums.RoomType
    length?: IntNullableFilter<"Room"> | number | null
    width?: IntNullableFilter<"Room"> | number | null
    height?: IntNullableFilter<"Room"> | number | null
    currentCondition?: StringNullableFilter<"Room"> | string | null
    accessNotes?: StringNullableFilter<"Room"> | string | null
    clientId?: StringFilter<"Room"> | string
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
  }

  export type JobUpsertWithWhereUniqueWithoutClientInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutClientInput, JobUncheckedUpdateWithoutClientInput>
    create: XOR<JobCreateWithoutClientInput, JobUncheckedCreateWithoutClientInput>
  }

  export type JobUpdateWithWhereUniqueWithoutClientInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutClientInput, JobUncheckedUpdateWithoutClientInput>
  }

  export type JobUpdateManyWithWhereWithoutClientInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutClientInput>
  }

  export type ActivityUpsertWithWhereUniqueWithoutClientInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutClientInput, ActivityUncheckedUpdateWithoutClientInput>
    create: XOR<ActivityCreateWithoutClientInput, ActivityUncheckedCreateWithoutClientInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutClientInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutClientInput, ActivityUncheckedUpdateWithoutClientInput>
  }

  export type ActivityUpdateManyWithWhereWithoutClientInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutClientInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutClientInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutClientInput, DocumentUncheckedUpdateWithoutClientInput>
    create: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutClientInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutClientInput, DocumentUncheckedUpdateWithoutClientInput>
  }

  export type DocumentUpdateManyWithWhereWithoutClientInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutClientInput>
  }

  export type AppointmentUpsertWithWhereUniqueWithoutClientInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutClientInput, AppointmentUncheckedUpdateWithoutClientInput>
    create: XOR<AppointmentCreateWithoutClientInput, AppointmentUncheckedCreateWithoutClientInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutClientInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutClientInput, AppointmentUncheckedUpdateWithoutClientInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutClientInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutClientInput>
  }

  export type MoodboardUpsertWithWhereUniqueWithoutClientInput = {
    where: MoodboardWhereUniqueInput
    update: XOR<MoodboardUpdateWithoutClientInput, MoodboardUncheckedUpdateWithoutClientInput>
    create: XOR<MoodboardCreateWithoutClientInput, MoodboardUncheckedCreateWithoutClientInput>
  }

  export type MoodboardUpdateWithWhereUniqueWithoutClientInput = {
    where: MoodboardWhereUniqueInput
    data: XOR<MoodboardUpdateWithoutClientInput, MoodboardUncheckedUpdateWithoutClientInput>
  }

  export type MoodboardUpdateManyWithWhereWithoutClientInput = {
    where: MoodboardScalarWhereInput
    data: XOR<MoodboardUpdateManyMutationInput, MoodboardUncheckedUpdateManyWithoutClientInput>
  }

  export type MoodboardScalarWhereInput = {
    AND?: MoodboardScalarWhereInput | MoodboardScalarWhereInput[]
    OR?: MoodboardScalarWhereInput[]
    NOT?: MoodboardScalarWhereInput | MoodboardScalarWhereInput[]
    id?: StringFilter<"Moodboard"> | string
    title?: StringFilter<"Moodboard"> | string
    description?: StringNullableFilter<"Moodboard"> | string | null
    status?: EnumMoodboardStatusFilter<"Moodboard"> | $Enums.MoodboardStatus
    clientId?: StringFilter<"Moodboard"> | string
    jobId?: StringNullableFilter<"Moodboard"> | string | null
    isClientVisible?: BoolFilter<"Moodboard"> | boolean
    clientLastViewedAt?: DateTimeNullableFilter<"Moodboard"> | Date | string | null
    createdAt?: DateTimeFilter<"Moodboard"> | Date | string
    updatedAt?: DateTimeFilter<"Moodboard"> | Date | string
  }

  export type ClientCreateWithoutContactsInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedClientsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedClientsInput
    owner: UserCreateNestedOneWithoutOwnedClientsInput
    leads?: LeadCreateNestedManyWithoutClientInput
    deals?: DealCreateNestedManyWithoutClientInput
    rooms?: RoomCreateNestedManyWithoutClientInput
    jobs?: JobCreateNestedManyWithoutClientInput
    activities?: ActivityCreateNestedManyWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    appointments?: AppointmentCreateNestedManyWithoutClientInput
    moodboards?: MoodboardCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutContactsInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownerId: string
    leads?: LeadUncheckedCreateNestedManyWithoutClientInput
    deals?: DealUncheckedCreateNestedManyWithoutClientInput
    rooms?: RoomUncheckedCreateNestedManyWithoutClientInput
    jobs?: JobUncheckedCreateNestedManyWithoutClientInput
    activities?: ActivityUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClientInput
    moodboards?: MoodboardUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutContactsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutContactsInput, ClientUncheckedCreateWithoutContactsInput>
  }

  export type ActivityCreateWithoutContactInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    description?: string | null
    direction?: $Enums.Direction | null
    duration?: number | null
    outcome?: string | null
    emailMessageId?: string | null
    callRecordingUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutActivitiesInput
    client?: ClientCreateNestedOneWithoutActivitiesInput
    lead?: LeadCreateNestedOneWithoutActivitiesInput
    deal?: DealCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutContactInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    description?: string | null
    direction?: $Enums.Direction | null
    duration?: number | null
    outcome?: string | null
    userId: string
    clientId?: string | null
    leadId?: string | null
    dealId?: string | null
    emailMessageId?: string | null
    callRecordingUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type ActivityCreateOrConnectWithoutContactInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput>
  }

  export type ActivityCreateManyContactInputEnvelope = {
    data: ActivityCreateManyContactInput | ActivityCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutContactsInput = {
    update: XOR<ClientUpdateWithoutContactsInput, ClientUncheckedUpdateWithoutContactsInput>
    create: XOR<ClientCreateWithoutContactsInput, ClientUncheckedCreateWithoutContactsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutContactsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutContactsInput, ClientUncheckedUpdateWithoutContactsInput>
  }

  export type ClientUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedClientsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedClientsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedClientsNestedInput
    leads?: LeadUpdateManyWithoutClientNestedInput
    deals?: DealUpdateManyWithoutClientNestedInput
    rooms?: RoomUpdateManyWithoutClientNestedInput
    jobs?: JobUpdateManyWithoutClientNestedInput
    activities?: ActivityUpdateManyWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUpdateManyWithoutClientNestedInput
    moodboards?: MoodboardUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    leads?: LeadUncheckedUpdateManyWithoutClientNestedInput
    deals?: DealUncheckedUpdateManyWithoutClientNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutClientNestedInput
    jobs?: JobUncheckedUpdateManyWithoutClientNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClientNestedInput
    moodboards?: MoodboardUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ActivityUpsertWithWhereUniqueWithoutContactInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutContactInput, ActivityUncheckedUpdateWithoutContactInput>
    create: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutContactInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutContactInput, ActivityUncheckedUpdateWithoutContactInput>
  }

  export type ActivityUpdateManyWithWhereWithoutContactInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutContactInput>
  }

  export type ClientCreateWithoutLeadsInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedClientsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedClientsInput
    owner: UserCreateNestedOneWithoutOwnedClientsInput
    contacts?: ContactCreateNestedManyWithoutClientInput
    deals?: DealCreateNestedManyWithoutClientInput
    rooms?: RoomCreateNestedManyWithoutClientInput
    jobs?: JobCreateNestedManyWithoutClientInput
    activities?: ActivityCreateNestedManyWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    appointments?: AppointmentCreateNestedManyWithoutClientInput
    moodboards?: MoodboardCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutLeadsInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownerId: string
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    deals?: DealUncheckedCreateNestedManyWithoutClientInput
    rooms?: RoomUncheckedCreateNestedManyWithoutClientInput
    jobs?: JobUncheckedCreateNestedManyWithoutClientInput
    activities?: ActivityUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClientInput
    moodboards?: MoodboardUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutLeadsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutLeadsInput, ClientUncheckedCreateWithoutLeadsInput>
  }

  export type UserCreateWithoutOwnedLeadsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatedByInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionCreateNestedManyWithoutDesignerInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentCreateNestedManyWithoutAuthorInput
    snagReports?: SnagCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateWithoutOwnedLeadsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientUncheckedCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutDesignerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientUncheckedCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobUncheckedCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput
    snagReports?: SnagUncheckedCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogUncheckedCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserCreateOrConnectWithoutOwnedLeadsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedLeadsInput, UserUncheckedCreateWithoutOwnedLeadsInput>
  }

  export type DealCreateWithoutLeadInput = {
    id?: string
    title: string
    description?: string | null
    value: Decimal | DecimalJsLike | number | string
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    stage: PipelineStageCreateNestedOneWithoutDealsInput
    client: ClientCreateNestedOneWithoutDealsInput
    owner: UserCreateNestedOneWithoutOwnedDealsInput
    job?: JobCreateNestedOneWithoutDealInput
    activities?: ActivityCreateNestedManyWithoutDealInput
    tasks?: TaskCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutLeadInput = {
    id?: string
    title: string
    description?: string | null
    value: Decimal | DecimalJsLike | number | string
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    stageId: string
    clientId: string
    ownerId: string
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutDealInput
    tasks?: TaskUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutLeadInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutLeadInput, DealUncheckedCreateWithoutLeadInput>
  }

  export type ActivityCreateWithoutLeadInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    description?: string | null
    direction?: $Enums.Direction | null
    duration?: number | null
    outcome?: string | null
    emailMessageId?: string | null
    callRecordingUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutActivitiesInput
    client?: ClientCreateNestedOneWithoutActivitiesInput
    contact?: ContactCreateNestedOneWithoutActivitiesInput
    deal?: DealCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutLeadInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    description?: string | null
    direction?: $Enums.Direction | null
    duration?: number | null
    outcome?: string | null
    userId: string
    clientId?: string | null
    contactId?: string | null
    dealId?: string | null
    emailMessageId?: string | null
    callRecordingUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type ActivityCreateOrConnectWithoutLeadInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutLeadInput, ActivityUncheckedCreateWithoutLeadInput>
  }

  export type ActivityCreateManyLeadInputEnvelope = {
    data: ActivityCreateManyLeadInput | ActivityCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutLeadInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    clientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignee: UserCreateNestedOneWithoutAssignedTasksInput
    createdBy: UserCreateNestedOneWithoutCreatedTasksInput
    deal?: DealCreateNestedOneWithoutTasksInput
    job?: JobCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutLeadInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    assigneeId: string
    createdById: string
    clientId?: string | null
    dealId?: string | null
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutLeadInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutLeadInput, TaskUncheckedCreateWithoutLeadInput>
  }

  export type TaskCreateManyLeadInputEnvelope = {
    data: TaskCreateManyLeadInput | TaskCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutLeadsInput = {
    update: XOR<ClientUpdateWithoutLeadsInput, ClientUncheckedUpdateWithoutLeadsInput>
    create: XOR<ClientCreateWithoutLeadsInput, ClientUncheckedCreateWithoutLeadsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutLeadsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutLeadsInput, ClientUncheckedUpdateWithoutLeadsInput>
  }

  export type ClientUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedClientsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedClientsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedClientsNestedInput
    contacts?: ContactUpdateManyWithoutClientNestedInput
    deals?: DealUpdateManyWithoutClientNestedInput
    rooms?: RoomUpdateManyWithoutClientNestedInput
    jobs?: JobUpdateManyWithoutClientNestedInput
    activities?: ActivityUpdateManyWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUpdateManyWithoutClientNestedInput
    moodboards?: MoodboardUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    deals?: DealUncheckedUpdateManyWithoutClientNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutClientNestedInput
    jobs?: JobUncheckedUpdateManyWithoutClientNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClientNestedInput
    moodboards?: MoodboardUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserUpsertWithoutOwnedLeadsInput = {
    update: XOR<UserUpdateWithoutOwnedLeadsInput, UserUncheckedUpdateWithoutOwnedLeadsInput>
    create: XOR<UserCreateWithoutOwnedLeadsInput, UserUncheckedCreateWithoutOwnedLeadsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedLeadsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedLeadsInput, UserUncheckedUpdateWithoutOwnedLeadsInput>
  }

  export type UserUpdateWithoutOwnedLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUncheckedUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUncheckedUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUncheckedUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUncheckedUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUncheckedUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type DealUpsertWithoutLeadInput = {
    update: XOR<DealUpdateWithoutLeadInput, DealUncheckedUpdateWithoutLeadInput>
    create: XOR<DealCreateWithoutLeadInput, DealUncheckedCreateWithoutLeadInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutLeadInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutLeadInput, DealUncheckedUpdateWithoutLeadInput>
  }

  export type DealUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: PipelineStageUpdateOneRequiredWithoutDealsNestedInput
    client?: ClientUpdateOneRequiredWithoutDealsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedDealsNestedInput
    job?: JobUpdateOneWithoutDealNestedInput
    activities?: ActivityUpdateManyWithoutDealNestedInput
    tasks?: TaskUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stageId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutDealNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
  }

  export type ActivityUpsertWithWhereUniqueWithoutLeadInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutLeadInput, ActivityUncheckedUpdateWithoutLeadInput>
    create: XOR<ActivityCreateWithoutLeadInput, ActivityUncheckedCreateWithoutLeadInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutLeadInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutLeadInput, ActivityUncheckedUpdateWithoutLeadInput>
  }

  export type ActivityUpdateManyWithWhereWithoutLeadInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutLeadInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutLeadInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutLeadInput, TaskUncheckedUpdateWithoutLeadInput>
    create: XOR<TaskCreateWithoutLeadInput, TaskUncheckedCreateWithoutLeadInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutLeadInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutLeadInput, TaskUncheckedUpdateWithoutLeadInput>
  }

  export type TaskUpdateManyWithWhereWithoutLeadInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutLeadInput>
  }

  export type PipelineStageCreateWithoutDealsInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    probability?: number
    isClosedWon?: boolean
    isClosedLost?: boolean
    autoTasks?: JsonNullValueInput | InputJsonValue
    autoEmails?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PipelineStageUncheckedCreateWithoutDealsInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    probability?: number
    isClosedWon?: boolean
    isClosedLost?: boolean
    autoTasks?: JsonNullValueInput | InputJsonValue
    autoEmails?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PipelineStageCreateOrConnectWithoutDealsInput = {
    where: PipelineStageWhereUniqueInput
    create: XOR<PipelineStageCreateWithoutDealsInput, PipelineStageUncheckedCreateWithoutDealsInput>
  }

  export type ClientCreateWithoutDealsInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedClientsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedClientsInput
    owner: UserCreateNestedOneWithoutOwnedClientsInput
    contacts?: ContactCreateNestedManyWithoutClientInput
    leads?: LeadCreateNestedManyWithoutClientInput
    rooms?: RoomCreateNestedManyWithoutClientInput
    jobs?: JobCreateNestedManyWithoutClientInput
    activities?: ActivityCreateNestedManyWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    appointments?: AppointmentCreateNestedManyWithoutClientInput
    moodboards?: MoodboardCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutDealsInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownerId: string
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    leads?: LeadUncheckedCreateNestedManyWithoutClientInput
    rooms?: RoomUncheckedCreateNestedManyWithoutClientInput
    jobs?: JobUncheckedCreateNestedManyWithoutClientInput
    activities?: ActivityUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClientInput
    moodboards?: MoodboardUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutDealsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutDealsInput, ClientUncheckedCreateWithoutDealsInput>
  }

  export type UserCreateWithoutOwnedDealsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatedByInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionCreateNestedManyWithoutDesignerInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentCreateNestedManyWithoutAuthorInput
    snagReports?: SnagCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateWithoutOwnedDealsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutDesignerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientUncheckedCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobUncheckedCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput
    snagReports?: SnagUncheckedCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogUncheckedCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserCreateOrConnectWithoutOwnedDealsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedDealsInput, UserUncheckedCreateWithoutOwnedDealsInput>
  }

  export type LeadCreateWithoutDealInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    client: ClientCreateNestedOneWithoutLeadsInput
    owner: UserCreateNestedOneWithoutOwnedLeadsInput
    activities?: ActivityCreateNestedManyWithoutLeadInput
    tasks?: TaskCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutDealInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    clientId: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutLeadInput
    tasks?: TaskUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutDealInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutDealInput, LeadUncheckedCreateWithoutDealInput>
  }

  export type JobCreateWithoutDealInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutJobsInput
    room: RoomCreateNestedOneWithoutJobsInput
    installerCompany?: InstallerCompanyCreateNestedOneWithoutJobsInput
    designer?: UserCreateNestedOneWithoutDesignerJobsInput
    tasks?: TaskCreateNestedManyWithoutJobInput
    appointments?: AppointmentCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionCreateNestedManyWithoutJobInput
    snags?: SnagCreateNestedManyWithoutJobInput
    documents?: DocumentCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemCreateNestedManyWithoutJobInput
    moodboards?: MoodboardCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutDealInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    clientId: string
    roomId: string
    dealId?: string | null
    installerCompanyId?: string | null
    designerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutJobInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutJobInput
    snags?: SnagUncheckedCreateNestedManyWithoutJobInput
    documents?: DocumentUncheckedCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemUncheckedCreateNestedManyWithoutJobInput
    moodboards?: MoodboardUncheckedCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutDealInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutDealInput, JobUncheckedCreateWithoutDealInput>
  }

  export type ActivityCreateWithoutDealInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    description?: string | null
    direction?: $Enums.Direction | null
    duration?: number | null
    outcome?: string | null
    emailMessageId?: string | null
    callRecordingUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutActivitiesInput
    client?: ClientCreateNestedOneWithoutActivitiesInput
    contact?: ContactCreateNestedOneWithoutActivitiesInput
    lead?: LeadCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutDealInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    description?: string | null
    direction?: $Enums.Direction | null
    duration?: number | null
    outcome?: string | null
    userId: string
    clientId?: string | null
    contactId?: string | null
    leadId?: string | null
    emailMessageId?: string | null
    callRecordingUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type ActivityCreateOrConnectWithoutDealInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutDealInput, ActivityUncheckedCreateWithoutDealInput>
  }

  export type ActivityCreateManyDealInputEnvelope = {
    data: ActivityCreateManyDealInput | ActivityCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutDealInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    clientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignee: UserCreateNestedOneWithoutAssignedTasksInput
    createdBy: UserCreateNestedOneWithoutCreatedTasksInput
    lead?: LeadCreateNestedOneWithoutTasksInput
    job?: JobCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutDealInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    assigneeId: string
    createdById: string
    clientId?: string | null
    leadId?: string | null
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutDealInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutDealInput, TaskUncheckedCreateWithoutDealInput>
  }

  export type TaskCreateManyDealInputEnvelope = {
    data: TaskCreateManyDealInput | TaskCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutDealInput = {
    id?: string
    filename: string
    originalFilename: string
    mimeType: string
    fileSize: number
    storageUrl: string
    category: $Enums.DocumentCategory
    description?: string | null
    isPublic?: boolean
    virusScanStatus?: $Enums.VirusScanStatus
    virusScanResult?: string | null
    createdAt?: Date | string
    client?: ClientCreateNestedOneWithoutDocumentsInput
    job?: JobCreateNestedOneWithoutDocumentsInput
    uploadedBy: UserCreateNestedOneWithoutUploadedDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutDealInput = {
    id?: string
    filename: string
    originalFilename: string
    mimeType: string
    fileSize: number
    storageUrl: string
    category: $Enums.DocumentCategory
    description?: string | null
    isPublic?: boolean
    virusScanStatus?: $Enums.VirusScanStatus
    virusScanResult?: string | null
    clientId?: string | null
    jobId?: string | null
    createdAt?: Date | string
    uploadedById: string
  }

  export type DocumentCreateOrConnectWithoutDealInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput>
  }

  export type DocumentCreateManyDealInputEnvelope = {
    data: DocumentCreateManyDealInput | DocumentCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type PipelineStageUpsertWithoutDealsInput = {
    update: XOR<PipelineStageUpdateWithoutDealsInput, PipelineStageUncheckedUpdateWithoutDealsInput>
    create: XOR<PipelineStageCreateWithoutDealsInput, PipelineStageUncheckedCreateWithoutDealsInput>
    where?: PipelineStageWhereInput
  }

  export type PipelineStageUpdateToOneWithWhereWithoutDealsInput = {
    where?: PipelineStageWhereInput
    data: XOR<PipelineStageUpdateWithoutDealsInput, PipelineStageUncheckedUpdateWithoutDealsInput>
  }

  export type PipelineStageUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    isClosedWon?: BoolFieldUpdateOperationsInput | boolean
    isClosedLost?: BoolFieldUpdateOperationsInput | boolean
    autoTasks?: JsonNullValueInput | InputJsonValue
    autoEmails?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineStageUncheckedUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    isClosedWon?: BoolFieldUpdateOperationsInput | boolean
    isClosedLost?: BoolFieldUpdateOperationsInput | boolean
    autoTasks?: JsonNullValueInput | InputJsonValue
    autoEmails?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUpsertWithoutDealsInput = {
    update: XOR<ClientUpdateWithoutDealsInput, ClientUncheckedUpdateWithoutDealsInput>
    create: XOR<ClientCreateWithoutDealsInput, ClientUncheckedCreateWithoutDealsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutDealsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutDealsInput, ClientUncheckedUpdateWithoutDealsInput>
  }

  export type ClientUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedClientsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedClientsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedClientsNestedInput
    contacts?: ContactUpdateManyWithoutClientNestedInput
    leads?: LeadUpdateManyWithoutClientNestedInput
    rooms?: RoomUpdateManyWithoutClientNestedInput
    jobs?: JobUpdateManyWithoutClientNestedInput
    activities?: ActivityUpdateManyWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUpdateManyWithoutClientNestedInput
    moodboards?: MoodboardUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    leads?: LeadUncheckedUpdateManyWithoutClientNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutClientNestedInput
    jobs?: JobUncheckedUpdateManyWithoutClientNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClientNestedInput
    moodboards?: MoodboardUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserUpsertWithoutOwnedDealsInput = {
    update: XOR<UserUpdateWithoutOwnedDealsInput, UserUncheckedUpdateWithoutOwnedDealsInput>
    create: XOR<UserCreateWithoutOwnedDealsInput, UserUncheckedCreateWithoutOwnedDealsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedDealsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedDealsInput, UserUncheckedUpdateWithoutOwnedDealsInput>
  }

  export type UserUpdateWithoutOwnedDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUncheckedUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUncheckedUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUncheckedUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUncheckedUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type LeadUpsertWithoutDealInput = {
    update: XOR<LeadUpdateWithoutDealInput, LeadUncheckedUpdateWithoutDealInput>
    create: XOR<LeadCreateWithoutDealInput, LeadUncheckedCreateWithoutDealInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutDealInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutDealInput, LeadUncheckedUpdateWithoutDealInput>
  }

  export type LeadUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutLeadsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedLeadsNestedInput
    activities?: ActivityUpdateManyWithoutLeadNestedInput
    tasks?: TaskUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutLeadNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type JobUpsertWithoutDealInput = {
    update: XOR<JobUpdateWithoutDealInput, JobUncheckedUpdateWithoutDealInput>
    create: XOR<JobCreateWithoutDealInput, JobUncheckedCreateWithoutDealInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutDealInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutDealInput, JobUncheckedUpdateWithoutDealInput>
  }

  export type JobUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutJobsNestedInput
    room?: RoomUpdateOneRequiredWithoutJobsNestedInput
    installerCompany?: InstallerCompanyUpdateOneWithoutJobsNestedInput
    designer?: UserUpdateOneWithoutDesignerJobsNestedInput
    tasks?: TaskUpdateManyWithoutJobNestedInput
    appointments?: AppointmentUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUpdateManyWithoutJobNestedInput
    snags?: SnagUpdateManyWithoutJobNestedInput
    documents?: DocumentUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    installerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    designerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutJobNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutJobNestedInput
    snags?: SnagUncheckedUpdateManyWithoutJobNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUncheckedUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUncheckedUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUncheckedUpdateManyWithoutJobNestedInput
  }

  export type ActivityUpsertWithWhereUniqueWithoutDealInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutDealInput, ActivityUncheckedUpdateWithoutDealInput>
    create: XOR<ActivityCreateWithoutDealInput, ActivityUncheckedCreateWithoutDealInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutDealInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutDealInput, ActivityUncheckedUpdateWithoutDealInput>
  }

  export type ActivityUpdateManyWithWhereWithoutDealInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutDealInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutDealInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutDealInput, TaskUncheckedUpdateWithoutDealInput>
    create: XOR<TaskCreateWithoutDealInput, TaskUncheckedCreateWithoutDealInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutDealInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutDealInput, TaskUncheckedUpdateWithoutDealInput>
  }

  export type TaskUpdateManyWithWhereWithoutDealInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutDealInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutDealInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutDealInput, DocumentUncheckedUpdateWithoutDealInput>
    create: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutDealInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutDealInput, DocumentUncheckedUpdateWithoutDealInput>
  }

  export type DocumentUpdateManyWithWhereWithoutDealInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutDealInput>
  }

  export type DealCreateWithoutStageInput = {
    id?: string
    title: string
    description?: string | null
    value: Decimal | DecimalJsLike | number | string
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    client: ClientCreateNestedOneWithoutDealsInput
    owner: UserCreateNestedOneWithoutOwnedDealsInput
    lead?: LeadCreateNestedOneWithoutDealInput
    job?: JobCreateNestedOneWithoutDealInput
    activities?: ActivityCreateNestedManyWithoutDealInput
    tasks?: TaskCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutStageInput = {
    id?: string
    title: string
    description?: string | null
    value: Decimal | DecimalJsLike | number | string
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    clientId: string
    ownerId: string
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    lead?: LeadUncheckedCreateNestedOneWithoutDealInput
    activities?: ActivityUncheckedCreateNestedManyWithoutDealInput
    tasks?: TaskUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutStageInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutStageInput, DealUncheckedCreateWithoutStageInput>
  }

  export type DealCreateManyStageInputEnvelope = {
    data: DealCreateManyStageInput | DealCreateManyStageInput[]
    skipDuplicates?: boolean
  }

  export type DealUpsertWithWhereUniqueWithoutStageInput = {
    where: DealWhereUniqueInput
    update: XOR<DealUpdateWithoutStageInput, DealUncheckedUpdateWithoutStageInput>
    create: XOR<DealCreateWithoutStageInput, DealUncheckedCreateWithoutStageInput>
  }

  export type DealUpdateWithWhereUniqueWithoutStageInput = {
    where: DealWhereUniqueInput
    data: XOR<DealUpdateWithoutStageInput, DealUncheckedUpdateWithoutStageInput>
  }

  export type DealUpdateManyWithWhereWithoutStageInput = {
    where: DealScalarWhereInput
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyWithoutStageInput>
  }

  export type UserCreateWithoutActivitiesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionCreateNestedManyWithoutDesignerInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentCreateNestedManyWithoutAuthorInput
    snagReports?: SnagCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateWithoutActivitiesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutDesignerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientUncheckedCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobUncheckedCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput
    snagReports?: SnagUncheckedCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogUncheckedCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserCreateOrConnectWithoutActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
  }

  export type ClientCreateWithoutActivitiesInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedClientsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedClientsInput
    owner: UserCreateNestedOneWithoutOwnedClientsInput
    contacts?: ContactCreateNestedManyWithoutClientInput
    leads?: LeadCreateNestedManyWithoutClientInput
    deals?: DealCreateNestedManyWithoutClientInput
    rooms?: RoomCreateNestedManyWithoutClientInput
    jobs?: JobCreateNestedManyWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    appointments?: AppointmentCreateNestedManyWithoutClientInput
    moodboards?: MoodboardCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutActivitiesInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownerId: string
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    leads?: LeadUncheckedCreateNestedManyWithoutClientInput
    deals?: DealUncheckedCreateNestedManyWithoutClientInput
    rooms?: RoomUncheckedCreateNestedManyWithoutClientInput
    jobs?: JobUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClientInput
    moodboards?: MoodboardUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutActivitiesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutActivitiesInput, ClientUncheckedCreateWithoutActivitiesInput>
  }

  export type ContactCreateWithoutActivitiesInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    jobTitle?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    client: ClientCreateNestedOneWithoutContactsInput
  }

  export type ContactUncheckedCreateWithoutActivitiesInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    jobTitle?: string | null
    isPrimary?: boolean
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
  }

  export type ContactCreateOrConnectWithoutActivitiesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutActivitiesInput, ContactUncheckedCreateWithoutActivitiesInput>
  }

  export type LeadCreateWithoutActivitiesInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    client: ClientCreateNestedOneWithoutLeadsInput
    owner: UserCreateNestedOneWithoutOwnedLeadsInput
    deal?: DealCreateNestedOneWithoutLeadInput
    tasks?: TaskCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutActivitiesInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    clientId: string
    ownerId: string
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    tasks?: TaskUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutActivitiesInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutActivitiesInput, LeadUncheckedCreateWithoutActivitiesInput>
  }

  export type DealCreateWithoutActivitiesInput = {
    id?: string
    title: string
    description?: string | null
    value: Decimal | DecimalJsLike | number | string
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    stage: PipelineStageCreateNestedOneWithoutDealsInput
    client: ClientCreateNestedOneWithoutDealsInput
    owner: UserCreateNestedOneWithoutOwnedDealsInput
    lead?: LeadCreateNestedOneWithoutDealInput
    job?: JobCreateNestedOneWithoutDealInput
    tasks?: TaskCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutActivitiesInput = {
    id?: string
    title: string
    description?: string | null
    value: Decimal | DecimalJsLike | number | string
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    stageId: string
    clientId: string
    ownerId: string
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    lead?: LeadUncheckedCreateNestedOneWithoutDealInput
    tasks?: TaskUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutActivitiesInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutActivitiesInput, DealUncheckedCreateWithoutActivitiesInput>
  }

  export type UserUpsertWithoutActivitiesInput = {
    update: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUncheckedUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUncheckedUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUncheckedUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUncheckedUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type ClientUpsertWithoutActivitiesInput = {
    update: XOR<ClientUpdateWithoutActivitiesInput, ClientUncheckedUpdateWithoutActivitiesInput>
    create: XOR<ClientCreateWithoutActivitiesInput, ClientUncheckedCreateWithoutActivitiesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutActivitiesInput, ClientUncheckedUpdateWithoutActivitiesInput>
  }

  export type ClientUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedClientsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedClientsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedClientsNestedInput
    contacts?: ContactUpdateManyWithoutClientNestedInput
    leads?: LeadUpdateManyWithoutClientNestedInput
    deals?: DealUpdateManyWithoutClientNestedInput
    rooms?: RoomUpdateManyWithoutClientNestedInput
    jobs?: JobUpdateManyWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUpdateManyWithoutClientNestedInput
    moodboards?: MoodboardUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    leads?: LeadUncheckedUpdateManyWithoutClientNestedInput
    deals?: DealUncheckedUpdateManyWithoutClientNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutClientNestedInput
    jobs?: JobUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClientNestedInput
    moodboards?: MoodboardUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ContactUpsertWithoutActivitiesInput = {
    update: XOR<ContactUpdateWithoutActivitiesInput, ContactUncheckedUpdateWithoutActivitiesInput>
    create: XOR<ContactCreateWithoutActivitiesInput, ContactUncheckedCreateWithoutActivitiesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutActivitiesInput, ContactUncheckedUpdateWithoutActivitiesInput>
  }

  export type ContactUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeadUpsertWithoutActivitiesInput = {
    update: XOR<LeadUpdateWithoutActivitiesInput, LeadUncheckedUpdateWithoutActivitiesInput>
    create: XOR<LeadCreateWithoutActivitiesInput, LeadUncheckedCreateWithoutActivitiesInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutActivitiesInput, LeadUncheckedUpdateWithoutActivitiesInput>
  }

  export type LeadUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutLeadsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedLeadsNestedInput
    deal?: DealUpdateOneWithoutLeadNestedInput
    tasks?: TaskUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: TaskUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type DealUpsertWithoutActivitiesInput = {
    update: XOR<DealUpdateWithoutActivitiesInput, DealUncheckedUpdateWithoutActivitiesInput>
    create: XOR<DealCreateWithoutActivitiesInput, DealUncheckedCreateWithoutActivitiesInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutActivitiesInput, DealUncheckedUpdateWithoutActivitiesInput>
  }

  export type DealUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: PipelineStageUpdateOneRequiredWithoutDealsNestedInput
    client?: ClientUpdateOneRequiredWithoutDealsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedDealsNestedInput
    lead?: LeadUpdateOneWithoutDealNestedInput
    job?: JobUpdateOneWithoutDealNestedInput
    tasks?: TaskUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stageId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    lead?: LeadUncheckedUpdateOneWithoutDealNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
  }

  export type UserCreateWithoutAssignedTasksInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealCreateNestedManyWithoutOwnerInput
    createdTasks?: TaskCreateNestedManyWithoutCreatedByInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionCreateNestedManyWithoutDesignerInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentCreateNestedManyWithoutAuthorInput
    snagReports?: SnagCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateWithoutAssignedTasksInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealUncheckedCreateNestedManyWithoutOwnerInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutDesignerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientUncheckedCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobUncheckedCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput
    snagReports?: SnagUncheckedCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogUncheckedCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserCreateOrConnectWithoutAssignedTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
  }

  export type UserCreateWithoutCreatedTasksInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionCreateNestedManyWithoutDesignerInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentCreateNestedManyWithoutAuthorInput
    snagReports?: SnagCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateWithoutCreatedTasksInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutDesignerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientUncheckedCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobUncheckedCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput
    snagReports?: SnagUncheckedCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogUncheckedCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserCreateOrConnectWithoutCreatedTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTasksInput, UserUncheckedCreateWithoutCreatedTasksInput>
  }

  export type LeadCreateWithoutTasksInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    client: ClientCreateNestedOneWithoutLeadsInput
    owner: UserCreateNestedOneWithoutOwnedLeadsInput
    deal?: DealCreateNestedOneWithoutLeadInput
    activities?: ActivityCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutTasksInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    clientId: string
    ownerId: string
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutTasksInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutTasksInput, LeadUncheckedCreateWithoutTasksInput>
  }

  export type DealCreateWithoutTasksInput = {
    id?: string
    title: string
    description?: string | null
    value: Decimal | DecimalJsLike | number | string
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    stage: PipelineStageCreateNestedOneWithoutDealsInput
    client: ClientCreateNestedOneWithoutDealsInput
    owner: UserCreateNestedOneWithoutOwnedDealsInput
    lead?: LeadCreateNestedOneWithoutDealInput
    job?: JobCreateNestedOneWithoutDealInput
    activities?: ActivityCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutTasksInput = {
    id?: string
    title: string
    description?: string | null
    value: Decimal | DecimalJsLike | number | string
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    stageId: string
    clientId: string
    ownerId: string
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    lead?: LeadUncheckedCreateNestedOneWithoutDealInput
    activities?: ActivityUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutTasksInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutTasksInput, DealUncheckedCreateWithoutTasksInput>
  }

  export type JobCreateWithoutTasksInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutJobsInput
    room: RoomCreateNestedOneWithoutJobsInput
    deal?: DealCreateNestedOneWithoutJobInput
    installerCompany?: InstallerCompanyCreateNestedOneWithoutJobsInput
    designer?: UserCreateNestedOneWithoutDesignerJobsInput
    appointments?: AppointmentCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionCreateNestedManyWithoutJobInput
    snags?: SnagCreateNestedManyWithoutJobInput
    documents?: DocumentCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemCreateNestedManyWithoutJobInput
    moodboards?: MoodboardCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutTasksInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    clientId: string
    roomId: string
    dealId?: string | null
    installerCompanyId?: string | null
    designerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deal?: DealUncheckedCreateNestedOneWithoutJobInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutJobInput
    snags?: SnagUncheckedCreateNestedManyWithoutJobInput
    documents?: DocumentUncheckedCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemUncheckedCreateNestedManyWithoutJobInput
    moodboards?: MoodboardUncheckedCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutTasksInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutTasksInput, JobUncheckedCreateWithoutTasksInput>
  }

  export type UserUpsertWithoutAssignedTasksInput = {
    update: XOR<UserUpdateWithoutAssignedTasksInput, UserUncheckedUpdateWithoutAssignedTasksInput>
    create: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedTasksInput, UserUncheckedUpdateWithoutAssignedTasksInput>
  }

  export type UserUpdateWithoutAssignedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUpdateManyWithoutOwnerNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUncheckedUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUncheckedUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUncheckedUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUncheckedUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUpsertWithoutCreatedTasksInput = {
    update: XOR<UserUpdateWithoutCreatedTasksInput, UserUncheckedUpdateWithoutCreatedTasksInput>
    create: XOR<UserCreateWithoutCreatedTasksInput, UserUncheckedCreateWithoutCreatedTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedTasksInput, UserUncheckedUpdateWithoutCreatedTasksInput>
  }

  export type UserUpdateWithoutCreatedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUncheckedUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUncheckedUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUncheckedUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUncheckedUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type LeadUpsertWithoutTasksInput = {
    update: XOR<LeadUpdateWithoutTasksInput, LeadUncheckedUpdateWithoutTasksInput>
    create: XOR<LeadCreateWithoutTasksInput, LeadUncheckedCreateWithoutTasksInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutTasksInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutTasksInput, LeadUncheckedUpdateWithoutTasksInput>
  }

  export type LeadUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutLeadsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedLeadsNestedInput
    deal?: DealUpdateOneWithoutLeadNestedInput
    activities?: ActivityUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type DealUpsertWithoutTasksInput = {
    update: XOR<DealUpdateWithoutTasksInput, DealUncheckedUpdateWithoutTasksInput>
    create: XOR<DealCreateWithoutTasksInput, DealUncheckedCreateWithoutTasksInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutTasksInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutTasksInput, DealUncheckedUpdateWithoutTasksInput>
  }

  export type DealUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: PipelineStageUpdateOneRequiredWithoutDealsNestedInput
    client?: ClientUpdateOneRequiredWithoutDealsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedDealsNestedInput
    lead?: LeadUpdateOneWithoutDealNestedInput
    job?: JobUpdateOneWithoutDealNestedInput
    activities?: ActivityUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stageId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    lead?: LeadUncheckedUpdateOneWithoutDealNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
  }

  export type JobUpsertWithoutTasksInput = {
    update: XOR<JobUpdateWithoutTasksInput, JobUncheckedUpdateWithoutTasksInput>
    create: XOR<JobCreateWithoutTasksInput, JobUncheckedCreateWithoutTasksInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutTasksInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutTasksInput, JobUncheckedUpdateWithoutTasksInput>
  }

  export type JobUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutJobsNestedInput
    room?: RoomUpdateOneRequiredWithoutJobsNestedInput
    deal?: DealUpdateOneWithoutJobNestedInput
    installerCompany?: InstallerCompanyUpdateOneWithoutJobsNestedInput
    designer?: UserUpdateOneWithoutDesignerJobsNestedInput
    appointments?: AppointmentUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUpdateManyWithoutJobNestedInput
    snags?: SnagUpdateManyWithoutJobNestedInput
    documents?: DocumentUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    installerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    designerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUncheckedUpdateOneWithoutJobNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutJobNestedInput
    snags?: SnagUncheckedUpdateManyWithoutJobNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUncheckedUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUncheckedUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUncheckedUpdateManyWithoutJobNestedInput
  }

  export type UserCreateWithoutAppointmentsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatedByInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionCreateNestedManyWithoutDesignerInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentCreateNestedManyWithoutAuthorInput
    snagReports?: SnagCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutDesignerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientUncheckedCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobUncheckedCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput
    snagReports?: SnagUncheckedCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogUncheckedCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserCreateOrConnectWithoutAppointmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
  }

  export type ClientCreateWithoutAppointmentsInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedClientsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedClientsInput
    owner: UserCreateNestedOneWithoutOwnedClientsInput
    contacts?: ContactCreateNestedManyWithoutClientInput
    leads?: LeadCreateNestedManyWithoutClientInput
    deals?: DealCreateNestedManyWithoutClientInput
    rooms?: RoomCreateNestedManyWithoutClientInput
    jobs?: JobCreateNestedManyWithoutClientInput
    activities?: ActivityCreateNestedManyWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    moodboards?: MoodboardCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownerId: string
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    leads?: LeadUncheckedCreateNestedManyWithoutClientInput
    deals?: DealUncheckedCreateNestedManyWithoutClientInput
    rooms?: RoomUncheckedCreateNestedManyWithoutClientInput
    jobs?: JobUncheckedCreateNestedManyWithoutClientInput
    activities?: ActivityUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    moodboards?: MoodboardUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutAppointmentsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutAppointmentsInput, ClientUncheckedCreateWithoutAppointmentsInput>
  }

  export type JobCreateWithoutAppointmentsInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutJobsInput
    room: RoomCreateNestedOneWithoutJobsInput
    deal?: DealCreateNestedOneWithoutJobInput
    installerCompany?: InstallerCompanyCreateNestedOneWithoutJobsInput
    designer?: UserCreateNestedOneWithoutDesignerJobsInput
    tasks?: TaskCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionCreateNestedManyWithoutJobInput
    snags?: SnagCreateNestedManyWithoutJobInput
    documents?: DocumentCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemCreateNestedManyWithoutJobInput
    moodboards?: MoodboardCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    clientId: string
    roomId: string
    dealId?: string | null
    installerCompanyId?: string | null
    designerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deal?: DealUncheckedCreateNestedOneWithoutJobInput
    tasks?: TaskUncheckedCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutJobInput
    snags?: SnagUncheckedCreateNestedManyWithoutJobInput
    documents?: DocumentUncheckedCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemUncheckedCreateNestedManyWithoutJobInput
    moodboards?: MoodboardUncheckedCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutAppointmentsInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutAppointmentsInput, JobUncheckedCreateWithoutAppointmentsInput>
  }

  export type UserUpsertWithoutAppointmentsInput = {
    update: XOR<UserUpdateWithoutAppointmentsInput, UserUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAppointmentsInput, UserUncheckedUpdateWithoutAppointmentsInput>
  }

  export type UserUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUncheckedUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUncheckedUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUncheckedUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUncheckedUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type ClientUpsertWithoutAppointmentsInput = {
    update: XOR<ClientUpdateWithoutAppointmentsInput, ClientUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<ClientCreateWithoutAppointmentsInput, ClientUncheckedCreateWithoutAppointmentsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutAppointmentsInput, ClientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ClientUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedClientsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedClientsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedClientsNestedInput
    contacts?: ContactUpdateManyWithoutClientNestedInput
    leads?: LeadUpdateManyWithoutClientNestedInput
    deals?: DealUpdateManyWithoutClientNestedInput
    rooms?: RoomUpdateManyWithoutClientNestedInput
    jobs?: JobUpdateManyWithoutClientNestedInput
    activities?: ActivityUpdateManyWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    moodboards?: MoodboardUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    leads?: LeadUncheckedUpdateManyWithoutClientNestedInput
    deals?: DealUncheckedUpdateManyWithoutClientNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutClientNestedInput
    jobs?: JobUncheckedUpdateManyWithoutClientNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    moodboards?: MoodboardUncheckedUpdateManyWithoutClientNestedInput
  }

  export type JobUpsertWithoutAppointmentsInput = {
    update: XOR<JobUpdateWithoutAppointmentsInput, JobUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<JobCreateWithoutAppointmentsInput, JobUncheckedCreateWithoutAppointmentsInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutAppointmentsInput, JobUncheckedUpdateWithoutAppointmentsInput>
  }

  export type JobUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutJobsNestedInput
    room?: RoomUpdateOneRequiredWithoutJobsNestedInput
    deal?: DealUpdateOneWithoutJobNestedInput
    installerCompany?: InstallerCompanyUpdateOneWithoutJobsNestedInput
    designer?: UserUpdateOneWithoutDesignerJobsNestedInput
    tasks?: TaskUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUpdateManyWithoutJobNestedInput
    snags?: SnagUpdateManyWithoutJobNestedInput
    documents?: DocumentUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    installerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    designerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUncheckedUpdateOneWithoutJobNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutJobNestedInput
    snags?: SnagUncheckedUpdateManyWithoutJobNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUncheckedUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUncheckedUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUncheckedUpdateManyWithoutJobNestedInput
  }

  export type ClientCreateWithoutRoomsInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedClientsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedClientsInput
    owner: UserCreateNestedOneWithoutOwnedClientsInput
    contacts?: ContactCreateNestedManyWithoutClientInput
    leads?: LeadCreateNestedManyWithoutClientInput
    deals?: DealCreateNestedManyWithoutClientInput
    jobs?: JobCreateNestedManyWithoutClientInput
    activities?: ActivityCreateNestedManyWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    appointments?: AppointmentCreateNestedManyWithoutClientInput
    moodboards?: MoodboardCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutRoomsInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownerId: string
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    leads?: LeadUncheckedCreateNestedManyWithoutClientInput
    deals?: DealUncheckedCreateNestedManyWithoutClientInput
    jobs?: JobUncheckedCreateNestedManyWithoutClientInput
    activities?: ActivityUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClientInput
    moodboards?: MoodboardUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutRoomsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutRoomsInput, ClientUncheckedCreateWithoutRoomsInput>
  }

  export type JobCreateWithoutRoomInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutJobsInput
    deal?: DealCreateNestedOneWithoutJobInput
    installerCompany?: InstallerCompanyCreateNestedOneWithoutJobsInput
    designer?: UserCreateNestedOneWithoutDesignerJobsInput
    tasks?: TaskCreateNestedManyWithoutJobInput
    appointments?: AppointmentCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionCreateNestedManyWithoutJobInput
    snags?: SnagCreateNestedManyWithoutJobInput
    documents?: DocumentCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemCreateNestedManyWithoutJobInput
    moodboards?: MoodboardCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutRoomInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    clientId: string
    dealId?: string | null
    installerCompanyId?: string | null
    designerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deal?: DealUncheckedCreateNestedOneWithoutJobInput
    tasks?: TaskUncheckedCreateNestedManyWithoutJobInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutJobInput
    snags?: SnagUncheckedCreateNestedManyWithoutJobInput
    documents?: DocumentUncheckedCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemUncheckedCreateNestedManyWithoutJobInput
    moodboards?: MoodboardUncheckedCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutRoomInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutRoomInput, JobUncheckedCreateWithoutRoomInput>
  }

  export type JobCreateManyRoomInputEnvelope = {
    data: JobCreateManyRoomInput | JobCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutRoomsInput = {
    update: XOR<ClientUpdateWithoutRoomsInput, ClientUncheckedUpdateWithoutRoomsInput>
    create: XOR<ClientCreateWithoutRoomsInput, ClientUncheckedCreateWithoutRoomsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutRoomsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutRoomsInput, ClientUncheckedUpdateWithoutRoomsInput>
  }

  export type ClientUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedClientsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedClientsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedClientsNestedInput
    contacts?: ContactUpdateManyWithoutClientNestedInput
    leads?: LeadUpdateManyWithoutClientNestedInput
    deals?: DealUpdateManyWithoutClientNestedInput
    jobs?: JobUpdateManyWithoutClientNestedInput
    activities?: ActivityUpdateManyWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUpdateManyWithoutClientNestedInput
    moodboards?: MoodboardUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    leads?: LeadUncheckedUpdateManyWithoutClientNestedInput
    deals?: DealUncheckedUpdateManyWithoutClientNestedInput
    jobs?: JobUncheckedUpdateManyWithoutClientNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClientNestedInput
    moodboards?: MoodboardUncheckedUpdateManyWithoutClientNestedInput
  }

  export type JobUpsertWithWhereUniqueWithoutRoomInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutRoomInput, JobUncheckedUpdateWithoutRoomInput>
    create: XOR<JobCreateWithoutRoomInput, JobUncheckedCreateWithoutRoomInput>
  }

  export type JobUpdateWithWhereUniqueWithoutRoomInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutRoomInput, JobUncheckedUpdateWithoutRoomInput>
  }

  export type JobUpdateManyWithWhereWithoutRoomInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutRoomInput>
  }

  export type ClientCreateWithoutJobsInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedClientsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedClientsInput
    owner: UserCreateNestedOneWithoutOwnedClientsInput
    contacts?: ContactCreateNestedManyWithoutClientInput
    leads?: LeadCreateNestedManyWithoutClientInput
    deals?: DealCreateNestedManyWithoutClientInput
    rooms?: RoomCreateNestedManyWithoutClientInput
    activities?: ActivityCreateNestedManyWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    appointments?: AppointmentCreateNestedManyWithoutClientInput
    moodboards?: MoodboardCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutJobsInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownerId: string
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    leads?: LeadUncheckedCreateNestedManyWithoutClientInput
    deals?: DealUncheckedCreateNestedManyWithoutClientInput
    rooms?: RoomUncheckedCreateNestedManyWithoutClientInput
    activities?: ActivityUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClientInput
    moodboards?: MoodboardUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutJobsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutJobsInput, ClientUncheckedCreateWithoutJobsInput>
  }

  export type RoomCreateWithoutJobsInput = {
    id?: string
    name: string
    type: $Enums.RoomType
    length?: number | null
    width?: number | null
    height?: number | null
    currentCondition?: string | null
    accessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutRoomsInput
  }

  export type RoomUncheckedCreateWithoutJobsInput = {
    id?: string
    name: string
    type: $Enums.RoomType
    length?: number | null
    width?: number | null
    height?: number | null
    currentCondition?: string | null
    accessNotes?: string | null
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomCreateOrConnectWithoutJobsInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutJobsInput, RoomUncheckedCreateWithoutJobsInput>
  }

  export type DealCreateWithoutJobInput = {
    id?: string
    title: string
    description?: string | null
    value: Decimal | DecimalJsLike | number | string
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    stage: PipelineStageCreateNestedOneWithoutDealsInput
    client: ClientCreateNestedOneWithoutDealsInput
    owner: UserCreateNestedOneWithoutOwnedDealsInput
    lead?: LeadCreateNestedOneWithoutDealInput
    activities?: ActivityCreateNestedManyWithoutDealInput
    tasks?: TaskCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutJobInput = {
    id?: string
    title: string
    description?: string | null
    value: Decimal | DecimalJsLike | number | string
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    stageId: string
    clientId: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    lead?: LeadUncheckedCreateNestedOneWithoutDealInput
    activities?: ActivityUncheckedCreateNestedManyWithoutDealInput
    tasks?: TaskUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutJobInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutJobInput, DealUncheckedCreateWithoutJobInput>
  }

  export type InstallerCompanyCreateWithoutJobsInput = {
    id?: string
    name: string
    contactEmail: string
    contactPhone: string
    address?: string | null
    insuranceExpiry?: Date | string | null
    dbsExpiry?: Date | string | null
    contractSigned?: boolean
    contractSignedAt?: Date | string | null
    isActive?: boolean
    isSuspended?: boolean
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutInstallerCompaniesInput
    teamMembers?: InstallerTeamMemberCreateNestedManyWithoutCompanyInput
  }

  export type InstallerCompanyUncheckedCreateWithoutJobsInput = {
    id?: string
    name: string
    contactEmail: string
    contactPhone: string
    address?: string | null
    insuranceExpiry?: Date | string | null
    dbsExpiry?: Date | string | null
    contractSigned?: boolean
    contractSignedAt?: Date | string | null
    isActive?: boolean
    isSuspended?: boolean
    suspensionReason?: string | null
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMembers?: InstallerTeamMemberUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type InstallerCompanyCreateOrConnectWithoutJobsInput = {
    where: InstallerCompanyWhereUniqueInput
    create: XOR<InstallerCompanyCreateWithoutJobsInput, InstallerCompanyUncheckedCreateWithoutJobsInput>
  }

  export type UserCreateWithoutDesignerJobsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatedByInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionCreateNestedManyWithoutDesignerInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientCreateNestedManyWithoutUpdatedByInput
    installerCompanies?: InstallerCompanyCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentCreateNestedManyWithoutAuthorInput
    snagReports?: SnagCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateWithoutDesignerJobsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutDesignerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientUncheckedCreateNestedManyWithoutUpdatedByInput
    installerCompanies?: InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput
    snagReports?: SnagUncheckedCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogUncheckedCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserCreateOrConnectWithoutDesignerJobsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDesignerJobsInput, UserUncheckedCreateWithoutDesignerJobsInput>
  }

  export type TaskCreateWithoutJobInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    clientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignee: UserCreateNestedOneWithoutAssignedTasksInput
    createdBy: UserCreateNestedOneWithoutCreatedTasksInput
    lead?: LeadCreateNestedOneWithoutTasksInput
    deal?: DealCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutJobInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    assigneeId: string
    createdById: string
    clientId?: string | null
    leadId?: string | null
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutJobInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutJobInput, TaskUncheckedCreateWithoutJobInput>
  }

  export type TaskCreateManyJobInputEnvelope = {
    data: TaskCreateManyJobInput | TaskCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutJobInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    meetingUrl?: string | null
    status?: $Enums.AppointmentStatus
    outlookEventId?: string | null
    calendarSynced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAppointmentsInput
    client: ClientCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutJobInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    meetingUrl?: string | null
    status?: $Enums.AppointmentStatus
    userId: string
    clientId: string
    outlookEventId?: string | null
    calendarSynced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentCreateOrConnectWithoutJobInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutJobInput, AppointmentUncheckedCreateWithoutJobInput>
  }

  export type AppointmentCreateManyJobInputEnvelope = {
    data: AppointmentCreateManyJobInput | AppointmentCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type JobDayLogCreateWithoutJobInput = {
    id?: string
    date: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    lunchStart?: Date | string | null
    lunchEnd?: Date | string | null
    checkInLatitude?: Decimal | DecimalJsLike | number | string | null
    checkInLongitude?: Decimal | DecimalJsLike | number | string | null
    checkInAddress?: string | null
    workCompleted?: string | null
    materialsUsed?: string | null
    issuesEncountered?: string | null
    startFormData?: NullableJsonNullValueInput | InputJsonValue
    dailyFormData?: NullableJsonNullValueInput | InputJsonValue
    endFormData?: NullableJsonNullValueInput | InputJsonValue
    photos?: JobDayLogCreatephotosInput | string[]
    isCompliant?: boolean
    complianceNotes?: string | null
    syncStatus?: $Enums.SyncStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutJobDayLogsInput
  }

  export type JobDayLogUncheckedCreateWithoutJobInput = {
    id?: string
    date: Date | string
    userId: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    lunchStart?: Date | string | null
    lunchEnd?: Date | string | null
    checkInLatitude?: Decimal | DecimalJsLike | number | string | null
    checkInLongitude?: Decimal | DecimalJsLike | number | string | null
    checkInAddress?: string | null
    workCompleted?: string | null
    materialsUsed?: string | null
    issuesEncountered?: string | null
    startFormData?: NullableJsonNullValueInput | InputJsonValue
    dailyFormData?: NullableJsonNullValueInput | InputJsonValue
    endFormData?: NullableJsonNullValueInput | InputJsonValue
    photos?: JobDayLogCreatephotosInput | string[]
    isCompliant?: boolean
    complianceNotes?: string | null
    syncStatus?: $Enums.SyncStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobDayLogCreateOrConnectWithoutJobInput = {
    where: JobDayLogWhereUniqueInput
    create: XOR<JobDayLogCreateWithoutJobInput, JobDayLogUncheckedCreateWithoutJobInput>
  }

  export type JobDayLogCreateManyJobInputEnvelope = {
    data: JobDayLogCreateManyJobInput | JobDayLogCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type DesignVersionCreateWithoutJobInput = {
    id?: string
    version?: number
    title: string
    description?: string | null
    status?: $Enums.DesignStatus
    renderUrls?: DesignVersionCreaterenderUrlsInput | string[]
    planUrls?: DesignVersionCreateplanUrlsInput | string[]
    specSheetUrl?: string | null
    isClientVisible?: boolean
    clientViewedAt?: Date | string | null
    clientApprovedAt?: Date | string | null
    clientFeedback?: string | null
    isFinal?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    designer: UserCreateNestedOneWithoutDesignVersionsInput
    clashTickets?: DesignClashTicketCreateNestedManyWithoutDesignVersionInput
  }

  export type DesignVersionUncheckedCreateWithoutJobInput = {
    id?: string
    version?: number
    title: string
    description?: string | null
    status?: $Enums.DesignStatus
    renderUrls?: DesignVersionCreaterenderUrlsInput | string[]
    planUrls?: DesignVersionCreateplanUrlsInput | string[]
    specSheetUrl?: string | null
    isClientVisible?: boolean
    clientViewedAt?: Date | string | null
    clientApprovedAt?: Date | string | null
    clientFeedback?: string | null
    designerId: string
    isFinal?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clashTickets?: DesignClashTicketUncheckedCreateNestedManyWithoutDesignVersionInput
  }

  export type DesignVersionCreateOrConnectWithoutJobInput = {
    where: DesignVersionWhereUniqueInput
    create: XOR<DesignVersionCreateWithoutJobInput, DesignVersionUncheckedCreateWithoutJobInput>
  }

  export type DesignVersionCreateManyJobInputEnvelope = {
    data: DesignVersionCreateManyJobInput | DesignVersionCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type SnagCreateWithoutJobInput = {
    id?: string
    title: string
    description: string
    category: $Enums.SnagCategory
    severity?: $Enums.Priority
    status?: $Enums.SnagStatus
    photoUrls?: SnagCreatephotoUrlsInput | string[]
    isClientVisible?: boolean
    clientNotified?: boolean
    resolution?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reportedBy: UserCreateNestedOneWithoutSnagReportsInput
    assignedTo?: UserCreateNestedOneWithoutSnagAssignmentsInput
  }

  export type SnagUncheckedCreateWithoutJobInput = {
    id?: string
    title: string
    description: string
    category: $Enums.SnagCategory
    severity?: $Enums.Priority
    status?: $Enums.SnagStatus
    photoUrls?: SnagCreatephotoUrlsInput | string[]
    isClientVisible?: boolean
    clientNotified?: boolean
    resolution?: string | null
    resolvedAt?: Date | string | null
    reportedById: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SnagCreateOrConnectWithoutJobInput = {
    where: SnagWhereUniqueInput
    create: XOR<SnagCreateWithoutJobInput, SnagUncheckedCreateWithoutJobInput>
  }

  export type SnagCreateManyJobInputEnvelope = {
    data: SnagCreateManyJobInput | SnagCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutJobInput = {
    id?: string
    filename: string
    originalFilename: string
    mimeType: string
    fileSize: number
    storageUrl: string
    category: $Enums.DocumentCategory
    description?: string | null
    isPublic?: boolean
    virusScanStatus?: $Enums.VirusScanStatus
    virusScanResult?: string | null
    createdAt?: Date | string
    client?: ClientCreateNestedOneWithoutDocumentsInput
    deal?: DealCreateNestedOneWithoutDocumentsInput
    uploadedBy: UserCreateNestedOneWithoutUploadedDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutJobInput = {
    id?: string
    filename: string
    originalFilename: string
    mimeType: string
    fileSize: number
    storageUrl: string
    category: $Enums.DocumentCategory
    description?: string | null
    isPublic?: boolean
    virusScanStatus?: $Enums.VirusScanStatus
    virusScanResult?: string | null
    clientId?: string | null
    dealId?: string | null
    createdAt?: Date | string
    uploadedById: string
  }

  export type DocumentCreateOrConnectWithoutJobInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutJobInput, DocumentUncheckedCreateWithoutJobInput>
  }

  export type DocumentCreateManyJobInputEnvelope = {
    data: DocumentCreateManyJobInput | DocumentCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type ParsedSpecItemCreateWithoutJobInput = {
    id?: string
    originalText: string
    parsedCategory?: string | null
    parsedBrand?: string | null
    parsedModel?: string | null
    parsedDescription?: string | null
    parsedQuantity?: number | null
    parsedPrice?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.SpecItemStatus
    notes?: string | null
    substitution?: string | null
    actualPrice?: Decimal | DecimalJsLike | number | string | null
    parseConfidence: number
    requiresReview?: boolean
    sourceDocumentId?: string | null
    sourcePage?: number | null
    sourceLineNumber?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParsedSpecItemUncheckedCreateWithoutJobInput = {
    id?: string
    originalText: string
    parsedCategory?: string | null
    parsedBrand?: string | null
    parsedModel?: string | null
    parsedDescription?: string | null
    parsedQuantity?: number | null
    parsedPrice?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.SpecItemStatus
    notes?: string | null
    substitution?: string | null
    actualPrice?: Decimal | DecimalJsLike | number | string | null
    parseConfidence: number
    requiresReview?: boolean
    sourceDocumentId?: string | null
    sourcePage?: number | null
    sourceLineNumber?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParsedSpecItemCreateOrConnectWithoutJobInput = {
    where: ParsedSpecItemWhereUniqueInput
    create: XOR<ParsedSpecItemCreateWithoutJobInput, ParsedSpecItemUncheckedCreateWithoutJobInput>
  }

  export type ParsedSpecItemCreateManyJobInputEnvelope = {
    data: ParsedSpecItemCreateManyJobInput | ParsedSpecItemCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type MoodboardCreateWithoutJobInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.MoodboardStatus
    isClientVisible?: boolean
    clientLastViewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutMoodboardsInput
    items?: MoodboardItemCreateNestedManyWithoutMoodboardInput
  }

  export type MoodboardUncheckedCreateWithoutJobInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.MoodboardStatus
    clientId: string
    isClientVisible?: boolean
    clientLastViewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: MoodboardItemUncheckedCreateNestedManyWithoutMoodboardInput
  }

  export type MoodboardCreateOrConnectWithoutJobInput = {
    where: MoodboardWhereUniqueInput
    create: XOR<MoodboardCreateWithoutJobInput, MoodboardUncheckedCreateWithoutJobInput>
  }

  export type MoodboardCreateManyJobInputEnvelope = {
    data: MoodboardCreateManyJobInput | MoodboardCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type HandoverPackCreateWithoutJobInput = {
    id?: string
    title: string
    description?: string | null
    completionCertUrl?: string | null
    warrantyDocsUrls?: HandoverPackCreatewarrantyDocsUrlsInput | string[]
    finalPhotosUrls?: HandoverPackCreatefinalPhotosUrlsInput | string[]
    guidesIncluded?: HandoverPackCreateguidesIncludedInput | string[]
    isGenerated?: boolean
    generatedAt?: Date | string | null
    deliveredAt?: Date | string | null
    clientAccessedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HandoverPackUncheckedCreateWithoutJobInput = {
    id?: string
    title: string
    description?: string | null
    completionCertUrl?: string | null
    warrantyDocsUrls?: HandoverPackCreatewarrantyDocsUrlsInput | string[]
    finalPhotosUrls?: HandoverPackCreatefinalPhotosUrlsInput | string[]
    guidesIncluded?: HandoverPackCreateguidesIncludedInput | string[]
    isGenerated?: boolean
    generatedAt?: Date | string | null
    deliveredAt?: Date | string | null
    clientAccessedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HandoverPackCreateOrConnectWithoutJobInput = {
    where: HandoverPackWhereUniqueInput
    create: XOR<HandoverPackCreateWithoutJobInput, HandoverPackUncheckedCreateWithoutJobInput>
  }

  export type HandoverPackCreateManyJobInputEnvelope = {
    data: HandoverPackCreateManyJobInput | HandoverPackCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutJobsInput = {
    update: XOR<ClientUpdateWithoutJobsInput, ClientUncheckedUpdateWithoutJobsInput>
    create: XOR<ClientCreateWithoutJobsInput, ClientUncheckedCreateWithoutJobsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutJobsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutJobsInput, ClientUncheckedUpdateWithoutJobsInput>
  }

  export type ClientUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedClientsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedClientsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedClientsNestedInput
    contacts?: ContactUpdateManyWithoutClientNestedInput
    leads?: LeadUpdateManyWithoutClientNestedInput
    deals?: DealUpdateManyWithoutClientNestedInput
    rooms?: RoomUpdateManyWithoutClientNestedInput
    activities?: ActivityUpdateManyWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUpdateManyWithoutClientNestedInput
    moodboards?: MoodboardUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    leads?: LeadUncheckedUpdateManyWithoutClientNestedInput
    deals?: DealUncheckedUpdateManyWithoutClientNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutClientNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClientNestedInput
    moodboards?: MoodboardUncheckedUpdateManyWithoutClientNestedInput
  }

  export type RoomUpsertWithoutJobsInput = {
    update: XOR<RoomUpdateWithoutJobsInput, RoomUncheckedUpdateWithoutJobsInput>
    create: XOR<RoomCreateWithoutJobsInput, RoomUncheckedCreateWithoutJobsInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutJobsInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutJobsInput, RoomUncheckedUpdateWithoutJobsInput>
  }

  export type RoomUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    length?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    currentCondition?: NullableStringFieldUpdateOperationsInput | string | null
    accessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutRoomsNestedInput
  }

  export type RoomUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    length?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    currentCondition?: NullableStringFieldUpdateOperationsInput | string | null
    accessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealUpsertWithoutJobInput = {
    update: XOR<DealUpdateWithoutJobInput, DealUncheckedUpdateWithoutJobInput>
    create: XOR<DealCreateWithoutJobInput, DealUncheckedCreateWithoutJobInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutJobInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutJobInput, DealUncheckedUpdateWithoutJobInput>
  }

  export type DealUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: PipelineStageUpdateOneRequiredWithoutDealsNestedInput
    client?: ClientUpdateOneRequiredWithoutDealsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedDealsNestedInput
    lead?: LeadUpdateOneWithoutDealNestedInput
    activities?: ActivityUpdateManyWithoutDealNestedInput
    tasks?: TaskUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stageId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    lead?: LeadUncheckedUpdateOneWithoutDealNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutDealNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
  }

  export type InstallerCompanyUpsertWithoutJobsInput = {
    update: XOR<InstallerCompanyUpdateWithoutJobsInput, InstallerCompanyUncheckedUpdateWithoutJobsInput>
    create: XOR<InstallerCompanyCreateWithoutJobsInput, InstallerCompanyUncheckedCreateWithoutJobsInput>
    where?: InstallerCompanyWhereInput
  }

  export type InstallerCompanyUpdateToOneWithWhereWithoutJobsInput = {
    where?: InstallerCompanyWhereInput
    data: XOR<InstallerCompanyUpdateWithoutJobsInput, InstallerCompanyUncheckedUpdateWithoutJobsInput>
  }

  export type InstallerCompanyUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dbsExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractSigned?: BoolFieldUpdateOperationsInput | boolean
    contractSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutInstallerCompaniesNestedInput
    teamMembers?: InstallerTeamMemberUpdateManyWithoutCompanyNestedInput
  }

  export type InstallerCompanyUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dbsExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractSigned?: BoolFieldUpdateOperationsInput | boolean
    contractSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMembers?: InstallerTeamMemberUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutDesignerJobsInput = {
    update: XOR<UserUpdateWithoutDesignerJobsInput, UserUncheckedUpdateWithoutDesignerJobsInput>
    create: XOR<UserCreateWithoutDesignerJobsInput, UserUncheckedCreateWithoutDesignerJobsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDesignerJobsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDesignerJobsInput, UserUncheckedUpdateWithoutDesignerJobsInput>
  }

  export type UserUpdateWithoutDesignerJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUpdateManyWithoutUpdatedByNestedInput
    installerCompanies?: InstallerCompanyUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateWithoutDesignerJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUncheckedUpdateManyWithoutUpdatedByNestedInput
    installerCompanies?: InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUncheckedUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUncheckedUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutJobInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutJobInput, TaskUncheckedUpdateWithoutJobInput>
    create: XOR<TaskCreateWithoutJobInput, TaskUncheckedCreateWithoutJobInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutJobInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutJobInput, TaskUncheckedUpdateWithoutJobInput>
  }

  export type TaskUpdateManyWithWhereWithoutJobInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutJobInput>
  }

  export type AppointmentUpsertWithWhereUniqueWithoutJobInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutJobInput, AppointmentUncheckedUpdateWithoutJobInput>
    create: XOR<AppointmentCreateWithoutJobInput, AppointmentUncheckedCreateWithoutJobInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutJobInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutJobInput, AppointmentUncheckedUpdateWithoutJobInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutJobInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutJobInput>
  }

  export type JobDayLogUpsertWithWhereUniqueWithoutJobInput = {
    where: JobDayLogWhereUniqueInput
    update: XOR<JobDayLogUpdateWithoutJobInput, JobDayLogUncheckedUpdateWithoutJobInput>
    create: XOR<JobDayLogCreateWithoutJobInput, JobDayLogUncheckedCreateWithoutJobInput>
  }

  export type JobDayLogUpdateWithWhereUniqueWithoutJobInput = {
    where: JobDayLogWhereUniqueInput
    data: XOR<JobDayLogUpdateWithoutJobInput, JobDayLogUncheckedUpdateWithoutJobInput>
  }

  export type JobDayLogUpdateManyWithWhereWithoutJobInput = {
    where: JobDayLogScalarWhereInput
    data: XOR<JobDayLogUpdateManyMutationInput, JobDayLogUncheckedUpdateManyWithoutJobInput>
  }

  export type DesignVersionUpsertWithWhereUniqueWithoutJobInput = {
    where: DesignVersionWhereUniqueInput
    update: XOR<DesignVersionUpdateWithoutJobInput, DesignVersionUncheckedUpdateWithoutJobInput>
    create: XOR<DesignVersionCreateWithoutJobInput, DesignVersionUncheckedCreateWithoutJobInput>
  }

  export type DesignVersionUpdateWithWhereUniqueWithoutJobInput = {
    where: DesignVersionWhereUniqueInput
    data: XOR<DesignVersionUpdateWithoutJobInput, DesignVersionUncheckedUpdateWithoutJobInput>
  }

  export type DesignVersionUpdateManyWithWhereWithoutJobInput = {
    where: DesignVersionScalarWhereInput
    data: XOR<DesignVersionUpdateManyMutationInput, DesignVersionUncheckedUpdateManyWithoutJobInput>
  }

  export type SnagUpsertWithWhereUniqueWithoutJobInput = {
    where: SnagWhereUniqueInput
    update: XOR<SnagUpdateWithoutJobInput, SnagUncheckedUpdateWithoutJobInput>
    create: XOR<SnagCreateWithoutJobInput, SnagUncheckedCreateWithoutJobInput>
  }

  export type SnagUpdateWithWhereUniqueWithoutJobInput = {
    where: SnagWhereUniqueInput
    data: XOR<SnagUpdateWithoutJobInput, SnagUncheckedUpdateWithoutJobInput>
  }

  export type SnagUpdateManyWithWhereWithoutJobInput = {
    where: SnagScalarWhereInput
    data: XOR<SnagUpdateManyMutationInput, SnagUncheckedUpdateManyWithoutJobInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutJobInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutJobInput, DocumentUncheckedUpdateWithoutJobInput>
    create: XOR<DocumentCreateWithoutJobInput, DocumentUncheckedCreateWithoutJobInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutJobInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutJobInput, DocumentUncheckedUpdateWithoutJobInput>
  }

  export type DocumentUpdateManyWithWhereWithoutJobInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutJobInput>
  }

  export type ParsedSpecItemUpsertWithWhereUniqueWithoutJobInput = {
    where: ParsedSpecItemWhereUniqueInput
    update: XOR<ParsedSpecItemUpdateWithoutJobInput, ParsedSpecItemUncheckedUpdateWithoutJobInput>
    create: XOR<ParsedSpecItemCreateWithoutJobInput, ParsedSpecItemUncheckedCreateWithoutJobInput>
  }

  export type ParsedSpecItemUpdateWithWhereUniqueWithoutJobInput = {
    where: ParsedSpecItemWhereUniqueInput
    data: XOR<ParsedSpecItemUpdateWithoutJobInput, ParsedSpecItemUncheckedUpdateWithoutJobInput>
  }

  export type ParsedSpecItemUpdateManyWithWhereWithoutJobInput = {
    where: ParsedSpecItemScalarWhereInput
    data: XOR<ParsedSpecItemUpdateManyMutationInput, ParsedSpecItemUncheckedUpdateManyWithoutJobInput>
  }

  export type ParsedSpecItemScalarWhereInput = {
    AND?: ParsedSpecItemScalarWhereInput | ParsedSpecItemScalarWhereInput[]
    OR?: ParsedSpecItemScalarWhereInput[]
    NOT?: ParsedSpecItemScalarWhereInput | ParsedSpecItemScalarWhereInput[]
    id?: StringFilter<"ParsedSpecItem"> | string
    originalText?: StringFilter<"ParsedSpecItem"> | string
    parsedCategory?: StringNullableFilter<"ParsedSpecItem"> | string | null
    parsedBrand?: StringNullableFilter<"ParsedSpecItem"> | string | null
    parsedModel?: StringNullableFilter<"ParsedSpecItem"> | string | null
    parsedDescription?: StringNullableFilter<"ParsedSpecItem"> | string | null
    parsedQuantity?: IntNullableFilter<"ParsedSpecItem"> | number | null
    parsedPrice?: DecimalNullableFilter<"ParsedSpecItem"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumSpecItemStatusFilter<"ParsedSpecItem"> | $Enums.SpecItemStatus
    notes?: StringNullableFilter<"ParsedSpecItem"> | string | null
    substitution?: StringNullableFilter<"ParsedSpecItem"> | string | null
    actualPrice?: DecimalNullableFilter<"ParsedSpecItem"> | Decimal | DecimalJsLike | number | string | null
    parseConfidence?: FloatFilter<"ParsedSpecItem"> | number
    requiresReview?: BoolFilter<"ParsedSpecItem"> | boolean
    jobId?: StringFilter<"ParsedSpecItem"> | string
    sourceDocumentId?: StringNullableFilter<"ParsedSpecItem"> | string | null
    sourcePage?: IntNullableFilter<"ParsedSpecItem"> | number | null
    sourceLineNumber?: IntNullableFilter<"ParsedSpecItem"> | number | null
    createdAt?: DateTimeFilter<"ParsedSpecItem"> | Date | string
    updatedAt?: DateTimeFilter<"ParsedSpecItem"> | Date | string
  }

  export type MoodboardUpsertWithWhereUniqueWithoutJobInput = {
    where: MoodboardWhereUniqueInput
    update: XOR<MoodboardUpdateWithoutJobInput, MoodboardUncheckedUpdateWithoutJobInput>
    create: XOR<MoodboardCreateWithoutJobInput, MoodboardUncheckedCreateWithoutJobInput>
  }

  export type MoodboardUpdateWithWhereUniqueWithoutJobInput = {
    where: MoodboardWhereUniqueInput
    data: XOR<MoodboardUpdateWithoutJobInput, MoodboardUncheckedUpdateWithoutJobInput>
  }

  export type MoodboardUpdateManyWithWhereWithoutJobInput = {
    where: MoodboardScalarWhereInput
    data: XOR<MoodboardUpdateManyMutationInput, MoodboardUncheckedUpdateManyWithoutJobInput>
  }

  export type HandoverPackUpsertWithWhereUniqueWithoutJobInput = {
    where: HandoverPackWhereUniqueInput
    update: XOR<HandoverPackUpdateWithoutJobInput, HandoverPackUncheckedUpdateWithoutJobInput>
    create: XOR<HandoverPackCreateWithoutJobInput, HandoverPackUncheckedCreateWithoutJobInput>
  }

  export type HandoverPackUpdateWithWhereUniqueWithoutJobInput = {
    where: HandoverPackWhereUniqueInput
    data: XOR<HandoverPackUpdateWithoutJobInput, HandoverPackUncheckedUpdateWithoutJobInput>
  }

  export type HandoverPackUpdateManyWithWhereWithoutJobInput = {
    where: HandoverPackScalarWhereInput
    data: XOR<HandoverPackUpdateManyMutationInput, HandoverPackUncheckedUpdateManyWithoutJobInput>
  }

  export type HandoverPackScalarWhereInput = {
    AND?: HandoverPackScalarWhereInput | HandoverPackScalarWhereInput[]
    OR?: HandoverPackScalarWhereInput[]
    NOT?: HandoverPackScalarWhereInput | HandoverPackScalarWhereInput[]
    id?: StringFilter<"HandoverPack"> | string
    title?: StringFilter<"HandoverPack"> | string
    description?: StringNullableFilter<"HandoverPack"> | string | null
    completionCertUrl?: StringNullableFilter<"HandoverPack"> | string | null
    warrantyDocsUrls?: StringNullableListFilter<"HandoverPack">
    finalPhotosUrls?: StringNullableListFilter<"HandoverPack">
    guidesIncluded?: StringNullableListFilter<"HandoverPack">
    isGenerated?: BoolFilter<"HandoverPack"> | boolean
    generatedAt?: DateTimeNullableFilter<"HandoverPack"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"HandoverPack"> | Date | string | null
    clientAccessedAt?: DateTimeNullableFilter<"HandoverPack"> | Date | string | null
    jobId?: StringFilter<"HandoverPack"> | string
    createdAt?: DateTimeFilter<"HandoverPack"> | Date | string
    updatedAt?: DateTimeFilter<"HandoverPack"> | Date | string
  }

  export type UserCreateWithoutJobDayLogsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatedByInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionCreateNestedManyWithoutDesignerInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentCreateNestedManyWithoutAuthorInput
    snagReports?: SnagCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateWithoutJobDayLogsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutDesignerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientUncheckedCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobUncheckedCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput
    snagReports?: SnagUncheckedCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogUncheckedCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserCreateOrConnectWithoutJobDayLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJobDayLogsInput, UserUncheckedCreateWithoutJobDayLogsInput>
  }

  export type JobCreateWithoutJobDayLogsInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutJobsInput
    room: RoomCreateNestedOneWithoutJobsInput
    deal?: DealCreateNestedOneWithoutJobInput
    installerCompany?: InstallerCompanyCreateNestedOneWithoutJobsInput
    designer?: UserCreateNestedOneWithoutDesignerJobsInput
    tasks?: TaskCreateNestedManyWithoutJobInput
    appointments?: AppointmentCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionCreateNestedManyWithoutJobInput
    snags?: SnagCreateNestedManyWithoutJobInput
    documents?: DocumentCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemCreateNestedManyWithoutJobInput
    moodboards?: MoodboardCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutJobDayLogsInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    clientId: string
    roomId: string
    dealId?: string | null
    installerCompanyId?: string | null
    designerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deal?: DealUncheckedCreateNestedOneWithoutJobInput
    tasks?: TaskUncheckedCreateNestedManyWithoutJobInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutJobInput
    snags?: SnagUncheckedCreateNestedManyWithoutJobInput
    documents?: DocumentUncheckedCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemUncheckedCreateNestedManyWithoutJobInput
    moodboards?: MoodboardUncheckedCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutJobDayLogsInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutJobDayLogsInput, JobUncheckedCreateWithoutJobDayLogsInput>
  }

  export type UserUpsertWithoutJobDayLogsInput = {
    update: XOR<UserUpdateWithoutJobDayLogsInput, UserUncheckedUpdateWithoutJobDayLogsInput>
    create: XOR<UserCreateWithoutJobDayLogsInput, UserUncheckedCreateWithoutJobDayLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutJobDayLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutJobDayLogsInput, UserUncheckedUpdateWithoutJobDayLogsInput>
  }

  export type UserUpdateWithoutJobDayLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateWithoutJobDayLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUncheckedUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUncheckedUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUncheckedUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUncheckedUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type JobUpsertWithoutJobDayLogsInput = {
    update: XOR<JobUpdateWithoutJobDayLogsInput, JobUncheckedUpdateWithoutJobDayLogsInput>
    create: XOR<JobCreateWithoutJobDayLogsInput, JobUncheckedCreateWithoutJobDayLogsInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutJobDayLogsInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutJobDayLogsInput, JobUncheckedUpdateWithoutJobDayLogsInput>
  }

  export type JobUpdateWithoutJobDayLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutJobsNestedInput
    room?: RoomUpdateOneRequiredWithoutJobsNestedInput
    deal?: DealUpdateOneWithoutJobNestedInput
    installerCompany?: InstallerCompanyUpdateOneWithoutJobsNestedInput
    designer?: UserUpdateOneWithoutDesignerJobsNestedInput
    tasks?: TaskUpdateManyWithoutJobNestedInput
    appointments?: AppointmentUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUpdateManyWithoutJobNestedInput
    snags?: SnagUpdateManyWithoutJobNestedInput
    documents?: DocumentUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutJobDayLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    installerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    designerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUncheckedUpdateOneWithoutJobNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutJobNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutJobNestedInput
    snags?: SnagUncheckedUpdateManyWithoutJobNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUncheckedUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUncheckedUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUncheckedUpdateManyWithoutJobNestedInput
  }

  export type UserCreateWithoutInstallerCompaniesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatedByInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionCreateNestedManyWithoutDesignerInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobCreateNestedManyWithoutDesignerInput
    clashReports?: DesignClashTicketCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentCreateNestedManyWithoutAuthorInput
    snagReports?: SnagCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateWithoutInstallerCompaniesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutDesignerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientUncheckedCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobUncheckedCreateNestedManyWithoutDesignerInput
    clashReports?: DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput
    snagReports?: SnagUncheckedCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogUncheckedCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserCreateOrConnectWithoutInstallerCompaniesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInstallerCompaniesInput, UserUncheckedCreateWithoutInstallerCompaniesInput>
  }

  export type InstallerTeamMemberCreateWithoutCompanyInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    dbsExpiry?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstallerTeamMemberUncheckedCreateWithoutCompanyInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    dbsExpiry?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstallerTeamMemberCreateOrConnectWithoutCompanyInput = {
    where: InstallerTeamMemberWhereUniqueInput
    create: XOR<InstallerTeamMemberCreateWithoutCompanyInput, InstallerTeamMemberUncheckedCreateWithoutCompanyInput>
  }

  export type InstallerTeamMemberCreateManyCompanyInputEnvelope = {
    data: InstallerTeamMemberCreateManyCompanyInput | InstallerTeamMemberCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type JobCreateWithoutInstallerCompanyInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutJobsInput
    room: RoomCreateNestedOneWithoutJobsInput
    deal?: DealCreateNestedOneWithoutJobInput
    designer?: UserCreateNestedOneWithoutDesignerJobsInput
    tasks?: TaskCreateNestedManyWithoutJobInput
    appointments?: AppointmentCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionCreateNestedManyWithoutJobInput
    snags?: SnagCreateNestedManyWithoutJobInput
    documents?: DocumentCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemCreateNestedManyWithoutJobInput
    moodboards?: MoodboardCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutInstallerCompanyInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    clientId: string
    roomId: string
    dealId?: string | null
    designerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deal?: DealUncheckedCreateNestedOneWithoutJobInput
    tasks?: TaskUncheckedCreateNestedManyWithoutJobInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutJobInput
    snags?: SnagUncheckedCreateNestedManyWithoutJobInput
    documents?: DocumentUncheckedCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemUncheckedCreateNestedManyWithoutJobInput
    moodboards?: MoodboardUncheckedCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutInstallerCompanyInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutInstallerCompanyInput, JobUncheckedCreateWithoutInstallerCompanyInput>
  }

  export type JobCreateManyInstallerCompanyInputEnvelope = {
    data: JobCreateManyInstallerCompanyInput | JobCreateManyInstallerCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutInstallerCompaniesInput = {
    update: XOR<UserUpdateWithoutInstallerCompaniesInput, UserUncheckedUpdateWithoutInstallerCompaniesInput>
    create: XOR<UserCreateWithoutInstallerCompaniesInput, UserUncheckedCreateWithoutInstallerCompaniesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInstallerCompaniesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInstallerCompaniesInput, UserUncheckedUpdateWithoutInstallerCompaniesInput>
  }

  export type UserUpdateWithoutInstallerCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUpdateManyWithoutDesignerNestedInput
    clashReports?: DesignClashTicketUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateWithoutInstallerCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUncheckedUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUncheckedUpdateManyWithoutDesignerNestedInput
    clashReports?: DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUncheckedUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUncheckedUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type InstallerTeamMemberUpsertWithWhereUniqueWithoutCompanyInput = {
    where: InstallerTeamMemberWhereUniqueInput
    update: XOR<InstallerTeamMemberUpdateWithoutCompanyInput, InstallerTeamMemberUncheckedUpdateWithoutCompanyInput>
    create: XOR<InstallerTeamMemberCreateWithoutCompanyInput, InstallerTeamMemberUncheckedCreateWithoutCompanyInput>
  }

  export type InstallerTeamMemberUpdateWithWhereUniqueWithoutCompanyInput = {
    where: InstallerTeamMemberWhereUniqueInput
    data: XOR<InstallerTeamMemberUpdateWithoutCompanyInput, InstallerTeamMemberUncheckedUpdateWithoutCompanyInput>
  }

  export type InstallerTeamMemberUpdateManyWithWhereWithoutCompanyInput = {
    where: InstallerTeamMemberScalarWhereInput
    data: XOR<InstallerTeamMemberUpdateManyMutationInput, InstallerTeamMemberUncheckedUpdateManyWithoutCompanyInput>
  }

  export type InstallerTeamMemberScalarWhereInput = {
    AND?: InstallerTeamMemberScalarWhereInput | InstallerTeamMemberScalarWhereInput[]
    OR?: InstallerTeamMemberScalarWhereInput[]
    NOT?: InstallerTeamMemberScalarWhereInput | InstallerTeamMemberScalarWhereInput[]
    id?: StringFilter<"InstallerTeamMember"> | string
    firstName?: StringFilter<"InstallerTeamMember"> | string
    lastName?: StringFilter<"InstallerTeamMember"> | string
    email?: StringNullableFilter<"InstallerTeamMember"> | string | null
    phone?: StringNullableFilter<"InstallerTeamMember"> | string | null
    dbsExpiry?: DateTimeNullableFilter<"InstallerTeamMember"> | Date | string | null
    isActive?: BoolFilter<"InstallerTeamMember"> | boolean
    companyId?: StringFilter<"InstallerTeamMember"> | string
    createdAt?: DateTimeFilter<"InstallerTeamMember"> | Date | string
    updatedAt?: DateTimeFilter<"InstallerTeamMember"> | Date | string
  }

  export type JobUpsertWithWhereUniqueWithoutInstallerCompanyInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutInstallerCompanyInput, JobUncheckedUpdateWithoutInstallerCompanyInput>
    create: XOR<JobCreateWithoutInstallerCompanyInput, JobUncheckedCreateWithoutInstallerCompanyInput>
  }

  export type JobUpdateWithWhereUniqueWithoutInstallerCompanyInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutInstallerCompanyInput, JobUncheckedUpdateWithoutInstallerCompanyInput>
  }

  export type JobUpdateManyWithWhereWithoutInstallerCompanyInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutInstallerCompanyInput>
  }

  export type InstallerCompanyCreateWithoutTeamMembersInput = {
    id?: string
    name: string
    contactEmail: string
    contactPhone: string
    address?: string | null
    insuranceExpiry?: Date | string | null
    dbsExpiry?: Date | string | null
    contractSigned?: boolean
    contractSignedAt?: Date | string | null
    isActive?: boolean
    isSuspended?: boolean
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutInstallerCompaniesInput
    jobs?: JobCreateNestedManyWithoutInstallerCompanyInput
  }

  export type InstallerCompanyUncheckedCreateWithoutTeamMembersInput = {
    id?: string
    name: string
    contactEmail: string
    contactPhone: string
    address?: string | null
    insuranceExpiry?: Date | string | null
    dbsExpiry?: Date | string | null
    contractSigned?: boolean
    contractSignedAt?: Date | string | null
    isActive?: boolean
    isSuspended?: boolean
    suspensionReason?: string | null
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutInstallerCompanyInput
  }

  export type InstallerCompanyCreateOrConnectWithoutTeamMembersInput = {
    where: InstallerCompanyWhereUniqueInput
    create: XOR<InstallerCompanyCreateWithoutTeamMembersInput, InstallerCompanyUncheckedCreateWithoutTeamMembersInput>
  }

  export type InstallerCompanyUpsertWithoutTeamMembersInput = {
    update: XOR<InstallerCompanyUpdateWithoutTeamMembersInput, InstallerCompanyUncheckedUpdateWithoutTeamMembersInput>
    create: XOR<InstallerCompanyCreateWithoutTeamMembersInput, InstallerCompanyUncheckedCreateWithoutTeamMembersInput>
    where?: InstallerCompanyWhereInput
  }

  export type InstallerCompanyUpdateToOneWithWhereWithoutTeamMembersInput = {
    where?: InstallerCompanyWhereInput
    data: XOR<InstallerCompanyUpdateWithoutTeamMembersInput, InstallerCompanyUncheckedUpdateWithoutTeamMembersInput>
  }

  export type InstallerCompanyUpdateWithoutTeamMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dbsExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractSigned?: BoolFieldUpdateOperationsInput | boolean
    contractSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutInstallerCompaniesNestedInput
    jobs?: JobUpdateManyWithoutInstallerCompanyNestedInput
  }

  export type InstallerCompanyUncheckedUpdateWithoutTeamMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dbsExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractSigned?: BoolFieldUpdateOperationsInput | boolean
    contractSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutInstallerCompanyNestedInput
  }

  export type JobCreateWithoutDesignVersionsInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutJobsInput
    room: RoomCreateNestedOneWithoutJobsInput
    deal?: DealCreateNestedOneWithoutJobInput
    installerCompany?: InstallerCompanyCreateNestedOneWithoutJobsInput
    designer?: UserCreateNestedOneWithoutDesignerJobsInput
    tasks?: TaskCreateNestedManyWithoutJobInput
    appointments?: AppointmentCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutJobInput
    snags?: SnagCreateNestedManyWithoutJobInput
    documents?: DocumentCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemCreateNestedManyWithoutJobInput
    moodboards?: MoodboardCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutDesignVersionsInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    clientId: string
    roomId: string
    dealId?: string | null
    installerCompanyId?: string | null
    designerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deal?: DealUncheckedCreateNestedOneWithoutJobInput
    tasks?: TaskUncheckedCreateNestedManyWithoutJobInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutJobInput
    snags?: SnagUncheckedCreateNestedManyWithoutJobInput
    documents?: DocumentUncheckedCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemUncheckedCreateNestedManyWithoutJobInput
    moodboards?: MoodboardUncheckedCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutDesignVersionsInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutDesignVersionsInput, JobUncheckedCreateWithoutDesignVersionsInput>
  }

  export type UserCreateWithoutDesignVersionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatedByInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutUserInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentCreateNestedManyWithoutAuthorInput
    snagReports?: SnagCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateWithoutDesignVersionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutUserInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientUncheckedCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobUncheckedCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput
    snagReports?: SnagUncheckedCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogUncheckedCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserCreateOrConnectWithoutDesignVersionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDesignVersionsInput, UserUncheckedCreateWithoutDesignVersionsInput>
  }

  export type DesignClashTicketCreateWithoutDesignVersionInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ClashStatus
    priority?: $Enums.Priority
    photoUrls?: DesignClashTicketCreatephotoUrlsInput | string[]
    resolution?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reportedBy: UserCreateNestedOneWithoutClashReportsInput
    assignedTo?: UserCreateNestedOneWithoutClashAssignmentsInput
  }

  export type DesignClashTicketUncheckedCreateWithoutDesignVersionInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ClashStatus
    priority?: $Enums.Priority
    photoUrls?: DesignClashTicketCreatephotoUrlsInput | string[]
    resolution?: string | null
    resolvedAt?: Date | string | null
    reportedById: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignClashTicketCreateOrConnectWithoutDesignVersionInput = {
    where: DesignClashTicketWhereUniqueInput
    create: XOR<DesignClashTicketCreateWithoutDesignVersionInput, DesignClashTicketUncheckedCreateWithoutDesignVersionInput>
  }

  export type DesignClashTicketCreateManyDesignVersionInputEnvelope = {
    data: DesignClashTicketCreateManyDesignVersionInput | DesignClashTicketCreateManyDesignVersionInput[]
    skipDuplicates?: boolean
  }

  export type JobUpsertWithoutDesignVersionsInput = {
    update: XOR<JobUpdateWithoutDesignVersionsInput, JobUncheckedUpdateWithoutDesignVersionsInput>
    create: XOR<JobCreateWithoutDesignVersionsInput, JobUncheckedCreateWithoutDesignVersionsInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutDesignVersionsInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutDesignVersionsInput, JobUncheckedUpdateWithoutDesignVersionsInput>
  }

  export type JobUpdateWithoutDesignVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutJobsNestedInput
    room?: RoomUpdateOneRequiredWithoutJobsNestedInput
    deal?: DealUpdateOneWithoutJobNestedInput
    installerCompany?: InstallerCompanyUpdateOneWithoutJobsNestedInput
    designer?: UserUpdateOneWithoutDesignerJobsNestedInput
    tasks?: TaskUpdateManyWithoutJobNestedInput
    appointments?: AppointmentUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutJobNestedInput
    snags?: SnagUpdateManyWithoutJobNestedInput
    documents?: DocumentUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutDesignVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    installerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    designerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUncheckedUpdateOneWithoutJobNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutJobNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutJobNestedInput
    snags?: SnagUncheckedUpdateManyWithoutJobNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUncheckedUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUncheckedUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUncheckedUpdateManyWithoutJobNestedInput
  }

  export type UserUpsertWithoutDesignVersionsInput = {
    update: XOR<UserUpdateWithoutDesignVersionsInput, UserUncheckedUpdateWithoutDesignVersionsInput>
    create: XOR<UserCreateWithoutDesignVersionsInput, UserUncheckedCreateWithoutDesignVersionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDesignVersionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDesignVersionsInput, UserUncheckedUpdateWithoutDesignVersionsInput>
  }

  export type UserUpdateWithoutDesignVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutUserNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateWithoutDesignVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutUserNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUncheckedUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUncheckedUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUncheckedUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUncheckedUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type DesignClashTicketUpsertWithWhereUniqueWithoutDesignVersionInput = {
    where: DesignClashTicketWhereUniqueInput
    update: XOR<DesignClashTicketUpdateWithoutDesignVersionInput, DesignClashTicketUncheckedUpdateWithoutDesignVersionInput>
    create: XOR<DesignClashTicketCreateWithoutDesignVersionInput, DesignClashTicketUncheckedCreateWithoutDesignVersionInput>
  }

  export type DesignClashTicketUpdateWithWhereUniqueWithoutDesignVersionInput = {
    where: DesignClashTicketWhereUniqueInput
    data: XOR<DesignClashTicketUpdateWithoutDesignVersionInput, DesignClashTicketUncheckedUpdateWithoutDesignVersionInput>
  }

  export type DesignClashTicketUpdateManyWithWhereWithoutDesignVersionInput = {
    where: DesignClashTicketScalarWhereInput
    data: XOR<DesignClashTicketUpdateManyMutationInput, DesignClashTicketUncheckedUpdateManyWithoutDesignVersionInput>
  }

  export type DesignVersionCreateWithoutClashTicketsInput = {
    id?: string
    version?: number
    title: string
    description?: string | null
    status?: $Enums.DesignStatus
    renderUrls?: DesignVersionCreaterenderUrlsInput | string[]
    planUrls?: DesignVersionCreateplanUrlsInput | string[]
    specSheetUrl?: string | null
    isClientVisible?: boolean
    clientViewedAt?: Date | string | null
    clientApprovedAt?: Date | string | null
    clientFeedback?: string | null
    isFinal?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    job: JobCreateNestedOneWithoutDesignVersionsInput
    designer: UserCreateNestedOneWithoutDesignVersionsInput
  }

  export type DesignVersionUncheckedCreateWithoutClashTicketsInput = {
    id?: string
    version?: number
    title: string
    description?: string | null
    status?: $Enums.DesignStatus
    renderUrls?: DesignVersionCreaterenderUrlsInput | string[]
    planUrls?: DesignVersionCreateplanUrlsInput | string[]
    specSheetUrl?: string | null
    isClientVisible?: boolean
    clientViewedAt?: Date | string | null
    clientApprovedAt?: Date | string | null
    clientFeedback?: string | null
    jobId: string
    designerId: string
    isFinal?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignVersionCreateOrConnectWithoutClashTicketsInput = {
    where: DesignVersionWhereUniqueInput
    create: XOR<DesignVersionCreateWithoutClashTicketsInput, DesignVersionUncheckedCreateWithoutClashTicketsInput>
  }

  export type UserCreateWithoutClashReportsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatedByInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionCreateNestedManyWithoutDesignerInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyCreateNestedManyWithoutOwnerInput
    clashAssignments?: DesignClashTicketCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentCreateNestedManyWithoutAuthorInput
    snagReports?: SnagCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateWithoutClashReportsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutDesignerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientUncheckedCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobUncheckedCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput
    clashAssignments?: DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput
    snagReports?: SnagUncheckedCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogUncheckedCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserCreateOrConnectWithoutClashReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClashReportsInput, UserUncheckedCreateWithoutClashReportsInput>
  }

  export type UserCreateWithoutClashAssignmentsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatedByInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionCreateNestedManyWithoutDesignerInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketCreateNestedManyWithoutReportedByInput
    moodboardComments?: MoodboardCommentCreateNestedManyWithoutAuthorInput
    snagReports?: SnagCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateWithoutClashAssignmentsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutDesignerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientUncheckedCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobUncheckedCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput
    moodboardComments?: MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput
    snagReports?: SnagUncheckedCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogUncheckedCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserCreateOrConnectWithoutClashAssignmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClashAssignmentsInput, UserUncheckedCreateWithoutClashAssignmentsInput>
  }

  export type DesignVersionUpsertWithoutClashTicketsInput = {
    update: XOR<DesignVersionUpdateWithoutClashTicketsInput, DesignVersionUncheckedUpdateWithoutClashTicketsInput>
    create: XOR<DesignVersionCreateWithoutClashTicketsInput, DesignVersionUncheckedCreateWithoutClashTicketsInput>
    where?: DesignVersionWhereInput
  }

  export type DesignVersionUpdateToOneWithWhereWithoutClashTicketsInput = {
    where?: DesignVersionWhereInput
    data: XOR<DesignVersionUpdateWithoutClashTicketsInput, DesignVersionUncheckedUpdateWithoutClashTicketsInput>
  }

  export type DesignVersionUpdateWithoutClashTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDesignStatusFieldUpdateOperationsInput | $Enums.DesignStatus
    renderUrls?: DesignVersionUpdaterenderUrlsInput | string[]
    planUrls?: DesignVersionUpdateplanUrlsInput | string[]
    specSheetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutDesignVersionsNestedInput
    designer?: UserUpdateOneRequiredWithoutDesignVersionsNestedInput
  }

  export type DesignVersionUncheckedUpdateWithoutClashTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDesignStatusFieldUpdateOperationsInput | $Enums.DesignStatus
    renderUrls?: DesignVersionUpdaterenderUrlsInput | string[]
    planUrls?: DesignVersionUpdateplanUrlsInput | string[]
    specSheetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: StringFieldUpdateOperationsInput | string
    designerId?: StringFieldUpdateOperationsInput | string
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutClashReportsInput = {
    update: XOR<UserUpdateWithoutClashReportsInput, UserUncheckedUpdateWithoutClashReportsInput>
    create: XOR<UserCreateWithoutClashReportsInput, UserUncheckedCreateWithoutClashReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClashReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClashReportsInput, UserUncheckedUpdateWithoutClashReportsInput>
  }

  export type UserUpdateWithoutClashReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUpdateManyWithoutOwnerNestedInput
    clashAssignments?: DesignClashTicketUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateWithoutClashReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUncheckedUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUncheckedUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput
    clashAssignments?: DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUncheckedUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUncheckedUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUpsertWithoutClashAssignmentsInput = {
    update: XOR<UserUpdateWithoutClashAssignmentsInput, UserUncheckedUpdateWithoutClashAssignmentsInput>
    create: XOR<UserCreateWithoutClashAssignmentsInput, UserUncheckedCreateWithoutClashAssignmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClashAssignmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClashAssignmentsInput, UserUncheckedUpdateWithoutClashAssignmentsInput>
  }

  export type UserUpdateWithoutClashAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUpdateManyWithoutReportedByNestedInput
    moodboardComments?: MoodboardCommentUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateWithoutClashAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUncheckedUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUncheckedUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput
    moodboardComments?: MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUncheckedUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUncheckedUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type ClientCreateWithoutMoodboardsInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedClientsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedClientsInput
    owner: UserCreateNestedOneWithoutOwnedClientsInput
    contacts?: ContactCreateNestedManyWithoutClientInput
    leads?: LeadCreateNestedManyWithoutClientInput
    deals?: DealCreateNestedManyWithoutClientInput
    rooms?: RoomCreateNestedManyWithoutClientInput
    jobs?: JobCreateNestedManyWithoutClientInput
    activities?: ActivityCreateNestedManyWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    appointments?: AppointmentCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutMoodboardsInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownerId: string
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    leads?: LeadUncheckedCreateNestedManyWithoutClientInput
    deals?: DealUncheckedCreateNestedManyWithoutClientInput
    rooms?: RoomUncheckedCreateNestedManyWithoutClientInput
    jobs?: JobUncheckedCreateNestedManyWithoutClientInput
    activities?: ActivityUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutMoodboardsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutMoodboardsInput, ClientUncheckedCreateWithoutMoodboardsInput>
  }

  export type JobCreateWithoutMoodboardsInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutJobsInput
    room: RoomCreateNestedOneWithoutJobsInput
    deal?: DealCreateNestedOneWithoutJobInput
    installerCompany?: InstallerCompanyCreateNestedOneWithoutJobsInput
    designer?: UserCreateNestedOneWithoutDesignerJobsInput
    tasks?: TaskCreateNestedManyWithoutJobInput
    appointments?: AppointmentCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionCreateNestedManyWithoutJobInput
    snags?: SnagCreateNestedManyWithoutJobInput
    documents?: DocumentCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutMoodboardsInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    clientId: string
    roomId: string
    dealId?: string | null
    installerCompanyId?: string | null
    designerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deal?: DealUncheckedCreateNestedOneWithoutJobInput
    tasks?: TaskUncheckedCreateNestedManyWithoutJobInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutJobInput
    snags?: SnagUncheckedCreateNestedManyWithoutJobInput
    documents?: DocumentUncheckedCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemUncheckedCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutMoodboardsInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutMoodboardsInput, JobUncheckedCreateWithoutMoodboardsInput>
  }

  export type MoodboardItemCreateWithoutMoodboardInput = {
    id?: string
    title?: string | null
    description?: string | null
    imageUrl: string
    sourceUrl?: string | null
    category?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clientComments?: MoodboardCommentCreateNestedManyWithoutItemInput
  }

  export type MoodboardItemUncheckedCreateWithoutMoodboardInput = {
    id?: string
    title?: string | null
    description?: string | null
    imageUrl: string
    sourceUrl?: string | null
    category?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clientComments?: MoodboardCommentUncheckedCreateNestedManyWithoutItemInput
  }

  export type MoodboardItemCreateOrConnectWithoutMoodboardInput = {
    where: MoodboardItemWhereUniqueInput
    create: XOR<MoodboardItemCreateWithoutMoodboardInput, MoodboardItemUncheckedCreateWithoutMoodboardInput>
  }

  export type MoodboardItemCreateManyMoodboardInputEnvelope = {
    data: MoodboardItemCreateManyMoodboardInput | MoodboardItemCreateManyMoodboardInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutMoodboardsInput = {
    update: XOR<ClientUpdateWithoutMoodboardsInput, ClientUncheckedUpdateWithoutMoodboardsInput>
    create: XOR<ClientCreateWithoutMoodboardsInput, ClientUncheckedCreateWithoutMoodboardsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutMoodboardsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutMoodboardsInput, ClientUncheckedUpdateWithoutMoodboardsInput>
  }

  export type ClientUpdateWithoutMoodboardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedClientsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedClientsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedClientsNestedInput
    contacts?: ContactUpdateManyWithoutClientNestedInput
    leads?: LeadUpdateManyWithoutClientNestedInput
    deals?: DealUpdateManyWithoutClientNestedInput
    rooms?: RoomUpdateManyWithoutClientNestedInput
    jobs?: JobUpdateManyWithoutClientNestedInput
    activities?: ActivityUpdateManyWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutMoodboardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    leads?: LeadUncheckedUpdateManyWithoutClientNestedInput
    deals?: DealUncheckedUpdateManyWithoutClientNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutClientNestedInput
    jobs?: JobUncheckedUpdateManyWithoutClientNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClientNestedInput
  }

  export type JobUpsertWithoutMoodboardsInput = {
    update: XOR<JobUpdateWithoutMoodboardsInput, JobUncheckedUpdateWithoutMoodboardsInput>
    create: XOR<JobCreateWithoutMoodboardsInput, JobUncheckedCreateWithoutMoodboardsInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutMoodboardsInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutMoodboardsInput, JobUncheckedUpdateWithoutMoodboardsInput>
  }

  export type JobUpdateWithoutMoodboardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutJobsNestedInput
    room?: RoomUpdateOneRequiredWithoutJobsNestedInput
    deal?: DealUpdateOneWithoutJobNestedInput
    installerCompany?: InstallerCompanyUpdateOneWithoutJobsNestedInput
    designer?: UserUpdateOneWithoutDesignerJobsNestedInput
    tasks?: TaskUpdateManyWithoutJobNestedInput
    appointments?: AppointmentUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUpdateManyWithoutJobNestedInput
    snags?: SnagUpdateManyWithoutJobNestedInput
    documents?: DocumentUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutMoodboardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    installerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    designerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUncheckedUpdateOneWithoutJobNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutJobNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutJobNestedInput
    snags?: SnagUncheckedUpdateManyWithoutJobNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUncheckedUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUncheckedUpdateManyWithoutJobNestedInput
  }

  export type MoodboardItemUpsertWithWhereUniqueWithoutMoodboardInput = {
    where: MoodboardItemWhereUniqueInput
    update: XOR<MoodboardItemUpdateWithoutMoodboardInput, MoodboardItemUncheckedUpdateWithoutMoodboardInput>
    create: XOR<MoodboardItemCreateWithoutMoodboardInput, MoodboardItemUncheckedCreateWithoutMoodboardInput>
  }

  export type MoodboardItemUpdateWithWhereUniqueWithoutMoodboardInput = {
    where: MoodboardItemWhereUniqueInput
    data: XOR<MoodboardItemUpdateWithoutMoodboardInput, MoodboardItemUncheckedUpdateWithoutMoodboardInput>
  }

  export type MoodboardItemUpdateManyWithWhereWithoutMoodboardInput = {
    where: MoodboardItemScalarWhereInput
    data: XOR<MoodboardItemUpdateManyMutationInput, MoodboardItemUncheckedUpdateManyWithoutMoodboardInput>
  }

  export type MoodboardItemScalarWhereInput = {
    AND?: MoodboardItemScalarWhereInput | MoodboardItemScalarWhereInput[]
    OR?: MoodboardItemScalarWhereInput[]
    NOT?: MoodboardItemScalarWhereInput | MoodboardItemScalarWhereInput[]
    id?: StringFilter<"MoodboardItem"> | string
    title?: StringNullableFilter<"MoodboardItem"> | string | null
    description?: StringNullableFilter<"MoodboardItem"> | string | null
    imageUrl?: StringFilter<"MoodboardItem"> | string
    sourceUrl?: StringNullableFilter<"MoodboardItem"> | string | null
    category?: StringNullableFilter<"MoodboardItem"> | string | null
    order?: IntFilter<"MoodboardItem"> | number
    moodboardId?: StringFilter<"MoodboardItem"> | string
    createdAt?: DateTimeFilter<"MoodboardItem"> | Date | string
    updatedAt?: DateTimeFilter<"MoodboardItem"> | Date | string
  }

  export type MoodboardCommentCreateWithoutItemInput = {
    id?: string
    content: string
    xPosition: number
    yPosition: number
    authorName?: string | null
    createdAt?: Date | string
    author?: UserCreateNestedOneWithoutMoodboardCommentsInput
  }

  export type MoodboardCommentUncheckedCreateWithoutItemInput = {
    id?: string
    content: string
    xPosition: number
    yPosition: number
    authorId?: string | null
    authorName?: string | null
    createdAt?: Date | string
  }

  export type MoodboardCommentCreateOrConnectWithoutItemInput = {
    where: MoodboardCommentWhereUniqueInput
    create: XOR<MoodboardCommentCreateWithoutItemInput, MoodboardCommentUncheckedCreateWithoutItemInput>
  }

  export type MoodboardCommentCreateManyItemInputEnvelope = {
    data: MoodboardCommentCreateManyItemInput | MoodboardCommentCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type MoodboardCreateWithoutItemsInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.MoodboardStatus
    isClientVisible?: boolean
    clientLastViewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutMoodboardsInput
    job?: JobCreateNestedOneWithoutMoodboardsInput
  }

  export type MoodboardUncheckedCreateWithoutItemsInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.MoodboardStatus
    clientId: string
    jobId?: string | null
    isClientVisible?: boolean
    clientLastViewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MoodboardCreateOrConnectWithoutItemsInput = {
    where: MoodboardWhereUniqueInput
    create: XOR<MoodboardCreateWithoutItemsInput, MoodboardUncheckedCreateWithoutItemsInput>
  }

  export type MoodboardCommentUpsertWithWhereUniqueWithoutItemInput = {
    where: MoodboardCommentWhereUniqueInput
    update: XOR<MoodboardCommentUpdateWithoutItemInput, MoodboardCommentUncheckedUpdateWithoutItemInput>
    create: XOR<MoodboardCommentCreateWithoutItemInput, MoodboardCommentUncheckedCreateWithoutItemInput>
  }

  export type MoodboardCommentUpdateWithWhereUniqueWithoutItemInput = {
    where: MoodboardCommentWhereUniqueInput
    data: XOR<MoodboardCommentUpdateWithoutItemInput, MoodboardCommentUncheckedUpdateWithoutItemInput>
  }

  export type MoodboardCommentUpdateManyWithWhereWithoutItemInput = {
    where: MoodboardCommentScalarWhereInput
    data: XOR<MoodboardCommentUpdateManyMutationInput, MoodboardCommentUncheckedUpdateManyWithoutItemInput>
  }

  export type MoodboardUpsertWithoutItemsInput = {
    update: XOR<MoodboardUpdateWithoutItemsInput, MoodboardUncheckedUpdateWithoutItemsInput>
    create: XOR<MoodboardCreateWithoutItemsInput, MoodboardUncheckedCreateWithoutItemsInput>
    where?: MoodboardWhereInput
  }

  export type MoodboardUpdateToOneWithWhereWithoutItemsInput = {
    where?: MoodboardWhereInput
    data: XOR<MoodboardUpdateWithoutItemsInput, MoodboardUncheckedUpdateWithoutItemsInput>
  }

  export type MoodboardUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMoodboardStatusFieldUpdateOperationsInput | $Enums.MoodboardStatus
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientLastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutMoodboardsNestedInput
    job?: JobUpdateOneWithoutMoodboardsNestedInput
  }

  export type MoodboardUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMoodboardStatusFieldUpdateOperationsInput | $Enums.MoodboardStatus
    clientId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientLastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutMoodboardCommentsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatedByInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionCreateNestedManyWithoutDesignerInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketCreateNestedManyWithoutAssignedToInput
    snagReports?: SnagCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateWithoutMoodboardCommentsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutDesignerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientUncheckedCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobUncheckedCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput
    snagReports?: SnagUncheckedCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogUncheckedCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserCreateOrConnectWithoutMoodboardCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMoodboardCommentsInput, UserUncheckedCreateWithoutMoodboardCommentsInput>
  }

  export type MoodboardItemCreateWithoutClientCommentsInput = {
    id?: string
    title?: string | null
    description?: string | null
    imageUrl: string
    sourceUrl?: string | null
    category?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    moodboard: MoodboardCreateNestedOneWithoutItemsInput
  }

  export type MoodboardItemUncheckedCreateWithoutClientCommentsInput = {
    id?: string
    title?: string | null
    description?: string | null
    imageUrl: string
    sourceUrl?: string | null
    category?: string | null
    order?: number
    moodboardId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MoodboardItemCreateOrConnectWithoutClientCommentsInput = {
    where: MoodboardItemWhereUniqueInput
    create: XOR<MoodboardItemCreateWithoutClientCommentsInput, MoodboardItemUncheckedCreateWithoutClientCommentsInput>
  }

  export type UserUpsertWithoutMoodboardCommentsInput = {
    update: XOR<UserUpdateWithoutMoodboardCommentsInput, UserUncheckedUpdateWithoutMoodboardCommentsInput>
    create: XOR<UserCreateWithoutMoodboardCommentsInput, UserUncheckedCreateWithoutMoodboardCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMoodboardCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMoodboardCommentsInput, UserUncheckedUpdateWithoutMoodboardCommentsInput>
  }

  export type UserUpdateWithoutMoodboardCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUpdateManyWithoutAssignedToNestedInput
    snagReports?: SnagUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateWithoutMoodboardCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUncheckedUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUncheckedUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    snagReports?: SnagUncheckedUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUncheckedUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type MoodboardItemUpsertWithoutClientCommentsInput = {
    update: XOR<MoodboardItemUpdateWithoutClientCommentsInput, MoodboardItemUncheckedUpdateWithoutClientCommentsInput>
    create: XOR<MoodboardItemCreateWithoutClientCommentsInput, MoodboardItemUncheckedCreateWithoutClientCommentsInput>
    where?: MoodboardItemWhereInput
  }

  export type MoodboardItemUpdateToOneWithWhereWithoutClientCommentsInput = {
    where?: MoodboardItemWhereInput
    data: XOR<MoodboardItemUpdateWithoutClientCommentsInput, MoodboardItemUncheckedUpdateWithoutClientCommentsInput>
  }

  export type MoodboardItemUpdateWithoutClientCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moodboard?: MoodboardUpdateOneRequiredWithoutItemsNestedInput
  }

  export type MoodboardItemUncheckedUpdateWithoutClientCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    moodboardId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobCreateWithoutParsedSpecItemsInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutJobsInput
    room: RoomCreateNestedOneWithoutJobsInput
    deal?: DealCreateNestedOneWithoutJobInput
    installerCompany?: InstallerCompanyCreateNestedOneWithoutJobsInput
    designer?: UserCreateNestedOneWithoutDesignerJobsInput
    tasks?: TaskCreateNestedManyWithoutJobInput
    appointments?: AppointmentCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionCreateNestedManyWithoutJobInput
    snags?: SnagCreateNestedManyWithoutJobInput
    documents?: DocumentCreateNestedManyWithoutJobInput
    moodboards?: MoodboardCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutParsedSpecItemsInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    clientId: string
    roomId: string
    dealId?: string | null
    installerCompanyId?: string | null
    designerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deal?: DealUncheckedCreateNestedOneWithoutJobInput
    tasks?: TaskUncheckedCreateNestedManyWithoutJobInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutJobInput
    snags?: SnagUncheckedCreateNestedManyWithoutJobInput
    documents?: DocumentUncheckedCreateNestedManyWithoutJobInput
    moodboards?: MoodboardUncheckedCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutParsedSpecItemsInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutParsedSpecItemsInput, JobUncheckedCreateWithoutParsedSpecItemsInput>
  }

  export type JobUpsertWithoutParsedSpecItemsInput = {
    update: XOR<JobUpdateWithoutParsedSpecItemsInput, JobUncheckedUpdateWithoutParsedSpecItemsInput>
    create: XOR<JobCreateWithoutParsedSpecItemsInput, JobUncheckedCreateWithoutParsedSpecItemsInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutParsedSpecItemsInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutParsedSpecItemsInput, JobUncheckedUpdateWithoutParsedSpecItemsInput>
  }

  export type JobUpdateWithoutParsedSpecItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutJobsNestedInput
    room?: RoomUpdateOneRequiredWithoutJobsNestedInput
    deal?: DealUpdateOneWithoutJobNestedInput
    installerCompany?: InstallerCompanyUpdateOneWithoutJobsNestedInput
    designer?: UserUpdateOneWithoutDesignerJobsNestedInput
    tasks?: TaskUpdateManyWithoutJobNestedInput
    appointments?: AppointmentUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUpdateManyWithoutJobNestedInput
    snags?: SnagUpdateManyWithoutJobNestedInput
    documents?: DocumentUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutParsedSpecItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    installerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    designerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUncheckedUpdateOneWithoutJobNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutJobNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutJobNestedInput
    snags?: SnagUncheckedUpdateManyWithoutJobNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUncheckedUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobCreateWithoutSnagsInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutJobsInput
    room: RoomCreateNestedOneWithoutJobsInput
    deal?: DealCreateNestedOneWithoutJobInput
    installerCompany?: InstallerCompanyCreateNestedOneWithoutJobsInput
    designer?: UserCreateNestedOneWithoutDesignerJobsInput
    tasks?: TaskCreateNestedManyWithoutJobInput
    appointments?: AppointmentCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionCreateNestedManyWithoutJobInput
    documents?: DocumentCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemCreateNestedManyWithoutJobInput
    moodboards?: MoodboardCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutSnagsInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    clientId: string
    roomId: string
    dealId?: string | null
    installerCompanyId?: string | null
    designerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deal?: DealUncheckedCreateNestedOneWithoutJobInput
    tasks?: TaskUncheckedCreateNestedManyWithoutJobInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutJobInput
    documents?: DocumentUncheckedCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemUncheckedCreateNestedManyWithoutJobInput
    moodboards?: MoodboardUncheckedCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutSnagsInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutSnagsInput, JobUncheckedCreateWithoutSnagsInput>
  }

  export type UserCreateWithoutSnagReportsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatedByInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionCreateNestedManyWithoutDesignerInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentCreateNestedManyWithoutAuthorInput
    snagAssignments?: SnagCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateWithoutSnagReportsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutDesignerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientUncheckedCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobUncheckedCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput
    snagAssignments?: SnagUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogUncheckedCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserCreateOrConnectWithoutSnagReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSnagReportsInput, UserUncheckedCreateWithoutSnagReportsInput>
  }

  export type UserCreateWithoutSnagAssignmentsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatedByInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionCreateNestedManyWithoutDesignerInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentCreateNestedManyWithoutAuthorInput
    snagReports?: SnagCreateNestedManyWithoutReportedByInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateWithoutSnagAssignmentsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutDesignerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientUncheckedCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobUncheckedCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput
    snagReports?: SnagUncheckedCreateNestedManyWithoutReportedByInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogUncheckedCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserCreateOrConnectWithoutSnagAssignmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSnagAssignmentsInput, UserUncheckedCreateWithoutSnagAssignmentsInput>
  }

  export type JobUpsertWithoutSnagsInput = {
    update: XOR<JobUpdateWithoutSnagsInput, JobUncheckedUpdateWithoutSnagsInput>
    create: XOR<JobCreateWithoutSnagsInput, JobUncheckedCreateWithoutSnagsInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutSnagsInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutSnagsInput, JobUncheckedUpdateWithoutSnagsInput>
  }

  export type JobUpdateWithoutSnagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutJobsNestedInput
    room?: RoomUpdateOneRequiredWithoutJobsNestedInput
    deal?: DealUpdateOneWithoutJobNestedInput
    installerCompany?: InstallerCompanyUpdateOneWithoutJobsNestedInput
    designer?: UserUpdateOneWithoutDesignerJobsNestedInput
    tasks?: TaskUpdateManyWithoutJobNestedInput
    appointments?: AppointmentUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUpdateManyWithoutJobNestedInput
    documents?: DocumentUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutSnagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    installerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    designerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUncheckedUpdateOneWithoutJobNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutJobNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutJobNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUncheckedUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUncheckedUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUncheckedUpdateManyWithoutJobNestedInput
  }

  export type UserUpsertWithoutSnagReportsInput = {
    update: XOR<UserUpdateWithoutSnagReportsInput, UserUncheckedUpdateWithoutSnagReportsInput>
    create: XOR<UserCreateWithoutSnagReportsInput, UserUncheckedCreateWithoutSnagReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSnagReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSnagReportsInput, UserUncheckedUpdateWithoutSnagReportsInput>
  }

  export type UserUpdateWithoutSnagReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUpdateManyWithoutAuthorNestedInput
    snagAssignments?: SnagUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSnagReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUncheckedUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUncheckedUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snagAssignments?: SnagUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUncheckedUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUpsertWithoutSnagAssignmentsInput = {
    update: XOR<UserUpdateWithoutSnagAssignmentsInput, UserUncheckedUpdateWithoutSnagAssignmentsInput>
    create: XOR<UserCreateWithoutSnagAssignmentsInput, UserUncheckedCreateWithoutSnagAssignmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSnagAssignmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSnagAssignmentsInput, UserUncheckedUpdateWithoutSnagAssignmentsInput>
  }

  export type UserUpdateWithoutSnagAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUpdateManyWithoutReportedByNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSnagAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUncheckedUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUncheckedUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUncheckedUpdateManyWithoutReportedByNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUncheckedUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type ClientCreateWithoutDocumentsInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedClientsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedClientsInput
    owner: UserCreateNestedOneWithoutOwnedClientsInput
    contacts?: ContactCreateNestedManyWithoutClientInput
    leads?: LeadCreateNestedManyWithoutClientInput
    deals?: DealCreateNestedManyWithoutClientInput
    rooms?: RoomCreateNestedManyWithoutClientInput
    jobs?: JobCreateNestedManyWithoutClientInput
    activities?: ActivityCreateNestedManyWithoutClientInput
    appointments?: AppointmentCreateNestedManyWithoutClientInput
    moodboards?: MoodboardCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutDocumentsInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownerId: string
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    leads?: LeadUncheckedCreateNestedManyWithoutClientInput
    deals?: DealUncheckedCreateNestedManyWithoutClientInput
    rooms?: RoomUncheckedCreateNestedManyWithoutClientInput
    jobs?: JobUncheckedCreateNestedManyWithoutClientInput
    activities?: ActivityUncheckedCreateNestedManyWithoutClientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClientInput
    moodboards?: MoodboardUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutDocumentsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>
  }

  export type DealCreateWithoutDocumentsInput = {
    id?: string
    title: string
    description?: string | null
    value: Decimal | DecimalJsLike | number | string
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    stage: PipelineStageCreateNestedOneWithoutDealsInput
    client: ClientCreateNestedOneWithoutDealsInput
    owner: UserCreateNestedOneWithoutOwnedDealsInput
    lead?: LeadCreateNestedOneWithoutDealInput
    job?: JobCreateNestedOneWithoutDealInput
    activities?: ActivityCreateNestedManyWithoutDealInput
    tasks?: TaskCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutDocumentsInput = {
    id?: string
    title: string
    description?: string | null
    value: Decimal | DecimalJsLike | number | string
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    stageId: string
    clientId: string
    ownerId: string
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    lead?: LeadUncheckedCreateNestedOneWithoutDealInput
    activities?: ActivityUncheckedCreateNestedManyWithoutDealInput
    tasks?: TaskUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutDocumentsInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutDocumentsInput, DealUncheckedCreateWithoutDocumentsInput>
  }

  export type JobCreateWithoutDocumentsInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutJobsInput
    room: RoomCreateNestedOneWithoutJobsInput
    deal?: DealCreateNestedOneWithoutJobInput
    installerCompany?: InstallerCompanyCreateNestedOneWithoutJobsInput
    designer?: UserCreateNestedOneWithoutDesignerJobsInput
    tasks?: TaskCreateNestedManyWithoutJobInput
    appointments?: AppointmentCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionCreateNestedManyWithoutJobInput
    snags?: SnagCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemCreateNestedManyWithoutJobInput
    moodboards?: MoodboardCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutDocumentsInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    clientId: string
    roomId: string
    dealId?: string | null
    installerCompanyId?: string | null
    designerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deal?: DealUncheckedCreateNestedOneWithoutJobInput
    tasks?: TaskUncheckedCreateNestedManyWithoutJobInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutJobInput
    snags?: SnagUncheckedCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemUncheckedCreateNestedManyWithoutJobInput
    moodboards?: MoodboardUncheckedCreateNestedManyWithoutJobInput
    handoverPacks?: HandoverPackUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutDocumentsInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutDocumentsInput, JobUncheckedCreateWithoutDocumentsInput>
  }

  export type UserCreateWithoutUploadedDocumentsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatedByInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionCreateNestedManyWithoutDesignerInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentCreateNestedManyWithoutAuthorInput
    snagReports?: SnagCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagCreateNestedManyWithoutAssignedToInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateWithoutUploadedDocumentsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutDesignerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientUncheckedCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobUncheckedCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput
    snagReports?: SnagUncheckedCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagUncheckedCreateNestedManyWithoutAssignedToInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogUncheckedCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserCreateOrConnectWithoutUploadedDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
  }

  export type ClientUpsertWithoutDocumentsInput = {
    update: XOR<ClientUpdateWithoutDocumentsInput, ClientUncheckedUpdateWithoutDocumentsInput>
    create: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutDocumentsInput, ClientUncheckedUpdateWithoutDocumentsInput>
  }

  export type ClientUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedClientsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedClientsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedClientsNestedInput
    contacts?: ContactUpdateManyWithoutClientNestedInput
    leads?: LeadUpdateManyWithoutClientNestedInput
    deals?: DealUpdateManyWithoutClientNestedInput
    rooms?: RoomUpdateManyWithoutClientNestedInput
    jobs?: JobUpdateManyWithoutClientNestedInput
    activities?: ActivityUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUpdateManyWithoutClientNestedInput
    moodboards?: MoodboardUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    leads?: LeadUncheckedUpdateManyWithoutClientNestedInput
    deals?: DealUncheckedUpdateManyWithoutClientNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutClientNestedInput
    jobs?: JobUncheckedUpdateManyWithoutClientNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClientNestedInput
    moodboards?: MoodboardUncheckedUpdateManyWithoutClientNestedInput
  }

  export type DealUpsertWithoutDocumentsInput = {
    update: XOR<DealUpdateWithoutDocumentsInput, DealUncheckedUpdateWithoutDocumentsInput>
    create: XOR<DealCreateWithoutDocumentsInput, DealUncheckedCreateWithoutDocumentsInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutDocumentsInput, DealUncheckedUpdateWithoutDocumentsInput>
  }

  export type DealUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: PipelineStageUpdateOneRequiredWithoutDealsNestedInput
    client?: ClientUpdateOneRequiredWithoutDealsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedDealsNestedInput
    lead?: LeadUpdateOneWithoutDealNestedInput
    job?: JobUpdateOneWithoutDealNestedInput
    activities?: ActivityUpdateManyWithoutDealNestedInput
    tasks?: TaskUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stageId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    lead?: LeadUncheckedUpdateOneWithoutDealNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutDealNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutDealNestedInput
  }

  export type JobUpsertWithoutDocumentsInput = {
    update: XOR<JobUpdateWithoutDocumentsInput, JobUncheckedUpdateWithoutDocumentsInput>
    create: XOR<JobCreateWithoutDocumentsInput, JobUncheckedCreateWithoutDocumentsInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutDocumentsInput, JobUncheckedUpdateWithoutDocumentsInput>
  }

  export type JobUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutJobsNestedInput
    room?: RoomUpdateOneRequiredWithoutJobsNestedInput
    deal?: DealUpdateOneWithoutJobNestedInput
    installerCompany?: InstallerCompanyUpdateOneWithoutJobsNestedInput
    designer?: UserUpdateOneWithoutDesignerJobsNestedInput
    tasks?: TaskUpdateManyWithoutJobNestedInput
    appointments?: AppointmentUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUpdateManyWithoutJobNestedInput
    snags?: SnagUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    installerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    designerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUncheckedUpdateOneWithoutJobNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutJobNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutJobNestedInput
    snags?: SnagUncheckedUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUncheckedUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUncheckedUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUncheckedUpdateManyWithoutJobNestedInput
  }

  export type UserUpsertWithoutUploadedDocumentsInput = {
    update: XOR<UserUpdateWithoutUploadedDocumentsInput, UserUncheckedUpdateWithoutUploadedDocumentsInput>
    create: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedDocumentsInput, UserUncheckedUpdateWithoutUploadedDocumentsInput>
  }

  export type UserUpdateWithoutUploadedDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUpdateManyWithoutAssignedToNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUncheckedUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUncheckedUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUncheckedUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUncheckedUpdateManyWithoutAssignedToNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUncheckedUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type FormSubmissionCreateWithoutTemplateInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    submissionSource?: $Enums.SubmissionSource
    clientId?: string | null
    jobId?: string | null
    submittedAt?: Date | string
    submittedBy?: UserCreateNestedOneWithoutFormSubmissionsInput
  }

  export type FormSubmissionUncheckedCreateWithoutTemplateInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    submissionSource?: $Enums.SubmissionSource
    submittedById?: string | null
    clientId?: string | null
    jobId?: string | null
    submittedAt?: Date | string
  }

  export type FormSubmissionCreateOrConnectWithoutTemplateInput = {
    where: FormSubmissionWhereUniqueInput
    create: XOR<FormSubmissionCreateWithoutTemplateInput, FormSubmissionUncheckedCreateWithoutTemplateInput>
  }

  export type FormSubmissionCreateManyTemplateInputEnvelope = {
    data: FormSubmissionCreateManyTemplateInput | FormSubmissionCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type FormSubmissionUpsertWithWhereUniqueWithoutTemplateInput = {
    where: FormSubmissionWhereUniqueInput
    update: XOR<FormSubmissionUpdateWithoutTemplateInput, FormSubmissionUncheckedUpdateWithoutTemplateInput>
    create: XOR<FormSubmissionCreateWithoutTemplateInput, FormSubmissionUncheckedCreateWithoutTemplateInput>
  }

  export type FormSubmissionUpdateWithWhereUniqueWithoutTemplateInput = {
    where: FormSubmissionWhereUniqueInput
    data: XOR<FormSubmissionUpdateWithoutTemplateInput, FormSubmissionUncheckedUpdateWithoutTemplateInput>
  }

  export type FormSubmissionUpdateManyWithWhereWithoutTemplateInput = {
    where: FormSubmissionScalarWhereInput
    data: XOR<FormSubmissionUpdateManyMutationInput, FormSubmissionUncheckedUpdateManyWithoutTemplateInput>
  }

  export type FormTemplateCreateWithoutSubmissionsInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.FormCategory
    schema: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormTemplateUncheckedCreateWithoutSubmissionsInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.FormCategory
    schema: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormTemplateCreateOrConnectWithoutSubmissionsInput = {
    where: FormTemplateWhereUniqueInput
    create: XOR<FormTemplateCreateWithoutSubmissionsInput, FormTemplateUncheckedCreateWithoutSubmissionsInput>
  }

  export type UserCreateWithoutFormSubmissionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatedByInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionCreateNestedManyWithoutDesignerInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentCreateNestedManyWithoutAuthorInput
    snagReports?: SnagCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploadedByInput
    eventLogs?: EventLogCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateWithoutFormSubmissionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutDesignerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientUncheckedCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobUncheckedCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput
    snagReports?: SnagUncheckedCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    eventLogs?: EventLogUncheckedCreateNestedManyWithoutUserInput
    mergeReviews?: MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserCreateOrConnectWithoutFormSubmissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFormSubmissionsInput, UserUncheckedCreateWithoutFormSubmissionsInput>
  }

  export type FormTemplateUpsertWithoutSubmissionsInput = {
    update: XOR<FormTemplateUpdateWithoutSubmissionsInput, FormTemplateUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<FormTemplateCreateWithoutSubmissionsInput, FormTemplateUncheckedCreateWithoutSubmissionsInput>
    where?: FormTemplateWhereInput
  }

  export type FormTemplateUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: FormTemplateWhereInput
    data: XOR<FormTemplateUpdateWithoutSubmissionsInput, FormTemplateUncheckedUpdateWithoutSubmissionsInput>
  }

  export type FormTemplateUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumFormCategoryFieldUpdateOperationsInput | $Enums.FormCategory
    schema?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormTemplateUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumFormCategoryFieldUpdateOperationsInput | $Enums.FormCategory
    schema?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutFormSubmissionsInput = {
    update: XOR<UserUpdateWithoutFormSubmissionsInput, UserUncheckedUpdateWithoutFormSubmissionsInput>
    create: XOR<UserCreateWithoutFormSubmissionsInput, UserUncheckedCreateWithoutFormSubmissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFormSubmissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFormSubmissionsInput, UserUncheckedUpdateWithoutFormSubmissionsInput>
  }

  export type UserUpdateWithoutFormSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploadedByNestedInput
    eventLogs?: EventLogUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateWithoutFormSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUncheckedUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUncheckedUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUncheckedUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    eventLogs?: EventLogUncheckedUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type JobCreateWithoutHandoverPacksInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutJobsInput
    room: RoomCreateNestedOneWithoutJobsInput
    deal?: DealCreateNestedOneWithoutJobInput
    installerCompany?: InstallerCompanyCreateNestedOneWithoutJobsInput
    designer?: UserCreateNestedOneWithoutDesignerJobsInput
    tasks?: TaskCreateNestedManyWithoutJobInput
    appointments?: AppointmentCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionCreateNestedManyWithoutJobInput
    snags?: SnagCreateNestedManyWithoutJobInput
    documents?: DocumentCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemCreateNestedManyWithoutJobInput
    moodboards?: MoodboardCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutHandoverPacksInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    clientId: string
    roomId: string
    dealId?: string | null
    installerCompanyId?: string | null
    designerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deal?: DealUncheckedCreateNestedOneWithoutJobInput
    tasks?: TaskUncheckedCreateNestedManyWithoutJobInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutJobInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutJobInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutJobInput
    snags?: SnagUncheckedCreateNestedManyWithoutJobInput
    documents?: DocumentUncheckedCreateNestedManyWithoutJobInput
    parsedSpecItems?: ParsedSpecItemUncheckedCreateNestedManyWithoutJobInput
    moodboards?: MoodboardUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutHandoverPacksInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutHandoverPacksInput, JobUncheckedCreateWithoutHandoverPacksInput>
  }

  export type JobUpsertWithoutHandoverPacksInput = {
    update: XOR<JobUpdateWithoutHandoverPacksInput, JobUncheckedUpdateWithoutHandoverPacksInput>
    create: XOR<JobCreateWithoutHandoverPacksInput, JobUncheckedCreateWithoutHandoverPacksInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutHandoverPacksInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutHandoverPacksInput, JobUncheckedUpdateWithoutHandoverPacksInput>
  }

  export type JobUpdateWithoutHandoverPacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutJobsNestedInput
    room?: RoomUpdateOneRequiredWithoutJobsNestedInput
    deal?: DealUpdateOneWithoutJobNestedInput
    installerCompany?: InstallerCompanyUpdateOneWithoutJobsNestedInput
    designer?: UserUpdateOneWithoutDesignerJobsNestedInput
    tasks?: TaskUpdateManyWithoutJobNestedInput
    appointments?: AppointmentUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUpdateManyWithoutJobNestedInput
    snags?: SnagUpdateManyWithoutJobNestedInput
    documents?: DocumentUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutHandoverPacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    installerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    designerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUncheckedUpdateOneWithoutJobNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutJobNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutJobNestedInput
    snags?: SnagUncheckedUpdateManyWithoutJobNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUncheckedUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUncheckedUpdateManyWithoutJobNestedInput
  }

  export type EmailSequenceStepCreateWithoutJourneyInput = {
    id?: string
    stepNumber: number
    templateId: string
    delayDays?: number
    delayHours?: number
    sendConditions?: JsonNullValueInput | InputJsonValue
  }

  export type EmailSequenceStepUncheckedCreateWithoutJourneyInput = {
    id?: string
    stepNumber: number
    templateId: string
    delayDays?: number
    delayHours?: number
    sendConditions?: JsonNullValueInput | InputJsonValue
  }

  export type EmailSequenceStepCreateOrConnectWithoutJourneyInput = {
    where: EmailSequenceStepWhereUniqueInput
    create: XOR<EmailSequenceStepCreateWithoutJourneyInput, EmailSequenceStepUncheckedCreateWithoutJourneyInput>
  }

  export type EmailSequenceStepCreateManyJourneyInputEnvelope = {
    data: EmailSequenceStepCreateManyJourneyInput | EmailSequenceStepCreateManyJourneyInput[]
    skipDuplicates?: boolean
  }

  export type EmailSequenceStepUpsertWithWhereUniqueWithoutJourneyInput = {
    where: EmailSequenceStepWhereUniqueInput
    update: XOR<EmailSequenceStepUpdateWithoutJourneyInput, EmailSequenceStepUncheckedUpdateWithoutJourneyInput>
    create: XOR<EmailSequenceStepCreateWithoutJourneyInput, EmailSequenceStepUncheckedCreateWithoutJourneyInput>
  }

  export type EmailSequenceStepUpdateWithWhereUniqueWithoutJourneyInput = {
    where: EmailSequenceStepWhereUniqueInput
    data: XOR<EmailSequenceStepUpdateWithoutJourneyInput, EmailSequenceStepUncheckedUpdateWithoutJourneyInput>
  }

  export type EmailSequenceStepUpdateManyWithWhereWithoutJourneyInput = {
    where: EmailSequenceStepScalarWhereInput
    data: XOR<EmailSequenceStepUpdateManyMutationInput, EmailSequenceStepUncheckedUpdateManyWithoutJourneyInput>
  }

  export type EmailSequenceStepScalarWhereInput = {
    AND?: EmailSequenceStepScalarWhereInput | EmailSequenceStepScalarWhereInput[]
    OR?: EmailSequenceStepScalarWhereInput[]
    NOT?: EmailSequenceStepScalarWhereInput | EmailSequenceStepScalarWhereInput[]
    id?: StringFilter<"EmailSequenceStep"> | string
    stepNumber?: IntFilter<"EmailSequenceStep"> | number
    templateId?: StringFilter<"EmailSequenceStep"> | string
    delayDays?: IntFilter<"EmailSequenceStep"> | number
    delayHours?: IntFilter<"EmailSequenceStep"> | number
    sendConditions?: JsonFilter<"EmailSequenceStep">
    journeyId?: StringFilter<"EmailSequenceStep"> | string
  }

  export type EmailJourneyCreateWithoutEmailSequenceInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    triggerEvent: $Enums.EmailTrigger
    triggerConditions?: JsonNullValueInput | InputJsonValue
    totalSent?: number
    totalOpened?: number
    totalClicked?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailJourneyUncheckedCreateWithoutEmailSequenceInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    triggerEvent: $Enums.EmailTrigger
    triggerConditions?: JsonNullValueInput | InputJsonValue
    totalSent?: number
    totalOpened?: number
    totalClicked?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailJourneyCreateOrConnectWithoutEmailSequenceInput = {
    where: EmailJourneyWhereUniqueInput
    create: XOR<EmailJourneyCreateWithoutEmailSequenceInput, EmailJourneyUncheckedCreateWithoutEmailSequenceInput>
  }

  export type EmailJourneyUpsertWithoutEmailSequenceInput = {
    update: XOR<EmailJourneyUpdateWithoutEmailSequenceInput, EmailJourneyUncheckedUpdateWithoutEmailSequenceInput>
    create: XOR<EmailJourneyCreateWithoutEmailSequenceInput, EmailJourneyUncheckedCreateWithoutEmailSequenceInput>
    where?: EmailJourneyWhereInput
  }

  export type EmailJourneyUpdateToOneWithWhereWithoutEmailSequenceInput = {
    where?: EmailJourneyWhereInput
    data: XOR<EmailJourneyUpdateWithoutEmailSequenceInput, EmailJourneyUncheckedUpdateWithoutEmailSequenceInput>
  }

  export type EmailJourneyUpdateWithoutEmailSequenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    triggerEvent?: EnumEmailTriggerFieldUpdateOperationsInput | $Enums.EmailTrigger
    triggerConditions?: JsonNullValueInput | InputJsonValue
    totalSent?: IntFieldUpdateOperationsInput | number
    totalOpened?: IntFieldUpdateOperationsInput | number
    totalClicked?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailJourneyUncheckedUpdateWithoutEmailSequenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    triggerEvent?: EnumEmailTriggerFieldUpdateOperationsInput | $Enums.EmailTrigger
    triggerConditions?: JsonNullValueInput | InputJsonValue
    totalSent?: IntFieldUpdateOperationsInput | number
    totalOpened?: IntFieldUpdateOperationsInput | number
    totalClicked?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryCreateWithoutWebhookInput = {
    id?: string
    eventType: $Enums.WebhookEvent
    payload: JsonNullValueInput | InputJsonValue
    httpStatus?: number | null
    responseBody?: string | null
    errorMessage?: string | null
    deliveryAttempts?: number
    deliveredAt?: Date | string | null
    createdAt?: Date | string
  }

  export type WebhookDeliveryUncheckedCreateWithoutWebhookInput = {
    id?: string
    eventType: $Enums.WebhookEvent
    payload: JsonNullValueInput | InputJsonValue
    httpStatus?: number | null
    responseBody?: string | null
    errorMessage?: string | null
    deliveryAttempts?: number
    deliveredAt?: Date | string | null
    createdAt?: Date | string
  }

  export type WebhookDeliveryCreateOrConnectWithoutWebhookInput = {
    where: WebhookDeliveryWhereUniqueInput
    create: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput>
  }

  export type WebhookDeliveryCreateManyWebhookInputEnvelope = {
    data: WebhookDeliveryCreateManyWebhookInput | WebhookDeliveryCreateManyWebhookInput[]
    skipDuplicates?: boolean
  }

  export type WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput = {
    where: WebhookDeliveryWhereUniqueInput
    update: XOR<WebhookDeliveryUpdateWithoutWebhookInput, WebhookDeliveryUncheckedUpdateWithoutWebhookInput>
    create: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput>
  }

  export type WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput = {
    where: WebhookDeliveryWhereUniqueInput
    data: XOR<WebhookDeliveryUpdateWithoutWebhookInput, WebhookDeliveryUncheckedUpdateWithoutWebhookInput>
  }

  export type WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput = {
    where: WebhookDeliveryScalarWhereInput
    data: XOR<WebhookDeliveryUpdateManyMutationInput, WebhookDeliveryUncheckedUpdateManyWithoutWebhookInput>
  }

  export type WebhookDeliveryScalarWhereInput = {
    AND?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
    OR?: WebhookDeliveryScalarWhereInput[]
    NOT?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
    id?: StringFilter<"WebhookDelivery"> | string
    eventType?: EnumWebhookEventFilter<"WebhookDelivery"> | $Enums.WebhookEvent
    payload?: JsonFilter<"WebhookDelivery">
    httpStatus?: IntNullableFilter<"WebhookDelivery"> | number | null
    responseBody?: StringNullableFilter<"WebhookDelivery"> | string | null
    errorMessage?: StringNullableFilter<"WebhookDelivery"> | string | null
    deliveryAttempts?: IntFilter<"WebhookDelivery"> | number
    deliveredAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
    webhookId?: StringFilter<"WebhookDelivery"> | string
    createdAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
  }

  export type WebhookCreateWithoutDeliveriesInput = {
    id?: string
    name: string
    url: string
    events?: WebhookCreateeventsInput | $Enums.WebhookEvent[]
    secret?: string | null
    isActive?: boolean
    totalDeliveries?: number
    lastDeliveryAt?: Date | string | null
    lastSuccessAt?: Date | string | null
    lastFailureAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookUncheckedCreateWithoutDeliveriesInput = {
    id?: string
    name: string
    url: string
    events?: WebhookCreateeventsInput | $Enums.WebhookEvent[]
    secret?: string | null
    isActive?: boolean
    totalDeliveries?: number
    lastDeliveryAt?: Date | string | null
    lastSuccessAt?: Date | string | null
    lastFailureAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookCreateOrConnectWithoutDeliveriesInput = {
    where: WebhookWhereUniqueInput
    create: XOR<WebhookCreateWithoutDeliveriesInput, WebhookUncheckedCreateWithoutDeliveriesInput>
  }

  export type WebhookUpsertWithoutDeliveriesInput = {
    update: XOR<WebhookUpdateWithoutDeliveriesInput, WebhookUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<WebhookCreateWithoutDeliveriesInput, WebhookUncheckedCreateWithoutDeliveriesInput>
    where?: WebhookWhereInput
  }

  export type WebhookUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: WebhookWhereInput
    data: XOR<WebhookUpdateWithoutDeliveriesInput, WebhookUncheckedUpdateWithoutDeliveriesInput>
  }

  export type WebhookUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | $Enums.WebhookEvent[]
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    lastDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailureAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookUncheckedUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | $Enums.WebhookEvent[]
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    lastDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailureAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutEventLogsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatedByInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionCreateNestedManyWithoutDesignerInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentCreateNestedManyWithoutAuthorInput
    snagReports?: SnagCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutSubmittedByInput
    mergeReviews?: MergeQueueCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateWithoutEventLogsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutDesignerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientUncheckedCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobUncheckedCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput
    snagReports?: SnagUncheckedCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    mergeReviews?: MergeQueueUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserCreateOrConnectWithoutEventLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventLogsInput, UserUncheckedCreateWithoutEventLogsInput>
  }

  export type UserUpsertWithoutEventLogsInput = {
    update: XOR<UserUpdateWithoutEventLogsInput, UserUncheckedUpdateWithoutEventLogsInput>
    create: XOR<UserCreateWithoutEventLogsInput, UserUncheckedCreateWithoutEventLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventLogsInput, UserUncheckedUpdateWithoutEventLogsInput>
  }

  export type UserUpdateWithoutEventLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutSubmittedByNestedInput
    mergeReviews?: MergeQueueUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateWithoutEventLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUncheckedUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUncheckedUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUncheckedUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    mergeReviews?: MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type UserCreateWithoutMergeReviewsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatedByInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionCreateNestedManyWithoutDesignerInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentCreateNestedManyWithoutAuthorInput
    snagReports?: SnagCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMergeReviewsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    ownedClients?: ClientUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedDeals?: DealUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    jobDayLogs?: JobDayLogUncheckedCreateNestedManyWithoutUserInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutDesignerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    updatedClients?: ClientUncheckedCreateNestedManyWithoutUpdatedByInput
    designerJobs?: JobUncheckedCreateNestedManyWithoutDesignerInput
    installerCompanies?: InstallerCompanyUncheckedCreateNestedManyWithoutOwnerInput
    clashReports?: DesignClashTicketUncheckedCreateNestedManyWithoutReportedByInput
    clashAssignments?: DesignClashTicketUncheckedCreateNestedManyWithoutAssignedToInput
    moodboardComments?: MoodboardCommentUncheckedCreateNestedManyWithoutAuthorInput
    snagReports?: SnagUncheckedCreateNestedManyWithoutReportedByInput
    snagAssignments?: SnagUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    eventLogs?: EventLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMergeReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMergeReviewsInput, UserUncheckedCreateWithoutMergeReviewsInput>
  }

  export type UserUpsertWithoutMergeReviewsInput = {
    update: XOR<UserUpdateWithoutMergeReviewsInput, UserUncheckedUpdateWithoutMergeReviewsInput>
    create: XOR<UserCreateWithoutMergeReviewsInput, UserUncheckedCreateWithoutMergeReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMergeReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMergeReviewsInput, UserUncheckedUpdateWithoutMergeReviewsInput>
  }

  export type UserUpdateWithoutMergeReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMergeReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUncheckedUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUncheckedUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUncheckedUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyCreatedByInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: string | null
  }

  export type UserCreateManyUpdatedByInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type ClientCreateManyOwnerInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
  }

  export type LeadCreateManyOwnerInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    clientId: string
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
  }

  export type DealCreateManyOwnerInput = {
    id?: string
    title: string
    description?: string | null
    value: Decimal | DecimalJsLike | number | string
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    stageId: string
    clientId: string
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
  }

  export type TaskCreateManyAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdById: string
    clientId?: string | null
    leadId?: string | null
    dealId?: string | null
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateManyCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    assigneeId: string
    clientId?: string | null
    leadId?: string | null
    dealId?: string | null
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityCreateManyUserInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    description?: string | null
    direction?: $Enums.Direction | null
    duration?: number | null
    outcome?: string | null
    clientId?: string | null
    contactId?: string | null
    leadId?: string | null
    dealId?: string | null
    emailMessageId?: string | null
    callRecordingUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type AppointmentCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    meetingUrl?: string | null
    status?: $Enums.AppointmentStatus
    clientId: string
    jobId?: string | null
    outlookEventId?: string | null
    calendarSynced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobDayLogCreateManyUserInput = {
    id?: string
    date: Date | string
    jobId: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    lunchStart?: Date | string | null
    lunchEnd?: Date | string | null
    checkInLatitude?: Decimal | DecimalJsLike | number | string | null
    checkInLongitude?: Decimal | DecimalJsLike | number | string | null
    checkInAddress?: string | null
    workCompleted?: string | null
    materialsUsed?: string | null
    issuesEncountered?: string | null
    startFormData?: NullableJsonNullValueInput | InputJsonValue
    dailyFormData?: NullableJsonNullValueInput | InputJsonValue
    endFormData?: NullableJsonNullValueInput | InputJsonValue
    photos?: JobDayLogCreatephotosInput | string[]
    isCompliant?: boolean
    complianceNotes?: string | null
    syncStatus?: $Enums.SyncStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignVersionCreateManyDesignerInput = {
    id?: string
    version?: number
    title: string
    description?: string | null
    status?: $Enums.DesignStatus
    renderUrls?: DesignVersionCreaterenderUrlsInput | string[]
    planUrls?: DesignVersionCreateplanUrlsInput | string[]
    specSheetUrl?: string | null
    isClientVisible?: boolean
    clientViewedAt?: Date | string | null
    clientApprovedAt?: Date | string | null
    clientFeedback?: string | null
    jobId: string
    isFinal?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientCreateManyCreatedByInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: string | null
    ownerId: string
  }

  export type ClientCreateManyUpdatedByInput = {
    id?: string
    companyName?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    county?: string | null
    postcode?: string | null
    country?: string
    clientType?: $Enums.ClientType
    leadSource?: string | null
    referralSource?: string | null
    portalKey?: string | null
    portalLastAccessAt?: Date | string | null
    marketingConsent?: boolean
    marketingConsentDate?: Date | string | null
    emailConsent?: boolean
    smsConsent?: boolean
    callRecordingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    ownerId: string
  }

  export type JobCreateManyDesignerInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    clientId: string
    roomId: string
    dealId?: string | null
    installerCompanyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstallerCompanyCreateManyOwnerInput = {
    id?: string
    name: string
    contactEmail: string
    contactPhone: string
    address?: string | null
    insuranceExpiry?: Date | string | null
    dbsExpiry?: Date | string | null
    contractSigned?: boolean
    contractSignedAt?: Date | string | null
    isActive?: boolean
    isSuspended?: boolean
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignClashTicketCreateManyReportedByInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ClashStatus
    priority?: $Enums.Priority
    photoUrls?: DesignClashTicketCreatephotoUrlsInput | string[]
    resolution?: string | null
    resolvedAt?: Date | string | null
    designVersionId: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignClashTicketCreateManyAssignedToInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ClashStatus
    priority?: $Enums.Priority
    photoUrls?: DesignClashTicketCreatephotoUrlsInput | string[]
    resolution?: string | null
    resolvedAt?: Date | string | null
    designVersionId: string
    reportedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MoodboardCommentCreateManyAuthorInput = {
    id?: string
    content: string
    xPosition: number
    yPosition: number
    authorName?: string | null
    itemId: string
    createdAt?: Date | string
  }

  export type SnagCreateManyReportedByInput = {
    id?: string
    title: string
    description: string
    category: $Enums.SnagCategory
    severity?: $Enums.Priority
    status?: $Enums.SnagStatus
    photoUrls?: SnagCreatephotoUrlsInput | string[]
    isClientVisible?: boolean
    clientNotified?: boolean
    resolution?: string | null
    resolvedAt?: Date | string | null
    jobId: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SnagCreateManyAssignedToInput = {
    id?: string
    title: string
    description: string
    category: $Enums.SnagCategory
    severity?: $Enums.Priority
    status?: $Enums.SnagStatus
    photoUrls?: SnagCreatephotoUrlsInput | string[]
    isClientVisible?: boolean
    clientNotified?: boolean
    resolution?: string | null
    resolvedAt?: Date | string | null
    jobId: string
    reportedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyUploadedByInput = {
    id?: string
    filename: string
    originalFilename: string
    mimeType: string
    fileSize: number
    storageUrl: string
    category: $Enums.DocumentCategory
    description?: string | null
    isPublic?: boolean
    virusScanStatus?: $Enums.VirusScanStatus
    virusScanResult?: string | null
    clientId?: string | null
    dealId?: string | null
    jobId?: string | null
    createdAt?: Date | string
  }

  export type FormSubmissionCreateManySubmittedByInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    submissionSource?: $Enums.SubmissionSource
    templateId: string
    clientId?: string | null
    jobId?: string | null
    submittedAt?: Date | string
  }

  export type EventLogCreateManyUserInput = {
    id?: string
    eventType: string
    entityType: string
    entityId: string
    changes: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    occurredAt?: Date | string
  }

  export type MergeQueueCreateManyReviewedByInput = {
    id?: string
    entityType: string
    primaryEntityId: string
    duplicateEntityId: string
    status?: $Enums.MergeStatus
    mergeRules: JsonNullValueInput | InputJsonValue
    reviewedAt?: Date | string | null
    mergedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUncheckedUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUncheckedUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUncheckedUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUncheckedUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    ownedClients?: ClientUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedDeals?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutUserNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutDesignerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedClients?: ClientUncheckedUpdateManyWithoutUpdatedByNestedInput
    designerJobs?: JobUncheckedUpdateManyWithoutDesignerNestedInput
    installerCompanies?: InstallerCompanyUncheckedUpdateManyWithoutOwnerNestedInput
    clashReports?: DesignClashTicketUncheckedUpdateManyWithoutReportedByNestedInput
    clashAssignments?: DesignClashTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    moodboardComments?: MoodboardCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snagReports?: SnagUncheckedUpdateManyWithoutReportedByNestedInput
    snagAssignments?: SnagUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    eventLogs?: EventLogUncheckedUpdateManyWithoutUserNestedInput
    mergeReviews?: MergeQueueUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedClientsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedClientsNestedInput
    contacts?: ContactUpdateManyWithoutClientNestedInput
    leads?: LeadUpdateManyWithoutClientNestedInput
    deals?: DealUpdateManyWithoutClientNestedInput
    rooms?: RoomUpdateManyWithoutClientNestedInput
    jobs?: JobUpdateManyWithoutClientNestedInput
    activities?: ActivityUpdateManyWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUpdateManyWithoutClientNestedInput
    moodboards?: MoodboardUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    leads?: LeadUncheckedUpdateManyWithoutClientNestedInput
    deals?: DealUncheckedUpdateManyWithoutClientNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutClientNestedInput
    jobs?: JobUncheckedUpdateManyWithoutClientNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClientNestedInput
    moodboards?: MoodboardUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeadUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutLeadsNestedInput
    deal?: DealUpdateOneWithoutLeadNestedInput
    activities?: ActivityUpdateManyWithoutLeadNestedInput
    tasks?: TaskUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutLeadNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DealUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: PipelineStageUpdateOneRequiredWithoutDealsNestedInput
    client?: ClientUpdateOneRequiredWithoutDealsNestedInput
    lead?: LeadUpdateOneWithoutDealNestedInput
    job?: JobUpdateOneWithoutDealNestedInput
    activities?: ActivityUpdateManyWithoutDealNestedInput
    tasks?: TaskUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stageId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    lead?: LeadUncheckedUpdateOneWithoutDealNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutDealNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stageId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTasksNestedInput
    lead?: LeadUpdateOneWithoutTasksNestedInput
    deal?: DealUpdateOneWithoutTasksNestedInput
    job?: JobUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignee?: UserUpdateOneRequiredWithoutAssignedTasksNestedInput
    lead?: LeadUpdateOneWithoutTasksNestedInput
    deal?: DealUpdateOneWithoutTasksNestedInput
    job?: JobUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: NullableEnumDirectionFieldUpdateOperationsInput | $Enums.Direction | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    emailMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    callRecordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneWithoutActivitiesNestedInput
    contact?: ContactUpdateOneWithoutActivitiesNestedInput
    lead?: LeadUpdateOneWithoutActivitiesNestedInput
    deal?: DealUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: NullableEnumDirectionFieldUpdateOperationsInput | $Enums.Direction | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    emailMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    callRecordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActivityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: NullableEnumDirectionFieldUpdateOperationsInput | $Enums.Direction | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    emailMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    callRecordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AppointmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    outlookEventId?: NullableStringFieldUpdateOperationsInput | string | null
    calendarSynced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutAppointmentsNestedInput
    job?: JobUpdateOneWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    clientId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    outlookEventId?: NullableStringFieldUpdateOperationsInput | string | null
    calendarSynced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    clientId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    outlookEventId?: NullableStringFieldUpdateOperationsInput | string | null
    calendarSynced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobDayLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lunchStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lunchEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInLatitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    checkInLongitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    checkInAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workCompleted?: NullableStringFieldUpdateOperationsInput | string | null
    materialsUsed?: NullableStringFieldUpdateOperationsInput | string | null
    issuesEncountered?: NullableStringFieldUpdateOperationsInput | string | null
    startFormData?: NullableJsonNullValueInput | InputJsonValue
    dailyFormData?: NullableJsonNullValueInput | InputJsonValue
    endFormData?: NullableJsonNullValueInput | InputJsonValue
    photos?: JobDayLogUpdatephotosInput | string[]
    isCompliant?: BoolFieldUpdateOperationsInput | boolean
    complianceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutJobDayLogsNestedInput
  }

  export type JobDayLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobId?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lunchStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lunchEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInLatitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    checkInLongitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    checkInAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workCompleted?: NullableStringFieldUpdateOperationsInput | string | null
    materialsUsed?: NullableStringFieldUpdateOperationsInput | string | null
    issuesEncountered?: NullableStringFieldUpdateOperationsInput | string | null
    startFormData?: NullableJsonNullValueInput | InputJsonValue
    dailyFormData?: NullableJsonNullValueInput | InputJsonValue
    endFormData?: NullableJsonNullValueInput | InputJsonValue
    photos?: JobDayLogUpdatephotosInput | string[]
    isCompliant?: BoolFieldUpdateOperationsInput | boolean
    complianceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobDayLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobId?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lunchStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lunchEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInLatitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    checkInLongitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    checkInAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workCompleted?: NullableStringFieldUpdateOperationsInput | string | null
    materialsUsed?: NullableStringFieldUpdateOperationsInput | string | null
    issuesEncountered?: NullableStringFieldUpdateOperationsInput | string | null
    startFormData?: NullableJsonNullValueInput | InputJsonValue
    dailyFormData?: NullableJsonNullValueInput | InputJsonValue
    endFormData?: NullableJsonNullValueInput | InputJsonValue
    photos?: JobDayLogUpdatephotosInput | string[]
    isCompliant?: BoolFieldUpdateOperationsInput | boolean
    complianceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignVersionUpdateWithoutDesignerInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDesignStatusFieldUpdateOperationsInput | $Enums.DesignStatus
    renderUrls?: DesignVersionUpdaterenderUrlsInput | string[]
    planUrls?: DesignVersionUpdateplanUrlsInput | string[]
    specSheetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutDesignVersionsNestedInput
    clashTickets?: DesignClashTicketUpdateManyWithoutDesignVersionNestedInput
  }

  export type DesignVersionUncheckedUpdateWithoutDesignerInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDesignStatusFieldUpdateOperationsInput | $Enums.DesignStatus
    renderUrls?: DesignVersionUpdaterenderUrlsInput | string[]
    planUrls?: DesignVersionUpdateplanUrlsInput | string[]
    specSheetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: StringFieldUpdateOperationsInput | string
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clashTickets?: DesignClashTicketUncheckedUpdateManyWithoutDesignVersionNestedInput
  }

  export type DesignVersionUncheckedUpdateManyWithoutDesignerInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDesignStatusFieldUpdateOperationsInput | $Enums.DesignStatus
    renderUrls?: DesignVersionUpdaterenderUrlsInput | string[]
    planUrls?: DesignVersionUpdateplanUrlsInput | string[]
    specSheetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: StringFieldUpdateOperationsInput | string
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: UserUpdateOneWithoutUpdatedClientsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedClientsNestedInput
    contacts?: ContactUpdateManyWithoutClientNestedInput
    leads?: LeadUpdateManyWithoutClientNestedInput
    deals?: DealUpdateManyWithoutClientNestedInput
    rooms?: RoomUpdateManyWithoutClientNestedInput
    jobs?: JobUpdateManyWithoutClientNestedInput
    activities?: ActivityUpdateManyWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUpdateManyWithoutClientNestedInput
    moodboards?: MoodboardUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    leads?: LeadUncheckedUpdateManyWithoutClientNestedInput
    deals?: DealUncheckedUpdateManyWithoutClientNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutClientNestedInput
    jobs?: JobUncheckedUpdateManyWithoutClientNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClientNestedInput
    moodboards?: MoodboardUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedClientsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedClientsNestedInput
    contacts?: ContactUpdateManyWithoutClientNestedInput
    leads?: LeadUpdateManyWithoutClientNestedInput
    deals?: DealUpdateManyWithoutClientNestedInput
    rooms?: RoomUpdateManyWithoutClientNestedInput
    jobs?: JobUpdateManyWithoutClientNestedInput
    activities?: ActivityUpdateManyWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUpdateManyWithoutClientNestedInput
    moodboards?: MoodboardUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    leads?: LeadUncheckedUpdateManyWithoutClientNestedInput
    deals?: DealUncheckedUpdateManyWithoutClientNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutClientNestedInput
    jobs?: JobUncheckedUpdateManyWithoutClientNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClientNestedInput
    moodboards?: MoodboardUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    portalKey?: NullableStringFieldUpdateOperationsInput | string | null
    portalLastAccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    marketingConsentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailConsent?: BoolFieldUpdateOperationsInput | boolean
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    callRecordingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
  }

  export type JobUpdateWithoutDesignerInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutJobsNestedInput
    room?: RoomUpdateOneRequiredWithoutJobsNestedInput
    deal?: DealUpdateOneWithoutJobNestedInput
    installerCompany?: InstallerCompanyUpdateOneWithoutJobsNestedInput
    tasks?: TaskUpdateManyWithoutJobNestedInput
    appointments?: AppointmentUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUpdateManyWithoutJobNestedInput
    snags?: SnagUpdateManyWithoutJobNestedInput
    documents?: DocumentUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutDesignerInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    installerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUncheckedUpdateOneWithoutJobNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutJobNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutJobNestedInput
    snags?: SnagUncheckedUpdateManyWithoutJobNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUncheckedUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUncheckedUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateManyWithoutDesignerInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    installerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstallerCompanyUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dbsExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractSigned?: BoolFieldUpdateOperationsInput | boolean
    contractSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMembers?: InstallerTeamMemberUpdateManyWithoutCompanyNestedInput
    jobs?: JobUpdateManyWithoutInstallerCompanyNestedInput
  }

  export type InstallerCompanyUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dbsExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractSigned?: BoolFieldUpdateOperationsInput | boolean
    contractSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMembers?: InstallerTeamMemberUncheckedUpdateManyWithoutCompanyNestedInput
    jobs?: JobUncheckedUpdateManyWithoutInstallerCompanyNestedInput
  }

  export type InstallerCompanyUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dbsExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractSigned?: BoolFieldUpdateOperationsInput | boolean
    contractSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignClashTicketUpdateWithoutReportedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumClashStatusFieldUpdateOperationsInput | $Enums.ClashStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    photoUrls?: DesignClashTicketUpdatephotoUrlsInput | string[]
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    designVersion?: DesignVersionUpdateOneRequiredWithoutClashTicketsNestedInput
    assignedTo?: UserUpdateOneWithoutClashAssignmentsNestedInput
  }

  export type DesignClashTicketUncheckedUpdateWithoutReportedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumClashStatusFieldUpdateOperationsInput | $Enums.ClashStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    photoUrls?: DesignClashTicketUpdatephotoUrlsInput | string[]
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designVersionId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignClashTicketUncheckedUpdateManyWithoutReportedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumClashStatusFieldUpdateOperationsInput | $Enums.ClashStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    photoUrls?: DesignClashTicketUpdatephotoUrlsInput | string[]
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designVersionId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignClashTicketUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumClashStatusFieldUpdateOperationsInput | $Enums.ClashStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    photoUrls?: DesignClashTicketUpdatephotoUrlsInput | string[]
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    designVersion?: DesignVersionUpdateOneRequiredWithoutClashTicketsNestedInput
    reportedBy?: UserUpdateOneRequiredWithoutClashReportsNestedInput
  }

  export type DesignClashTicketUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumClashStatusFieldUpdateOperationsInput | $Enums.ClashStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    photoUrls?: DesignClashTicketUpdatephotoUrlsInput | string[]
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designVersionId?: StringFieldUpdateOperationsInput | string
    reportedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignClashTicketUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumClashStatusFieldUpdateOperationsInput | $Enums.ClashStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    photoUrls?: DesignClashTicketUpdatephotoUrlsInput | string[]
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designVersionId?: StringFieldUpdateOperationsInput | string
    reportedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodboardCommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    xPosition?: FloatFieldUpdateOperationsInput | number
    yPosition?: FloatFieldUpdateOperationsInput | number
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: MoodboardItemUpdateOneRequiredWithoutClientCommentsNestedInput
  }

  export type MoodboardCommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    xPosition?: FloatFieldUpdateOperationsInput | number
    yPosition?: FloatFieldUpdateOperationsInput | number
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodboardCommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    xPosition?: FloatFieldUpdateOperationsInput | number
    yPosition?: FloatFieldUpdateOperationsInput | number
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnagUpdateWithoutReportedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumSnagCategoryFieldUpdateOperationsInput | $Enums.SnagCategory
    severity?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumSnagStatusFieldUpdateOperationsInput | $Enums.SnagStatus
    photoUrls?: SnagUpdatephotoUrlsInput | string[]
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientNotified?: BoolFieldUpdateOperationsInput | boolean
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutSnagsNestedInput
    assignedTo?: UserUpdateOneWithoutSnagAssignmentsNestedInput
  }

  export type SnagUncheckedUpdateWithoutReportedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumSnagCategoryFieldUpdateOperationsInput | $Enums.SnagCategory
    severity?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumSnagStatusFieldUpdateOperationsInput | $Enums.SnagStatus
    photoUrls?: SnagUpdatephotoUrlsInput | string[]
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientNotified?: BoolFieldUpdateOperationsInput | boolean
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnagUncheckedUpdateManyWithoutReportedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumSnagCategoryFieldUpdateOperationsInput | $Enums.SnagCategory
    severity?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumSnagStatusFieldUpdateOperationsInput | $Enums.SnagStatus
    photoUrls?: SnagUpdatephotoUrlsInput | string[]
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientNotified?: BoolFieldUpdateOperationsInput | boolean
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnagUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumSnagCategoryFieldUpdateOperationsInput | $Enums.SnagCategory
    severity?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumSnagStatusFieldUpdateOperationsInput | $Enums.SnagStatus
    photoUrls?: SnagUpdatephotoUrlsInput | string[]
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientNotified?: BoolFieldUpdateOperationsInput | boolean
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutSnagsNestedInput
    reportedBy?: UserUpdateOneRequiredWithoutSnagReportsNestedInput
  }

  export type SnagUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumSnagCategoryFieldUpdateOperationsInput | $Enums.SnagCategory
    severity?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumSnagStatusFieldUpdateOperationsInput | $Enums.SnagStatus
    photoUrls?: SnagUpdatephotoUrlsInput | string[]
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientNotified?: BoolFieldUpdateOperationsInput | boolean
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobId?: StringFieldUpdateOperationsInput | string
    reportedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnagUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumSnagCategoryFieldUpdateOperationsInput | $Enums.SnagCategory
    severity?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumSnagStatusFieldUpdateOperationsInput | $Enums.SnagStatus
    photoUrls?: SnagUpdatephotoUrlsInput | string[]
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientNotified?: BoolFieldUpdateOperationsInput | boolean
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobId?: StringFieldUpdateOperationsInput | string
    reportedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    virusScanStatus?: EnumVirusScanStatusFieldUpdateOperationsInput | $Enums.VirusScanStatus
    virusScanResult?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutDocumentsNestedInput
    deal?: DealUpdateOneWithoutDocumentsNestedInput
    job?: JobUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    virusScanStatus?: EnumVirusScanStatusFieldUpdateOperationsInput | $Enums.VirusScanStatus
    virusScanResult?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    virusScanStatus?: EnumVirusScanStatusFieldUpdateOperationsInput | $Enums.VirusScanStatus
    virusScanResult?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionUpdateWithoutSubmittedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    submissionSource?: EnumSubmissionSourceFieldUpdateOperationsInput | $Enums.SubmissionSource
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: FormTemplateUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type FormSubmissionUncheckedUpdateWithoutSubmittedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    submissionSource?: EnumSubmissionSourceFieldUpdateOperationsInput | $Enums.SubmissionSource
    templateId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionUncheckedUpdateManyWithoutSubmittedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    submissionSource?: EnumSubmissionSourceFieldUpdateOperationsInput | $Enums.SubmissionSource
    templateId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MergeQueueUpdateWithoutReviewedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    primaryEntityId?: StringFieldUpdateOperationsInput | string
    duplicateEntityId?: StringFieldUpdateOperationsInput | string
    status?: EnumMergeStatusFieldUpdateOperationsInput | $Enums.MergeStatus
    mergeRules?: JsonNullValueInput | InputJsonValue
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mergedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MergeQueueUncheckedUpdateWithoutReviewedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    primaryEntityId?: StringFieldUpdateOperationsInput | string
    duplicateEntityId?: StringFieldUpdateOperationsInput | string
    status?: EnumMergeStatusFieldUpdateOperationsInput | $Enums.MergeStatus
    mergeRules?: JsonNullValueInput | InputJsonValue
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mergedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MergeQueueUncheckedUpdateManyWithoutReviewedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    primaryEntityId?: StringFieldUpdateOperationsInput | string
    duplicateEntityId?: StringFieldUpdateOperationsInput | string
    status?: EnumMergeStatusFieldUpdateOperationsInput | $Enums.MergeStatus
    mergeRules?: JsonNullValueInput | InputJsonValue
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mergedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateManyClientInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    jobTitle?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
  }

  export type LeadCreateManyClientInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    ownerId: string
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
  }

  export type DealCreateManyClientInput = {
    id?: string
    title: string
    description?: string | null
    value: Decimal | DecimalJsLike | number | string
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    stageId: string
    ownerId: string
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
  }

  export type RoomCreateManyClientInput = {
    id?: string
    name: string
    type: $Enums.RoomType
    length?: number | null
    width?: number | null
    height?: number | null
    currentCondition?: string | null
    accessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobCreateManyClientInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    roomId: string
    dealId?: string | null
    installerCompanyId?: string | null
    designerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityCreateManyClientInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    description?: string | null
    direction?: $Enums.Direction | null
    duration?: number | null
    outcome?: string | null
    userId: string
    contactId?: string | null
    leadId?: string | null
    dealId?: string | null
    emailMessageId?: string | null
    callRecordingUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type DocumentCreateManyClientInput = {
    id?: string
    filename: string
    originalFilename: string
    mimeType: string
    fileSize: number
    storageUrl: string
    category: $Enums.DocumentCategory
    description?: string | null
    isPublic?: boolean
    virusScanStatus?: $Enums.VirusScanStatus
    virusScanResult?: string | null
    dealId?: string | null
    jobId?: string | null
    createdAt?: Date | string
    uploadedById: string
  }

  export type AppointmentCreateManyClientInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    meetingUrl?: string | null
    status?: $Enums.AppointmentStatus
    userId: string
    jobId?: string | null
    outlookEventId?: string | null
    calendarSynced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MoodboardCreateManyClientInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.MoodboardStatus
    jobId?: string | null
    isClientVisible?: boolean
    clientLastViewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeadUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: UserUpdateOneRequiredWithoutOwnedLeadsNestedInput
    deal?: DealUpdateOneWithoutLeadNestedInput
    activities?: ActivityUpdateManyWithoutLeadNestedInput
    tasks?: TaskUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutLeadNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DealUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: PipelineStageUpdateOneRequiredWithoutDealsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedDealsNestedInput
    lead?: LeadUpdateOneWithoutDealNestedInput
    job?: JobUpdateOneWithoutDealNestedInput
    activities?: ActivityUpdateManyWithoutDealNestedInput
    tasks?: TaskUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stageId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    lead?: LeadUncheckedUpdateOneWithoutDealNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutDealNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stageId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoomUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    length?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    currentCondition?: NullableStringFieldUpdateOperationsInput | string | null
    accessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    length?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    currentCondition?: NullableStringFieldUpdateOperationsInput | string | null
    accessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    length?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    currentCondition?: NullableStringFieldUpdateOperationsInput | string | null
    accessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: RoomUpdateOneRequiredWithoutJobsNestedInput
    deal?: DealUpdateOneWithoutJobNestedInput
    installerCompany?: InstallerCompanyUpdateOneWithoutJobsNestedInput
    designer?: UserUpdateOneWithoutDesignerJobsNestedInput
    tasks?: TaskUpdateManyWithoutJobNestedInput
    appointments?: AppointmentUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUpdateManyWithoutJobNestedInput
    snags?: SnagUpdateManyWithoutJobNestedInput
    documents?: DocumentUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    roomId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    installerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    designerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUncheckedUpdateOneWithoutJobNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutJobNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutJobNestedInput
    snags?: SnagUncheckedUpdateManyWithoutJobNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUncheckedUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUncheckedUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    roomId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    installerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    designerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: NullableEnumDirectionFieldUpdateOperationsInput | $Enums.Direction | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    emailMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    callRecordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput
    contact?: ContactUpdateOneWithoutActivitiesNestedInput
    lead?: LeadUpdateOneWithoutActivitiesNestedInput
    deal?: DealUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: NullableEnumDirectionFieldUpdateOperationsInput | $Enums.Direction | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    emailMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    callRecordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActivityUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: NullableEnumDirectionFieldUpdateOperationsInput | $Enums.Direction | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    emailMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    callRecordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    virusScanStatus?: EnumVirusScanStatusFieldUpdateOperationsInput | $Enums.VirusScanStatus
    virusScanResult?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUpdateOneWithoutDocumentsNestedInput
    job?: JobUpdateOneWithoutDocumentsNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    virusScanStatus?: EnumVirusScanStatusFieldUpdateOperationsInput | $Enums.VirusScanStatus
    virusScanResult?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    virusScanStatus?: EnumVirusScanStatusFieldUpdateOperationsInput | $Enums.VirusScanStatus
    virusScanResult?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type AppointmentUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    outlookEventId?: NullableStringFieldUpdateOperationsInput | string | null
    calendarSynced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    job?: JobUpdateOneWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    userId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    outlookEventId?: NullableStringFieldUpdateOperationsInput | string | null
    calendarSynced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    userId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    outlookEventId?: NullableStringFieldUpdateOperationsInput | string | null
    calendarSynced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodboardUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMoodboardStatusFieldUpdateOperationsInput | $Enums.MoodboardStatus
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientLastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneWithoutMoodboardsNestedInput
    items?: MoodboardItemUpdateManyWithoutMoodboardNestedInput
  }

  export type MoodboardUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMoodboardStatusFieldUpdateOperationsInput | $Enums.MoodboardStatus
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientLastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: MoodboardItemUncheckedUpdateManyWithoutMoodboardNestedInput
  }

  export type MoodboardUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMoodboardStatusFieldUpdateOperationsInput | $Enums.MoodboardStatus
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientLastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyContactInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    description?: string | null
    direction?: $Enums.Direction | null
    duration?: number | null
    outcome?: string | null
    userId: string
    clientId?: string | null
    leadId?: string | null
    dealId?: string | null
    emailMessageId?: string | null
    callRecordingUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type ActivityUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: NullableEnumDirectionFieldUpdateOperationsInput | $Enums.Direction | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    emailMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    callRecordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput
    client?: ClientUpdateOneWithoutActivitiesNestedInput
    lead?: LeadUpdateOneWithoutActivitiesNestedInput
    deal?: DealUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: NullableEnumDirectionFieldUpdateOperationsInput | $Enums.Direction | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    emailMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    callRecordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActivityUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: NullableEnumDirectionFieldUpdateOperationsInput | $Enums.Direction | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    emailMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    callRecordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActivityCreateManyLeadInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    description?: string | null
    direction?: $Enums.Direction | null
    duration?: number | null
    outcome?: string | null
    userId: string
    clientId?: string | null
    contactId?: string | null
    dealId?: string | null
    emailMessageId?: string | null
    callRecordingUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type TaskCreateManyLeadInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    assigneeId: string
    createdById: string
    clientId?: string | null
    dealId?: string | null
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: NullableEnumDirectionFieldUpdateOperationsInput | $Enums.Direction | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    emailMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    callRecordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput
    client?: ClientUpdateOneWithoutActivitiesNestedInput
    contact?: ContactUpdateOneWithoutActivitiesNestedInput
    deal?: DealUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: NullableEnumDirectionFieldUpdateOperationsInput | $Enums.Direction | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    emailMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    callRecordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActivityUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: NullableEnumDirectionFieldUpdateOperationsInput | $Enums.Direction | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    emailMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    callRecordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignee?: UserUpdateOneRequiredWithoutAssignedTasksNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTasksNestedInput
    deal?: DealUpdateOneWithoutTasksNestedInput
    job?: JobUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyDealInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    description?: string | null
    direction?: $Enums.Direction | null
    duration?: number | null
    outcome?: string | null
    userId: string
    clientId?: string | null
    contactId?: string | null
    leadId?: string | null
    emailMessageId?: string | null
    callRecordingUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type TaskCreateManyDealInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    assigneeId: string
    createdById: string
    clientId?: string | null
    leadId?: string | null
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyDealInput = {
    id?: string
    filename: string
    originalFilename: string
    mimeType: string
    fileSize: number
    storageUrl: string
    category: $Enums.DocumentCategory
    description?: string | null
    isPublic?: boolean
    virusScanStatus?: $Enums.VirusScanStatus
    virusScanResult?: string | null
    clientId?: string | null
    jobId?: string | null
    createdAt?: Date | string
    uploadedById: string
  }

  export type ActivityUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: NullableEnumDirectionFieldUpdateOperationsInput | $Enums.Direction | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    emailMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    callRecordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput
    client?: ClientUpdateOneWithoutActivitiesNestedInput
    contact?: ContactUpdateOneWithoutActivitiesNestedInput
    lead?: LeadUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: NullableEnumDirectionFieldUpdateOperationsInput | $Enums.Direction | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    emailMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    callRecordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActivityUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: NullableEnumDirectionFieldUpdateOperationsInput | $Enums.Direction | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    emailMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    callRecordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignee?: UserUpdateOneRequiredWithoutAssignedTasksNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTasksNestedInput
    lead?: LeadUpdateOneWithoutTasksNestedInput
    job?: JobUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    virusScanStatus?: EnumVirusScanStatusFieldUpdateOperationsInput | $Enums.VirusScanStatus
    virusScanResult?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutDocumentsNestedInput
    job?: JobUpdateOneWithoutDocumentsNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    virusScanStatus?: EnumVirusScanStatusFieldUpdateOperationsInput | $Enums.VirusScanStatus
    virusScanResult?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    virusScanStatus?: EnumVirusScanStatusFieldUpdateOperationsInput | $Enums.VirusScanStatus
    virusScanResult?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type DealCreateManyStageInput = {
    id?: string
    title: string
    description?: string | null
    value: Decimal | DecimalJsLike | number | string
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    clientId: string
    ownerId: string
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
  }

  export type DealUpdateWithoutStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutDealsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedDealsNestedInput
    lead?: LeadUpdateOneWithoutDealNestedInput
    job?: JobUpdateOneWithoutDealNestedInput
    activities?: ActivityUpdateManyWithoutDealNestedInput
    tasks?: TaskUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    lead?: LeadUncheckedUpdateOneWithoutDealNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutDealNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateManyWithoutStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobCreateManyRoomInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    clientId: string
    dealId?: string | null
    installerCompanyId?: string | null
    designerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutJobsNestedInput
    deal?: DealUpdateOneWithoutJobNestedInput
    installerCompany?: InstallerCompanyUpdateOneWithoutJobsNestedInput
    designer?: UserUpdateOneWithoutDesignerJobsNestedInput
    tasks?: TaskUpdateManyWithoutJobNestedInput
    appointments?: AppointmentUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUpdateManyWithoutJobNestedInput
    snags?: SnagUpdateManyWithoutJobNestedInput
    documents?: DocumentUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    installerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    designerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUncheckedUpdateOneWithoutJobNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutJobNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutJobNestedInput
    snags?: SnagUncheckedUpdateManyWithoutJobNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUncheckedUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUncheckedUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    installerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    designerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyJobInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    assigneeId: string
    createdById: string
    clientId?: string | null
    leadId?: string | null
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentCreateManyJobInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    meetingUrl?: string | null
    status?: $Enums.AppointmentStatus
    userId: string
    clientId: string
    outlookEventId?: string | null
    calendarSynced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobDayLogCreateManyJobInput = {
    id?: string
    date: Date | string
    userId: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    lunchStart?: Date | string | null
    lunchEnd?: Date | string | null
    checkInLatitude?: Decimal | DecimalJsLike | number | string | null
    checkInLongitude?: Decimal | DecimalJsLike | number | string | null
    checkInAddress?: string | null
    workCompleted?: string | null
    materialsUsed?: string | null
    issuesEncountered?: string | null
    startFormData?: NullableJsonNullValueInput | InputJsonValue
    dailyFormData?: NullableJsonNullValueInput | InputJsonValue
    endFormData?: NullableJsonNullValueInput | InputJsonValue
    photos?: JobDayLogCreatephotosInput | string[]
    isCompliant?: boolean
    complianceNotes?: string | null
    syncStatus?: $Enums.SyncStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignVersionCreateManyJobInput = {
    id?: string
    version?: number
    title: string
    description?: string | null
    status?: $Enums.DesignStatus
    renderUrls?: DesignVersionCreaterenderUrlsInput | string[]
    planUrls?: DesignVersionCreateplanUrlsInput | string[]
    specSheetUrl?: string | null
    isClientVisible?: boolean
    clientViewedAt?: Date | string | null
    clientApprovedAt?: Date | string | null
    clientFeedback?: string | null
    designerId: string
    isFinal?: boolean
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SnagCreateManyJobInput = {
    id?: string
    title: string
    description: string
    category: $Enums.SnagCategory
    severity?: $Enums.Priority
    status?: $Enums.SnagStatus
    photoUrls?: SnagCreatephotoUrlsInput | string[]
    isClientVisible?: boolean
    clientNotified?: boolean
    resolution?: string | null
    resolvedAt?: Date | string | null
    reportedById: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyJobInput = {
    id?: string
    filename: string
    originalFilename: string
    mimeType: string
    fileSize: number
    storageUrl: string
    category: $Enums.DocumentCategory
    description?: string | null
    isPublic?: boolean
    virusScanStatus?: $Enums.VirusScanStatus
    virusScanResult?: string | null
    clientId?: string | null
    dealId?: string | null
    createdAt?: Date | string
    uploadedById: string
  }

  export type ParsedSpecItemCreateManyJobInput = {
    id?: string
    originalText: string
    parsedCategory?: string | null
    parsedBrand?: string | null
    parsedModel?: string | null
    parsedDescription?: string | null
    parsedQuantity?: number | null
    parsedPrice?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.SpecItemStatus
    notes?: string | null
    substitution?: string | null
    actualPrice?: Decimal | DecimalJsLike | number | string | null
    parseConfidence: number
    requiresReview?: boolean
    sourceDocumentId?: string | null
    sourcePage?: number | null
    sourceLineNumber?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MoodboardCreateManyJobInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.MoodboardStatus
    clientId: string
    isClientVisible?: boolean
    clientLastViewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HandoverPackCreateManyJobInput = {
    id?: string
    title: string
    description?: string | null
    completionCertUrl?: string | null
    warrantyDocsUrls?: HandoverPackCreatewarrantyDocsUrlsInput | string[]
    finalPhotosUrls?: HandoverPackCreatefinalPhotosUrlsInput | string[]
    guidesIncluded?: HandoverPackCreateguidesIncludedInput | string[]
    isGenerated?: boolean
    generatedAt?: Date | string | null
    deliveredAt?: Date | string | null
    clientAccessedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignee?: UserUpdateOneRequiredWithoutAssignedTasksNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTasksNestedInput
    lead?: LeadUpdateOneWithoutTasksNestedInput
    deal?: DealUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    outlookEventId?: NullableStringFieldUpdateOperationsInput | string | null
    calendarSynced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    client?: ClientUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    userId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    outlookEventId?: NullableStringFieldUpdateOperationsInput | string | null
    calendarSynced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    userId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    outlookEventId?: NullableStringFieldUpdateOperationsInput | string | null
    calendarSynced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobDayLogUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lunchStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lunchEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInLatitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    checkInLongitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    checkInAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workCompleted?: NullableStringFieldUpdateOperationsInput | string | null
    materialsUsed?: NullableStringFieldUpdateOperationsInput | string | null
    issuesEncountered?: NullableStringFieldUpdateOperationsInput | string | null
    startFormData?: NullableJsonNullValueInput | InputJsonValue
    dailyFormData?: NullableJsonNullValueInput | InputJsonValue
    endFormData?: NullableJsonNullValueInput | InputJsonValue
    photos?: JobDayLogUpdatephotosInput | string[]
    isCompliant?: BoolFieldUpdateOperationsInput | boolean
    complianceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutJobDayLogsNestedInput
  }

  export type JobDayLogUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lunchStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lunchEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInLatitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    checkInLongitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    checkInAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workCompleted?: NullableStringFieldUpdateOperationsInput | string | null
    materialsUsed?: NullableStringFieldUpdateOperationsInput | string | null
    issuesEncountered?: NullableStringFieldUpdateOperationsInput | string | null
    startFormData?: NullableJsonNullValueInput | InputJsonValue
    dailyFormData?: NullableJsonNullValueInput | InputJsonValue
    endFormData?: NullableJsonNullValueInput | InputJsonValue
    photos?: JobDayLogUpdatephotosInput | string[]
    isCompliant?: BoolFieldUpdateOperationsInput | boolean
    complianceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobDayLogUncheckedUpdateManyWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lunchStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lunchEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInLatitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    checkInLongitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    checkInAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workCompleted?: NullableStringFieldUpdateOperationsInput | string | null
    materialsUsed?: NullableStringFieldUpdateOperationsInput | string | null
    issuesEncountered?: NullableStringFieldUpdateOperationsInput | string | null
    startFormData?: NullableJsonNullValueInput | InputJsonValue
    dailyFormData?: NullableJsonNullValueInput | InputJsonValue
    endFormData?: NullableJsonNullValueInput | InputJsonValue
    photos?: JobDayLogUpdatephotosInput | string[]
    isCompliant?: BoolFieldUpdateOperationsInput | boolean
    complianceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignVersionUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDesignStatusFieldUpdateOperationsInput | $Enums.DesignStatus
    renderUrls?: DesignVersionUpdaterenderUrlsInput | string[]
    planUrls?: DesignVersionUpdateplanUrlsInput | string[]
    specSheetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    designer?: UserUpdateOneRequiredWithoutDesignVersionsNestedInput
    clashTickets?: DesignClashTicketUpdateManyWithoutDesignVersionNestedInput
  }

  export type DesignVersionUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDesignStatusFieldUpdateOperationsInput | $Enums.DesignStatus
    renderUrls?: DesignVersionUpdaterenderUrlsInput | string[]
    planUrls?: DesignVersionUpdateplanUrlsInput | string[]
    specSheetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    designerId?: StringFieldUpdateOperationsInput | string
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clashTickets?: DesignClashTicketUncheckedUpdateManyWithoutDesignVersionNestedInput
  }

  export type DesignVersionUncheckedUpdateManyWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDesignStatusFieldUpdateOperationsInput | $Enums.DesignStatus
    renderUrls?: DesignVersionUpdaterenderUrlsInput | string[]
    planUrls?: DesignVersionUpdateplanUrlsInput | string[]
    specSheetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    designerId?: StringFieldUpdateOperationsInput | string
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnagUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumSnagCategoryFieldUpdateOperationsInput | $Enums.SnagCategory
    severity?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumSnagStatusFieldUpdateOperationsInput | $Enums.SnagStatus
    photoUrls?: SnagUpdatephotoUrlsInput | string[]
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientNotified?: BoolFieldUpdateOperationsInput | boolean
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedBy?: UserUpdateOneRequiredWithoutSnagReportsNestedInput
    assignedTo?: UserUpdateOneWithoutSnagAssignmentsNestedInput
  }

  export type SnagUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumSnagCategoryFieldUpdateOperationsInput | $Enums.SnagCategory
    severity?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumSnagStatusFieldUpdateOperationsInput | $Enums.SnagStatus
    photoUrls?: SnagUpdatephotoUrlsInput | string[]
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientNotified?: BoolFieldUpdateOperationsInput | boolean
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportedById?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnagUncheckedUpdateManyWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumSnagCategoryFieldUpdateOperationsInput | $Enums.SnagCategory
    severity?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumSnagStatusFieldUpdateOperationsInput | $Enums.SnagStatus
    photoUrls?: SnagUpdatephotoUrlsInput | string[]
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientNotified?: BoolFieldUpdateOperationsInput | boolean
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportedById?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    virusScanStatus?: EnumVirusScanStatusFieldUpdateOperationsInput | $Enums.VirusScanStatus
    virusScanResult?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutDocumentsNestedInput
    deal?: DealUpdateOneWithoutDocumentsNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    virusScanStatus?: EnumVirusScanStatusFieldUpdateOperationsInput | $Enums.VirusScanStatus
    virusScanResult?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUncheckedUpdateManyWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    virusScanStatus?: EnumVirusScanStatusFieldUpdateOperationsInput | $Enums.VirusScanStatus
    virusScanResult?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type ParsedSpecItemUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    parsedCategory?: NullableStringFieldUpdateOperationsInput | string | null
    parsedBrand?: NullableStringFieldUpdateOperationsInput | string | null
    parsedModel?: NullableStringFieldUpdateOperationsInput | string | null
    parsedDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parsedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    parsedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumSpecItemStatusFieldUpdateOperationsInput | $Enums.SpecItemStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    substitution?: NullableStringFieldUpdateOperationsInput | string | null
    actualPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    parseConfidence?: FloatFieldUpdateOperationsInput | number
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    sourceDocumentId?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePage?: NullableIntFieldUpdateOperationsInput | number | null
    sourceLineNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedSpecItemUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    parsedCategory?: NullableStringFieldUpdateOperationsInput | string | null
    parsedBrand?: NullableStringFieldUpdateOperationsInput | string | null
    parsedModel?: NullableStringFieldUpdateOperationsInput | string | null
    parsedDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parsedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    parsedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumSpecItemStatusFieldUpdateOperationsInput | $Enums.SpecItemStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    substitution?: NullableStringFieldUpdateOperationsInput | string | null
    actualPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    parseConfidence?: FloatFieldUpdateOperationsInput | number
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    sourceDocumentId?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePage?: NullableIntFieldUpdateOperationsInput | number | null
    sourceLineNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedSpecItemUncheckedUpdateManyWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    parsedCategory?: NullableStringFieldUpdateOperationsInput | string | null
    parsedBrand?: NullableStringFieldUpdateOperationsInput | string | null
    parsedModel?: NullableStringFieldUpdateOperationsInput | string | null
    parsedDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parsedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    parsedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumSpecItemStatusFieldUpdateOperationsInput | $Enums.SpecItemStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    substitution?: NullableStringFieldUpdateOperationsInput | string | null
    actualPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    parseConfidence?: FloatFieldUpdateOperationsInput | number
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    sourceDocumentId?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePage?: NullableIntFieldUpdateOperationsInput | number | null
    sourceLineNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodboardUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMoodboardStatusFieldUpdateOperationsInput | $Enums.MoodboardStatus
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientLastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutMoodboardsNestedInput
    items?: MoodboardItemUpdateManyWithoutMoodboardNestedInput
  }

  export type MoodboardUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMoodboardStatusFieldUpdateOperationsInput | $Enums.MoodboardStatus
    clientId?: StringFieldUpdateOperationsInput | string
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientLastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: MoodboardItemUncheckedUpdateManyWithoutMoodboardNestedInput
  }

  export type MoodboardUncheckedUpdateManyWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMoodboardStatusFieldUpdateOperationsInput | $Enums.MoodboardStatus
    clientId?: StringFieldUpdateOperationsInput | string
    isClientVisible?: BoolFieldUpdateOperationsInput | boolean
    clientLastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HandoverPackUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    completionCertUrl?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyDocsUrls?: HandoverPackUpdatewarrantyDocsUrlsInput | string[]
    finalPhotosUrls?: HandoverPackUpdatefinalPhotosUrlsInput | string[]
    guidesIncluded?: HandoverPackUpdateguidesIncludedInput | string[]
    isGenerated?: BoolFieldUpdateOperationsInput | boolean
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HandoverPackUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    completionCertUrl?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyDocsUrls?: HandoverPackUpdatewarrantyDocsUrlsInput | string[]
    finalPhotosUrls?: HandoverPackUpdatefinalPhotosUrlsInput | string[]
    guidesIncluded?: HandoverPackUpdateguidesIncludedInput | string[]
    isGenerated?: BoolFieldUpdateOperationsInput | boolean
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HandoverPackUncheckedUpdateManyWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    completionCertUrl?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyDocsUrls?: HandoverPackUpdatewarrantyDocsUrlsInput | string[]
    finalPhotosUrls?: HandoverPackUpdatefinalPhotosUrlsInput | string[]
    guidesIncluded?: HandoverPackUpdateguidesIncludedInput | string[]
    isGenerated?: BoolFieldUpdateOperationsInput | boolean
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstallerTeamMemberCreateManyCompanyInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    dbsExpiry?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobCreateManyInstallerCompanyInput = {
    id?: string
    jobNumber: string
    title: string
    description?: string | null
    status?: $Enums.JobStatus
    quotedDate?: Date | string | null
    surveyDate?: Date | string | null
    designDate?: Date | string | null
    startDate?: Date | string | null
    expectedEndDate?: Date | string | null
    actualEndDate?: Date | string | null
    quotedValue?: Decimal | DecimalJsLike | number | string | null
    finalValue?: Decimal | DecimalJsLike | number | string | null
    depositAmount?: Decimal | DecimalJsLike | number | string | null
    depositPaid?: boolean
    designFeePaid?: boolean
    balancePaid?: boolean
    clientId: string
    roomId: string
    dealId?: string | null
    designerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstallerTeamMemberUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dbsExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstallerTeamMemberUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dbsExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstallerTeamMemberUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dbsExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobUpdateWithoutInstallerCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutJobsNestedInput
    room?: RoomUpdateOneRequiredWithoutJobsNestedInput
    deal?: DealUpdateOneWithoutJobNestedInput
    designer?: UserUpdateOneWithoutDesignerJobsNestedInput
    tasks?: TaskUpdateManyWithoutJobNestedInput
    appointments?: AppointmentUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUpdateManyWithoutJobNestedInput
    snags?: SnagUpdateManyWithoutJobNestedInput
    documents?: DocumentUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutInstallerCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    designerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUncheckedUpdateOneWithoutJobNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutJobNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutJobNestedInput
    jobDayLogs?: JobDayLogUncheckedUpdateManyWithoutJobNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutJobNestedInput
    snags?: SnagUncheckedUpdateManyWithoutJobNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutJobNestedInput
    parsedSpecItems?: ParsedSpecItemUncheckedUpdateManyWithoutJobNestedInput
    moodboards?: MoodboardUncheckedUpdateManyWithoutJobNestedInput
    handoverPacks?: HandoverPackUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateManyWithoutInstallerCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    quotedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depositPaid?: BoolFieldUpdateOperationsInput | boolean
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    balancePaid?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    designerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignClashTicketCreateManyDesignVersionInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ClashStatus
    priority?: $Enums.Priority
    photoUrls?: DesignClashTicketCreatephotoUrlsInput | string[]
    resolution?: string | null
    resolvedAt?: Date | string | null
    reportedById: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignClashTicketUpdateWithoutDesignVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumClashStatusFieldUpdateOperationsInput | $Enums.ClashStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    photoUrls?: DesignClashTicketUpdatephotoUrlsInput | string[]
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedBy?: UserUpdateOneRequiredWithoutClashReportsNestedInput
    assignedTo?: UserUpdateOneWithoutClashAssignmentsNestedInput
  }

  export type DesignClashTicketUncheckedUpdateWithoutDesignVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumClashStatusFieldUpdateOperationsInput | $Enums.ClashStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    photoUrls?: DesignClashTicketUpdatephotoUrlsInput | string[]
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportedById?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignClashTicketUncheckedUpdateManyWithoutDesignVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumClashStatusFieldUpdateOperationsInput | $Enums.ClashStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    photoUrls?: DesignClashTicketUpdatephotoUrlsInput | string[]
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportedById?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodboardItemCreateManyMoodboardInput = {
    id?: string
    title?: string | null
    description?: string | null
    imageUrl: string
    sourceUrl?: string | null
    category?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MoodboardItemUpdateWithoutMoodboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientComments?: MoodboardCommentUpdateManyWithoutItemNestedInput
  }

  export type MoodboardItemUncheckedUpdateWithoutMoodboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientComments?: MoodboardCommentUncheckedUpdateManyWithoutItemNestedInput
  }

  export type MoodboardItemUncheckedUpdateManyWithoutMoodboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodboardCommentCreateManyItemInput = {
    id?: string
    content: string
    xPosition: number
    yPosition: number
    authorId?: string | null
    authorName?: string | null
    createdAt?: Date | string
  }

  export type MoodboardCommentUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    xPosition?: FloatFieldUpdateOperationsInput | number
    yPosition?: FloatFieldUpdateOperationsInput | number
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneWithoutMoodboardCommentsNestedInput
  }

  export type MoodboardCommentUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    xPosition?: FloatFieldUpdateOperationsInput | number
    yPosition?: FloatFieldUpdateOperationsInput | number
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodboardCommentUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    xPosition?: FloatFieldUpdateOperationsInput | number
    yPosition?: FloatFieldUpdateOperationsInput | number
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionCreateManyTemplateInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    submissionSource?: $Enums.SubmissionSource
    submittedById?: string | null
    clientId?: string | null
    jobId?: string | null
    submittedAt?: Date | string
  }

  export type FormSubmissionUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    submissionSource?: EnumSubmissionSourceFieldUpdateOperationsInput | $Enums.SubmissionSource
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedBy?: UserUpdateOneWithoutFormSubmissionsNestedInput
  }

  export type FormSubmissionUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    submissionSource?: EnumSubmissionSourceFieldUpdateOperationsInput | $Enums.SubmissionSource
    submittedById?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    submissionSource?: EnumSubmissionSourceFieldUpdateOperationsInput | $Enums.SubmissionSource
    submittedById?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSequenceStepCreateManyJourneyInput = {
    id?: string
    stepNumber: number
    templateId: string
    delayDays?: number
    delayHours?: number
    sendConditions?: JsonNullValueInput | InputJsonValue
  }

  export type EmailSequenceStepUpdateWithoutJourneyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    templateId?: StringFieldUpdateOperationsInput | string
    delayDays?: IntFieldUpdateOperationsInput | number
    delayHours?: IntFieldUpdateOperationsInput | number
    sendConditions?: JsonNullValueInput | InputJsonValue
  }

  export type EmailSequenceStepUncheckedUpdateWithoutJourneyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    templateId?: StringFieldUpdateOperationsInput | string
    delayDays?: IntFieldUpdateOperationsInput | number
    delayHours?: IntFieldUpdateOperationsInput | number
    sendConditions?: JsonNullValueInput | InputJsonValue
  }

  export type EmailSequenceStepUncheckedUpdateManyWithoutJourneyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    templateId?: StringFieldUpdateOperationsInput | string
    delayDays?: IntFieldUpdateOperationsInput | number
    delayHours?: IntFieldUpdateOperationsInput | number
    sendConditions?: JsonNullValueInput | InputJsonValue
  }

  export type WebhookDeliveryCreateManyWebhookInput = {
    id?: string
    eventType: $Enums.WebhookEvent
    payload: JsonNullValueInput | InputJsonValue
    httpStatus?: number | null
    responseBody?: string | null
    errorMessage?: string | null
    deliveryAttempts?: number
    deliveredAt?: Date | string | null
    createdAt?: Date | string
  }

  export type WebhookDeliveryUpdateWithoutWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWebhookEventFieldUpdateOperationsInput | $Enums.WebhookEvent
    payload?: JsonNullValueInput | InputJsonValue
    httpStatus?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAttempts?: IntFieldUpdateOperationsInput | number
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryUncheckedUpdateWithoutWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWebhookEventFieldUpdateOperationsInput | $Enums.WebhookEvent
    payload?: JsonNullValueInput | InputJsonValue
    httpStatus?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAttempts?: IntFieldUpdateOperationsInput | number
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryUncheckedUpdateManyWithoutWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWebhookEventFieldUpdateOperationsInput | $Enums.WebhookEvent
    payload?: JsonNullValueInput | InputJsonValue
    httpStatus?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAttempts?: IntFieldUpdateOperationsInput | number
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientCountOutputTypeDefaultArgs instead
     */
    export type ClientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactCountOutputTypeDefaultArgs instead
     */
    export type ContactCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeadCountOutputTypeDefaultArgs instead
     */
    export type LeadCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeadCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DealCountOutputTypeDefaultArgs instead
     */
    export type DealCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DealCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PipelineStageCountOutputTypeDefaultArgs instead
     */
    export type PipelineStageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PipelineStageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomCountOutputTypeDefaultArgs instead
     */
    export type RoomCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobCountOutputTypeDefaultArgs instead
     */
    export type JobCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstallerCompanyCountOutputTypeDefaultArgs instead
     */
    export type InstallerCompanyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstallerCompanyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DesignVersionCountOutputTypeDefaultArgs instead
     */
    export type DesignVersionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DesignVersionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MoodboardCountOutputTypeDefaultArgs instead
     */
    export type MoodboardCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MoodboardCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MoodboardItemCountOutputTypeDefaultArgs instead
     */
    export type MoodboardItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MoodboardItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormTemplateCountOutputTypeDefaultArgs instead
     */
    export type FormTemplateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormTemplateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailJourneyCountOutputTypeDefaultArgs instead
     */
    export type EmailJourneyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailJourneyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WebhookCountOutputTypeDefaultArgs instead
     */
    export type WebhookCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WebhookCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientDefaultArgs instead
     */
    export type ClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactDefaultArgs instead
     */
    export type ContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeadDefaultArgs instead
     */
    export type LeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DealDefaultArgs instead
     */
    export type DealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DealDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PipelineStageDefaultArgs instead
     */
    export type PipelineStageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PipelineStageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivityDefaultArgs instead
     */
    export type ActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskDefaultArgs instead
     */
    export type TaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AppointmentDefaultArgs instead
     */
    export type AppointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppointmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomDefaultArgs instead
     */
    export type RoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobDefaultArgs instead
     */
    export type JobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobDayLogDefaultArgs instead
     */
    export type JobDayLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobDayLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstallerCompanyDefaultArgs instead
     */
    export type InstallerCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstallerCompanyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstallerTeamMemberDefaultArgs instead
     */
    export type InstallerTeamMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstallerTeamMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DesignVersionDefaultArgs instead
     */
    export type DesignVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DesignVersionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DesignClashTicketDefaultArgs instead
     */
    export type DesignClashTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DesignClashTicketDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MoodboardDefaultArgs instead
     */
    export type MoodboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MoodboardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MoodboardItemDefaultArgs instead
     */
    export type MoodboardItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MoodboardItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MoodboardCommentDefaultArgs instead
     */
    export type MoodboardCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MoodboardCommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParsedSpecItemDefaultArgs instead
     */
    export type ParsedSpecItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParsedSpecItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SnagDefaultArgs instead
     */
    export type SnagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SnagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentDefaultArgs instead
     */
    export type DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormTemplateDefaultArgs instead
     */
    export type FormTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormSubmissionDefaultArgs instead
     */
    export type FormSubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormSubmissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HandoverPackDefaultArgs instead
     */
    export type HandoverPackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HandoverPackDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GuideDefaultArgs instead
     */
    export type GuideArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GuideDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailJourneyDefaultArgs instead
     */
    export type EmailJourneyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailJourneyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailSequenceStepDefaultArgs instead
     */
    export type EmailSequenceStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailSequenceStepDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WebhookDefaultArgs instead
     */
    export type WebhookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WebhookDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WebhookDeliveryDefaultArgs instead
     */
    export type WebhookDeliveryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WebhookDeliveryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventLogDefaultArgs instead
     */
    export type EventLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IntegrationDefaultArgs instead
     */
    export type IntegrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IntegrationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MergeQueueDefaultArgs instead
     */
    export type MergeQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MergeQueueDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}