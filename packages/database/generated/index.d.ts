
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Enquiry
 * 
 */
export type Enquiry = $Result.DefaultSelection<Prisma.$EnquiryPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model Lead
 * 
 */
export type Lead = $Result.DefaultSelection<Prisma.$LeadPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model CompletedProject
 * 
 */
export type CompletedProject = $Result.DefaultSelection<Prisma.$CompletedProjectPayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model Snag
 * 
 */
export type Snag = $Result.DefaultSelection<Prisma.$SnagPayload>
/**
 * Model EventLog
 * 
 */
export type EventLog = $Result.DefaultSelection<Prisma.$EventLogPayload>
/**
 * Model WorkflowDefinition
 * 
 */
export type WorkflowDefinition = $Result.DefaultSelection<Prisma.$WorkflowDefinitionPayload>
/**
 * Model WorkflowStep
 * 
 */
export type WorkflowStep = $Result.DefaultSelection<Prisma.$WorkflowStepPayload>
/**
 * Model WorkflowStepApprover
 * 
 */
export type WorkflowStepApprover = $Result.DefaultSelection<Prisma.$WorkflowStepApproverPayload>
/**
 * Model WorkflowInstance
 * 
 */
export type WorkflowInstance = $Result.DefaultSelection<Prisma.$WorkflowInstancePayload>
/**
 * Model WorkflowStepExecution
 * 
 */
export type WorkflowStepExecution = $Result.DefaultSelection<Prisma.$WorkflowStepExecutionPayload>
/**
 * Model WorkflowApproval
 * 
 */
export type WorkflowApproval = $Result.DefaultSelection<Prisma.$WorkflowApprovalPayload>
/**
 * Model WorkflowTemplate
 * 
 */
export type WorkflowTemplate = $Result.DefaultSelection<Prisma.$WorkflowTemplatePayload>
/**
 * Model AutomationRule
 * 
 */
export type AutomationRule = $Result.DefaultSelection<Prisma.$AutomationRulePayload>
/**
 * Model AutomationExecution
 * 
 */
export type AutomationExecution = $Result.DefaultSelection<Prisma.$AutomationExecutionPayload>
/**
 * Model TestPlan
 * 
 */
export type TestPlan = $Result.DefaultSelection<Prisma.$TestPlanPayload>
/**
 * Model TestCase
 * 
 */
export type TestCase = $Result.DefaultSelection<Prisma.$TestCasePayload>
/**
 * Model TestExecution
 * 
 */
export type TestExecution = $Result.DefaultSelection<Prisma.$TestExecutionPayload>
/**
 * Model Defect
 * 
 */
export type Defect = $Result.DefaultSelection<Prisma.$DefectPayload>
/**
 * Model DefectTestCase
 * 
 */
export type DefectTestCase = $Result.DefaultSelection<Prisma.$DefectTestCasePayload>
/**
 * Model DefectComment
 * 
 */
export type DefectComment = $Result.DefaultSelection<Prisma.$DefectCommentPayload>
/**
 * Model QAReview
 * 
 */
export type QAReview = $Result.DefaultSelection<Prisma.$QAReviewPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  SALES: 'SALES',
  DESIGNER: 'DESIGNER',
  INSTALLER: 'INSTALLER',
  FINANCE: 'FINANCE'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const AccountStatus: {
  ACTIVE: 'ACTIVE',
  ARCHIVED: 'ARCHIVED'
};

export type AccountStatus = (typeof AccountStatus)[keyof typeof AccountStatus]


export const EnquiryStatus: {
  NEW: 'NEW',
  CONTACTED: 'CONTACTED',
  QUALIFIED: 'QUALIFIED',
  CONVERTED: 'CONVERTED',
  REJECTED: 'REJECTED',
  NURTURING: 'NURTURING'
};

export type EnquiryStatus = (typeof EnquiryStatus)[keyof typeof EnquiryStatus]


export const Priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const LeadStatus: {
  NEW: 'NEW',
  CONTACTED: 'CONTACTED',
  QUALIFIED: 'QUALIFIED',
  PROPOSAL_SENT: 'PROPOSAL_SENT',
  NEGOTIATING: 'NEGOTIATING',
  WON: 'WON',
  LOST: 'LOST'
};

export type LeadStatus = (typeof LeadStatus)[keyof typeof LeadStatus]


export const ProjectType: {
  KITCHEN: 'KITCHEN',
  BATHROOM: 'BATHROOM',
  CLOAKROOM: 'CLOAKROOM',
  ENSUITE: 'ENSUITE',
  WET_ROOM: 'WET_ROOM',
  OTHER: 'OTHER'
};

export type ProjectType = (typeof ProjectType)[keyof typeof ProjectType]


export const ProjectStatus: {
  PLANNING: 'PLANNING',
  DESIGN: 'DESIGN',
  QUOTED: 'QUOTED',
  APPROVED: 'APPROVED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  ON_HOLD: 'ON_HOLD'
};

export type ProjectStatus = (typeof ProjectStatus)[keyof typeof ProjectStatus]


export const CompletedProjectStatus: {
  SCHEDULED: 'SCHEDULED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type CompletedProjectStatus = (typeof CompletedProjectStatus)[keyof typeof CompletedProjectStatus]


export const ActivityType: {
  NOTE: 'NOTE',
  CALL: 'CALL',
  EMAIL: 'EMAIL',
  SMS: 'SMS',
  MEETING: 'MEETING',
  VOICEMAIL: 'VOICEMAIL',
  SIGNATURE: 'SIGNATURE',
  UPLOAD: 'UPLOAD',
  FORM: 'FORM',
  SYSTEM: 'SYSTEM'
};

export type ActivityType = (typeof ActivityType)[keyof typeof ActivityType]


export const TaskStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  DONE: 'DONE',
  CANCELLED: 'CANCELLED'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const AppointmentType: {
  DESIGN_CONSULTATION: 'DESIGN_CONSULTATION',
  SITE_SURVEY: 'SITE_SURVEY',
  DESIGN_PRESENTATION: 'DESIGN_PRESENTATION',
  CONTRACT_SIGNING: 'CONTRACT_SIGNING',
  INSTALL_START: 'INSTALL_START',
  PROGRESS_CHECK: 'PROGRESS_CHECK',
  HANDOVER: 'HANDOVER',
  AFTERCARE: 'AFTERCARE',
  FOLLOW_UP: 'FOLLOW_UP'
};

export type AppointmentType = (typeof AppointmentType)[keyof typeof AppointmentType]


export const AppointmentStatus: {
  SCHEDULED: 'SCHEDULED',
  CONFIRMED: 'CONFIRMED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  NO_SHOW: 'NO_SHOW'
};

export type AppointmentStatus = (typeof AppointmentStatus)[keyof typeof AppointmentStatus]


export const DocumentType: {
  DESIGN_DRAWING: 'DESIGN_DRAWING',
  TECHNICAL_DRAWING: 'TECHNICAL_DRAWING',
  SITE_SURVEY: 'SITE_SURVEY',
  PRODUCT_SPECIFICATION: 'PRODUCT_SPECIFICATION',
  QUOTATION: 'QUOTATION',
  CONTRACT: 'CONTRACT',
  INVOICE: 'INVOICE',
  PHOTO_BEFORE: 'PHOTO_BEFORE',
  PHOTO_PROGRESS: 'PHOTO_PROGRESS',
  PHOTO_COMPLETION: 'PHOTO_COMPLETION',
  CERTIFICATE: 'CERTIFICATE',
  WARRANTY: 'WARRANTY',
  RENDER_3D: 'RENDER_3D',
  FLOOR_PLAN: 'FLOOR_PLAN',
  OTHER: 'OTHER'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const SnagStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED'
};

export type SnagStatus = (typeof SnagStatus)[keyof typeof SnagStatus]


export const WorkflowTriggerType: {
  MANUAL: 'MANUAL',
  AUTOMATIC: 'AUTOMATIC',
  SCHEDULED: 'SCHEDULED',
  CONDITIONAL: 'CONDITIONAL'
};

export type WorkflowTriggerType = (typeof WorkflowTriggerType)[keyof typeof WorkflowTriggerType]


export const WorkflowStepType: {
  APPROVAL: 'APPROVAL',
  TASK: 'TASK',
  NOTIFICATION: 'NOTIFICATION',
  EMAIL: 'EMAIL',
  SMS: 'SMS',
  WEBHOOK: 'WEBHOOK',
  DATA_UPDATE: 'DATA_UPDATE',
  WAIT: 'WAIT',
  DECISION: 'DECISION',
  SCRIPT: 'SCRIPT'
};

export type WorkflowStepType = (typeof WorkflowStepType)[keyof typeof WorkflowStepType]


export const ApproverType: {
  REQUIRED: 'REQUIRED',
  OPTIONAL: 'OPTIONAL',
  INFORMATIONAL: 'INFORMATIONAL'
};

export type ApproverType = (typeof ApproverType)[keyof typeof ApproverType]


export const WorkflowStatus: {
  PENDING: 'PENDING',
  RUNNING: 'RUNNING',
  PAUSED: 'PAUSED',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type WorkflowStatus = (typeof WorkflowStatus)[keyof typeof WorkflowStatus]


export const WorkflowStepStatus: {
  PENDING: 'PENDING',
  RUNNING: 'RUNNING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  SKIPPED: 'SKIPPED',
  CANCELLED: 'CANCELLED'
};

export type WorkflowStepStatus = (typeof WorkflowStepStatus)[keyof typeof WorkflowStepStatus]


export const ApprovalStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  EXPIRED: 'EXPIRED'
};

export type ApprovalStatus = (typeof ApprovalStatus)[keyof typeof ApprovalStatus]


export const AutomationStatus: {
  SUCCESS: 'SUCCESS',
  FAILED: 'FAILED',
  PARTIAL: 'PARTIAL'
};

export type AutomationStatus = (typeof AutomationStatus)[keyof typeof AutomationStatus]


export const TestPlanStatus: {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  ARCHIVED: 'ARCHIVED'
};

export type TestPlanStatus = (typeof TestPlanStatus)[keyof typeof TestPlanStatus]


export const TestCasePriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type TestCasePriority = (typeof TestCasePriority)[keyof typeof TestCasePriority]


export const TestCaseStatus: {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  DEPRECATED: 'DEPRECATED'
};

export type TestCaseStatus = (typeof TestCaseStatus)[keyof typeof TestCaseStatus]


export const TestExecutionStatus: {
  NOT_STARTED: 'NOT_STARTED',
  IN_PROGRESS: 'IN_PROGRESS',
  PASSED: 'PASSED',
  FAILED: 'FAILED',
  BLOCKED: 'BLOCKED',
  SKIPPED: 'SKIPPED'
};

export type TestExecutionStatus = (typeof TestExecutionStatus)[keyof typeof TestExecutionStatus]


export const DefectSeverity: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL',
  BLOCKER: 'BLOCKER'
};

export type DefectSeverity = (typeof DefectSeverity)[keyof typeof DefectSeverity]


export const DefectPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type DefectPriority = (typeof DefectPriority)[keyof typeof DefectPriority]


export const DefectStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED',
  REOPENED: 'REOPENED',
  REJECTED: 'REJECTED'
};

export type DefectStatus = (typeof DefectStatus)[keyof typeof DefectStatus]


export const QAReviewStatus: {
  PENDING: 'PENDING',
  IN_REVIEW: 'IN_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  NEEDS_REVISION: 'NEEDS_REVISION'
};

export type QAReviewStatus = (typeof QAReviewStatus)[keyof typeof QAReviewStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type AccountStatus = $Enums.AccountStatus

export const AccountStatus: typeof $Enums.AccountStatus

export type EnquiryStatus = $Enums.EnquiryStatus

export const EnquiryStatus: typeof $Enums.EnquiryStatus

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type LeadStatus = $Enums.LeadStatus

export const LeadStatus: typeof $Enums.LeadStatus

export type ProjectType = $Enums.ProjectType

export const ProjectType: typeof $Enums.ProjectType

export type ProjectStatus = $Enums.ProjectStatus

export const ProjectStatus: typeof $Enums.ProjectStatus

export type CompletedProjectStatus = $Enums.CompletedProjectStatus

export const CompletedProjectStatus: typeof $Enums.CompletedProjectStatus

export type ActivityType = $Enums.ActivityType

export const ActivityType: typeof $Enums.ActivityType

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type AppointmentType = $Enums.AppointmentType

export const AppointmentType: typeof $Enums.AppointmentType

export type AppointmentStatus = $Enums.AppointmentStatus

export const AppointmentStatus: typeof $Enums.AppointmentStatus

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type SnagStatus = $Enums.SnagStatus

export const SnagStatus: typeof $Enums.SnagStatus

export type WorkflowTriggerType = $Enums.WorkflowTriggerType

export const WorkflowTriggerType: typeof $Enums.WorkflowTriggerType

export type WorkflowStepType = $Enums.WorkflowStepType

export const WorkflowStepType: typeof $Enums.WorkflowStepType

export type ApproverType = $Enums.ApproverType

export const ApproverType: typeof $Enums.ApproverType

export type WorkflowStatus = $Enums.WorkflowStatus

export const WorkflowStatus: typeof $Enums.WorkflowStatus

export type WorkflowStepStatus = $Enums.WorkflowStepStatus

export const WorkflowStepStatus: typeof $Enums.WorkflowStepStatus

export type ApprovalStatus = $Enums.ApprovalStatus

export const ApprovalStatus: typeof $Enums.ApprovalStatus

export type AutomationStatus = $Enums.AutomationStatus

export const AutomationStatus: typeof $Enums.AutomationStatus

export type TestPlanStatus = $Enums.TestPlanStatus

export const TestPlanStatus: typeof $Enums.TestPlanStatus

export type TestCasePriority = $Enums.TestCasePriority

export const TestCasePriority: typeof $Enums.TestCasePriority

export type TestCaseStatus = $Enums.TestCaseStatus

export const TestCaseStatus: typeof $Enums.TestCaseStatus

export type TestExecutionStatus = $Enums.TestExecutionStatus

export const TestExecutionStatus: typeof $Enums.TestExecutionStatus

export type DefectSeverity = $Enums.DefectSeverity

export const DefectSeverity: typeof $Enums.DefectSeverity

export type DefectPriority = $Enums.DefectPriority

export const DefectPriority: typeof $Enums.DefectPriority

export type DefectStatus = $Enums.DefectStatus

export const DefectStatus: typeof $Enums.DefectStatus

export type QAReviewStatus = $Enums.QAReviewStatus

export const QAReviewStatus: typeof $Enums.QAReviewStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.enquiry`: Exposes CRUD operations for the **Enquiry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enquiries
    * const enquiries = await prisma.enquiry.findMany()
    * ```
    */
  get enquiry(): Prisma.EnquiryDelegate<ExtArgs>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs>;

  /**
   * `prisma.lead`: Exposes CRUD operations for the **Lead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leads
    * const leads = await prisma.lead.findMany()
    * ```
    */
  get lead(): Prisma.LeadDelegate<ExtArgs>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs>;

  /**
   * `prisma.completedProject`: Exposes CRUD operations for the **CompletedProject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompletedProjects
    * const completedProjects = await prisma.completedProject.findMany()
    * ```
    */
  get completedProject(): Prisma.CompletedProjectDelegate<ExtArgs>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs>;

  /**
   * `prisma.snag`: Exposes CRUD operations for the **Snag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Snags
    * const snags = await prisma.snag.findMany()
    * ```
    */
  get snag(): Prisma.SnagDelegate<ExtArgs>;

  /**
   * `prisma.eventLog`: Exposes CRUD operations for the **EventLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventLogs
    * const eventLogs = await prisma.eventLog.findMany()
    * ```
    */
  get eventLog(): Prisma.EventLogDelegate<ExtArgs>;

  /**
   * `prisma.workflowDefinition`: Exposes CRUD operations for the **WorkflowDefinition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkflowDefinitions
    * const workflowDefinitions = await prisma.workflowDefinition.findMany()
    * ```
    */
  get workflowDefinition(): Prisma.WorkflowDefinitionDelegate<ExtArgs>;

  /**
   * `prisma.workflowStep`: Exposes CRUD operations for the **WorkflowStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkflowSteps
    * const workflowSteps = await prisma.workflowStep.findMany()
    * ```
    */
  get workflowStep(): Prisma.WorkflowStepDelegate<ExtArgs>;

  /**
   * `prisma.workflowStepApprover`: Exposes CRUD operations for the **WorkflowStepApprover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkflowStepApprovers
    * const workflowStepApprovers = await prisma.workflowStepApprover.findMany()
    * ```
    */
  get workflowStepApprover(): Prisma.WorkflowStepApproverDelegate<ExtArgs>;

  /**
   * `prisma.workflowInstance`: Exposes CRUD operations for the **WorkflowInstance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkflowInstances
    * const workflowInstances = await prisma.workflowInstance.findMany()
    * ```
    */
  get workflowInstance(): Prisma.WorkflowInstanceDelegate<ExtArgs>;

  /**
   * `prisma.workflowStepExecution`: Exposes CRUD operations for the **WorkflowStepExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkflowStepExecutions
    * const workflowStepExecutions = await prisma.workflowStepExecution.findMany()
    * ```
    */
  get workflowStepExecution(): Prisma.WorkflowStepExecutionDelegate<ExtArgs>;

  /**
   * `prisma.workflowApproval`: Exposes CRUD operations for the **WorkflowApproval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkflowApprovals
    * const workflowApprovals = await prisma.workflowApproval.findMany()
    * ```
    */
  get workflowApproval(): Prisma.WorkflowApprovalDelegate<ExtArgs>;

  /**
   * `prisma.workflowTemplate`: Exposes CRUD operations for the **WorkflowTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkflowTemplates
    * const workflowTemplates = await prisma.workflowTemplate.findMany()
    * ```
    */
  get workflowTemplate(): Prisma.WorkflowTemplateDelegate<ExtArgs>;

  /**
   * `prisma.automationRule`: Exposes CRUD operations for the **AutomationRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutomationRules
    * const automationRules = await prisma.automationRule.findMany()
    * ```
    */
  get automationRule(): Prisma.AutomationRuleDelegate<ExtArgs>;

  /**
   * `prisma.automationExecution`: Exposes CRUD operations for the **AutomationExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutomationExecutions
    * const automationExecutions = await prisma.automationExecution.findMany()
    * ```
    */
  get automationExecution(): Prisma.AutomationExecutionDelegate<ExtArgs>;

  /**
   * `prisma.testPlan`: Exposes CRUD operations for the **TestPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestPlans
    * const testPlans = await prisma.testPlan.findMany()
    * ```
    */
  get testPlan(): Prisma.TestPlanDelegate<ExtArgs>;

  /**
   * `prisma.testCase`: Exposes CRUD operations for the **TestCase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestCases
    * const testCases = await prisma.testCase.findMany()
    * ```
    */
  get testCase(): Prisma.TestCaseDelegate<ExtArgs>;

  /**
   * `prisma.testExecution`: Exposes CRUD operations for the **TestExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestExecutions
    * const testExecutions = await prisma.testExecution.findMany()
    * ```
    */
  get testExecution(): Prisma.TestExecutionDelegate<ExtArgs>;

  /**
   * `prisma.defect`: Exposes CRUD operations for the **Defect** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Defects
    * const defects = await prisma.defect.findMany()
    * ```
    */
  get defect(): Prisma.DefectDelegate<ExtArgs>;

  /**
   * `prisma.defectTestCase`: Exposes CRUD operations for the **DefectTestCase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DefectTestCases
    * const defectTestCases = await prisma.defectTestCase.findMany()
    * ```
    */
  get defectTestCase(): Prisma.DefectTestCaseDelegate<ExtArgs>;

  /**
   * `prisma.defectComment`: Exposes CRUD operations for the **DefectComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DefectComments
    * const defectComments = await prisma.defectComment.findMany()
    * ```
    */
  get defectComment(): Prisma.DefectCommentDelegate<ExtArgs>;

  /**
   * `prisma.qAReview`: Exposes CRUD operations for the **QAReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QAReviews
    * const qAReviews = await prisma.qAReview.findMany()
    * ```
    */
  get qAReview(): Prisma.QAReviewDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Enquiry: 'Enquiry',
    Contact: 'Contact',
    Lead: 'Lead',
    Project: 'Project',
    CompletedProject: 'CompletedProject',
    Activity: 'Activity',
    Task: 'Task',
    Appointment: 'Appointment',
    Document: 'Document',
    Snag: 'Snag',
    EventLog: 'EventLog',
    WorkflowDefinition: 'WorkflowDefinition',
    WorkflowStep: 'WorkflowStep',
    WorkflowStepApprover: 'WorkflowStepApprover',
    WorkflowInstance: 'WorkflowInstance',
    WorkflowStepExecution: 'WorkflowStepExecution',
    WorkflowApproval: 'WorkflowApproval',
    WorkflowTemplate: 'WorkflowTemplate',
    AutomationRule: 'AutomationRule',
    AutomationExecution: 'AutomationExecution',
    TestPlan: 'TestPlan',
    TestCase: 'TestCase',
    TestExecution: 'TestExecution',
    Defect: 'Defect',
    DefectTestCase: 'DefectTestCase',
    DefectComment: 'DefectComment',
    QAReview: 'QAReview'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "account" | "enquiry" | "contact" | "lead" | "project" | "completedProject" | "activity" | "task" | "appointment" | "document" | "snag" | "eventLog" | "workflowDefinition" | "workflowStep" | "workflowStepApprover" | "workflowInstance" | "workflowStepExecution" | "workflowApproval" | "workflowTemplate" | "automationRule" | "automationExecution" | "testPlan" | "testCase" | "testExecution" | "defect" | "defectTestCase" | "defectComment" | "qAReview"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Enquiry: {
        payload: Prisma.$EnquiryPayload<ExtArgs>
        fields: Prisma.EnquiryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnquiryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnquiryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>
          }
          findFirst: {
            args: Prisma.EnquiryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnquiryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>
          }
          findMany: {
            args: Prisma.EnquiryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>[]
          }
          create: {
            args: Prisma.EnquiryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>
          }
          createMany: {
            args: Prisma.EnquiryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnquiryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>[]
          }
          delete: {
            args: Prisma.EnquiryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>
          }
          update: {
            args: Prisma.EnquiryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>
          }
          deleteMany: {
            args: Prisma.EnquiryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnquiryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EnquiryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>
          }
          aggregate: {
            args: Prisma.EnquiryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnquiry>
          }
          groupBy: {
            args: Prisma.EnquiryGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnquiryGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnquiryCountArgs<ExtArgs>
            result: $Utils.Optional<EnquiryCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      Lead: {
        payload: Prisma.$LeadPayload<ExtArgs>
        fields: Prisma.LeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findFirst: {
            args: Prisma.LeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findMany: {
            args: Prisma.LeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          create: {
            args: Prisma.LeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          createMany: {
            args: Prisma.LeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          delete: {
            args: Prisma.LeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          update: {
            args: Prisma.LeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          deleteMany: {
            args: Prisma.LeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          aggregate: {
            args: Prisma.LeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLead>
          }
          groupBy: {
            args: Prisma.LeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadCountArgs<ExtArgs>
            result: $Utils.Optional<LeadCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      CompletedProject: {
        payload: Prisma.$CompletedProjectPayload<ExtArgs>
        fields: Prisma.CompletedProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompletedProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompletedProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedProjectPayload>
          }
          findFirst: {
            args: Prisma.CompletedProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompletedProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedProjectPayload>
          }
          findMany: {
            args: Prisma.CompletedProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedProjectPayload>[]
          }
          create: {
            args: Prisma.CompletedProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedProjectPayload>
          }
          createMany: {
            args: Prisma.CompletedProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompletedProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedProjectPayload>[]
          }
          delete: {
            args: Prisma.CompletedProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedProjectPayload>
          }
          update: {
            args: Prisma.CompletedProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedProjectPayload>
          }
          deleteMany: {
            args: Prisma.CompletedProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompletedProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompletedProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedProjectPayload>
          }
          aggregate: {
            args: Prisma.CompletedProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompletedProject>
          }
          groupBy: {
            args: Prisma.CompletedProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompletedProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompletedProjectCountArgs<ExtArgs>
            result: $Utils.Optional<CompletedProjectCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      Snag: {
        payload: Prisma.$SnagPayload<ExtArgs>
        fields: Prisma.SnagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SnagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SnagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnagPayload>
          }
          findFirst: {
            args: Prisma.SnagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SnagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnagPayload>
          }
          findMany: {
            args: Prisma.SnagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnagPayload>[]
          }
          create: {
            args: Prisma.SnagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnagPayload>
          }
          createMany: {
            args: Prisma.SnagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SnagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnagPayload>[]
          }
          delete: {
            args: Prisma.SnagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnagPayload>
          }
          update: {
            args: Prisma.SnagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnagPayload>
          }
          deleteMany: {
            args: Prisma.SnagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SnagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SnagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnagPayload>
          }
          aggregate: {
            args: Prisma.SnagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSnag>
          }
          groupBy: {
            args: Prisma.SnagGroupByArgs<ExtArgs>
            result: $Utils.Optional<SnagGroupByOutputType>[]
          }
          count: {
            args: Prisma.SnagCountArgs<ExtArgs>
            result: $Utils.Optional<SnagCountAggregateOutputType> | number
          }
        }
      }
      EventLog: {
        payload: Prisma.$EventLogPayload<ExtArgs>
        fields: Prisma.EventLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload>
          }
          findFirst: {
            args: Prisma.EventLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload>
          }
          findMany: {
            args: Prisma.EventLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload>[]
          }
          create: {
            args: Prisma.EventLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload>
          }
          createMany: {
            args: Prisma.EventLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload>[]
          }
          delete: {
            args: Prisma.EventLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload>
          }
          update: {
            args: Prisma.EventLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload>
          }
          deleteMany: {
            args: Prisma.EventLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload>
          }
          aggregate: {
            args: Prisma.EventLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventLog>
          }
          groupBy: {
            args: Prisma.EventLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventLogCountArgs<ExtArgs>
            result: $Utils.Optional<EventLogCountAggregateOutputType> | number
          }
        }
      }
      WorkflowDefinition: {
        payload: Prisma.$WorkflowDefinitionPayload<ExtArgs>
        fields: Prisma.WorkflowDefinitionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowDefinitionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowDefinitionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowDefinitionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowDefinitionPayload>
          }
          findFirst: {
            args: Prisma.WorkflowDefinitionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowDefinitionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowDefinitionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowDefinitionPayload>
          }
          findMany: {
            args: Prisma.WorkflowDefinitionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowDefinitionPayload>[]
          }
          create: {
            args: Prisma.WorkflowDefinitionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowDefinitionPayload>
          }
          createMany: {
            args: Prisma.WorkflowDefinitionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowDefinitionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowDefinitionPayload>[]
          }
          delete: {
            args: Prisma.WorkflowDefinitionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowDefinitionPayload>
          }
          update: {
            args: Prisma.WorkflowDefinitionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowDefinitionPayload>
          }
          deleteMany: {
            args: Prisma.WorkflowDefinitionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowDefinitionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkflowDefinitionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowDefinitionPayload>
          }
          aggregate: {
            args: Prisma.WorkflowDefinitionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflowDefinition>
          }
          groupBy: {
            args: Prisma.WorkflowDefinitionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowDefinitionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowDefinitionCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowDefinitionCountAggregateOutputType> | number
          }
        }
      }
      WorkflowStep: {
        payload: Prisma.$WorkflowStepPayload<ExtArgs>
        fields: Prisma.WorkflowStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>
          }
          findFirst: {
            args: Prisma.WorkflowStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>
          }
          findMany: {
            args: Prisma.WorkflowStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>[]
          }
          create: {
            args: Prisma.WorkflowStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>
          }
          createMany: {
            args: Prisma.WorkflowStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>[]
          }
          delete: {
            args: Prisma.WorkflowStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>
          }
          update: {
            args: Prisma.WorkflowStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>
          }
          deleteMany: {
            args: Prisma.WorkflowStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkflowStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>
          }
          aggregate: {
            args: Prisma.WorkflowStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflowStep>
          }
          groupBy: {
            args: Prisma.WorkflowStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowStepCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowStepCountAggregateOutputType> | number
          }
        }
      }
      WorkflowStepApprover: {
        payload: Prisma.$WorkflowStepApproverPayload<ExtArgs>
        fields: Prisma.WorkflowStepApproverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowStepApproverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepApproverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowStepApproverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepApproverPayload>
          }
          findFirst: {
            args: Prisma.WorkflowStepApproverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepApproverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowStepApproverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepApproverPayload>
          }
          findMany: {
            args: Prisma.WorkflowStepApproverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepApproverPayload>[]
          }
          create: {
            args: Prisma.WorkflowStepApproverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepApproverPayload>
          }
          createMany: {
            args: Prisma.WorkflowStepApproverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowStepApproverCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepApproverPayload>[]
          }
          delete: {
            args: Prisma.WorkflowStepApproverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepApproverPayload>
          }
          update: {
            args: Prisma.WorkflowStepApproverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepApproverPayload>
          }
          deleteMany: {
            args: Prisma.WorkflowStepApproverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowStepApproverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkflowStepApproverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepApproverPayload>
          }
          aggregate: {
            args: Prisma.WorkflowStepApproverAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflowStepApprover>
          }
          groupBy: {
            args: Prisma.WorkflowStepApproverGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowStepApproverGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowStepApproverCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowStepApproverCountAggregateOutputType> | number
          }
        }
      }
      WorkflowInstance: {
        payload: Prisma.$WorkflowInstancePayload<ExtArgs>
        fields: Prisma.WorkflowInstanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowInstanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowInstancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowInstanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowInstancePayload>
          }
          findFirst: {
            args: Prisma.WorkflowInstanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowInstancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowInstanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowInstancePayload>
          }
          findMany: {
            args: Prisma.WorkflowInstanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowInstancePayload>[]
          }
          create: {
            args: Prisma.WorkflowInstanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowInstancePayload>
          }
          createMany: {
            args: Prisma.WorkflowInstanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowInstanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowInstancePayload>[]
          }
          delete: {
            args: Prisma.WorkflowInstanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowInstancePayload>
          }
          update: {
            args: Prisma.WorkflowInstanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowInstancePayload>
          }
          deleteMany: {
            args: Prisma.WorkflowInstanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowInstanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkflowInstanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowInstancePayload>
          }
          aggregate: {
            args: Prisma.WorkflowInstanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflowInstance>
          }
          groupBy: {
            args: Prisma.WorkflowInstanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowInstanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowInstanceCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowInstanceCountAggregateOutputType> | number
          }
        }
      }
      WorkflowStepExecution: {
        payload: Prisma.$WorkflowStepExecutionPayload<ExtArgs>
        fields: Prisma.WorkflowStepExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowStepExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowStepExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepExecutionPayload>
          }
          findFirst: {
            args: Prisma.WorkflowStepExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowStepExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepExecutionPayload>
          }
          findMany: {
            args: Prisma.WorkflowStepExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepExecutionPayload>[]
          }
          create: {
            args: Prisma.WorkflowStepExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepExecutionPayload>
          }
          createMany: {
            args: Prisma.WorkflowStepExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowStepExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepExecutionPayload>[]
          }
          delete: {
            args: Prisma.WorkflowStepExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepExecutionPayload>
          }
          update: {
            args: Prisma.WorkflowStepExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepExecutionPayload>
          }
          deleteMany: {
            args: Prisma.WorkflowStepExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowStepExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkflowStepExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepExecutionPayload>
          }
          aggregate: {
            args: Prisma.WorkflowStepExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflowStepExecution>
          }
          groupBy: {
            args: Prisma.WorkflowStepExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowStepExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowStepExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowStepExecutionCountAggregateOutputType> | number
          }
        }
      }
      WorkflowApproval: {
        payload: Prisma.$WorkflowApprovalPayload<ExtArgs>
        fields: Prisma.WorkflowApprovalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowApprovalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowApprovalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowApprovalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowApprovalPayload>
          }
          findFirst: {
            args: Prisma.WorkflowApprovalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowApprovalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowApprovalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowApprovalPayload>
          }
          findMany: {
            args: Prisma.WorkflowApprovalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowApprovalPayload>[]
          }
          create: {
            args: Prisma.WorkflowApprovalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowApprovalPayload>
          }
          createMany: {
            args: Prisma.WorkflowApprovalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowApprovalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowApprovalPayload>[]
          }
          delete: {
            args: Prisma.WorkflowApprovalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowApprovalPayload>
          }
          update: {
            args: Prisma.WorkflowApprovalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowApprovalPayload>
          }
          deleteMany: {
            args: Prisma.WorkflowApprovalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowApprovalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkflowApprovalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowApprovalPayload>
          }
          aggregate: {
            args: Prisma.WorkflowApprovalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflowApproval>
          }
          groupBy: {
            args: Prisma.WorkflowApprovalGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowApprovalGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowApprovalCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowApprovalCountAggregateOutputType> | number
          }
        }
      }
      WorkflowTemplate: {
        payload: Prisma.$WorkflowTemplatePayload<ExtArgs>
        fields: Prisma.WorkflowTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload>
          }
          findFirst: {
            args: Prisma.WorkflowTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload>
          }
          findMany: {
            args: Prisma.WorkflowTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload>[]
          }
          create: {
            args: Prisma.WorkflowTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload>
          }
          createMany: {
            args: Prisma.WorkflowTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload>[]
          }
          delete: {
            args: Prisma.WorkflowTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload>
          }
          update: {
            args: Prisma.WorkflowTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload>
          }
          deleteMany: {
            args: Prisma.WorkflowTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkflowTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload>
          }
          aggregate: {
            args: Prisma.WorkflowTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflowTemplate>
          }
          groupBy: {
            args: Prisma.WorkflowTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowTemplateCountAggregateOutputType> | number
          }
        }
      }
      AutomationRule: {
        payload: Prisma.$AutomationRulePayload<ExtArgs>
        fields: Prisma.AutomationRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutomationRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutomationRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>
          }
          findFirst: {
            args: Prisma.AutomationRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutomationRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>
          }
          findMany: {
            args: Prisma.AutomationRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>[]
          }
          create: {
            args: Prisma.AutomationRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>
          }
          createMany: {
            args: Prisma.AutomationRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutomationRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>[]
          }
          delete: {
            args: Prisma.AutomationRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>
          }
          update: {
            args: Prisma.AutomationRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>
          }
          deleteMany: {
            args: Prisma.AutomationRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutomationRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AutomationRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>
          }
          aggregate: {
            args: Prisma.AutomationRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutomationRule>
          }
          groupBy: {
            args: Prisma.AutomationRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutomationRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutomationRuleCountArgs<ExtArgs>
            result: $Utils.Optional<AutomationRuleCountAggregateOutputType> | number
          }
        }
      }
      AutomationExecution: {
        payload: Prisma.$AutomationExecutionPayload<ExtArgs>
        fields: Prisma.AutomationExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutomationExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutomationExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload>
          }
          findFirst: {
            args: Prisma.AutomationExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutomationExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload>
          }
          findMany: {
            args: Prisma.AutomationExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload>[]
          }
          create: {
            args: Prisma.AutomationExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload>
          }
          createMany: {
            args: Prisma.AutomationExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutomationExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload>[]
          }
          delete: {
            args: Prisma.AutomationExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload>
          }
          update: {
            args: Prisma.AutomationExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload>
          }
          deleteMany: {
            args: Prisma.AutomationExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutomationExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AutomationExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload>
          }
          aggregate: {
            args: Prisma.AutomationExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutomationExecution>
          }
          groupBy: {
            args: Prisma.AutomationExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutomationExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutomationExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<AutomationExecutionCountAggregateOutputType> | number
          }
        }
      }
      TestPlan: {
        payload: Prisma.$TestPlanPayload<ExtArgs>
        fields: Prisma.TestPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPlanPayload>
          }
          findFirst: {
            args: Prisma.TestPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPlanPayload>
          }
          findMany: {
            args: Prisma.TestPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPlanPayload>[]
          }
          create: {
            args: Prisma.TestPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPlanPayload>
          }
          createMany: {
            args: Prisma.TestPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPlanPayload>[]
          }
          delete: {
            args: Prisma.TestPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPlanPayload>
          }
          update: {
            args: Prisma.TestPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPlanPayload>
          }
          deleteMany: {
            args: Prisma.TestPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPlanPayload>
          }
          aggregate: {
            args: Prisma.TestPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestPlan>
          }
          groupBy: {
            args: Prisma.TestPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestPlanCountArgs<ExtArgs>
            result: $Utils.Optional<TestPlanCountAggregateOutputType> | number
          }
        }
      }
      TestCase: {
        payload: Prisma.$TestCasePayload<ExtArgs>
        fields: Prisma.TestCaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestCaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestCaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCasePayload>
          }
          findFirst: {
            args: Prisma.TestCaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestCaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCasePayload>
          }
          findMany: {
            args: Prisma.TestCaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCasePayload>[]
          }
          create: {
            args: Prisma.TestCaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCasePayload>
          }
          createMany: {
            args: Prisma.TestCaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestCaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCasePayload>[]
          }
          delete: {
            args: Prisma.TestCaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCasePayload>
          }
          update: {
            args: Prisma.TestCaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCasePayload>
          }
          deleteMany: {
            args: Prisma.TestCaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestCaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestCaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCasePayload>
          }
          aggregate: {
            args: Prisma.TestCaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestCase>
          }
          groupBy: {
            args: Prisma.TestCaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestCaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestCaseCountArgs<ExtArgs>
            result: $Utils.Optional<TestCaseCountAggregateOutputType> | number
          }
        }
      }
      TestExecution: {
        payload: Prisma.$TestExecutionPayload<ExtArgs>
        fields: Prisma.TestExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestExecutionPayload>
          }
          findFirst: {
            args: Prisma.TestExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestExecutionPayload>
          }
          findMany: {
            args: Prisma.TestExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestExecutionPayload>[]
          }
          create: {
            args: Prisma.TestExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestExecutionPayload>
          }
          createMany: {
            args: Prisma.TestExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestExecutionPayload>[]
          }
          delete: {
            args: Prisma.TestExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestExecutionPayload>
          }
          update: {
            args: Prisma.TestExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestExecutionPayload>
          }
          deleteMany: {
            args: Prisma.TestExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestExecutionPayload>
          }
          aggregate: {
            args: Prisma.TestExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestExecution>
          }
          groupBy: {
            args: Prisma.TestExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<TestExecutionCountAggregateOutputType> | number
          }
        }
      }
      Defect: {
        payload: Prisma.$DefectPayload<ExtArgs>
        fields: Prisma.DefectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DefectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DefectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectPayload>
          }
          findFirst: {
            args: Prisma.DefectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DefectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectPayload>
          }
          findMany: {
            args: Prisma.DefectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectPayload>[]
          }
          create: {
            args: Prisma.DefectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectPayload>
          }
          createMany: {
            args: Prisma.DefectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DefectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectPayload>[]
          }
          delete: {
            args: Prisma.DefectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectPayload>
          }
          update: {
            args: Prisma.DefectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectPayload>
          }
          deleteMany: {
            args: Prisma.DefectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DefectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DefectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectPayload>
          }
          aggregate: {
            args: Prisma.DefectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDefect>
          }
          groupBy: {
            args: Prisma.DefectGroupByArgs<ExtArgs>
            result: $Utils.Optional<DefectGroupByOutputType>[]
          }
          count: {
            args: Prisma.DefectCountArgs<ExtArgs>
            result: $Utils.Optional<DefectCountAggregateOutputType> | number
          }
        }
      }
      DefectTestCase: {
        payload: Prisma.$DefectTestCasePayload<ExtArgs>
        fields: Prisma.DefectTestCaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DefectTestCaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectTestCasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DefectTestCaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectTestCasePayload>
          }
          findFirst: {
            args: Prisma.DefectTestCaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectTestCasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DefectTestCaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectTestCasePayload>
          }
          findMany: {
            args: Prisma.DefectTestCaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectTestCasePayload>[]
          }
          create: {
            args: Prisma.DefectTestCaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectTestCasePayload>
          }
          createMany: {
            args: Prisma.DefectTestCaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DefectTestCaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectTestCasePayload>[]
          }
          delete: {
            args: Prisma.DefectTestCaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectTestCasePayload>
          }
          update: {
            args: Prisma.DefectTestCaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectTestCasePayload>
          }
          deleteMany: {
            args: Prisma.DefectTestCaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DefectTestCaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DefectTestCaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectTestCasePayload>
          }
          aggregate: {
            args: Prisma.DefectTestCaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDefectTestCase>
          }
          groupBy: {
            args: Prisma.DefectTestCaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<DefectTestCaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.DefectTestCaseCountArgs<ExtArgs>
            result: $Utils.Optional<DefectTestCaseCountAggregateOutputType> | number
          }
        }
      }
      DefectComment: {
        payload: Prisma.$DefectCommentPayload<ExtArgs>
        fields: Prisma.DefectCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DefectCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DefectCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectCommentPayload>
          }
          findFirst: {
            args: Prisma.DefectCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DefectCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectCommentPayload>
          }
          findMany: {
            args: Prisma.DefectCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectCommentPayload>[]
          }
          create: {
            args: Prisma.DefectCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectCommentPayload>
          }
          createMany: {
            args: Prisma.DefectCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DefectCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectCommentPayload>[]
          }
          delete: {
            args: Prisma.DefectCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectCommentPayload>
          }
          update: {
            args: Prisma.DefectCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectCommentPayload>
          }
          deleteMany: {
            args: Prisma.DefectCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DefectCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DefectCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectCommentPayload>
          }
          aggregate: {
            args: Prisma.DefectCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDefectComment>
          }
          groupBy: {
            args: Prisma.DefectCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DefectCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DefectCommentCountArgs<ExtArgs>
            result: $Utils.Optional<DefectCommentCountAggregateOutputType> | number
          }
        }
      }
      QAReview: {
        payload: Prisma.$QAReviewPayload<ExtArgs>
        fields: Prisma.QAReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QAReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QAReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAReviewPayload>
          }
          findFirst: {
            args: Prisma.QAReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QAReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAReviewPayload>
          }
          findMany: {
            args: Prisma.QAReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAReviewPayload>[]
          }
          create: {
            args: Prisma.QAReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAReviewPayload>
          }
          createMany: {
            args: Prisma.QAReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QAReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAReviewPayload>[]
          }
          delete: {
            args: Prisma.QAReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAReviewPayload>
          }
          update: {
            args: Prisma.QAReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAReviewPayload>
          }
          deleteMany: {
            args: Prisma.QAReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QAReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QAReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAReviewPayload>
          }
          aggregate: {
            args: Prisma.QAReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQAReview>
          }
          groupBy: {
            args: Prisma.QAReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<QAReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.QAReviewCountArgs<ExtArgs>
            result: $Utils.Optional<QAReviewCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    ownedAccounts: number
    activities: number
    ownedCompletedProjects: number
    ownedEnquiries: number
    ownedLeads: number
    ownedProjects: number
    assignedTasks: number
    createdUsers: number
    updatedUsers: number
    createdWorkflows: number
    initiatedWorkflows: number
    assignedSteps: number
    approverSteps: number
    approvals: number
    createdTemplates: number
    createdRules: number
    createdTestPlans: number
    assignedTestPlans: number
    createdTestCases: number
    testExecutions: number
    reportedDefects: number
    assignedDefects: number
    qaReviews: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedAccounts?: boolean | UserCountOutputTypeCountOwnedAccountsArgs
    activities?: boolean | UserCountOutputTypeCountActivitiesArgs
    ownedCompletedProjects?: boolean | UserCountOutputTypeCountOwnedCompletedProjectsArgs
    ownedEnquiries?: boolean | UserCountOutputTypeCountOwnedEnquiriesArgs
    ownedLeads?: boolean | UserCountOutputTypeCountOwnedLeadsArgs
    ownedProjects?: boolean | UserCountOutputTypeCountOwnedProjectsArgs
    assignedTasks?: boolean | UserCountOutputTypeCountAssignedTasksArgs
    createdUsers?: boolean | UserCountOutputTypeCountCreatedUsersArgs
    updatedUsers?: boolean | UserCountOutputTypeCountUpdatedUsersArgs
    createdWorkflows?: boolean | UserCountOutputTypeCountCreatedWorkflowsArgs
    initiatedWorkflows?: boolean | UserCountOutputTypeCountInitiatedWorkflowsArgs
    assignedSteps?: boolean | UserCountOutputTypeCountAssignedStepsArgs
    approverSteps?: boolean | UserCountOutputTypeCountApproverStepsArgs
    approvals?: boolean | UserCountOutputTypeCountApprovalsArgs
    createdTemplates?: boolean | UserCountOutputTypeCountCreatedTemplatesArgs
    createdRules?: boolean | UserCountOutputTypeCountCreatedRulesArgs
    createdTestPlans?: boolean | UserCountOutputTypeCountCreatedTestPlansArgs
    assignedTestPlans?: boolean | UserCountOutputTypeCountAssignedTestPlansArgs
    createdTestCases?: boolean | UserCountOutputTypeCountCreatedTestCasesArgs
    testExecutions?: boolean | UserCountOutputTypeCountTestExecutionsArgs
    reportedDefects?: boolean | UserCountOutputTypeCountReportedDefectsArgs
    assignedDefects?: boolean | UserCountOutputTypeCountAssignedDefectsArgs
    qaReviews?: boolean | UserCountOutputTypeCountQaReviewsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedCompletedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompletedProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedEnquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnquiryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowDefinitionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInitiatedWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowInstanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowStepExecutionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApproverStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowStepApproverWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowApprovalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowTemplateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationRuleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTestPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestPlanWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedTestPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestPlanWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTestCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestCaseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTestExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestExecutionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportedDefectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedDefectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQaReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QAReviewWhereInput
  }


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    activities: number
    appointments: number
    completedProjects: number
    contacts: number
    documents: number
    enquiries: number
    events: number
    leads: number
    projects: number
    snags: number
    tasks: number
    workflows: number
    workflowInstances: number
    workflowTemplates: number
    automationRules: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | AccountCountOutputTypeCountActivitiesArgs
    appointments?: boolean | AccountCountOutputTypeCountAppointmentsArgs
    completedProjects?: boolean | AccountCountOutputTypeCountCompletedProjectsArgs
    contacts?: boolean | AccountCountOutputTypeCountContactsArgs
    documents?: boolean | AccountCountOutputTypeCountDocumentsArgs
    enquiries?: boolean | AccountCountOutputTypeCountEnquiriesArgs
    events?: boolean | AccountCountOutputTypeCountEventsArgs
    leads?: boolean | AccountCountOutputTypeCountLeadsArgs
    projects?: boolean | AccountCountOutputTypeCountProjectsArgs
    snags?: boolean | AccountCountOutputTypeCountSnagsArgs
    tasks?: boolean | AccountCountOutputTypeCountTasksArgs
    workflows?: boolean | AccountCountOutputTypeCountWorkflowsArgs
    workflowInstances?: boolean | AccountCountOutputTypeCountWorkflowInstancesArgs
    workflowTemplates?: boolean | AccountCountOutputTypeCountWorkflowTemplatesArgs
    automationRules?: boolean | AccountCountOutputTypeCountAutomationRulesArgs
  }

  // Custom InputTypes
  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountCompletedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompletedProjectWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountEnquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnquiryWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventLogWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountSnagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SnagWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowDefinitionWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountWorkflowInstancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowInstanceWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountWorkflowTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowTemplateWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountAutomationRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationRuleWhereInput
  }


  /**
   * Count Type EnquiryCountOutputType
   */

  export type EnquiryCountOutputType = {
    activities: number
    tasks: number
  }

  export type EnquiryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | EnquiryCountOutputTypeCountActivitiesArgs
    tasks?: boolean | EnquiryCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * EnquiryCountOutputType without action
   */
  export type EnquiryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnquiryCountOutputType
     */
    select?: EnquiryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EnquiryCountOutputType without action
   */
  export type EnquiryCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * EnquiryCountOutputType without action
   */
  export type EnquiryCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type LeadCountOutputType
   */

  export type LeadCountOutputType = {
    activities: number
    tasks: number
  }

  export type LeadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | LeadCountOutputTypeCountActivitiesArgs
    tasks?: boolean | LeadCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCountOutputType
     */
    select?: LeadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    activities: number
    appointments: number
    documents: number
    snags: number
    tasks: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | ProjectCountOutputTypeCountActivitiesArgs
    appointments?: boolean | ProjectCountOutputTypeCountAppointmentsArgs
    documents?: boolean | ProjectCountOutputTypeCountDocumentsArgs
    snags?: boolean | ProjectCountOutputTypeCountSnagsArgs
    tasks?: boolean | ProjectCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSnagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SnagWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type WorkflowDefinitionCountOutputType
   */

  export type WorkflowDefinitionCountOutputType = {
    steps: number
    instances: number
    templates: number
  }

  export type WorkflowDefinitionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steps?: boolean | WorkflowDefinitionCountOutputTypeCountStepsArgs
    instances?: boolean | WorkflowDefinitionCountOutputTypeCountInstancesArgs
    templates?: boolean | WorkflowDefinitionCountOutputTypeCountTemplatesArgs
  }

  // Custom InputTypes
  /**
   * WorkflowDefinitionCountOutputType without action
   */
  export type WorkflowDefinitionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinitionCountOutputType
     */
    select?: WorkflowDefinitionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkflowDefinitionCountOutputType without action
   */
  export type WorkflowDefinitionCountOutputTypeCountStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowStepWhereInput
  }

  /**
   * WorkflowDefinitionCountOutputType without action
   */
  export type WorkflowDefinitionCountOutputTypeCountInstancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowInstanceWhereInput
  }

  /**
   * WorkflowDefinitionCountOutputType without action
   */
  export type WorkflowDefinitionCountOutputTypeCountTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowTemplateWhereInput
  }


  /**
   * Count Type WorkflowStepCountOutputType
   */

  export type WorkflowStepCountOutputType = {
    executions: number
    approvers: number
  }

  export type WorkflowStepCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executions?: boolean | WorkflowStepCountOutputTypeCountExecutionsArgs
    approvers?: boolean | WorkflowStepCountOutputTypeCountApproversArgs
  }

  // Custom InputTypes
  /**
   * WorkflowStepCountOutputType without action
   */
  export type WorkflowStepCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepCountOutputType
     */
    select?: WorkflowStepCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkflowStepCountOutputType without action
   */
  export type WorkflowStepCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowStepExecutionWhereInput
  }

  /**
   * WorkflowStepCountOutputType without action
   */
  export type WorkflowStepCountOutputTypeCountApproversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowStepApproverWhereInput
  }


  /**
   * Count Type WorkflowStepApproverCountOutputType
   */

  export type WorkflowStepApproverCountOutputType = {
    approvals: number
  }

  export type WorkflowStepApproverCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approvals?: boolean | WorkflowStepApproverCountOutputTypeCountApprovalsArgs
  }

  // Custom InputTypes
  /**
   * WorkflowStepApproverCountOutputType without action
   */
  export type WorkflowStepApproverCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepApproverCountOutputType
     */
    select?: WorkflowStepApproverCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkflowStepApproverCountOutputType without action
   */
  export type WorkflowStepApproverCountOutputTypeCountApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowApprovalWhereInput
  }


  /**
   * Count Type WorkflowInstanceCountOutputType
   */

  export type WorkflowInstanceCountOutputType = {
    executions: number
    approvals: number
  }

  export type WorkflowInstanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executions?: boolean | WorkflowInstanceCountOutputTypeCountExecutionsArgs
    approvals?: boolean | WorkflowInstanceCountOutputTypeCountApprovalsArgs
  }

  // Custom InputTypes
  /**
   * WorkflowInstanceCountOutputType without action
   */
  export type WorkflowInstanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstanceCountOutputType
     */
    select?: WorkflowInstanceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkflowInstanceCountOutputType without action
   */
  export type WorkflowInstanceCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowStepExecutionWhereInput
  }

  /**
   * WorkflowInstanceCountOutputType without action
   */
  export type WorkflowInstanceCountOutputTypeCountApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowApprovalWhereInput
  }


  /**
   * Count Type AutomationRuleCountOutputType
   */

  export type AutomationRuleCountOutputType = {
    executions: number
  }

  export type AutomationRuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executions?: boolean | AutomationRuleCountOutputTypeCountExecutionsArgs
  }

  // Custom InputTypes
  /**
   * AutomationRuleCountOutputType without action
   */
  export type AutomationRuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRuleCountOutputType
     */
    select?: AutomationRuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AutomationRuleCountOutputType without action
   */
  export type AutomationRuleCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationExecutionWhereInput
  }


  /**
   * Count Type TestPlanCountOutputType
   */

  export type TestPlanCountOutputType = {
    testCases: number
    executions: number
    reviews: number
  }

  export type TestPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testCases?: boolean | TestPlanCountOutputTypeCountTestCasesArgs
    executions?: boolean | TestPlanCountOutputTypeCountExecutionsArgs
    reviews?: boolean | TestPlanCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * TestPlanCountOutputType without action
   */
  export type TestPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPlanCountOutputType
     */
    select?: TestPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TestPlanCountOutputType without action
   */
  export type TestPlanCountOutputTypeCountTestCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestCaseWhereInput
  }

  /**
   * TestPlanCountOutputType without action
   */
  export type TestPlanCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestExecutionWhereInput
  }

  /**
   * TestPlanCountOutputType without action
   */
  export type TestPlanCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QAReviewWhereInput
  }


  /**
   * Count Type TestCaseCountOutputType
   */

  export type TestCaseCountOutputType = {
    executions: number
    defects: number
  }

  export type TestCaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executions?: boolean | TestCaseCountOutputTypeCountExecutionsArgs
    defects?: boolean | TestCaseCountOutputTypeCountDefectsArgs
  }

  // Custom InputTypes
  /**
   * TestCaseCountOutputType without action
   */
  export type TestCaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCaseCountOutputType
     */
    select?: TestCaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TestCaseCountOutputType without action
   */
  export type TestCaseCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestExecutionWhereInput
  }

  /**
   * TestCaseCountOutputType without action
   */
  export type TestCaseCountOutputTypeCountDefectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefectTestCaseWhereInput
  }


  /**
   * Count Type TestExecutionCountOutputType
   */

  export type TestExecutionCountOutputType = {
    defects: number
  }

  export type TestExecutionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defects?: boolean | TestExecutionCountOutputTypeCountDefectsArgs
  }

  // Custom InputTypes
  /**
   * TestExecutionCountOutputType without action
   */
  export type TestExecutionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestExecutionCountOutputType
     */
    select?: TestExecutionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TestExecutionCountOutputType without action
   */
  export type TestExecutionCountOutputTypeCountDefectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefectWhereInput
  }


  /**
   * Count Type DefectCountOutputType
   */

  export type DefectCountOutputType = {
    testCases: number
    comments: number
  }

  export type DefectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testCases?: boolean | DefectCountOutputTypeCountTestCasesArgs
    comments?: boolean | DefectCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * DefectCountOutputType without action
   */
  export type DefectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectCountOutputType
     */
    select?: DefectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DefectCountOutputType without action
   */
  export type DefectCountOutputTypeCountTestCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefectTestCaseWhereInput
  }

  /**
   * DefectCountOutputType without action
   */
  export type DefectCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefectCommentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    lastLoginAt: Date | null
    emailVerifiedAt: Date | null
    twoFactorSecret: string | null
    twoFactorEnabled: boolean | null
    avatarUrl: string | null
    timezone: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    lastLoginAt: Date | null
    emailVerifiedAt: Date | null
    twoFactorSecret: string | null
    twoFactorEnabled: boolean | null
    avatarUrl: string | null
    timezone: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    firstName: number
    lastName: number
    phone: number
    role: number
    isActive: number
    lastLoginAt: number
    emailVerifiedAt: number
    twoFactorSecret: number
    twoFactorEnabled: number
    avatarUrl: number
    timezone: number
    preferences: number
    createdAt: number
    updatedAt: number
    createdById: number
    updatedById: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    phone?: true
    role?: true
    isActive?: true
    lastLoginAt?: true
    emailVerifiedAt?: true
    twoFactorSecret?: true
    twoFactorEnabled?: true
    avatarUrl?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    phone?: true
    role?: true
    isActive?: true
    lastLoginAt?: true
    emailVerifiedAt?: true
    twoFactorSecret?: true
    twoFactorEnabled?: true
    avatarUrl?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    phone?: true
    role?: true
    isActive?: true
    lastLoginAt?: true
    emailVerifiedAt?: true
    twoFactorSecret?: true
    twoFactorEnabled?: true
    avatarUrl?: true
    timezone?: true
    preferences?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string | null
    firstName: string
    lastName: string
    phone: string | null
    role: $Enums.UserRole
    isActive: boolean
    lastLoginAt: Date | null
    emailVerifiedAt: Date | null
    twoFactorSecret: string | null
    twoFactorEnabled: boolean
    avatarUrl: string | null
    timezone: string
    preferences: JsonValue
    createdAt: Date
    updatedAt: Date
    createdById: string | null
    updatedById: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    role?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    emailVerifiedAt?: boolean
    twoFactorSecret?: boolean
    twoFactorEnabled?: boolean
    avatarUrl?: boolean
    timezone?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    ownedAccounts?: boolean | User$ownedAccountsArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    ownedCompletedProjects?: boolean | User$ownedCompletedProjectsArgs<ExtArgs>
    ownedEnquiries?: boolean | User$ownedEnquiriesArgs<ExtArgs>
    ownedLeads?: boolean | User$ownedLeadsArgs<ExtArgs>
    ownedProjects?: boolean | User$ownedProjectsArgs<ExtArgs>
    assignedTasks?: boolean | User$assignedTasksArgs<ExtArgs>
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    createdUsers?: boolean | User$createdUsersArgs<ExtArgs>
    updatedBy?: boolean | User$updatedByArgs<ExtArgs>
    updatedUsers?: boolean | User$updatedUsersArgs<ExtArgs>
    createdWorkflows?: boolean | User$createdWorkflowsArgs<ExtArgs>
    initiatedWorkflows?: boolean | User$initiatedWorkflowsArgs<ExtArgs>
    assignedSteps?: boolean | User$assignedStepsArgs<ExtArgs>
    approverSteps?: boolean | User$approverStepsArgs<ExtArgs>
    approvals?: boolean | User$approvalsArgs<ExtArgs>
    createdTemplates?: boolean | User$createdTemplatesArgs<ExtArgs>
    createdRules?: boolean | User$createdRulesArgs<ExtArgs>
    createdTestPlans?: boolean | User$createdTestPlansArgs<ExtArgs>
    assignedTestPlans?: boolean | User$assignedTestPlansArgs<ExtArgs>
    createdTestCases?: boolean | User$createdTestCasesArgs<ExtArgs>
    testExecutions?: boolean | User$testExecutionsArgs<ExtArgs>
    reportedDefects?: boolean | User$reportedDefectsArgs<ExtArgs>
    assignedDefects?: boolean | User$assignedDefectsArgs<ExtArgs>
    qaReviews?: boolean | User$qaReviewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    role?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    emailVerifiedAt?: boolean
    twoFactorSecret?: boolean
    twoFactorEnabled?: boolean
    avatarUrl?: boolean
    timezone?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    updatedBy?: boolean | User$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    role?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    emailVerifiedAt?: boolean
    twoFactorSecret?: boolean
    twoFactorEnabled?: boolean
    avatarUrl?: boolean
    timezone?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedAccounts?: boolean | User$ownedAccountsArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    ownedCompletedProjects?: boolean | User$ownedCompletedProjectsArgs<ExtArgs>
    ownedEnquiries?: boolean | User$ownedEnquiriesArgs<ExtArgs>
    ownedLeads?: boolean | User$ownedLeadsArgs<ExtArgs>
    ownedProjects?: boolean | User$ownedProjectsArgs<ExtArgs>
    assignedTasks?: boolean | User$assignedTasksArgs<ExtArgs>
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    createdUsers?: boolean | User$createdUsersArgs<ExtArgs>
    updatedBy?: boolean | User$updatedByArgs<ExtArgs>
    updatedUsers?: boolean | User$updatedUsersArgs<ExtArgs>
    createdWorkflows?: boolean | User$createdWorkflowsArgs<ExtArgs>
    initiatedWorkflows?: boolean | User$initiatedWorkflowsArgs<ExtArgs>
    assignedSteps?: boolean | User$assignedStepsArgs<ExtArgs>
    approverSteps?: boolean | User$approverStepsArgs<ExtArgs>
    approvals?: boolean | User$approvalsArgs<ExtArgs>
    createdTemplates?: boolean | User$createdTemplatesArgs<ExtArgs>
    createdRules?: boolean | User$createdRulesArgs<ExtArgs>
    createdTestPlans?: boolean | User$createdTestPlansArgs<ExtArgs>
    assignedTestPlans?: boolean | User$assignedTestPlansArgs<ExtArgs>
    createdTestCases?: boolean | User$createdTestCasesArgs<ExtArgs>
    testExecutions?: boolean | User$testExecutionsArgs<ExtArgs>
    reportedDefects?: boolean | User$reportedDefectsArgs<ExtArgs>
    assignedDefects?: boolean | User$assignedDefectsArgs<ExtArgs>
    qaReviews?: boolean | User$qaReviewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    updatedBy?: boolean | User$updatedByArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      ownedAccounts: Prisma.$AccountPayload<ExtArgs>[]
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      ownedCompletedProjects: Prisma.$CompletedProjectPayload<ExtArgs>[]
      ownedEnquiries: Prisma.$EnquiryPayload<ExtArgs>[]
      ownedLeads: Prisma.$LeadPayload<ExtArgs>[]
      ownedProjects: Prisma.$ProjectPayload<ExtArgs>[]
      assignedTasks: Prisma.$TaskPayload<ExtArgs>[]
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      createdUsers: Prisma.$UserPayload<ExtArgs>[]
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
      updatedUsers: Prisma.$UserPayload<ExtArgs>[]
      createdWorkflows: Prisma.$WorkflowDefinitionPayload<ExtArgs>[]
      initiatedWorkflows: Prisma.$WorkflowInstancePayload<ExtArgs>[]
      assignedSteps: Prisma.$WorkflowStepExecutionPayload<ExtArgs>[]
      approverSteps: Prisma.$WorkflowStepApproverPayload<ExtArgs>[]
      approvals: Prisma.$WorkflowApprovalPayload<ExtArgs>[]
      createdTemplates: Prisma.$WorkflowTemplatePayload<ExtArgs>[]
      createdRules: Prisma.$AutomationRulePayload<ExtArgs>[]
      createdTestPlans: Prisma.$TestPlanPayload<ExtArgs>[]
      assignedTestPlans: Prisma.$TestPlanPayload<ExtArgs>[]
      createdTestCases: Prisma.$TestCasePayload<ExtArgs>[]
      testExecutions: Prisma.$TestExecutionPayload<ExtArgs>[]
      reportedDefects: Prisma.$DefectPayload<ExtArgs>[]
      assignedDefects: Prisma.$DefectPayload<ExtArgs>[]
      qaReviews: Prisma.$QAReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string | null
      firstName: string
      lastName: string
      phone: string | null
      role: $Enums.UserRole
      isActive: boolean
      lastLoginAt: Date | null
      emailVerifiedAt: Date | null
      twoFactorSecret: string | null
      twoFactorEnabled: boolean
      avatarUrl: string | null
      timezone: string
      preferences: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
      createdById: string | null
      updatedById: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ownedAccounts<T extends User$ownedAccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany"> | Null>
    activities<T extends User$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany"> | Null>
    ownedCompletedProjects<T extends User$ownedCompletedProjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedCompletedProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompletedProjectPayload<ExtArgs>, T, "findMany"> | Null>
    ownedEnquiries<T extends User$ownedEnquiriesArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedEnquiriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findMany"> | Null>
    ownedLeads<T extends User$ownedLeadsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedLeadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany"> | Null>
    ownedProjects<T extends User$ownedProjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    assignedTasks<T extends User$assignedTasksArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    createdBy<T extends User$createdByArgs<ExtArgs> = {}>(args?: Subset<T, User$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    createdUsers<T extends User$createdUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$createdUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    updatedBy<T extends User$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    updatedUsers<T extends User$updatedUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    createdWorkflows<T extends User$createdWorkflowsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdWorkflowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "findMany"> | Null>
    initiatedWorkflows<T extends User$initiatedWorkflowsArgs<ExtArgs> = {}>(args?: Subset<T, User$initiatedWorkflowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "findMany"> | Null>
    assignedSteps<T extends User$assignedStepsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedStepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowStepExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    approverSteps<T extends User$approverStepsArgs<ExtArgs> = {}>(args?: Subset<T, User$approverStepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowStepApproverPayload<ExtArgs>, T, "findMany"> | Null>
    approvals<T extends User$approvalsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowApprovalPayload<ExtArgs>, T, "findMany"> | Null>
    createdTemplates<T extends User$createdTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    createdRules<T extends User$createdRulesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findMany"> | Null>
    createdTestPlans<T extends User$createdTestPlansArgs<ExtArgs> = {}>(args?: Subset<T, User$createdTestPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestPlanPayload<ExtArgs>, T, "findMany"> | Null>
    assignedTestPlans<T extends User$assignedTestPlansArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedTestPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestPlanPayload<ExtArgs>, T, "findMany"> | Null>
    createdTestCases<T extends User$createdTestCasesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdTestCasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "findMany"> | Null>
    testExecutions<T extends User$testExecutionsArgs<ExtArgs> = {}>(args?: Subset<T, User$testExecutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    reportedDefects<T extends User$reportedDefectsArgs<ExtArgs> = {}>(args?: Subset<T, User$reportedDefectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefectPayload<ExtArgs>, T, "findMany"> | Null>
    assignedDefects<T extends User$assignedDefectsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedDefectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefectPayload<ExtArgs>, T, "findMany"> | Null>
    qaReviews<T extends User$qaReviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$qaReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QAReviewPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly emailVerifiedAt: FieldRef<"User", 'DateTime'>
    readonly twoFactorSecret: FieldRef<"User", 'String'>
    readonly twoFactorEnabled: FieldRef<"User", 'Boolean'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly timezone: FieldRef<"User", 'String'>
    readonly preferences: FieldRef<"User", 'Json'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly createdById: FieldRef<"User", 'String'>
    readonly updatedById: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.ownedAccounts
   */
  export type User$ownedAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.activities
   */
  export type User$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * User.ownedCompletedProjects
   */
  export type User$ownedCompletedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedProject
     */
    select?: CompletedProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedProjectInclude<ExtArgs> | null
    where?: CompletedProjectWhereInput
    orderBy?: CompletedProjectOrderByWithRelationInput | CompletedProjectOrderByWithRelationInput[]
    cursor?: CompletedProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompletedProjectScalarFieldEnum | CompletedProjectScalarFieldEnum[]
  }

  /**
   * User.ownedEnquiries
   */
  export type User$ownedEnquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    where?: EnquiryWhereInput
    orderBy?: EnquiryOrderByWithRelationInput | EnquiryOrderByWithRelationInput[]
    cursor?: EnquiryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnquiryScalarFieldEnum | EnquiryScalarFieldEnum[]
  }

  /**
   * User.ownedLeads
   */
  export type User$ownedLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * User.ownedProjects
   */
  export type User$ownedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.assignedTasks
   */
  export type User$assignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * User.createdBy
   */
  export type User$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.createdUsers
   */
  export type User$createdUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.updatedBy
   */
  export type User$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.updatedUsers
   */
  export type User$updatedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.createdWorkflows
   */
  export type User$createdWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinition
     */
    select?: WorkflowDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowDefinitionInclude<ExtArgs> | null
    where?: WorkflowDefinitionWhereInput
    orderBy?: WorkflowDefinitionOrderByWithRelationInput | WorkflowDefinitionOrderByWithRelationInput[]
    cursor?: WorkflowDefinitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowDefinitionScalarFieldEnum | WorkflowDefinitionScalarFieldEnum[]
  }

  /**
   * User.initiatedWorkflows
   */
  export type User$initiatedWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
    where?: WorkflowInstanceWhereInput
    orderBy?: WorkflowInstanceOrderByWithRelationInput | WorkflowInstanceOrderByWithRelationInput[]
    cursor?: WorkflowInstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowInstanceScalarFieldEnum | WorkflowInstanceScalarFieldEnum[]
  }

  /**
   * User.assignedSteps
   */
  export type User$assignedStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionInclude<ExtArgs> | null
    where?: WorkflowStepExecutionWhereInput
    orderBy?: WorkflowStepExecutionOrderByWithRelationInput | WorkflowStepExecutionOrderByWithRelationInput[]
    cursor?: WorkflowStepExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowStepExecutionScalarFieldEnum | WorkflowStepExecutionScalarFieldEnum[]
  }

  /**
   * User.approverSteps
   */
  export type User$approverStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepApprover
     */
    select?: WorkflowStepApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepApproverInclude<ExtArgs> | null
    where?: WorkflowStepApproverWhereInput
    orderBy?: WorkflowStepApproverOrderByWithRelationInput | WorkflowStepApproverOrderByWithRelationInput[]
    cursor?: WorkflowStepApproverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowStepApproverScalarFieldEnum | WorkflowStepApproverScalarFieldEnum[]
  }

  /**
   * User.approvals
   */
  export type User$approvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowApproval
     */
    select?: WorkflowApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowApprovalInclude<ExtArgs> | null
    where?: WorkflowApprovalWhereInput
    orderBy?: WorkflowApprovalOrderByWithRelationInput | WorkflowApprovalOrderByWithRelationInput[]
    cursor?: WorkflowApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowApprovalScalarFieldEnum | WorkflowApprovalScalarFieldEnum[]
  }

  /**
   * User.createdTemplates
   */
  export type User$createdTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTemplateInclude<ExtArgs> | null
    where?: WorkflowTemplateWhereInput
    orderBy?: WorkflowTemplateOrderByWithRelationInput | WorkflowTemplateOrderByWithRelationInput[]
    cursor?: WorkflowTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowTemplateScalarFieldEnum | WorkflowTemplateScalarFieldEnum[]
  }

  /**
   * User.createdRules
   */
  export type User$createdRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    where?: AutomationRuleWhereInput
    orderBy?: AutomationRuleOrderByWithRelationInput | AutomationRuleOrderByWithRelationInput[]
    cursor?: AutomationRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationRuleScalarFieldEnum | AutomationRuleScalarFieldEnum[]
  }

  /**
   * User.createdTestPlans
   */
  export type User$createdTestPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPlan
     */
    select?: TestPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPlanInclude<ExtArgs> | null
    where?: TestPlanWhereInput
    orderBy?: TestPlanOrderByWithRelationInput | TestPlanOrderByWithRelationInput[]
    cursor?: TestPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestPlanScalarFieldEnum | TestPlanScalarFieldEnum[]
  }

  /**
   * User.assignedTestPlans
   */
  export type User$assignedTestPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPlan
     */
    select?: TestPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPlanInclude<ExtArgs> | null
    where?: TestPlanWhereInput
    orderBy?: TestPlanOrderByWithRelationInput | TestPlanOrderByWithRelationInput[]
    cursor?: TestPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestPlanScalarFieldEnum | TestPlanScalarFieldEnum[]
  }

  /**
   * User.createdTestCases
   */
  export type User$createdTestCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseInclude<ExtArgs> | null
    where?: TestCaseWhereInput
    orderBy?: TestCaseOrderByWithRelationInput | TestCaseOrderByWithRelationInput[]
    cursor?: TestCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestCaseScalarFieldEnum | TestCaseScalarFieldEnum[]
  }

  /**
   * User.testExecutions
   */
  export type User$testExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestExecution
     */
    select?: TestExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestExecutionInclude<ExtArgs> | null
    where?: TestExecutionWhereInput
    orderBy?: TestExecutionOrderByWithRelationInput | TestExecutionOrderByWithRelationInput[]
    cursor?: TestExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestExecutionScalarFieldEnum | TestExecutionScalarFieldEnum[]
  }

  /**
   * User.reportedDefects
   */
  export type User$reportedDefectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defect
     */
    select?: DefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectInclude<ExtArgs> | null
    where?: DefectWhereInput
    orderBy?: DefectOrderByWithRelationInput | DefectOrderByWithRelationInput[]
    cursor?: DefectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DefectScalarFieldEnum | DefectScalarFieldEnum[]
  }

  /**
   * User.assignedDefects
   */
  export type User$assignedDefectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defect
     */
    select?: DefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectInclude<ExtArgs> | null
    where?: DefectWhereInput
    orderBy?: DefectOrderByWithRelationInput | DefectOrderByWithRelationInput[]
    cursor?: DefectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DefectScalarFieldEnum | DefectScalarFieldEnum[]
  }

  /**
   * User.qaReviews
   */
  export type User$qaReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAReview
     */
    select?: QAReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAReviewInclude<ExtArgs> | null
    where?: QAReviewWhereInput
    orderBy?: QAReviewOrderByWithRelationInput | QAReviewOrderByWithRelationInput[]
    cursor?: QAReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QAReviewScalarFieldEnum | QAReviewScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    name: string | null
    legalName: string | null
    ownerId: string | null
    status: $Enums.AccountStatus | null
    portalToken: string | null
    designFeePaid: boolean | null
    consentMarketing: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    createdById: string | null
    updatedById: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    name: string | null
    legalName: string | null
    ownerId: string | null
    status: $Enums.AccountStatus | null
    portalToken: string | null
    designFeePaid: boolean | null
    consentMarketing: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    createdById: string | null
    updatedById: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    orgId: number
    name: number
    legalName: number
    emails: number
    phones: number
    billingAddress: number
    siteAddresses: number
    ownerId: number
    tags: number
    status: number
    portalToken: number
    designFeePaid: number
    consentMarketing: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    createdById: number
    updatedById: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    legalName?: true
    ownerId?: true
    status?: true
    portalToken?: true
    designFeePaid?: true
    consentMarketing?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    legalName?: true
    ownerId?: true
    status?: true
    portalToken?: true
    designFeePaid?: true
    consentMarketing?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    legalName?: true
    emails?: true
    phones?: true
    billingAddress?: true
    siteAddresses?: true
    ownerId?: true
    tags?: true
    status?: true
    portalToken?: true
    designFeePaid?: true
    consentMarketing?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    createdById?: true
    updatedById?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    orgId: string | null
    name: string
    legalName: string | null
    emails: string[]
    phones: string[]
    billingAddress: JsonValue | null
    siteAddresses: JsonValue | null
    ownerId: string
    tags: string[]
    status: $Enums.AccountStatus
    portalToken: string
    designFeePaid: boolean
    consentMarketing: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    createdById: string | null
    updatedById: string | null
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    name?: boolean
    legalName?: boolean
    emails?: boolean
    phones?: boolean
    billingAddress?: boolean
    siteAddresses?: boolean
    ownerId?: boolean
    tags?: boolean
    status?: boolean
    portalToken?: boolean
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    activities?: boolean | Account$activitiesArgs<ExtArgs>
    appointments?: boolean | Account$appointmentsArgs<ExtArgs>
    completedProjects?: boolean | Account$completedProjectsArgs<ExtArgs>
    contacts?: boolean | Account$contactsArgs<ExtArgs>
    documents?: boolean | Account$documentsArgs<ExtArgs>
    enquiries?: boolean | Account$enquiriesArgs<ExtArgs>
    events?: boolean | Account$eventsArgs<ExtArgs>
    leads?: boolean | Account$leadsArgs<ExtArgs>
    projects?: boolean | Account$projectsArgs<ExtArgs>
    snags?: boolean | Account$snagsArgs<ExtArgs>
    tasks?: boolean | Account$tasksArgs<ExtArgs>
    workflows?: boolean | Account$workflowsArgs<ExtArgs>
    workflowInstances?: boolean | Account$workflowInstancesArgs<ExtArgs>
    workflowTemplates?: boolean | Account$workflowTemplatesArgs<ExtArgs>
    automationRules?: boolean | Account$automationRulesArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    name?: boolean
    legalName?: boolean
    emails?: boolean
    phones?: boolean
    billingAddress?: boolean
    siteAddresses?: boolean
    ownerId?: boolean
    tags?: boolean
    status?: boolean
    portalToken?: boolean
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    orgId?: boolean
    name?: boolean
    legalName?: boolean
    emails?: boolean
    phones?: boolean
    billingAddress?: boolean
    siteAddresses?: boolean
    ownerId?: boolean
    tags?: boolean
    status?: boolean
    portalToken?: boolean
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    activities?: boolean | Account$activitiesArgs<ExtArgs>
    appointments?: boolean | Account$appointmentsArgs<ExtArgs>
    completedProjects?: boolean | Account$completedProjectsArgs<ExtArgs>
    contacts?: boolean | Account$contactsArgs<ExtArgs>
    documents?: boolean | Account$documentsArgs<ExtArgs>
    enquiries?: boolean | Account$enquiriesArgs<ExtArgs>
    events?: boolean | Account$eventsArgs<ExtArgs>
    leads?: boolean | Account$leadsArgs<ExtArgs>
    projects?: boolean | Account$projectsArgs<ExtArgs>
    snags?: boolean | Account$snagsArgs<ExtArgs>
    tasks?: boolean | Account$tasksArgs<ExtArgs>
    workflows?: boolean | Account$workflowsArgs<ExtArgs>
    workflowInstances?: boolean | Account$workflowInstancesArgs<ExtArgs>
    workflowTemplates?: boolean | Account$workflowTemplatesArgs<ExtArgs>
    automationRules?: boolean | Account$automationRulesArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      completedProjects: Prisma.$CompletedProjectPayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      enquiries: Prisma.$EnquiryPayload<ExtArgs>[]
      events: Prisma.$EventLogPayload<ExtArgs>[]
      leads: Prisma.$LeadPayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      snags: Prisma.$SnagPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      workflows: Prisma.$WorkflowDefinitionPayload<ExtArgs>[]
      workflowInstances: Prisma.$WorkflowInstancePayload<ExtArgs>[]
      workflowTemplates: Prisma.$WorkflowTemplatePayload<ExtArgs>[]
      automationRules: Prisma.$AutomationRulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string | null
      name: string
      legalName: string | null
      emails: string[]
      phones: string[]
      billingAddress: Prisma.JsonValue | null
      siteAddresses: Prisma.JsonValue | null
      ownerId: string
      tags: string[]
      status: $Enums.AccountStatus
      portalToken: string
      designFeePaid: boolean
      consentMarketing: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      createdById: string | null
      updatedById: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    activities<T extends Account$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Account$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany"> | Null>
    appointments<T extends Account$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Account$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany"> | Null>
    completedProjects<T extends Account$completedProjectsArgs<ExtArgs> = {}>(args?: Subset<T, Account$completedProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompletedProjectPayload<ExtArgs>, T, "findMany"> | Null>
    contacts<T extends Account$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Account$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany"> | Null>
    documents<T extends Account$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Account$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany"> | Null>
    enquiries<T extends Account$enquiriesArgs<ExtArgs> = {}>(args?: Subset<T, Account$enquiriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findMany"> | Null>
    events<T extends Account$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Account$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "findMany"> | Null>
    leads<T extends Account$leadsArgs<ExtArgs> = {}>(args?: Subset<T, Account$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany"> | Null>
    projects<T extends Account$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Account$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    snags<T extends Account$snagsArgs<ExtArgs> = {}>(args?: Subset<T, Account$snagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnagPayload<ExtArgs>, T, "findMany"> | Null>
    tasks<T extends Account$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Account$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    workflows<T extends Account$workflowsArgs<ExtArgs> = {}>(args?: Subset<T, Account$workflowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "findMany"> | Null>
    workflowInstances<T extends Account$workflowInstancesArgs<ExtArgs> = {}>(args?: Subset<T, Account$workflowInstancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "findMany"> | Null>
    workflowTemplates<T extends Account$workflowTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, Account$workflowTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    automationRules<T extends Account$automationRulesArgs<ExtArgs> = {}>(args?: Subset<T, Account$automationRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly orgId: FieldRef<"Account", 'String'>
    readonly name: FieldRef<"Account", 'String'>
    readonly legalName: FieldRef<"Account", 'String'>
    readonly emails: FieldRef<"Account", 'String[]'>
    readonly phones: FieldRef<"Account", 'String[]'>
    readonly billingAddress: FieldRef<"Account", 'Json'>
    readonly siteAddresses: FieldRef<"Account", 'Json'>
    readonly ownerId: FieldRef<"Account", 'String'>
    readonly tags: FieldRef<"Account", 'String[]'>
    readonly status: FieldRef<"Account", 'AccountStatus'>
    readonly portalToken: FieldRef<"Account", 'String'>
    readonly designFeePaid: FieldRef<"Account", 'Boolean'>
    readonly consentMarketing: FieldRef<"Account", 'Boolean'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
    readonly deletedAt: FieldRef<"Account", 'DateTime'>
    readonly createdById: FieldRef<"Account", 'String'>
    readonly updatedById: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }

  /**
   * Account.activities
   */
  export type Account$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Account.appointments
   */
  export type Account$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Account.completedProjects
   */
  export type Account$completedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedProject
     */
    select?: CompletedProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedProjectInclude<ExtArgs> | null
    where?: CompletedProjectWhereInput
    orderBy?: CompletedProjectOrderByWithRelationInput | CompletedProjectOrderByWithRelationInput[]
    cursor?: CompletedProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompletedProjectScalarFieldEnum | CompletedProjectScalarFieldEnum[]
  }

  /**
   * Account.contacts
   */
  export type Account$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Account.documents
   */
  export type Account$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Account.enquiries
   */
  export type Account$enquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    where?: EnquiryWhereInput
    orderBy?: EnquiryOrderByWithRelationInput | EnquiryOrderByWithRelationInput[]
    cursor?: EnquiryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnquiryScalarFieldEnum | EnquiryScalarFieldEnum[]
  }

  /**
   * Account.events
   */
  export type Account$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventLogInclude<ExtArgs> | null
    where?: EventLogWhereInput
    orderBy?: EventLogOrderByWithRelationInput | EventLogOrderByWithRelationInput[]
    cursor?: EventLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventLogScalarFieldEnum | EventLogScalarFieldEnum[]
  }

  /**
   * Account.leads
   */
  export type Account$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Account.projects
   */
  export type Account$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Account.snags
   */
  export type Account$snagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagInclude<ExtArgs> | null
    where?: SnagWhereInput
    orderBy?: SnagOrderByWithRelationInput | SnagOrderByWithRelationInput[]
    cursor?: SnagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SnagScalarFieldEnum | SnagScalarFieldEnum[]
  }

  /**
   * Account.tasks
   */
  export type Account$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Account.workflows
   */
  export type Account$workflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinition
     */
    select?: WorkflowDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowDefinitionInclude<ExtArgs> | null
    where?: WorkflowDefinitionWhereInput
    orderBy?: WorkflowDefinitionOrderByWithRelationInput | WorkflowDefinitionOrderByWithRelationInput[]
    cursor?: WorkflowDefinitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowDefinitionScalarFieldEnum | WorkflowDefinitionScalarFieldEnum[]
  }

  /**
   * Account.workflowInstances
   */
  export type Account$workflowInstancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
    where?: WorkflowInstanceWhereInput
    orderBy?: WorkflowInstanceOrderByWithRelationInput | WorkflowInstanceOrderByWithRelationInput[]
    cursor?: WorkflowInstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowInstanceScalarFieldEnum | WorkflowInstanceScalarFieldEnum[]
  }

  /**
   * Account.workflowTemplates
   */
  export type Account$workflowTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTemplateInclude<ExtArgs> | null
    where?: WorkflowTemplateWhereInput
    orderBy?: WorkflowTemplateOrderByWithRelationInput | WorkflowTemplateOrderByWithRelationInput[]
    cursor?: WorkflowTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowTemplateScalarFieldEnum | WorkflowTemplateScalarFieldEnum[]
  }

  /**
   * Account.automationRules
   */
  export type Account$automationRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    where?: AutomationRuleWhereInput
    orderBy?: AutomationRuleOrderByWithRelationInput | AutomationRuleOrderByWithRelationInput[]
    cursor?: AutomationRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationRuleScalarFieldEnum | AutomationRuleScalarFieldEnum[]
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Enquiry
   */

  export type AggregateEnquiry = {
    _count: EnquiryCountAggregateOutputType | null
    _avg: EnquiryAvgAggregateOutputType | null
    _sum: EnquirySumAggregateOutputType | null
    _min: EnquiryMinAggregateOutputType | null
    _max: EnquiryMaxAggregateOutputType | null
  }

  export type EnquiryAvgAggregateOutputType = {
    estimatedValue: Decimal | null
  }

  export type EnquirySumAggregateOutputType = {
    estimatedValue: Decimal | null
  }

  export type EnquiryMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.EnquiryStatus | null
    priority: $Enums.Priority | null
    source: string | null
    campaign: string | null
    medium: string | null
    estimatedValue: Decimal | null
    contactMethod: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    mobile: string | null
    company: string | null
    message: string | null
    accountId: string | null
    ownerId: string | null
    leadId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
  }

  export type EnquiryMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.EnquiryStatus | null
    priority: $Enums.Priority | null
    source: string | null
    campaign: string | null
    medium: string | null
    estimatedValue: Decimal | null
    contactMethod: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    mobile: string | null
    company: string | null
    message: string | null
    accountId: string | null
    ownerId: string | null
    leadId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
  }

  export type EnquiryCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    priority: number
    source: number
    campaign: number
    medium: number
    estimatedValue: number
    contactMethod: number
    firstName: number
    lastName: number
    email: number
    phone: number
    mobile: number
    company: number
    message: number
    accountId: number
    ownerId: number
    leadId: number
    createdAt: number
    updatedAt: number
    createdById: number
    updatedById: number
    _all: number
  }


  export type EnquiryAvgAggregateInputType = {
    estimatedValue?: true
  }

  export type EnquirySumAggregateInputType = {
    estimatedValue?: true
  }

  export type EnquiryMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    source?: true
    campaign?: true
    medium?: true
    estimatedValue?: true
    contactMethod?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    mobile?: true
    company?: true
    message?: true
    accountId?: true
    ownerId?: true
    leadId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type EnquiryMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    source?: true
    campaign?: true
    medium?: true
    estimatedValue?: true
    contactMethod?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    mobile?: true
    company?: true
    message?: true
    accountId?: true
    ownerId?: true
    leadId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type EnquiryCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    source?: true
    campaign?: true
    medium?: true
    estimatedValue?: true
    contactMethod?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    mobile?: true
    company?: true
    message?: true
    accountId?: true
    ownerId?: true
    leadId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    _all?: true
  }

  export type EnquiryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enquiry to aggregate.
     */
    where?: EnquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enquiries to fetch.
     */
    orderBy?: EnquiryOrderByWithRelationInput | EnquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enquiries
    **/
    _count?: true | EnquiryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnquiryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnquirySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnquiryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnquiryMaxAggregateInputType
  }

  export type GetEnquiryAggregateType<T extends EnquiryAggregateArgs> = {
        [P in keyof T & keyof AggregateEnquiry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnquiry[P]>
      : GetScalarType<T[P], AggregateEnquiry[P]>
  }




  export type EnquiryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnquiryWhereInput
    orderBy?: EnquiryOrderByWithAggregationInput | EnquiryOrderByWithAggregationInput[]
    by: EnquiryScalarFieldEnum[] | EnquiryScalarFieldEnum
    having?: EnquiryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnquiryCountAggregateInputType | true
    _avg?: EnquiryAvgAggregateInputType
    _sum?: EnquirySumAggregateInputType
    _min?: EnquiryMinAggregateInputType
    _max?: EnquiryMaxAggregateInputType
  }

  export type EnquiryGroupByOutputType = {
    id: string
    title: string
    description: string | null
    status: $Enums.EnquiryStatus
    priority: $Enums.Priority
    source: string | null
    campaign: string | null
    medium: string | null
    estimatedValue: Decimal | null
    contactMethod: string | null
    firstName: string
    lastName: string
    email: string | null
    phone: string | null
    mobile: string | null
    company: string | null
    message: string | null
    accountId: string | null
    ownerId: string
    leadId: string | null
    createdAt: Date
    updatedAt: Date
    createdById: string | null
    updatedById: string | null
    _count: EnquiryCountAggregateOutputType | null
    _avg: EnquiryAvgAggregateOutputType | null
    _sum: EnquirySumAggregateOutputType | null
    _min: EnquiryMinAggregateOutputType | null
    _max: EnquiryMaxAggregateOutputType | null
  }

  type GetEnquiryGroupByPayload<T extends EnquiryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnquiryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnquiryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnquiryGroupByOutputType[P]>
            : GetScalarType<T[P], EnquiryGroupByOutputType[P]>
        }
      >
    >


  export type EnquirySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    source?: boolean
    campaign?: boolean
    medium?: boolean
    estimatedValue?: boolean
    contactMethod?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    mobile?: boolean
    company?: boolean
    message?: boolean
    accountId?: boolean
    ownerId?: boolean
    leadId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    activities?: boolean | Enquiry$activitiesArgs<ExtArgs>
    account?: boolean | Enquiry$accountArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    lead?: boolean | Enquiry$leadArgs<ExtArgs>
    tasks?: boolean | Enquiry$tasksArgs<ExtArgs>
    _count?: boolean | EnquiryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enquiry"]>

  export type EnquirySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    source?: boolean
    campaign?: boolean
    medium?: boolean
    estimatedValue?: boolean
    contactMethod?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    mobile?: boolean
    company?: boolean
    message?: boolean
    accountId?: boolean
    ownerId?: boolean
    leadId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    account?: boolean | Enquiry$accountArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enquiry"]>

  export type EnquirySelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    source?: boolean
    campaign?: boolean
    medium?: boolean
    estimatedValue?: boolean
    contactMethod?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    mobile?: boolean
    company?: boolean
    message?: boolean
    accountId?: boolean
    ownerId?: boolean
    leadId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
  }

  export type EnquiryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | Enquiry$activitiesArgs<ExtArgs>
    account?: boolean | Enquiry$accountArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    lead?: boolean | Enquiry$leadArgs<ExtArgs>
    tasks?: boolean | Enquiry$tasksArgs<ExtArgs>
    _count?: boolean | EnquiryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EnquiryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | Enquiry$accountArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EnquiryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Enquiry"
    objects: {
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      account: Prisma.$AccountPayload<ExtArgs> | null
      owner: Prisma.$UserPayload<ExtArgs>
      lead: Prisma.$LeadPayload<ExtArgs> | null
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      status: $Enums.EnquiryStatus
      priority: $Enums.Priority
      source: string | null
      campaign: string | null
      medium: string | null
      estimatedValue: Prisma.Decimal | null
      contactMethod: string | null
      firstName: string
      lastName: string
      email: string | null
      phone: string | null
      mobile: string | null
      company: string | null
      message: string | null
      accountId: string | null
      ownerId: string
      leadId: string | null
      createdAt: Date
      updatedAt: Date
      createdById: string | null
      updatedById: string | null
    }, ExtArgs["result"]["enquiry"]>
    composites: {}
  }

  type EnquiryGetPayload<S extends boolean | null | undefined | EnquiryDefaultArgs> = $Result.GetResult<Prisma.$EnquiryPayload, S>

  type EnquiryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EnquiryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EnquiryCountAggregateInputType | true
    }

  export interface EnquiryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Enquiry'], meta: { name: 'Enquiry' } }
    /**
     * Find zero or one Enquiry that matches the filter.
     * @param {EnquiryFindUniqueArgs} args - Arguments to find a Enquiry
     * @example
     * // Get one Enquiry
     * const enquiry = await prisma.enquiry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnquiryFindUniqueArgs>(args: SelectSubset<T, EnquiryFindUniqueArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Enquiry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EnquiryFindUniqueOrThrowArgs} args - Arguments to find a Enquiry
     * @example
     * // Get one Enquiry
     * const enquiry = await prisma.enquiry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnquiryFindUniqueOrThrowArgs>(args: SelectSubset<T, EnquiryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Enquiry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryFindFirstArgs} args - Arguments to find a Enquiry
     * @example
     * // Get one Enquiry
     * const enquiry = await prisma.enquiry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnquiryFindFirstArgs>(args?: SelectSubset<T, EnquiryFindFirstArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Enquiry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryFindFirstOrThrowArgs} args - Arguments to find a Enquiry
     * @example
     * // Get one Enquiry
     * const enquiry = await prisma.enquiry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnquiryFindFirstOrThrowArgs>(args?: SelectSubset<T, EnquiryFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Enquiries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enquiries
     * const enquiries = await prisma.enquiry.findMany()
     * 
     * // Get first 10 Enquiries
     * const enquiries = await prisma.enquiry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enquiryWithIdOnly = await prisma.enquiry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnquiryFindManyArgs>(args?: SelectSubset<T, EnquiryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Enquiry.
     * @param {EnquiryCreateArgs} args - Arguments to create a Enquiry.
     * @example
     * // Create one Enquiry
     * const Enquiry = await prisma.enquiry.create({
     *   data: {
     *     // ... data to create a Enquiry
     *   }
     * })
     * 
     */
    create<T extends EnquiryCreateArgs>(args: SelectSubset<T, EnquiryCreateArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Enquiries.
     * @param {EnquiryCreateManyArgs} args - Arguments to create many Enquiries.
     * @example
     * // Create many Enquiries
     * const enquiry = await prisma.enquiry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnquiryCreateManyArgs>(args?: SelectSubset<T, EnquiryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Enquiries and returns the data saved in the database.
     * @param {EnquiryCreateManyAndReturnArgs} args - Arguments to create many Enquiries.
     * @example
     * // Create many Enquiries
     * const enquiry = await prisma.enquiry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Enquiries and only return the `id`
     * const enquiryWithIdOnly = await prisma.enquiry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnquiryCreateManyAndReturnArgs>(args?: SelectSubset<T, EnquiryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Enquiry.
     * @param {EnquiryDeleteArgs} args - Arguments to delete one Enquiry.
     * @example
     * // Delete one Enquiry
     * const Enquiry = await prisma.enquiry.delete({
     *   where: {
     *     // ... filter to delete one Enquiry
     *   }
     * })
     * 
     */
    delete<T extends EnquiryDeleteArgs>(args: SelectSubset<T, EnquiryDeleteArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Enquiry.
     * @param {EnquiryUpdateArgs} args - Arguments to update one Enquiry.
     * @example
     * // Update one Enquiry
     * const enquiry = await prisma.enquiry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnquiryUpdateArgs>(args: SelectSubset<T, EnquiryUpdateArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Enquiries.
     * @param {EnquiryDeleteManyArgs} args - Arguments to filter Enquiries to delete.
     * @example
     * // Delete a few Enquiries
     * const { count } = await prisma.enquiry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnquiryDeleteManyArgs>(args?: SelectSubset<T, EnquiryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enquiries
     * const enquiry = await prisma.enquiry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnquiryUpdateManyArgs>(args: SelectSubset<T, EnquiryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Enquiry.
     * @param {EnquiryUpsertArgs} args - Arguments to update or create a Enquiry.
     * @example
     * // Update or create a Enquiry
     * const enquiry = await prisma.enquiry.upsert({
     *   create: {
     *     // ... data to create a Enquiry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enquiry we want to update
     *   }
     * })
     */
    upsert<T extends EnquiryUpsertArgs>(args: SelectSubset<T, EnquiryUpsertArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Enquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryCountArgs} args - Arguments to filter Enquiries to count.
     * @example
     * // Count the number of Enquiries
     * const count = await prisma.enquiry.count({
     *   where: {
     *     // ... the filter for the Enquiries we want to count
     *   }
     * })
    **/
    count<T extends EnquiryCountArgs>(
      args?: Subset<T, EnquiryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnquiryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnquiryAggregateArgs>(args: Subset<T, EnquiryAggregateArgs>): Prisma.PrismaPromise<GetEnquiryAggregateType<T>>

    /**
     * Group by Enquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnquiryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnquiryGroupByArgs['orderBy'] }
        : { orderBy?: EnquiryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnquiryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnquiryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Enquiry model
   */
  readonly fields: EnquiryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Enquiry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnquiryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activities<T extends Enquiry$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Enquiry$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany"> | Null>
    account<T extends Enquiry$accountArgs<ExtArgs> = {}>(args?: Subset<T, Enquiry$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lead<T extends Enquiry$leadArgs<ExtArgs> = {}>(args?: Subset<T, Enquiry$leadArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tasks<T extends Enquiry$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Enquiry$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Enquiry model
   */ 
  interface EnquiryFieldRefs {
    readonly id: FieldRef<"Enquiry", 'String'>
    readonly title: FieldRef<"Enquiry", 'String'>
    readonly description: FieldRef<"Enquiry", 'String'>
    readonly status: FieldRef<"Enquiry", 'EnquiryStatus'>
    readonly priority: FieldRef<"Enquiry", 'Priority'>
    readonly source: FieldRef<"Enquiry", 'String'>
    readonly campaign: FieldRef<"Enquiry", 'String'>
    readonly medium: FieldRef<"Enquiry", 'String'>
    readonly estimatedValue: FieldRef<"Enquiry", 'Decimal'>
    readonly contactMethod: FieldRef<"Enquiry", 'String'>
    readonly firstName: FieldRef<"Enquiry", 'String'>
    readonly lastName: FieldRef<"Enquiry", 'String'>
    readonly email: FieldRef<"Enquiry", 'String'>
    readonly phone: FieldRef<"Enquiry", 'String'>
    readonly mobile: FieldRef<"Enquiry", 'String'>
    readonly company: FieldRef<"Enquiry", 'String'>
    readonly message: FieldRef<"Enquiry", 'String'>
    readonly accountId: FieldRef<"Enquiry", 'String'>
    readonly ownerId: FieldRef<"Enquiry", 'String'>
    readonly leadId: FieldRef<"Enquiry", 'String'>
    readonly createdAt: FieldRef<"Enquiry", 'DateTime'>
    readonly updatedAt: FieldRef<"Enquiry", 'DateTime'>
    readonly createdById: FieldRef<"Enquiry", 'String'>
    readonly updatedById: FieldRef<"Enquiry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Enquiry findUnique
   */
  export type EnquiryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * Filter, which Enquiry to fetch.
     */
    where: EnquiryWhereUniqueInput
  }

  /**
   * Enquiry findUniqueOrThrow
   */
  export type EnquiryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * Filter, which Enquiry to fetch.
     */
    where: EnquiryWhereUniqueInput
  }

  /**
   * Enquiry findFirst
   */
  export type EnquiryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * Filter, which Enquiry to fetch.
     */
    where?: EnquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enquiries to fetch.
     */
    orderBy?: EnquiryOrderByWithRelationInput | EnquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enquiries.
     */
    cursor?: EnquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enquiries.
     */
    distinct?: EnquiryScalarFieldEnum | EnquiryScalarFieldEnum[]
  }

  /**
   * Enquiry findFirstOrThrow
   */
  export type EnquiryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * Filter, which Enquiry to fetch.
     */
    where?: EnquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enquiries to fetch.
     */
    orderBy?: EnquiryOrderByWithRelationInput | EnquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enquiries.
     */
    cursor?: EnquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enquiries.
     */
    distinct?: EnquiryScalarFieldEnum | EnquiryScalarFieldEnum[]
  }

  /**
   * Enquiry findMany
   */
  export type EnquiryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * Filter, which Enquiries to fetch.
     */
    where?: EnquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enquiries to fetch.
     */
    orderBy?: EnquiryOrderByWithRelationInput | EnquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enquiries.
     */
    cursor?: EnquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enquiries.
     */
    skip?: number
    distinct?: EnquiryScalarFieldEnum | EnquiryScalarFieldEnum[]
  }

  /**
   * Enquiry create
   */
  export type EnquiryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * The data needed to create a Enquiry.
     */
    data: XOR<EnquiryCreateInput, EnquiryUncheckedCreateInput>
  }

  /**
   * Enquiry createMany
   */
  export type EnquiryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enquiries.
     */
    data: EnquiryCreateManyInput | EnquiryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Enquiry createManyAndReturn
   */
  export type EnquiryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Enquiries.
     */
    data: EnquiryCreateManyInput | EnquiryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Enquiry update
   */
  export type EnquiryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * The data needed to update a Enquiry.
     */
    data: XOR<EnquiryUpdateInput, EnquiryUncheckedUpdateInput>
    /**
     * Choose, which Enquiry to update.
     */
    where: EnquiryWhereUniqueInput
  }

  /**
   * Enquiry updateMany
   */
  export type EnquiryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enquiries.
     */
    data: XOR<EnquiryUpdateManyMutationInput, EnquiryUncheckedUpdateManyInput>
    /**
     * Filter which Enquiries to update
     */
    where?: EnquiryWhereInput
  }

  /**
   * Enquiry upsert
   */
  export type EnquiryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * The filter to search for the Enquiry to update in case it exists.
     */
    where: EnquiryWhereUniqueInput
    /**
     * In case the Enquiry found by the `where` argument doesn't exist, create a new Enquiry with this data.
     */
    create: XOR<EnquiryCreateInput, EnquiryUncheckedCreateInput>
    /**
     * In case the Enquiry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnquiryUpdateInput, EnquiryUncheckedUpdateInput>
  }

  /**
   * Enquiry delete
   */
  export type EnquiryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * Filter which Enquiry to delete.
     */
    where: EnquiryWhereUniqueInput
  }

  /**
   * Enquiry deleteMany
   */
  export type EnquiryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enquiries to delete
     */
    where?: EnquiryWhereInput
  }

  /**
   * Enquiry.activities
   */
  export type Enquiry$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Enquiry.account
   */
  export type Enquiry$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Enquiry.lead
   */
  export type Enquiry$leadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
  }

  /**
   * Enquiry.tasks
   */
  export type Enquiry$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Enquiry without action
   */
  export type EnquiryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    name: string | null
    role: string | null
    email: string | null
    phone: string | null
    isPrimary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    name: string | null
    role: string | null
    email: string | null
    phone: string | null
    isPrimary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    accountId: number
    name: number
    role: number
    email: number
    phone: number
    isPrimary: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    accountId?: true
    name?: true
    role?: true
    email?: true
    phone?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    accountId?: true
    name?: true
    role?: true
    email?: true
    phone?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    accountId?: true
    name?: true
    role?: true
    email?: true
    phone?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    accountId: string
    name: string
    role: string | null
    email: string | null
    phone: string | null
    isPrimary: boolean
    createdAt: Date
    updatedAt: Date
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    accountId?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      name: string
      role: string | null
      email: string | null
      phone: string | null
      isPrimary: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */ 
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly accountId: FieldRef<"Contact", 'String'>
    readonly name: FieldRef<"Contact", 'String'>
    readonly role: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly phone: FieldRef<"Contact", 'String'>
    readonly isPrimary: FieldRef<"Contact", 'Boolean'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model Lead
   */

  export type AggregateLead = {
    _count: LeadCountAggregateOutputType | null
    _avg: LeadAvgAggregateOutputType | null
    _sum: LeadSumAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  export type LeadAvgAggregateOutputType = {
    estimatedValue: Decimal | null
    probability: number | null
    responseTime: number | null
  }

  export type LeadSumAggregateOutputType = {
    estimatedValue: Decimal | null
    probability: number | null
    responseTime: number | null
  }

  export type LeadMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.LeadStatus | null
    priority: $Enums.Priority | null
    estimatedValue: Decimal | null
    probability: number | null
    expectedCloseDate: Date | null
    source: string | null
    campaign: string | null
    medium: string | null
    firstResponseAt: Date | null
    responseTime: number | null
    accountId: string | null
    ownerId: string | null
    enquiryId: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
  }

  export type LeadMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.LeadStatus | null
    priority: $Enums.Priority | null
    estimatedValue: Decimal | null
    probability: number | null
    expectedCloseDate: Date | null
    source: string | null
    campaign: string | null
    medium: string | null
    firstResponseAt: Date | null
    responseTime: number | null
    accountId: string | null
    ownerId: string | null
    enquiryId: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
  }

  export type LeadCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    priority: number
    estimatedValue: number
    probability: number
    expectedCloseDate: number
    source: number
    campaign: number
    medium: number
    firstResponseAt: number
    responseTime: number
    accountId: number
    ownerId: number
    enquiryId: number
    projectId: number
    createdAt: number
    updatedAt: number
    createdById: number
    updatedById: number
    _all: number
  }


  export type LeadAvgAggregateInputType = {
    estimatedValue?: true
    probability?: true
    responseTime?: true
  }

  export type LeadSumAggregateInputType = {
    estimatedValue?: true
    probability?: true
    responseTime?: true
  }

  export type LeadMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    estimatedValue?: true
    probability?: true
    expectedCloseDate?: true
    source?: true
    campaign?: true
    medium?: true
    firstResponseAt?: true
    responseTime?: true
    accountId?: true
    ownerId?: true
    enquiryId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type LeadMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    estimatedValue?: true
    probability?: true
    expectedCloseDate?: true
    source?: true
    campaign?: true
    medium?: true
    firstResponseAt?: true
    responseTime?: true
    accountId?: true
    ownerId?: true
    enquiryId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type LeadCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    estimatedValue?: true
    probability?: true
    expectedCloseDate?: true
    source?: true
    campaign?: true
    medium?: true
    firstResponseAt?: true
    responseTime?: true
    accountId?: true
    ownerId?: true
    enquiryId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    _all?: true
  }

  export type LeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lead to aggregate.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leads
    **/
    _count?: true | LeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadMaxAggregateInputType
  }

  export type GetLeadAggregateType<T extends LeadAggregateArgs> = {
        [P in keyof T & keyof AggregateLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLead[P]>
      : GetScalarType<T[P], AggregateLead[P]>
  }




  export type LeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithAggregationInput | LeadOrderByWithAggregationInput[]
    by: LeadScalarFieldEnum[] | LeadScalarFieldEnum
    having?: LeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadCountAggregateInputType | true
    _avg?: LeadAvgAggregateInputType
    _sum?: LeadSumAggregateInputType
    _min?: LeadMinAggregateInputType
    _max?: LeadMaxAggregateInputType
  }

  export type LeadGroupByOutputType = {
    id: string
    title: string
    description: string | null
    status: $Enums.LeadStatus
    priority: $Enums.Priority
    estimatedValue: Decimal | null
    probability: number
    expectedCloseDate: Date | null
    source: string | null
    campaign: string | null
    medium: string | null
    firstResponseAt: Date | null
    responseTime: number | null
    accountId: string
    ownerId: string
    enquiryId: string | null
    projectId: string | null
    createdAt: Date
    updatedAt: Date
    createdById: string | null
    updatedById: string | null
    _count: LeadCountAggregateOutputType | null
    _avg: LeadAvgAggregateOutputType | null
    _sum: LeadSumAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  type GetLeadGroupByPayload<T extends LeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadGroupByOutputType[P]>
            : GetScalarType<T[P], LeadGroupByOutputType[P]>
        }
      >
    >


  export type LeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    estimatedValue?: boolean
    probability?: boolean
    expectedCloseDate?: boolean
    source?: boolean
    campaign?: boolean
    medium?: boolean
    firstResponseAt?: boolean
    responseTime?: boolean
    accountId?: boolean
    ownerId?: boolean
    enquiryId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    activities?: boolean | Lead$activitiesArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    enquiry?: boolean | Lead$enquiryArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Lead$projectArgs<ExtArgs>
    tasks?: boolean | Lead$tasksArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    estimatedValue?: boolean
    probability?: boolean
    expectedCloseDate?: boolean
    source?: boolean
    campaign?: boolean
    medium?: boolean
    firstResponseAt?: boolean
    responseTime?: boolean
    accountId?: boolean
    ownerId?: boolean
    enquiryId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    enquiry?: boolean | Lead$enquiryArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    estimatedValue?: boolean
    probability?: boolean
    expectedCloseDate?: boolean
    source?: boolean
    campaign?: boolean
    medium?: boolean
    firstResponseAt?: boolean
    responseTime?: boolean
    accountId?: boolean
    ownerId?: boolean
    enquiryId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
  }

  export type LeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | Lead$activitiesArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    enquiry?: boolean | Lead$enquiryArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Lead$projectArgs<ExtArgs>
    tasks?: boolean | Lead$tasksArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    enquiry?: boolean | Lead$enquiryArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lead"
    objects: {
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      account: Prisma.$AccountPayload<ExtArgs>
      enquiry: Prisma.$EnquiryPayload<ExtArgs> | null
      owner: Prisma.$UserPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs> | null
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      status: $Enums.LeadStatus
      priority: $Enums.Priority
      estimatedValue: Prisma.Decimal | null
      probability: number
      expectedCloseDate: Date | null
      source: string | null
      campaign: string | null
      medium: string | null
      firstResponseAt: Date | null
      responseTime: number | null
      accountId: string
      ownerId: string
      enquiryId: string | null
      projectId: string | null
      createdAt: Date
      updatedAt: Date
      createdById: string | null
      updatedById: string | null
    }, ExtArgs["result"]["lead"]>
    composites: {}
  }

  type LeadGetPayload<S extends boolean | null | undefined | LeadDefaultArgs> = $Result.GetResult<Prisma.$LeadPayload, S>

  type LeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeadCountAggregateInputType | true
    }

  export interface LeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lead'], meta: { name: 'Lead' } }
    /**
     * Find zero or one Lead that matches the filter.
     * @param {LeadFindUniqueArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadFindUniqueArgs>(args: SelectSubset<T, LeadFindUniqueArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lead that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeadFindUniqueOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadFindFirstArgs>(args?: SelectSubset<T, LeadFindFirstArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Leads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leads
     * const leads = await prisma.lead.findMany()
     * 
     * // Get first 10 Leads
     * const leads = await prisma.lead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadWithIdOnly = await prisma.lead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadFindManyArgs>(args?: SelectSubset<T, LeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lead.
     * @param {LeadCreateArgs} args - Arguments to create a Lead.
     * @example
     * // Create one Lead
     * const Lead = await prisma.lead.create({
     *   data: {
     *     // ... data to create a Lead
     *   }
     * })
     * 
     */
    create<T extends LeadCreateArgs>(args: SelectSubset<T, LeadCreateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Leads.
     * @param {LeadCreateManyArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadCreateManyArgs>(args?: SelectSubset<T, LeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leads and returns the data saved in the database.
     * @param {LeadCreateManyAndReturnArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Lead.
     * @param {LeadDeleteArgs} args - Arguments to delete one Lead.
     * @example
     * // Delete one Lead
     * const Lead = await prisma.lead.delete({
     *   where: {
     *     // ... filter to delete one Lead
     *   }
     * })
     * 
     */
    delete<T extends LeadDeleteArgs>(args: SelectSubset<T, LeadDeleteArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lead.
     * @param {LeadUpdateArgs} args - Arguments to update one Lead.
     * @example
     * // Update one Lead
     * const lead = await prisma.lead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadUpdateArgs>(args: SelectSubset<T, LeadUpdateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Leads.
     * @param {LeadDeleteManyArgs} args - Arguments to filter Leads to delete.
     * @example
     * // Delete a few Leads
     * const { count } = await prisma.lead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadDeleteManyArgs>(args?: SelectSubset<T, LeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadUpdateManyArgs>(args: SelectSubset<T, LeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lead.
     * @param {LeadUpsertArgs} args - Arguments to update or create a Lead.
     * @example
     * // Update or create a Lead
     * const lead = await prisma.lead.upsert({
     *   create: {
     *     // ... data to create a Lead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lead we want to update
     *   }
     * })
     */
    upsert<T extends LeadUpsertArgs>(args: SelectSubset<T, LeadUpsertArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCountArgs} args - Arguments to filter Leads to count.
     * @example
     * // Count the number of Leads
     * const count = await prisma.lead.count({
     *   where: {
     *     // ... the filter for the Leads we want to count
     *   }
     * })
    **/
    count<T extends LeadCountArgs>(
      args?: Subset<T, LeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadAggregateArgs>(args: Subset<T, LeadAggregateArgs>): Prisma.PrismaPromise<GetLeadAggregateType<T>>

    /**
     * Group by Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadGroupByArgs['orderBy'] }
        : { orderBy?: LeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lead model
   */
  readonly fields: LeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activities<T extends Lead$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Lead$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany"> | Null>
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    enquiry<T extends Lead$enquiryArgs<ExtArgs> = {}>(args?: Subset<T, Lead$enquiryArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends Lead$projectArgs<ExtArgs> = {}>(args?: Subset<T, Lead$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tasks<T extends Lead$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Lead$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lead model
   */ 
  interface LeadFieldRefs {
    readonly id: FieldRef<"Lead", 'String'>
    readonly title: FieldRef<"Lead", 'String'>
    readonly description: FieldRef<"Lead", 'String'>
    readonly status: FieldRef<"Lead", 'LeadStatus'>
    readonly priority: FieldRef<"Lead", 'Priority'>
    readonly estimatedValue: FieldRef<"Lead", 'Decimal'>
    readonly probability: FieldRef<"Lead", 'Int'>
    readonly expectedCloseDate: FieldRef<"Lead", 'DateTime'>
    readonly source: FieldRef<"Lead", 'String'>
    readonly campaign: FieldRef<"Lead", 'String'>
    readonly medium: FieldRef<"Lead", 'String'>
    readonly firstResponseAt: FieldRef<"Lead", 'DateTime'>
    readonly responseTime: FieldRef<"Lead", 'Int'>
    readonly accountId: FieldRef<"Lead", 'String'>
    readonly ownerId: FieldRef<"Lead", 'String'>
    readonly enquiryId: FieldRef<"Lead", 'String'>
    readonly projectId: FieldRef<"Lead", 'String'>
    readonly createdAt: FieldRef<"Lead", 'DateTime'>
    readonly updatedAt: FieldRef<"Lead", 'DateTime'>
    readonly createdById: FieldRef<"Lead", 'String'>
    readonly updatedById: FieldRef<"Lead", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lead findUnique
   */
  export type LeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findUniqueOrThrow
   */
  export type LeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findFirst
   */
  export type LeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findFirstOrThrow
   */
  export type LeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findMany
   */
  export type LeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Leads to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead create
   */
  export type LeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to create a Lead.
     */
    data: XOR<LeadCreateInput, LeadUncheckedCreateInput>
  }

  /**
   * Lead createMany
   */
  export type LeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lead createManyAndReturn
   */
  export type LeadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lead update
   */
  export type LeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to update a Lead.
     */
    data: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
    /**
     * Choose, which Lead to update.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead updateMany
   */
  export type LeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
  }

  /**
   * Lead upsert
   */
  export type LeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The filter to search for the Lead to update in case it exists.
     */
    where: LeadWhereUniqueInput
    /**
     * In case the Lead found by the `where` argument doesn't exist, create a new Lead with this data.
     */
    create: XOR<LeadCreateInput, LeadUncheckedCreateInput>
    /**
     * In case the Lead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
  }

  /**
   * Lead delete
   */
  export type LeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter which Lead to delete.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead deleteMany
   */
  export type LeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leads to delete
     */
    where?: LeadWhereInput
  }

  /**
   * Lead.activities
   */
  export type Lead$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Lead.enquiry
   */
  export type Lead$enquiryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    where?: EnquiryWhereInput
  }

  /**
   * Lead.project
   */
  export type Lead$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Lead.tasks
   */
  export type Lead$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Lead without action
   */
  export type LeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    amountGrossIncVat: number | null
    vatRate: number | null
    probability: number | null
  }

  export type ProjectSumAggregateOutputType = {
    amountGrossIncVat: number | null
    vatRate: number | null
    probability: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: $Enums.ProjectType | null
    status: $Enums.ProjectStatus | null
    accountId: string | null
    ownerId: string | null
    amountGrossIncVat: number | null
    vatRate: number | null
    probability: number | null
    source: string | null
    leadId: string | null
    completedProjectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: $Enums.ProjectType | null
    status: $Enums.ProjectStatus | null
    accountId: string | null
    ownerId: string | null
    amountGrossIncVat: number | null
    vatRate: number | null
    probability: number | null
    source: string | null
    leadId: string | null
    completedProjectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    title: number
    description: number
    type: number
    status: number
    accountId: number
    ownerId: number
    amountGrossIncVat: number
    vatRate: number
    probability: number
    source: number
    utm: number
    leadId: number
    completedProjectId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    amountGrossIncVat?: true
    vatRate?: true
    probability?: true
  }

  export type ProjectSumAggregateInputType = {
    amountGrossIncVat?: true
    vatRate?: true
    probability?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    status?: true
    accountId?: true
    ownerId?: true
    amountGrossIncVat?: true
    vatRate?: true
    probability?: true
    source?: true
    leadId?: true
    completedProjectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    status?: true
    accountId?: true
    ownerId?: true
    amountGrossIncVat?: true
    vatRate?: true
    probability?: true
    source?: true
    leadId?: true
    completedProjectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    status?: true
    accountId?: true
    ownerId?: true
    amountGrossIncVat?: true
    vatRate?: true
    probability?: true
    source?: true
    utm?: true
    leadId?: true
    completedProjectId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    title: string
    description: string | null
    type: $Enums.ProjectType
    status: $Enums.ProjectStatus
    accountId: string
    ownerId: string
    amountGrossIncVat: number
    vatRate: number
    probability: number
    source: string | null
    utm: JsonValue | null
    leadId: string | null
    completedProjectId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    accountId?: boolean
    ownerId?: boolean
    amountGrossIncVat?: boolean
    vatRate?: boolean
    probability?: boolean
    source?: boolean
    utm?: boolean
    leadId?: boolean
    completedProjectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    activities?: boolean | Project$activitiesArgs<ExtArgs>
    appointments?: boolean | Project$appointmentsArgs<ExtArgs>
    completedProject?: boolean | Project$completedProjectArgs<ExtArgs>
    documents?: boolean | Project$documentsArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    lead?: boolean | Project$leadArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    snags?: boolean | Project$snagsArgs<ExtArgs>
    tasks?: boolean | Project$tasksArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    accountId?: boolean
    ownerId?: boolean
    amountGrossIncVat?: boolean
    vatRate?: boolean
    probability?: boolean
    source?: boolean
    utm?: boolean
    leadId?: boolean
    completedProjectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    lead?: boolean | Project$leadArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    accountId?: boolean
    ownerId?: boolean
    amountGrossIncVat?: boolean
    vatRate?: boolean
    probability?: boolean
    source?: boolean
    utm?: boolean
    leadId?: boolean
    completedProjectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | Project$activitiesArgs<ExtArgs>
    appointments?: boolean | Project$appointmentsArgs<ExtArgs>
    completedProject?: boolean | Project$completedProjectArgs<ExtArgs>
    documents?: boolean | Project$documentsArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    lead?: boolean | Project$leadArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    snags?: boolean | Project$snagsArgs<ExtArgs>
    tasks?: boolean | Project$tasksArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    lead?: boolean | Project$leadArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      completedProject: Prisma.$CompletedProjectPayload<ExtArgs> | null
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      account: Prisma.$AccountPayload<ExtArgs>
      lead: Prisma.$LeadPayload<ExtArgs> | null
      owner: Prisma.$UserPayload<ExtArgs>
      snags: Prisma.$SnagPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      type: $Enums.ProjectType
      status: $Enums.ProjectStatus
      accountId: string
      ownerId: string
      amountGrossIncVat: number
      vatRate: number
      probability: number
      source: string | null
      utm: Prisma.JsonValue | null
      leadId: string | null
      completedProjectId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activities<T extends Project$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Project$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany"> | Null>
    appointments<T extends Project$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Project$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany"> | Null>
    completedProject<T extends Project$completedProjectArgs<ExtArgs> = {}>(args?: Subset<T, Project$completedProjectArgs<ExtArgs>>): Prisma__CompletedProjectClient<$Result.GetResult<Prisma.$CompletedProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    documents<T extends Project$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Project$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany"> | Null>
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lead<T extends Project$leadArgs<ExtArgs> = {}>(args?: Subset<T, Project$leadArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    snags<T extends Project$snagsArgs<ExtArgs> = {}>(args?: Subset<T, Project$snagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnagPayload<ExtArgs>, T, "findMany"> | Null>
    tasks<T extends Project$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Project$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly title: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly type: FieldRef<"Project", 'ProjectType'>
    readonly status: FieldRef<"Project", 'ProjectStatus'>
    readonly accountId: FieldRef<"Project", 'String'>
    readonly ownerId: FieldRef<"Project", 'String'>
    readonly amountGrossIncVat: FieldRef<"Project", 'Int'>
    readonly vatRate: FieldRef<"Project", 'Float'>
    readonly probability: FieldRef<"Project", 'Int'>
    readonly source: FieldRef<"Project", 'String'>
    readonly utm: FieldRef<"Project", 'Json'>
    readonly leadId: FieldRef<"Project", 'String'>
    readonly completedProjectId: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }

  /**
   * Project.activities
   */
  export type Project$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Project.appointments
   */
  export type Project$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Project.completedProject
   */
  export type Project$completedProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedProject
     */
    select?: CompletedProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedProjectInclude<ExtArgs> | null
    where?: CompletedProjectWhereInput
  }

  /**
   * Project.documents
   */
  export type Project$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Project.lead
   */
  export type Project$leadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
  }

  /**
   * Project.snags
   */
  export type Project$snagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagInclude<ExtArgs> | null
    where?: SnagWhereInput
    orderBy?: SnagOrderByWithRelationInput | SnagOrderByWithRelationInput[]
    cursor?: SnagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SnagScalarFieldEnum | SnagScalarFieldEnum[]
  }

  /**
   * Project.tasks
   */
  export type Project$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model CompletedProject
   */

  export type AggregateCompletedProject = {
    _count: CompletedProjectCountAggregateOutputType | null
    _min: CompletedProjectMinAggregateOutputType | null
    _max: CompletedProjectMaxAggregateOutputType | null
  }

  export type CompletedProjectMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    projectId: string | null
    ownerId: string | null
    title: string | null
    description: string | null
    status: $Enums.CompletedProjectStatus | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompletedProjectMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    projectId: string | null
    ownerId: string | null
    title: string | null
    description: string | null
    status: $Enums.CompletedProjectStatus | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompletedProjectCountAggregateOutputType = {
    id: number
    accountId: number
    projectId: number
    ownerId: number
    title: number
    description: number
    status: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompletedProjectMinAggregateInputType = {
    id?: true
    accountId?: true
    projectId?: true
    ownerId?: true
    title?: true
    description?: true
    status?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompletedProjectMaxAggregateInputType = {
    id?: true
    accountId?: true
    projectId?: true
    ownerId?: true
    title?: true
    description?: true
    status?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompletedProjectCountAggregateInputType = {
    id?: true
    accountId?: true
    projectId?: true
    ownerId?: true
    title?: true
    description?: true
    status?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompletedProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompletedProject to aggregate.
     */
    where?: CompletedProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompletedProjects to fetch.
     */
    orderBy?: CompletedProjectOrderByWithRelationInput | CompletedProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompletedProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompletedProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompletedProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompletedProjects
    **/
    _count?: true | CompletedProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompletedProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompletedProjectMaxAggregateInputType
  }

  export type GetCompletedProjectAggregateType<T extends CompletedProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateCompletedProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompletedProject[P]>
      : GetScalarType<T[P], AggregateCompletedProject[P]>
  }




  export type CompletedProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompletedProjectWhereInput
    orderBy?: CompletedProjectOrderByWithAggregationInput | CompletedProjectOrderByWithAggregationInput[]
    by: CompletedProjectScalarFieldEnum[] | CompletedProjectScalarFieldEnum
    having?: CompletedProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompletedProjectCountAggregateInputType | true
    _min?: CompletedProjectMinAggregateInputType
    _max?: CompletedProjectMaxAggregateInputType
  }

  export type CompletedProjectGroupByOutputType = {
    id: string
    accountId: string
    projectId: string | null
    ownerId: string
    title: string
    description: string | null
    status: $Enums.CompletedProjectStatus
    startDate: Date | null
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CompletedProjectCountAggregateOutputType | null
    _min: CompletedProjectMinAggregateOutputType | null
    _max: CompletedProjectMaxAggregateOutputType | null
  }

  type GetCompletedProjectGroupByPayload<T extends CompletedProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompletedProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompletedProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompletedProjectGroupByOutputType[P]>
            : GetScalarType<T[P], CompletedProjectGroupByOutputType[P]>
        }
      >
    >


  export type CompletedProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    projectId?: boolean
    ownerId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | CompletedProject$projectArgs<ExtArgs>
  }, ExtArgs["result"]["completedProject"]>

  export type CompletedProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    projectId?: boolean
    ownerId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | CompletedProject$projectArgs<ExtArgs>
  }, ExtArgs["result"]["completedProject"]>

  export type CompletedProjectSelectScalar = {
    id?: boolean
    accountId?: boolean
    projectId?: boolean
    ownerId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompletedProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | CompletedProject$projectArgs<ExtArgs>
  }
  export type CompletedProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | CompletedProject$projectArgs<ExtArgs>
  }

  export type $CompletedProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompletedProject"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      projectId: string | null
      ownerId: string
      title: string
      description: string | null
      status: $Enums.CompletedProjectStatus
      startDate: Date | null
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["completedProject"]>
    composites: {}
  }

  type CompletedProjectGetPayload<S extends boolean | null | undefined | CompletedProjectDefaultArgs> = $Result.GetResult<Prisma.$CompletedProjectPayload, S>

  type CompletedProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompletedProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompletedProjectCountAggregateInputType | true
    }

  export interface CompletedProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompletedProject'], meta: { name: 'CompletedProject' } }
    /**
     * Find zero or one CompletedProject that matches the filter.
     * @param {CompletedProjectFindUniqueArgs} args - Arguments to find a CompletedProject
     * @example
     * // Get one CompletedProject
     * const completedProject = await prisma.completedProject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompletedProjectFindUniqueArgs>(args: SelectSubset<T, CompletedProjectFindUniqueArgs<ExtArgs>>): Prisma__CompletedProjectClient<$Result.GetResult<Prisma.$CompletedProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CompletedProject that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompletedProjectFindUniqueOrThrowArgs} args - Arguments to find a CompletedProject
     * @example
     * // Get one CompletedProject
     * const completedProject = await prisma.completedProject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompletedProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, CompletedProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompletedProjectClient<$Result.GetResult<Prisma.$CompletedProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CompletedProject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletedProjectFindFirstArgs} args - Arguments to find a CompletedProject
     * @example
     * // Get one CompletedProject
     * const completedProject = await prisma.completedProject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompletedProjectFindFirstArgs>(args?: SelectSubset<T, CompletedProjectFindFirstArgs<ExtArgs>>): Prisma__CompletedProjectClient<$Result.GetResult<Prisma.$CompletedProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CompletedProject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletedProjectFindFirstOrThrowArgs} args - Arguments to find a CompletedProject
     * @example
     * // Get one CompletedProject
     * const completedProject = await prisma.completedProject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompletedProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, CompletedProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompletedProjectClient<$Result.GetResult<Prisma.$CompletedProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CompletedProjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletedProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompletedProjects
     * const completedProjects = await prisma.completedProject.findMany()
     * 
     * // Get first 10 CompletedProjects
     * const completedProjects = await prisma.completedProject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const completedProjectWithIdOnly = await prisma.completedProject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompletedProjectFindManyArgs>(args?: SelectSubset<T, CompletedProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompletedProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CompletedProject.
     * @param {CompletedProjectCreateArgs} args - Arguments to create a CompletedProject.
     * @example
     * // Create one CompletedProject
     * const CompletedProject = await prisma.completedProject.create({
     *   data: {
     *     // ... data to create a CompletedProject
     *   }
     * })
     * 
     */
    create<T extends CompletedProjectCreateArgs>(args: SelectSubset<T, CompletedProjectCreateArgs<ExtArgs>>): Prisma__CompletedProjectClient<$Result.GetResult<Prisma.$CompletedProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CompletedProjects.
     * @param {CompletedProjectCreateManyArgs} args - Arguments to create many CompletedProjects.
     * @example
     * // Create many CompletedProjects
     * const completedProject = await prisma.completedProject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompletedProjectCreateManyArgs>(args?: SelectSubset<T, CompletedProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompletedProjects and returns the data saved in the database.
     * @param {CompletedProjectCreateManyAndReturnArgs} args - Arguments to create many CompletedProjects.
     * @example
     * // Create many CompletedProjects
     * const completedProject = await prisma.completedProject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompletedProjects and only return the `id`
     * const completedProjectWithIdOnly = await prisma.completedProject.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompletedProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, CompletedProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompletedProjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CompletedProject.
     * @param {CompletedProjectDeleteArgs} args - Arguments to delete one CompletedProject.
     * @example
     * // Delete one CompletedProject
     * const CompletedProject = await prisma.completedProject.delete({
     *   where: {
     *     // ... filter to delete one CompletedProject
     *   }
     * })
     * 
     */
    delete<T extends CompletedProjectDeleteArgs>(args: SelectSubset<T, CompletedProjectDeleteArgs<ExtArgs>>): Prisma__CompletedProjectClient<$Result.GetResult<Prisma.$CompletedProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CompletedProject.
     * @param {CompletedProjectUpdateArgs} args - Arguments to update one CompletedProject.
     * @example
     * // Update one CompletedProject
     * const completedProject = await prisma.completedProject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompletedProjectUpdateArgs>(args: SelectSubset<T, CompletedProjectUpdateArgs<ExtArgs>>): Prisma__CompletedProjectClient<$Result.GetResult<Prisma.$CompletedProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CompletedProjects.
     * @param {CompletedProjectDeleteManyArgs} args - Arguments to filter CompletedProjects to delete.
     * @example
     * // Delete a few CompletedProjects
     * const { count } = await prisma.completedProject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompletedProjectDeleteManyArgs>(args?: SelectSubset<T, CompletedProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompletedProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletedProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompletedProjects
     * const completedProject = await prisma.completedProject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompletedProjectUpdateManyArgs>(args: SelectSubset<T, CompletedProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompletedProject.
     * @param {CompletedProjectUpsertArgs} args - Arguments to update or create a CompletedProject.
     * @example
     * // Update or create a CompletedProject
     * const completedProject = await prisma.completedProject.upsert({
     *   create: {
     *     // ... data to create a CompletedProject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompletedProject we want to update
     *   }
     * })
     */
    upsert<T extends CompletedProjectUpsertArgs>(args: SelectSubset<T, CompletedProjectUpsertArgs<ExtArgs>>): Prisma__CompletedProjectClient<$Result.GetResult<Prisma.$CompletedProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CompletedProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletedProjectCountArgs} args - Arguments to filter CompletedProjects to count.
     * @example
     * // Count the number of CompletedProjects
     * const count = await prisma.completedProject.count({
     *   where: {
     *     // ... the filter for the CompletedProjects we want to count
     *   }
     * })
    **/
    count<T extends CompletedProjectCountArgs>(
      args?: Subset<T, CompletedProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompletedProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompletedProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletedProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompletedProjectAggregateArgs>(args: Subset<T, CompletedProjectAggregateArgs>): Prisma.PrismaPromise<GetCompletedProjectAggregateType<T>>

    /**
     * Group by CompletedProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletedProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompletedProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompletedProjectGroupByArgs['orderBy'] }
        : { orderBy?: CompletedProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompletedProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompletedProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompletedProject model
   */
  readonly fields: CompletedProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompletedProject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompletedProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends CompletedProject$projectArgs<ExtArgs> = {}>(args?: Subset<T, CompletedProject$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompletedProject model
   */ 
  interface CompletedProjectFieldRefs {
    readonly id: FieldRef<"CompletedProject", 'String'>
    readonly accountId: FieldRef<"CompletedProject", 'String'>
    readonly projectId: FieldRef<"CompletedProject", 'String'>
    readonly ownerId: FieldRef<"CompletedProject", 'String'>
    readonly title: FieldRef<"CompletedProject", 'String'>
    readonly description: FieldRef<"CompletedProject", 'String'>
    readonly status: FieldRef<"CompletedProject", 'CompletedProjectStatus'>
    readonly startDate: FieldRef<"CompletedProject", 'DateTime'>
    readonly endDate: FieldRef<"CompletedProject", 'DateTime'>
    readonly createdAt: FieldRef<"CompletedProject", 'DateTime'>
    readonly updatedAt: FieldRef<"CompletedProject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompletedProject findUnique
   */
  export type CompletedProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedProject
     */
    select?: CompletedProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedProjectInclude<ExtArgs> | null
    /**
     * Filter, which CompletedProject to fetch.
     */
    where: CompletedProjectWhereUniqueInput
  }

  /**
   * CompletedProject findUniqueOrThrow
   */
  export type CompletedProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedProject
     */
    select?: CompletedProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedProjectInclude<ExtArgs> | null
    /**
     * Filter, which CompletedProject to fetch.
     */
    where: CompletedProjectWhereUniqueInput
  }

  /**
   * CompletedProject findFirst
   */
  export type CompletedProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedProject
     */
    select?: CompletedProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedProjectInclude<ExtArgs> | null
    /**
     * Filter, which CompletedProject to fetch.
     */
    where?: CompletedProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompletedProjects to fetch.
     */
    orderBy?: CompletedProjectOrderByWithRelationInput | CompletedProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompletedProjects.
     */
    cursor?: CompletedProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompletedProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompletedProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompletedProjects.
     */
    distinct?: CompletedProjectScalarFieldEnum | CompletedProjectScalarFieldEnum[]
  }

  /**
   * CompletedProject findFirstOrThrow
   */
  export type CompletedProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedProject
     */
    select?: CompletedProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedProjectInclude<ExtArgs> | null
    /**
     * Filter, which CompletedProject to fetch.
     */
    where?: CompletedProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompletedProjects to fetch.
     */
    orderBy?: CompletedProjectOrderByWithRelationInput | CompletedProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompletedProjects.
     */
    cursor?: CompletedProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompletedProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompletedProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompletedProjects.
     */
    distinct?: CompletedProjectScalarFieldEnum | CompletedProjectScalarFieldEnum[]
  }

  /**
   * CompletedProject findMany
   */
  export type CompletedProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedProject
     */
    select?: CompletedProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedProjectInclude<ExtArgs> | null
    /**
     * Filter, which CompletedProjects to fetch.
     */
    where?: CompletedProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompletedProjects to fetch.
     */
    orderBy?: CompletedProjectOrderByWithRelationInput | CompletedProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompletedProjects.
     */
    cursor?: CompletedProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompletedProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompletedProjects.
     */
    skip?: number
    distinct?: CompletedProjectScalarFieldEnum | CompletedProjectScalarFieldEnum[]
  }

  /**
   * CompletedProject create
   */
  export type CompletedProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedProject
     */
    select?: CompletedProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a CompletedProject.
     */
    data: XOR<CompletedProjectCreateInput, CompletedProjectUncheckedCreateInput>
  }

  /**
   * CompletedProject createMany
   */
  export type CompletedProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompletedProjects.
     */
    data: CompletedProjectCreateManyInput | CompletedProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompletedProject createManyAndReturn
   */
  export type CompletedProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedProject
     */
    select?: CompletedProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CompletedProjects.
     */
    data: CompletedProjectCreateManyInput | CompletedProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompletedProject update
   */
  export type CompletedProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedProject
     */
    select?: CompletedProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a CompletedProject.
     */
    data: XOR<CompletedProjectUpdateInput, CompletedProjectUncheckedUpdateInput>
    /**
     * Choose, which CompletedProject to update.
     */
    where: CompletedProjectWhereUniqueInput
  }

  /**
   * CompletedProject updateMany
   */
  export type CompletedProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompletedProjects.
     */
    data: XOR<CompletedProjectUpdateManyMutationInput, CompletedProjectUncheckedUpdateManyInput>
    /**
     * Filter which CompletedProjects to update
     */
    where?: CompletedProjectWhereInput
  }

  /**
   * CompletedProject upsert
   */
  export type CompletedProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedProject
     */
    select?: CompletedProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the CompletedProject to update in case it exists.
     */
    where: CompletedProjectWhereUniqueInput
    /**
     * In case the CompletedProject found by the `where` argument doesn't exist, create a new CompletedProject with this data.
     */
    create: XOR<CompletedProjectCreateInput, CompletedProjectUncheckedCreateInput>
    /**
     * In case the CompletedProject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompletedProjectUpdateInput, CompletedProjectUncheckedUpdateInput>
  }

  /**
   * CompletedProject delete
   */
  export type CompletedProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedProject
     */
    select?: CompletedProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedProjectInclude<ExtArgs> | null
    /**
     * Filter which CompletedProject to delete.
     */
    where: CompletedProjectWhereUniqueInput
  }

  /**
   * CompletedProject deleteMany
   */
  export type CompletedProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompletedProjects to delete
     */
    where?: CompletedProjectWhereInput
  }

  /**
   * CompletedProject.project
   */
  export type CompletedProject$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * CompletedProject without action
   */
  export type CompletedProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedProject
     */
    select?: CompletedProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedProjectInclude<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    enquiryId: string | null
    leadId: string | null
    projectId: string | null
    userId: string | null
    type: $Enums.ActivityType | null
    threadKey: string | null
    summary: string | null
    body: string | null
    occurredAt: Date | null
    createdAt: Date | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    enquiryId: string | null
    leadId: string | null
    projectId: string | null
    userId: string | null
    type: $Enums.ActivityType | null
    threadKey: string | null
    summary: string | null
    body: string | null
    occurredAt: Date | null
    createdAt: Date | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    accountId: number
    enquiryId: number
    leadId: number
    projectId: number
    userId: number
    type: number
    threadKey: number
    summary: number
    body: number
    attachments: number
    durations: number
    metadata: number
    occurredAt: number
    createdAt: number
    _all: number
  }


  export type ActivityMinAggregateInputType = {
    id?: true
    accountId?: true
    enquiryId?: true
    leadId?: true
    projectId?: true
    userId?: true
    type?: true
    threadKey?: true
    summary?: true
    body?: true
    occurredAt?: true
    createdAt?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    accountId?: true
    enquiryId?: true
    leadId?: true
    projectId?: true
    userId?: true
    type?: true
    threadKey?: true
    summary?: true
    body?: true
    occurredAt?: true
    createdAt?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    accountId?: true
    enquiryId?: true
    leadId?: true
    projectId?: true
    userId?: true
    type?: true
    threadKey?: true
    summary?: true
    body?: true
    attachments?: true
    durations?: true
    metadata?: true
    occurredAt?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    accountId: string
    enquiryId: string | null
    leadId: string | null
    projectId: string | null
    userId: string | null
    type: $Enums.ActivityType
    threadKey: string | null
    summary: string | null
    body: string | null
    attachments: JsonValue | null
    durations: JsonValue | null
    metadata: JsonValue | null
    occurredAt: Date
    createdAt: Date
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    enquiryId?: boolean
    leadId?: boolean
    projectId?: boolean
    userId?: boolean
    type?: boolean
    threadKey?: boolean
    summary?: boolean
    body?: boolean
    attachments?: boolean
    durations?: boolean
    metadata?: boolean
    occurredAt?: boolean
    createdAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    enquiry?: boolean | Activity$enquiryArgs<ExtArgs>
    lead?: boolean | Activity$leadArgs<ExtArgs>
    project?: boolean | Activity$projectArgs<ExtArgs>
    user?: boolean | Activity$userArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    enquiryId?: boolean
    leadId?: boolean
    projectId?: boolean
    userId?: boolean
    type?: boolean
    threadKey?: boolean
    summary?: boolean
    body?: boolean
    attachments?: boolean
    durations?: boolean
    metadata?: boolean
    occurredAt?: boolean
    createdAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    enquiry?: boolean | Activity$enquiryArgs<ExtArgs>
    lead?: boolean | Activity$leadArgs<ExtArgs>
    project?: boolean | Activity$projectArgs<ExtArgs>
    user?: boolean | Activity$userArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    accountId?: boolean
    enquiryId?: boolean
    leadId?: boolean
    projectId?: boolean
    userId?: boolean
    type?: boolean
    threadKey?: boolean
    summary?: boolean
    body?: boolean
    attachments?: boolean
    durations?: boolean
    metadata?: boolean
    occurredAt?: boolean
    createdAt?: boolean
  }

  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    enquiry?: boolean | Activity$enquiryArgs<ExtArgs>
    lead?: boolean | Activity$leadArgs<ExtArgs>
    project?: boolean | Activity$projectArgs<ExtArgs>
    user?: boolean | Activity$userArgs<ExtArgs>
  }
  export type ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    enquiry?: boolean | Activity$enquiryArgs<ExtArgs>
    lead?: boolean | Activity$leadArgs<ExtArgs>
    project?: boolean | Activity$projectArgs<ExtArgs>
    user?: boolean | Activity$userArgs<ExtArgs>
  }

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      enquiry: Prisma.$EnquiryPayload<ExtArgs> | null
      lead: Prisma.$LeadPayload<ExtArgs> | null
      project: Prisma.$ProjectPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      enquiryId: string | null
      leadId: string | null
      projectId: string | null
      userId: string | null
      type: $Enums.ActivityType
      threadKey: string | null
      summary: string | null
      body: string | null
      attachments: Prisma.JsonValue | null
      durations: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      occurredAt: Date
      createdAt: Date
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    enquiry<T extends Activity$enquiryArgs<ExtArgs> = {}>(args?: Subset<T, Activity$enquiryArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    lead<T extends Activity$leadArgs<ExtArgs> = {}>(args?: Subset<T, Activity$leadArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    project<T extends Activity$projectArgs<ExtArgs> = {}>(args?: Subset<T, Activity$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends Activity$userArgs<ExtArgs> = {}>(args?: Subset<T, Activity$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */ 
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'String'>
    readonly accountId: FieldRef<"Activity", 'String'>
    readonly enquiryId: FieldRef<"Activity", 'String'>
    readonly leadId: FieldRef<"Activity", 'String'>
    readonly projectId: FieldRef<"Activity", 'String'>
    readonly userId: FieldRef<"Activity", 'String'>
    readonly type: FieldRef<"Activity", 'ActivityType'>
    readonly threadKey: FieldRef<"Activity", 'String'>
    readonly summary: FieldRef<"Activity", 'String'>
    readonly body: FieldRef<"Activity", 'String'>
    readonly attachments: FieldRef<"Activity", 'Json'>
    readonly durations: FieldRef<"Activity", 'Json'>
    readonly metadata: FieldRef<"Activity", 'Json'>
    readonly occurredAt: FieldRef<"Activity", 'DateTime'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
  }

  /**
   * Activity.enquiry
   */
  export type Activity$enquiryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    where?: EnquiryWhereInput
  }

  /**
   * Activity.lead
   */
  export type Activity$leadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
  }

  /**
   * Activity.project
   */
  export type Activity$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Activity.user
   */
  export type Activity$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.TaskStatus | null
    priority: $Enums.Priority | null
    dueDate: Date | null
    completedAt: Date | null
    assigneeId: string | null
    accountId: string | null
    enquiryId: string | null
    leadId: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.TaskStatus | null
    priority: $Enums.Priority | null
    dueDate: Date | null
    completedAt: Date | null
    assigneeId: string | null
    accountId: string | null
    enquiryId: string | null
    leadId: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    priority: number
    dueDate: number
    completedAt: number
    assigneeId: number
    accountId: number
    enquiryId: number
    leadId: number
    projectId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaskMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    completedAt?: true
    assigneeId?: true
    accountId?: true
    enquiryId?: true
    leadId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    completedAt?: true
    assigneeId?: true
    accountId?: true
    enquiryId?: true
    leadId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    completedAt?: true
    assigneeId?: true
    accountId?: true
    enquiryId?: true
    leadId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    title: string
    description: string | null
    status: $Enums.TaskStatus
    priority: $Enums.Priority
    dueDate: Date | null
    completedAt: Date | null
    assigneeId: string
    accountId: string
    enquiryId: string | null
    leadId: string | null
    projectId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    completedAt?: boolean
    assigneeId?: boolean
    accountId?: boolean
    enquiryId?: boolean
    leadId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    assignee?: boolean | UserDefaultArgs<ExtArgs>
    enquiry?: boolean | Task$enquiryArgs<ExtArgs>
    lead?: boolean | Task$leadArgs<ExtArgs>
    project?: boolean | Task$projectArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    completedAt?: boolean
    assigneeId?: boolean
    accountId?: boolean
    enquiryId?: boolean
    leadId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    assignee?: boolean | UserDefaultArgs<ExtArgs>
    enquiry?: boolean | Task$enquiryArgs<ExtArgs>
    lead?: boolean | Task$leadArgs<ExtArgs>
    project?: boolean | Task$projectArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    completedAt?: boolean
    assigneeId?: boolean
    accountId?: boolean
    enquiryId?: boolean
    leadId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    assignee?: boolean | UserDefaultArgs<ExtArgs>
    enquiry?: boolean | Task$enquiryArgs<ExtArgs>
    lead?: boolean | Task$leadArgs<ExtArgs>
    project?: boolean | Task$projectArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    assignee?: boolean | UserDefaultArgs<ExtArgs>
    enquiry?: boolean | Task$enquiryArgs<ExtArgs>
    lead?: boolean | Task$leadArgs<ExtArgs>
    project?: boolean | Task$projectArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      assignee: Prisma.$UserPayload<ExtArgs>
      enquiry: Prisma.$EnquiryPayload<ExtArgs> | null
      lead: Prisma.$LeadPayload<ExtArgs> | null
      project: Prisma.$ProjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      status: $Enums.TaskStatus
      priority: $Enums.Priority
      dueDate: Date | null
      completedAt: Date | null
      assigneeId: string
      accountId: string
      enquiryId: string | null
      leadId: string | null
      projectId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assignee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    enquiry<T extends Task$enquiryArgs<ExtArgs> = {}>(args?: Subset<T, Task$enquiryArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    lead<T extends Task$leadArgs<ExtArgs> = {}>(args?: Subset<T, Task$leadArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    project<T extends Task$projectArgs<ExtArgs> = {}>(args?: Subset<T, Task$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */ 
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'TaskStatus'>
    readonly priority: FieldRef<"Task", 'Priority'>
    readonly dueDate: FieldRef<"Task", 'DateTime'>
    readonly completedAt: FieldRef<"Task", 'DateTime'>
    readonly assigneeId: FieldRef<"Task", 'String'>
    readonly accountId: FieldRef<"Task", 'String'>
    readonly enquiryId: FieldRef<"Task", 'String'>
    readonly leadId: FieldRef<"Task", 'String'>
    readonly projectId: FieldRef<"Task", 'String'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
  }

  /**
   * Task.enquiry
   */
  export type Task$enquiryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    where?: EnquiryWhereInput
  }

  /**
   * Task.lead
   */
  export type Task$leadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
  }

  /**
   * Task.project
   */
  export type Task$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    projectId: string | null
    title: string | null
    description: string | null
    type: $Enums.AppointmentType | null
    startTime: Date | null
    endTime: Date | null
    location: string | null
    status: $Enums.AppointmentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    projectId: string | null
    title: string | null
    description: string | null
    type: $Enums.AppointmentType | null
    startTime: Date | null
    endTime: Date | null
    location: string | null
    status: $Enums.AppointmentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    accountId: number
    projectId: number
    title: number
    description: number
    type: number
    startTime: number
    endTime: number
    location: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AppointmentMinAggregateInputType = {
    id?: true
    accountId?: true
    projectId?: true
    title?: true
    description?: true
    type?: true
    startTime?: true
    endTime?: true
    location?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    accountId?: true
    projectId?: true
    title?: true
    description?: true
    type?: true
    startTime?: true
    endTime?: true
    location?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    accountId?: true
    projectId?: true
    title?: true
    description?: true
    type?: true
    startTime?: true
    endTime?: true
    location?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: string
    accountId: string
    projectId: string | null
    title: string
    description: string | null
    type: $Enums.AppointmentType
    startTime: Date
    endTime: Date
    location: string | null
    status: $Enums.AppointmentStatus
    createdAt: Date
    updatedAt: Date
    _count: AppointmentCountAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    startTime?: boolean
    endTime?: boolean
    location?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    project?: boolean | Appointment$projectArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    startTime?: boolean
    endTime?: boolean
    location?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    project?: boolean | Appointment$projectArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    id?: boolean
    accountId?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    startTime?: boolean
    endTime?: boolean
    location?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    project?: boolean | Appointment$projectArgs<ExtArgs>
  }
  export type AppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    project?: boolean | Appointment$projectArgs<ExtArgs>
  }

  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      projectId: string | null
      title: string
      description: string | null
      type: $Enums.AppointmentType
      startTime: Date
      endTime: Date
      location: string | null
      status: $Enums.AppointmentStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {AppointmentCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends Appointment$projectArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointment model
   */ 
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'String'>
    readonly accountId: FieldRef<"Appointment", 'String'>
    readonly projectId: FieldRef<"Appointment", 'String'>
    readonly title: FieldRef<"Appointment", 'String'>
    readonly description: FieldRef<"Appointment", 'String'>
    readonly type: FieldRef<"Appointment", 'AppointmentType'>
    readonly startTime: FieldRef<"Appointment", 'DateTime'>
    readonly endTime: FieldRef<"Appointment", 'DateTime'>
    readonly location: FieldRef<"Appointment", 'String'>
    readonly status: FieldRef<"Appointment", 'AppointmentStatus'>
    readonly createdAt: FieldRef<"Appointment", 'DateTime'>
    readonly updatedAt: FieldRef<"Appointment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Appointment createManyAndReturn
   */
  export type AppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
  }

  /**
   * Appointment.project
   */
  export type Appointment$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    projectId: string | null
    filename: string | null
    fileUrl: string | null
    fileSize: number | null
    mimeType: string | null
    type: $Enums.DocumentType | null
    uploadedBy: string | null
    createdAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    projectId: string | null
    filename: string | null
    fileUrl: string | null
    fileSize: number | null
    mimeType: string | null
    type: $Enums.DocumentType | null
    uploadedBy: string | null
    createdAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    accountId: number
    projectId: number
    filename: number
    fileUrl: number
    fileSize: number
    mimeType: number
    type: number
    uploadedBy: number
    createdAt: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    fileSize?: true
  }

  export type DocumentSumAggregateInputType = {
    fileSize?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    accountId?: true
    projectId?: true
    filename?: true
    fileUrl?: true
    fileSize?: true
    mimeType?: true
    type?: true
    uploadedBy?: true
    createdAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    accountId?: true
    projectId?: true
    filename?: true
    fileUrl?: true
    fileSize?: true
    mimeType?: true
    type?: true
    uploadedBy?: true
    createdAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    accountId?: true
    projectId?: true
    filename?: true
    fileUrl?: true
    fileSize?: true
    mimeType?: true
    type?: true
    uploadedBy?: true
    createdAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    accountId: string
    projectId: string | null
    filename: string
    fileUrl: string
    fileSize: number | null
    mimeType: string | null
    type: $Enums.DocumentType
    uploadedBy: string | null
    createdAt: Date
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    projectId?: boolean
    filename?: boolean
    fileUrl?: boolean
    fileSize?: boolean
    mimeType?: boolean
    type?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    project?: boolean | Document$projectArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    projectId?: boolean
    filename?: boolean
    fileUrl?: boolean
    fileSize?: boolean
    mimeType?: boolean
    type?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    project?: boolean | Document$projectArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    accountId?: boolean
    projectId?: boolean
    filename?: boolean
    fileUrl?: boolean
    fileSize?: boolean
    mimeType?: boolean
    type?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    project?: boolean | Document$projectArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    project?: boolean | Document$projectArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      projectId: string | null
      filename: string
      fileUrl: string
      fileSize: number | null
      mimeType: string | null
      type: $Enums.DocumentType
      uploadedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends Document$projectArgs<ExtArgs> = {}>(args?: Subset<T, Document$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */ 
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly accountId: FieldRef<"Document", 'String'>
    readonly projectId: FieldRef<"Document", 'String'>
    readonly filename: FieldRef<"Document", 'String'>
    readonly fileUrl: FieldRef<"Document", 'String'>
    readonly fileSize: FieldRef<"Document", 'Int'>
    readonly mimeType: FieldRef<"Document", 'String'>
    readonly type: FieldRef<"Document", 'DocumentType'>
    readonly uploadedBy: FieldRef<"Document", 'String'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }

  /**
   * Document.project
   */
  export type Document$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model Snag
   */

  export type AggregateSnag = {
    _count: SnagCountAggregateOutputType | null
    _min: SnagMinAggregateOutputType | null
    _max: SnagMaxAggregateOutputType | null
  }

  export type SnagMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    projectId: string | null
    title: string | null
    description: string | null
    status: $Enums.SnagStatus | null
    priority: $Enums.Priority | null
    assigneeId: string | null
    dueAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SnagMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    projectId: string | null
    title: string | null
    description: string | null
    status: $Enums.SnagStatus | null
    priority: $Enums.Priority | null
    assigneeId: string | null
    dueAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SnagCountAggregateOutputType = {
    id: number
    accountId: number
    projectId: number
    title: number
    description: number
    status: number
    priority: number
    assigneeId: number
    dueAt: number
    photos: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SnagMinAggregateInputType = {
    id?: true
    accountId?: true
    projectId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    assigneeId?: true
    dueAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SnagMaxAggregateInputType = {
    id?: true
    accountId?: true
    projectId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    assigneeId?: true
    dueAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SnagCountAggregateInputType = {
    id?: true
    accountId?: true
    projectId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    assigneeId?: true
    dueAt?: true
    photos?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SnagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Snag to aggregate.
     */
    where?: SnagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Snags to fetch.
     */
    orderBy?: SnagOrderByWithRelationInput | SnagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SnagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Snags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Snags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Snags
    **/
    _count?: true | SnagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SnagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SnagMaxAggregateInputType
  }

  export type GetSnagAggregateType<T extends SnagAggregateArgs> = {
        [P in keyof T & keyof AggregateSnag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSnag[P]>
      : GetScalarType<T[P], AggregateSnag[P]>
  }




  export type SnagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SnagWhereInput
    orderBy?: SnagOrderByWithAggregationInput | SnagOrderByWithAggregationInput[]
    by: SnagScalarFieldEnum[] | SnagScalarFieldEnum
    having?: SnagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SnagCountAggregateInputType | true
    _min?: SnagMinAggregateInputType
    _max?: SnagMaxAggregateInputType
  }

  export type SnagGroupByOutputType = {
    id: string
    accountId: string
    projectId: string
    title: string
    description: string
    status: $Enums.SnagStatus
    priority: $Enums.Priority
    assigneeId: string | null
    dueAt: Date | null
    photos: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: SnagCountAggregateOutputType | null
    _min: SnagMinAggregateOutputType | null
    _max: SnagMaxAggregateOutputType | null
  }

  type GetSnagGroupByPayload<T extends SnagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SnagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SnagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SnagGroupByOutputType[P]>
            : GetScalarType<T[P], SnagGroupByOutputType[P]>
        }
      >
    >


  export type SnagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    assigneeId?: boolean
    dueAt?: boolean
    photos?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["snag"]>

  export type SnagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    assigneeId?: boolean
    dueAt?: boolean
    photos?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["snag"]>

  export type SnagSelectScalar = {
    id?: boolean
    accountId?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    assigneeId?: boolean
    dueAt?: boolean
    photos?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SnagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type SnagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $SnagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Snag"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      projectId: string
      title: string
      description: string
      status: $Enums.SnagStatus
      priority: $Enums.Priority
      assigneeId: string | null
      dueAt: Date | null
      photos: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["snag"]>
    composites: {}
  }

  type SnagGetPayload<S extends boolean | null | undefined | SnagDefaultArgs> = $Result.GetResult<Prisma.$SnagPayload, S>

  type SnagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SnagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SnagCountAggregateInputType | true
    }

  export interface SnagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Snag'], meta: { name: 'Snag' } }
    /**
     * Find zero or one Snag that matches the filter.
     * @param {SnagFindUniqueArgs} args - Arguments to find a Snag
     * @example
     * // Get one Snag
     * const snag = await prisma.snag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SnagFindUniqueArgs>(args: SelectSubset<T, SnagFindUniqueArgs<ExtArgs>>): Prisma__SnagClient<$Result.GetResult<Prisma.$SnagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Snag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SnagFindUniqueOrThrowArgs} args - Arguments to find a Snag
     * @example
     * // Get one Snag
     * const snag = await prisma.snag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SnagFindUniqueOrThrowArgs>(args: SelectSubset<T, SnagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SnagClient<$Result.GetResult<Prisma.$SnagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Snag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnagFindFirstArgs} args - Arguments to find a Snag
     * @example
     * // Get one Snag
     * const snag = await prisma.snag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SnagFindFirstArgs>(args?: SelectSubset<T, SnagFindFirstArgs<ExtArgs>>): Prisma__SnagClient<$Result.GetResult<Prisma.$SnagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Snag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnagFindFirstOrThrowArgs} args - Arguments to find a Snag
     * @example
     * // Get one Snag
     * const snag = await prisma.snag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SnagFindFirstOrThrowArgs>(args?: SelectSubset<T, SnagFindFirstOrThrowArgs<ExtArgs>>): Prisma__SnagClient<$Result.GetResult<Prisma.$SnagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Snags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Snags
     * const snags = await prisma.snag.findMany()
     * 
     * // Get first 10 Snags
     * const snags = await prisma.snag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const snagWithIdOnly = await prisma.snag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SnagFindManyArgs>(args?: SelectSubset<T, SnagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Snag.
     * @param {SnagCreateArgs} args - Arguments to create a Snag.
     * @example
     * // Create one Snag
     * const Snag = await prisma.snag.create({
     *   data: {
     *     // ... data to create a Snag
     *   }
     * })
     * 
     */
    create<T extends SnagCreateArgs>(args: SelectSubset<T, SnagCreateArgs<ExtArgs>>): Prisma__SnagClient<$Result.GetResult<Prisma.$SnagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Snags.
     * @param {SnagCreateManyArgs} args - Arguments to create many Snags.
     * @example
     * // Create many Snags
     * const snag = await prisma.snag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SnagCreateManyArgs>(args?: SelectSubset<T, SnagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Snags and returns the data saved in the database.
     * @param {SnagCreateManyAndReturnArgs} args - Arguments to create many Snags.
     * @example
     * // Create many Snags
     * const snag = await prisma.snag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Snags and only return the `id`
     * const snagWithIdOnly = await prisma.snag.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SnagCreateManyAndReturnArgs>(args?: SelectSubset<T, SnagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnagPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Snag.
     * @param {SnagDeleteArgs} args - Arguments to delete one Snag.
     * @example
     * // Delete one Snag
     * const Snag = await prisma.snag.delete({
     *   where: {
     *     // ... filter to delete one Snag
     *   }
     * })
     * 
     */
    delete<T extends SnagDeleteArgs>(args: SelectSubset<T, SnagDeleteArgs<ExtArgs>>): Prisma__SnagClient<$Result.GetResult<Prisma.$SnagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Snag.
     * @param {SnagUpdateArgs} args - Arguments to update one Snag.
     * @example
     * // Update one Snag
     * const snag = await prisma.snag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SnagUpdateArgs>(args: SelectSubset<T, SnagUpdateArgs<ExtArgs>>): Prisma__SnagClient<$Result.GetResult<Prisma.$SnagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Snags.
     * @param {SnagDeleteManyArgs} args - Arguments to filter Snags to delete.
     * @example
     * // Delete a few Snags
     * const { count } = await prisma.snag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SnagDeleteManyArgs>(args?: SelectSubset<T, SnagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Snags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Snags
     * const snag = await prisma.snag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SnagUpdateManyArgs>(args: SelectSubset<T, SnagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Snag.
     * @param {SnagUpsertArgs} args - Arguments to update or create a Snag.
     * @example
     * // Update or create a Snag
     * const snag = await prisma.snag.upsert({
     *   create: {
     *     // ... data to create a Snag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Snag we want to update
     *   }
     * })
     */
    upsert<T extends SnagUpsertArgs>(args: SelectSubset<T, SnagUpsertArgs<ExtArgs>>): Prisma__SnagClient<$Result.GetResult<Prisma.$SnagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Snags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnagCountArgs} args - Arguments to filter Snags to count.
     * @example
     * // Count the number of Snags
     * const count = await prisma.snag.count({
     *   where: {
     *     // ... the filter for the Snags we want to count
     *   }
     * })
    **/
    count<T extends SnagCountArgs>(
      args?: Subset<T, SnagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SnagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Snag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SnagAggregateArgs>(args: Subset<T, SnagAggregateArgs>): Prisma.PrismaPromise<GetSnagAggregateType<T>>

    /**
     * Group by Snag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SnagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SnagGroupByArgs['orderBy'] }
        : { orderBy?: SnagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SnagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSnagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Snag model
   */
  readonly fields: SnagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Snag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SnagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Snag model
   */ 
  interface SnagFieldRefs {
    readonly id: FieldRef<"Snag", 'String'>
    readonly accountId: FieldRef<"Snag", 'String'>
    readonly projectId: FieldRef<"Snag", 'String'>
    readonly title: FieldRef<"Snag", 'String'>
    readonly description: FieldRef<"Snag", 'String'>
    readonly status: FieldRef<"Snag", 'SnagStatus'>
    readonly priority: FieldRef<"Snag", 'Priority'>
    readonly assigneeId: FieldRef<"Snag", 'String'>
    readonly dueAt: FieldRef<"Snag", 'DateTime'>
    readonly photos: FieldRef<"Snag", 'Json'>
    readonly createdAt: FieldRef<"Snag", 'DateTime'>
    readonly updatedAt: FieldRef<"Snag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Snag findUnique
   */
  export type SnagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagInclude<ExtArgs> | null
    /**
     * Filter, which Snag to fetch.
     */
    where: SnagWhereUniqueInput
  }

  /**
   * Snag findUniqueOrThrow
   */
  export type SnagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagInclude<ExtArgs> | null
    /**
     * Filter, which Snag to fetch.
     */
    where: SnagWhereUniqueInput
  }

  /**
   * Snag findFirst
   */
  export type SnagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagInclude<ExtArgs> | null
    /**
     * Filter, which Snag to fetch.
     */
    where?: SnagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Snags to fetch.
     */
    orderBy?: SnagOrderByWithRelationInput | SnagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Snags.
     */
    cursor?: SnagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Snags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Snags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Snags.
     */
    distinct?: SnagScalarFieldEnum | SnagScalarFieldEnum[]
  }

  /**
   * Snag findFirstOrThrow
   */
  export type SnagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagInclude<ExtArgs> | null
    /**
     * Filter, which Snag to fetch.
     */
    where?: SnagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Snags to fetch.
     */
    orderBy?: SnagOrderByWithRelationInput | SnagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Snags.
     */
    cursor?: SnagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Snags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Snags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Snags.
     */
    distinct?: SnagScalarFieldEnum | SnagScalarFieldEnum[]
  }

  /**
   * Snag findMany
   */
  export type SnagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagInclude<ExtArgs> | null
    /**
     * Filter, which Snags to fetch.
     */
    where?: SnagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Snags to fetch.
     */
    orderBy?: SnagOrderByWithRelationInput | SnagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Snags.
     */
    cursor?: SnagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Snags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Snags.
     */
    skip?: number
    distinct?: SnagScalarFieldEnum | SnagScalarFieldEnum[]
  }

  /**
   * Snag create
   */
  export type SnagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagInclude<ExtArgs> | null
    /**
     * The data needed to create a Snag.
     */
    data: XOR<SnagCreateInput, SnagUncheckedCreateInput>
  }

  /**
   * Snag createMany
   */
  export type SnagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Snags.
     */
    data: SnagCreateManyInput | SnagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Snag createManyAndReturn
   */
  export type SnagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Snags.
     */
    data: SnagCreateManyInput | SnagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Snag update
   */
  export type SnagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagInclude<ExtArgs> | null
    /**
     * The data needed to update a Snag.
     */
    data: XOR<SnagUpdateInput, SnagUncheckedUpdateInput>
    /**
     * Choose, which Snag to update.
     */
    where: SnagWhereUniqueInput
  }

  /**
   * Snag updateMany
   */
  export type SnagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Snags.
     */
    data: XOR<SnagUpdateManyMutationInput, SnagUncheckedUpdateManyInput>
    /**
     * Filter which Snags to update
     */
    where?: SnagWhereInput
  }

  /**
   * Snag upsert
   */
  export type SnagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagInclude<ExtArgs> | null
    /**
     * The filter to search for the Snag to update in case it exists.
     */
    where: SnagWhereUniqueInput
    /**
     * In case the Snag found by the `where` argument doesn't exist, create a new Snag with this data.
     */
    create: XOR<SnagCreateInput, SnagUncheckedCreateInput>
    /**
     * In case the Snag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SnagUpdateInput, SnagUncheckedUpdateInput>
  }

  /**
   * Snag delete
   */
  export type SnagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagInclude<ExtArgs> | null
    /**
     * Filter which Snag to delete.
     */
    where: SnagWhereUniqueInput
  }

  /**
   * Snag deleteMany
   */
  export type SnagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Snags to delete
     */
    where?: SnagWhereInput
  }

  /**
   * Snag without action
   */
  export type SnagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snag
     */
    select?: SnagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnagInclude<ExtArgs> | null
  }


  /**
   * Model EventLog
   */

  export type AggregateEventLog = {
    _count: EventLogCountAggregateOutputType | null
    _min: EventLogMinAggregateOutputType | null
    _max: EventLogMaxAggregateOutputType | null
  }

  export type EventLogMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    actorId: string | null
    entity: string | null
    entityId: string | null
    action: string | null
    createdAt: Date | null
  }

  export type EventLogMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    actorId: string | null
    entity: string | null
    entityId: string | null
    action: string | null
    createdAt: Date | null
  }

  export type EventLogCountAggregateOutputType = {
    id: number
    accountId: number
    actorId: number
    entity: number
    entityId: number
    action: number
    before: number
    after: number
    createdAt: number
    _all: number
  }


  export type EventLogMinAggregateInputType = {
    id?: true
    accountId?: true
    actorId?: true
    entity?: true
    entityId?: true
    action?: true
    createdAt?: true
  }

  export type EventLogMaxAggregateInputType = {
    id?: true
    accountId?: true
    actorId?: true
    entity?: true
    entityId?: true
    action?: true
    createdAt?: true
  }

  export type EventLogCountAggregateInputType = {
    id?: true
    accountId?: true
    actorId?: true
    entity?: true
    entityId?: true
    action?: true
    before?: true
    after?: true
    createdAt?: true
    _all?: true
  }

  export type EventLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventLog to aggregate.
     */
    where?: EventLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventLogs to fetch.
     */
    orderBy?: EventLogOrderByWithRelationInput | EventLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventLogs
    **/
    _count?: true | EventLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventLogMaxAggregateInputType
  }

  export type GetEventLogAggregateType<T extends EventLogAggregateArgs> = {
        [P in keyof T & keyof AggregateEventLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventLog[P]>
      : GetScalarType<T[P], AggregateEventLog[P]>
  }




  export type EventLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventLogWhereInput
    orderBy?: EventLogOrderByWithAggregationInput | EventLogOrderByWithAggregationInput[]
    by: EventLogScalarFieldEnum[] | EventLogScalarFieldEnum
    having?: EventLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventLogCountAggregateInputType | true
    _min?: EventLogMinAggregateInputType
    _max?: EventLogMaxAggregateInputType
  }

  export type EventLogGroupByOutputType = {
    id: string
    accountId: string | null
    actorId: string | null
    entity: string
    entityId: string
    action: string
    before: JsonValue | null
    after: JsonValue | null
    createdAt: Date
    _count: EventLogCountAggregateOutputType | null
    _min: EventLogMinAggregateOutputType | null
    _max: EventLogMaxAggregateOutputType | null
  }

  type GetEventLogGroupByPayload<T extends EventLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventLogGroupByOutputType[P]>
            : GetScalarType<T[P], EventLogGroupByOutputType[P]>
        }
      >
    >


  export type EventLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    actorId?: boolean
    entity?: boolean
    entityId?: boolean
    action?: boolean
    before?: boolean
    after?: boolean
    createdAt?: boolean
    account?: boolean | EventLog$accountArgs<ExtArgs>
  }, ExtArgs["result"]["eventLog"]>

  export type EventLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    actorId?: boolean
    entity?: boolean
    entityId?: boolean
    action?: boolean
    before?: boolean
    after?: boolean
    createdAt?: boolean
    account?: boolean | EventLog$accountArgs<ExtArgs>
  }, ExtArgs["result"]["eventLog"]>

  export type EventLogSelectScalar = {
    id?: boolean
    accountId?: boolean
    actorId?: boolean
    entity?: boolean
    entityId?: boolean
    action?: boolean
    before?: boolean
    after?: boolean
    createdAt?: boolean
  }

  export type EventLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | EventLog$accountArgs<ExtArgs>
  }
  export type EventLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | EventLog$accountArgs<ExtArgs>
  }

  export type $EventLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventLog"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string | null
      actorId: string | null
      entity: string
      entityId: string
      action: string
      before: Prisma.JsonValue | null
      after: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["eventLog"]>
    composites: {}
  }

  type EventLogGetPayload<S extends boolean | null | undefined | EventLogDefaultArgs> = $Result.GetResult<Prisma.$EventLogPayload, S>

  type EventLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventLogCountAggregateInputType | true
    }

  export interface EventLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventLog'], meta: { name: 'EventLog' } }
    /**
     * Find zero or one EventLog that matches the filter.
     * @param {EventLogFindUniqueArgs} args - Arguments to find a EventLog
     * @example
     * // Get one EventLog
     * const eventLog = await prisma.eventLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventLogFindUniqueArgs>(args: SelectSubset<T, EventLogFindUniqueArgs<ExtArgs>>): Prisma__EventLogClient<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EventLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventLogFindUniqueOrThrowArgs} args - Arguments to find a EventLog
     * @example
     * // Get one EventLog
     * const eventLog = await prisma.eventLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventLogFindUniqueOrThrowArgs>(args: SelectSubset<T, EventLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventLogClient<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EventLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLogFindFirstArgs} args - Arguments to find a EventLog
     * @example
     * // Get one EventLog
     * const eventLog = await prisma.eventLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventLogFindFirstArgs>(args?: SelectSubset<T, EventLogFindFirstArgs<ExtArgs>>): Prisma__EventLogClient<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EventLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLogFindFirstOrThrowArgs} args - Arguments to find a EventLog
     * @example
     * // Get one EventLog
     * const eventLog = await prisma.eventLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventLogFindFirstOrThrowArgs>(args?: SelectSubset<T, EventLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventLogClient<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EventLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventLogs
     * const eventLogs = await prisma.eventLog.findMany()
     * 
     * // Get first 10 EventLogs
     * const eventLogs = await prisma.eventLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventLogWithIdOnly = await prisma.eventLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventLogFindManyArgs>(args?: SelectSubset<T, EventLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EventLog.
     * @param {EventLogCreateArgs} args - Arguments to create a EventLog.
     * @example
     * // Create one EventLog
     * const EventLog = await prisma.eventLog.create({
     *   data: {
     *     // ... data to create a EventLog
     *   }
     * })
     * 
     */
    create<T extends EventLogCreateArgs>(args: SelectSubset<T, EventLogCreateArgs<ExtArgs>>): Prisma__EventLogClient<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EventLogs.
     * @param {EventLogCreateManyArgs} args - Arguments to create many EventLogs.
     * @example
     * // Create many EventLogs
     * const eventLog = await prisma.eventLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventLogCreateManyArgs>(args?: SelectSubset<T, EventLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventLogs and returns the data saved in the database.
     * @param {EventLogCreateManyAndReturnArgs} args - Arguments to create many EventLogs.
     * @example
     * // Create many EventLogs
     * const eventLog = await prisma.eventLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventLogs and only return the `id`
     * const eventLogWithIdOnly = await prisma.eventLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventLogCreateManyAndReturnArgs>(args?: SelectSubset<T, EventLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EventLog.
     * @param {EventLogDeleteArgs} args - Arguments to delete one EventLog.
     * @example
     * // Delete one EventLog
     * const EventLog = await prisma.eventLog.delete({
     *   where: {
     *     // ... filter to delete one EventLog
     *   }
     * })
     * 
     */
    delete<T extends EventLogDeleteArgs>(args: SelectSubset<T, EventLogDeleteArgs<ExtArgs>>): Prisma__EventLogClient<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EventLog.
     * @param {EventLogUpdateArgs} args - Arguments to update one EventLog.
     * @example
     * // Update one EventLog
     * const eventLog = await prisma.eventLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventLogUpdateArgs>(args: SelectSubset<T, EventLogUpdateArgs<ExtArgs>>): Prisma__EventLogClient<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EventLogs.
     * @param {EventLogDeleteManyArgs} args - Arguments to filter EventLogs to delete.
     * @example
     * // Delete a few EventLogs
     * const { count } = await prisma.eventLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventLogDeleteManyArgs>(args?: SelectSubset<T, EventLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventLogs
     * const eventLog = await prisma.eventLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventLogUpdateManyArgs>(args: SelectSubset<T, EventLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventLog.
     * @param {EventLogUpsertArgs} args - Arguments to update or create a EventLog.
     * @example
     * // Update or create a EventLog
     * const eventLog = await prisma.eventLog.upsert({
     *   create: {
     *     // ... data to create a EventLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventLog we want to update
     *   }
     * })
     */
    upsert<T extends EventLogUpsertArgs>(args: SelectSubset<T, EventLogUpsertArgs<ExtArgs>>): Prisma__EventLogClient<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EventLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLogCountArgs} args - Arguments to filter EventLogs to count.
     * @example
     * // Count the number of EventLogs
     * const count = await prisma.eventLog.count({
     *   where: {
     *     // ... the filter for the EventLogs we want to count
     *   }
     * })
    **/
    count<T extends EventLogCountArgs>(
      args?: Subset<T, EventLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventLogAggregateArgs>(args: Subset<T, EventLogAggregateArgs>): Prisma.PrismaPromise<GetEventLogAggregateType<T>>

    /**
     * Group by EventLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventLogGroupByArgs['orderBy'] }
        : { orderBy?: EventLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventLog model
   */
  readonly fields: EventLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends EventLog$accountArgs<ExtArgs> = {}>(args?: Subset<T, EventLog$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventLog model
   */ 
  interface EventLogFieldRefs {
    readonly id: FieldRef<"EventLog", 'String'>
    readonly accountId: FieldRef<"EventLog", 'String'>
    readonly actorId: FieldRef<"EventLog", 'String'>
    readonly entity: FieldRef<"EventLog", 'String'>
    readonly entityId: FieldRef<"EventLog", 'String'>
    readonly action: FieldRef<"EventLog", 'String'>
    readonly before: FieldRef<"EventLog", 'Json'>
    readonly after: FieldRef<"EventLog", 'Json'>
    readonly createdAt: FieldRef<"EventLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventLog findUnique
   */
  export type EventLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventLogInclude<ExtArgs> | null
    /**
     * Filter, which EventLog to fetch.
     */
    where: EventLogWhereUniqueInput
  }

  /**
   * EventLog findUniqueOrThrow
   */
  export type EventLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventLogInclude<ExtArgs> | null
    /**
     * Filter, which EventLog to fetch.
     */
    where: EventLogWhereUniqueInput
  }

  /**
   * EventLog findFirst
   */
  export type EventLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventLogInclude<ExtArgs> | null
    /**
     * Filter, which EventLog to fetch.
     */
    where?: EventLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventLogs to fetch.
     */
    orderBy?: EventLogOrderByWithRelationInput | EventLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventLogs.
     */
    cursor?: EventLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventLogs.
     */
    distinct?: EventLogScalarFieldEnum | EventLogScalarFieldEnum[]
  }

  /**
   * EventLog findFirstOrThrow
   */
  export type EventLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventLogInclude<ExtArgs> | null
    /**
     * Filter, which EventLog to fetch.
     */
    where?: EventLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventLogs to fetch.
     */
    orderBy?: EventLogOrderByWithRelationInput | EventLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventLogs.
     */
    cursor?: EventLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventLogs.
     */
    distinct?: EventLogScalarFieldEnum | EventLogScalarFieldEnum[]
  }

  /**
   * EventLog findMany
   */
  export type EventLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventLogInclude<ExtArgs> | null
    /**
     * Filter, which EventLogs to fetch.
     */
    where?: EventLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventLogs to fetch.
     */
    orderBy?: EventLogOrderByWithRelationInput | EventLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventLogs.
     */
    cursor?: EventLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventLogs.
     */
    skip?: number
    distinct?: EventLogScalarFieldEnum | EventLogScalarFieldEnum[]
  }

  /**
   * EventLog create
   */
  export type EventLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventLogInclude<ExtArgs> | null
    /**
     * The data needed to create a EventLog.
     */
    data: XOR<EventLogCreateInput, EventLogUncheckedCreateInput>
  }

  /**
   * EventLog createMany
   */
  export type EventLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventLogs.
     */
    data: EventLogCreateManyInput | EventLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventLog createManyAndReturn
   */
  export type EventLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EventLogs.
     */
    data: EventLogCreateManyInput | EventLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventLog update
   */
  export type EventLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventLogInclude<ExtArgs> | null
    /**
     * The data needed to update a EventLog.
     */
    data: XOR<EventLogUpdateInput, EventLogUncheckedUpdateInput>
    /**
     * Choose, which EventLog to update.
     */
    where: EventLogWhereUniqueInput
  }

  /**
   * EventLog updateMany
   */
  export type EventLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventLogs.
     */
    data: XOR<EventLogUpdateManyMutationInput, EventLogUncheckedUpdateManyInput>
    /**
     * Filter which EventLogs to update
     */
    where?: EventLogWhereInput
  }

  /**
   * EventLog upsert
   */
  export type EventLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventLogInclude<ExtArgs> | null
    /**
     * The filter to search for the EventLog to update in case it exists.
     */
    where: EventLogWhereUniqueInput
    /**
     * In case the EventLog found by the `where` argument doesn't exist, create a new EventLog with this data.
     */
    create: XOR<EventLogCreateInput, EventLogUncheckedCreateInput>
    /**
     * In case the EventLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventLogUpdateInput, EventLogUncheckedUpdateInput>
  }

  /**
   * EventLog delete
   */
  export type EventLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventLogInclude<ExtArgs> | null
    /**
     * Filter which EventLog to delete.
     */
    where: EventLogWhereUniqueInput
  }

  /**
   * EventLog deleteMany
   */
  export type EventLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventLogs to delete
     */
    where?: EventLogWhereInput
  }

  /**
   * EventLog.account
   */
  export type EventLog$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * EventLog without action
   */
  export type EventLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventLogInclude<ExtArgs> | null
  }


  /**
   * Model WorkflowDefinition
   */

  export type AggregateWorkflowDefinition = {
    _count: WorkflowDefinitionCountAggregateOutputType | null
    _avg: WorkflowDefinitionAvgAggregateOutputType | null
    _sum: WorkflowDefinitionSumAggregateOutputType | null
    _min: WorkflowDefinitionMinAggregateOutputType | null
    _max: WorkflowDefinitionMaxAggregateOutputType | null
  }

  export type WorkflowDefinitionAvgAggregateOutputType = {
    version: number | null
  }

  export type WorkflowDefinitionSumAggregateOutputType = {
    version: number | null
  }

  export type WorkflowDefinitionMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    version: number | null
    isActive: boolean | null
    triggerType: $Enums.WorkflowTriggerType | null
    accountId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowDefinitionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    version: number | null
    isActive: boolean | null
    triggerType: $Enums.WorkflowTriggerType | null
    accountId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowDefinitionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    version: number
    isActive: number
    triggerType: number
    triggerConditions: number
    accountId: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkflowDefinitionAvgAggregateInputType = {
    version?: true
  }

  export type WorkflowDefinitionSumAggregateInputType = {
    version?: true
  }

  export type WorkflowDefinitionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    version?: true
    isActive?: true
    triggerType?: true
    accountId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowDefinitionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    version?: true
    isActive?: true
    triggerType?: true
    accountId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowDefinitionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    version?: true
    isActive?: true
    triggerType?: true
    triggerConditions?: true
    accountId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkflowDefinitionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowDefinition to aggregate.
     */
    where?: WorkflowDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowDefinitions to fetch.
     */
    orderBy?: WorkflowDefinitionOrderByWithRelationInput | WorkflowDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkflowDefinitions
    **/
    _count?: true | WorkflowDefinitionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkflowDefinitionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkflowDefinitionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowDefinitionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowDefinitionMaxAggregateInputType
  }

  export type GetWorkflowDefinitionAggregateType<T extends WorkflowDefinitionAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflowDefinition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowDefinition[P]>
      : GetScalarType<T[P], AggregateWorkflowDefinition[P]>
  }




  export type WorkflowDefinitionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowDefinitionWhereInput
    orderBy?: WorkflowDefinitionOrderByWithAggregationInput | WorkflowDefinitionOrderByWithAggregationInput[]
    by: WorkflowDefinitionScalarFieldEnum[] | WorkflowDefinitionScalarFieldEnum
    having?: WorkflowDefinitionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowDefinitionCountAggregateInputType | true
    _avg?: WorkflowDefinitionAvgAggregateInputType
    _sum?: WorkflowDefinitionSumAggregateInputType
    _min?: WorkflowDefinitionMinAggregateInputType
    _max?: WorkflowDefinitionMaxAggregateInputType
  }

  export type WorkflowDefinitionGroupByOutputType = {
    id: string
    name: string
    description: string | null
    version: number
    isActive: boolean
    triggerType: $Enums.WorkflowTriggerType
    triggerConditions: JsonValue
    accountId: string
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: WorkflowDefinitionCountAggregateOutputType | null
    _avg: WorkflowDefinitionAvgAggregateOutputType | null
    _sum: WorkflowDefinitionSumAggregateOutputType | null
    _min: WorkflowDefinitionMinAggregateOutputType | null
    _max: WorkflowDefinitionMaxAggregateOutputType | null
  }

  type GetWorkflowDefinitionGroupByPayload<T extends WorkflowDefinitionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowDefinitionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowDefinitionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowDefinitionGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowDefinitionGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowDefinitionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    isActive?: boolean
    triggerType?: boolean
    triggerConditions?: boolean
    accountId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    steps?: boolean | WorkflowDefinition$stepsArgs<ExtArgs>
    instances?: boolean | WorkflowDefinition$instancesArgs<ExtArgs>
    templates?: boolean | WorkflowDefinition$templatesArgs<ExtArgs>
    _count?: boolean | WorkflowDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowDefinition"]>

  export type WorkflowDefinitionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    isActive?: boolean
    triggerType?: boolean
    triggerConditions?: boolean
    accountId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowDefinition"]>

  export type WorkflowDefinitionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    isActive?: boolean
    triggerType?: boolean
    triggerConditions?: boolean
    accountId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkflowDefinitionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    steps?: boolean | WorkflowDefinition$stepsArgs<ExtArgs>
    instances?: boolean | WorkflowDefinition$instancesArgs<ExtArgs>
    templates?: boolean | WorkflowDefinition$templatesArgs<ExtArgs>
    _count?: boolean | WorkflowDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkflowDefinitionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WorkflowDefinitionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkflowDefinition"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      steps: Prisma.$WorkflowStepPayload<ExtArgs>[]
      instances: Prisma.$WorkflowInstancePayload<ExtArgs>[]
      templates: Prisma.$WorkflowTemplatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      version: number
      isActive: boolean
      triggerType: $Enums.WorkflowTriggerType
      triggerConditions: Prisma.JsonValue
      accountId: string
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workflowDefinition"]>
    composites: {}
  }

  type WorkflowDefinitionGetPayload<S extends boolean | null | undefined | WorkflowDefinitionDefaultArgs> = $Result.GetResult<Prisma.$WorkflowDefinitionPayload, S>

  type WorkflowDefinitionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkflowDefinitionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkflowDefinitionCountAggregateInputType | true
    }

  export interface WorkflowDefinitionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkflowDefinition'], meta: { name: 'WorkflowDefinition' } }
    /**
     * Find zero or one WorkflowDefinition that matches the filter.
     * @param {WorkflowDefinitionFindUniqueArgs} args - Arguments to find a WorkflowDefinition
     * @example
     * // Get one WorkflowDefinition
     * const workflowDefinition = await prisma.workflowDefinition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowDefinitionFindUniqueArgs>(args: SelectSubset<T, WorkflowDefinitionFindUniqueArgs<ExtArgs>>): Prisma__WorkflowDefinitionClient<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkflowDefinition that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkflowDefinitionFindUniqueOrThrowArgs} args - Arguments to find a WorkflowDefinition
     * @example
     * // Get one WorkflowDefinition
     * const workflowDefinition = await prisma.workflowDefinition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowDefinitionFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowDefinitionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowDefinitionClient<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkflowDefinition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowDefinitionFindFirstArgs} args - Arguments to find a WorkflowDefinition
     * @example
     * // Get one WorkflowDefinition
     * const workflowDefinition = await prisma.workflowDefinition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowDefinitionFindFirstArgs>(args?: SelectSubset<T, WorkflowDefinitionFindFirstArgs<ExtArgs>>): Prisma__WorkflowDefinitionClient<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkflowDefinition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowDefinitionFindFirstOrThrowArgs} args - Arguments to find a WorkflowDefinition
     * @example
     * // Get one WorkflowDefinition
     * const workflowDefinition = await prisma.workflowDefinition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowDefinitionFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowDefinitionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowDefinitionClient<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkflowDefinitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowDefinitionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowDefinitions
     * const workflowDefinitions = await prisma.workflowDefinition.findMany()
     * 
     * // Get first 10 WorkflowDefinitions
     * const workflowDefinitions = await prisma.workflowDefinition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowDefinitionWithIdOnly = await prisma.workflowDefinition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowDefinitionFindManyArgs>(args?: SelectSubset<T, WorkflowDefinitionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkflowDefinition.
     * @param {WorkflowDefinitionCreateArgs} args - Arguments to create a WorkflowDefinition.
     * @example
     * // Create one WorkflowDefinition
     * const WorkflowDefinition = await prisma.workflowDefinition.create({
     *   data: {
     *     // ... data to create a WorkflowDefinition
     *   }
     * })
     * 
     */
    create<T extends WorkflowDefinitionCreateArgs>(args: SelectSubset<T, WorkflowDefinitionCreateArgs<ExtArgs>>): Prisma__WorkflowDefinitionClient<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkflowDefinitions.
     * @param {WorkflowDefinitionCreateManyArgs} args - Arguments to create many WorkflowDefinitions.
     * @example
     * // Create many WorkflowDefinitions
     * const workflowDefinition = await prisma.workflowDefinition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowDefinitionCreateManyArgs>(args?: SelectSubset<T, WorkflowDefinitionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkflowDefinitions and returns the data saved in the database.
     * @param {WorkflowDefinitionCreateManyAndReturnArgs} args - Arguments to create many WorkflowDefinitions.
     * @example
     * // Create many WorkflowDefinitions
     * const workflowDefinition = await prisma.workflowDefinition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkflowDefinitions and only return the `id`
     * const workflowDefinitionWithIdOnly = await prisma.workflowDefinition.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowDefinitionCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowDefinitionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkflowDefinition.
     * @param {WorkflowDefinitionDeleteArgs} args - Arguments to delete one WorkflowDefinition.
     * @example
     * // Delete one WorkflowDefinition
     * const WorkflowDefinition = await prisma.workflowDefinition.delete({
     *   where: {
     *     // ... filter to delete one WorkflowDefinition
     *   }
     * })
     * 
     */
    delete<T extends WorkflowDefinitionDeleteArgs>(args: SelectSubset<T, WorkflowDefinitionDeleteArgs<ExtArgs>>): Prisma__WorkflowDefinitionClient<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkflowDefinition.
     * @param {WorkflowDefinitionUpdateArgs} args - Arguments to update one WorkflowDefinition.
     * @example
     * // Update one WorkflowDefinition
     * const workflowDefinition = await prisma.workflowDefinition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowDefinitionUpdateArgs>(args: SelectSubset<T, WorkflowDefinitionUpdateArgs<ExtArgs>>): Prisma__WorkflowDefinitionClient<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkflowDefinitions.
     * @param {WorkflowDefinitionDeleteManyArgs} args - Arguments to filter WorkflowDefinitions to delete.
     * @example
     * // Delete a few WorkflowDefinitions
     * const { count } = await prisma.workflowDefinition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowDefinitionDeleteManyArgs>(args?: SelectSubset<T, WorkflowDefinitionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowDefinitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowDefinitions
     * const workflowDefinition = await prisma.workflowDefinition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowDefinitionUpdateManyArgs>(args: SelectSubset<T, WorkflowDefinitionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkflowDefinition.
     * @param {WorkflowDefinitionUpsertArgs} args - Arguments to update or create a WorkflowDefinition.
     * @example
     * // Update or create a WorkflowDefinition
     * const workflowDefinition = await prisma.workflowDefinition.upsert({
     *   create: {
     *     // ... data to create a WorkflowDefinition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowDefinition we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowDefinitionUpsertArgs>(args: SelectSubset<T, WorkflowDefinitionUpsertArgs<ExtArgs>>): Prisma__WorkflowDefinitionClient<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkflowDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowDefinitionCountArgs} args - Arguments to filter WorkflowDefinitions to count.
     * @example
     * // Count the number of WorkflowDefinitions
     * const count = await prisma.workflowDefinition.count({
     *   where: {
     *     // ... the filter for the WorkflowDefinitions we want to count
     *   }
     * })
    **/
    count<T extends WorkflowDefinitionCountArgs>(
      args?: Subset<T, WorkflowDefinitionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowDefinitionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkflowDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowDefinitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowDefinitionAggregateArgs>(args: Subset<T, WorkflowDefinitionAggregateArgs>): Prisma.PrismaPromise<GetWorkflowDefinitionAggregateType<T>>

    /**
     * Group by WorkflowDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowDefinitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowDefinitionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowDefinitionGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowDefinitionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowDefinitionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowDefinitionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkflowDefinition model
   */
  readonly fields: WorkflowDefinitionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowDefinition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowDefinitionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    steps<T extends WorkflowDefinition$stepsArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowDefinition$stepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findMany"> | Null>
    instances<T extends WorkflowDefinition$instancesArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowDefinition$instancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "findMany"> | Null>
    templates<T extends WorkflowDefinition$templatesArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowDefinition$templatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkflowDefinition model
   */ 
  interface WorkflowDefinitionFieldRefs {
    readonly id: FieldRef<"WorkflowDefinition", 'String'>
    readonly name: FieldRef<"WorkflowDefinition", 'String'>
    readonly description: FieldRef<"WorkflowDefinition", 'String'>
    readonly version: FieldRef<"WorkflowDefinition", 'Int'>
    readonly isActive: FieldRef<"WorkflowDefinition", 'Boolean'>
    readonly triggerType: FieldRef<"WorkflowDefinition", 'WorkflowTriggerType'>
    readonly triggerConditions: FieldRef<"WorkflowDefinition", 'Json'>
    readonly accountId: FieldRef<"WorkflowDefinition", 'String'>
    readonly createdById: FieldRef<"WorkflowDefinition", 'String'>
    readonly createdAt: FieldRef<"WorkflowDefinition", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkflowDefinition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkflowDefinition findUnique
   */
  export type WorkflowDefinitionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinition
     */
    select?: WorkflowDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowDefinition to fetch.
     */
    where: WorkflowDefinitionWhereUniqueInput
  }

  /**
   * WorkflowDefinition findUniqueOrThrow
   */
  export type WorkflowDefinitionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinition
     */
    select?: WorkflowDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowDefinition to fetch.
     */
    where: WorkflowDefinitionWhereUniqueInput
  }

  /**
   * WorkflowDefinition findFirst
   */
  export type WorkflowDefinitionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinition
     */
    select?: WorkflowDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowDefinition to fetch.
     */
    where?: WorkflowDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowDefinitions to fetch.
     */
    orderBy?: WorkflowDefinitionOrderByWithRelationInput | WorkflowDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowDefinitions.
     */
    cursor?: WorkflowDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowDefinitions.
     */
    distinct?: WorkflowDefinitionScalarFieldEnum | WorkflowDefinitionScalarFieldEnum[]
  }

  /**
   * WorkflowDefinition findFirstOrThrow
   */
  export type WorkflowDefinitionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinition
     */
    select?: WorkflowDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowDefinition to fetch.
     */
    where?: WorkflowDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowDefinitions to fetch.
     */
    orderBy?: WorkflowDefinitionOrderByWithRelationInput | WorkflowDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowDefinitions.
     */
    cursor?: WorkflowDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowDefinitions.
     */
    distinct?: WorkflowDefinitionScalarFieldEnum | WorkflowDefinitionScalarFieldEnum[]
  }

  /**
   * WorkflowDefinition findMany
   */
  export type WorkflowDefinitionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinition
     */
    select?: WorkflowDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowDefinitions to fetch.
     */
    where?: WorkflowDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowDefinitions to fetch.
     */
    orderBy?: WorkflowDefinitionOrderByWithRelationInput | WorkflowDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkflowDefinitions.
     */
    cursor?: WorkflowDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowDefinitions.
     */
    skip?: number
    distinct?: WorkflowDefinitionScalarFieldEnum | WorkflowDefinitionScalarFieldEnum[]
  }

  /**
   * WorkflowDefinition create
   */
  export type WorkflowDefinitionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinition
     */
    select?: WorkflowDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkflowDefinition.
     */
    data: XOR<WorkflowDefinitionCreateInput, WorkflowDefinitionUncheckedCreateInput>
  }

  /**
   * WorkflowDefinition createMany
   */
  export type WorkflowDefinitionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkflowDefinitions.
     */
    data: WorkflowDefinitionCreateManyInput | WorkflowDefinitionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkflowDefinition createManyAndReturn
   */
  export type WorkflowDefinitionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinition
     */
    select?: WorkflowDefinitionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkflowDefinitions.
     */
    data: WorkflowDefinitionCreateManyInput | WorkflowDefinitionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowDefinitionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkflowDefinition update
   */
  export type WorkflowDefinitionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinition
     */
    select?: WorkflowDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkflowDefinition.
     */
    data: XOR<WorkflowDefinitionUpdateInput, WorkflowDefinitionUncheckedUpdateInput>
    /**
     * Choose, which WorkflowDefinition to update.
     */
    where: WorkflowDefinitionWhereUniqueInput
  }

  /**
   * WorkflowDefinition updateMany
   */
  export type WorkflowDefinitionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkflowDefinitions.
     */
    data: XOR<WorkflowDefinitionUpdateManyMutationInput, WorkflowDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowDefinitions to update
     */
    where?: WorkflowDefinitionWhereInput
  }

  /**
   * WorkflowDefinition upsert
   */
  export type WorkflowDefinitionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinition
     */
    select?: WorkflowDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowDefinitionInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkflowDefinition to update in case it exists.
     */
    where: WorkflowDefinitionWhereUniqueInput
    /**
     * In case the WorkflowDefinition found by the `where` argument doesn't exist, create a new WorkflowDefinition with this data.
     */
    create: XOR<WorkflowDefinitionCreateInput, WorkflowDefinitionUncheckedCreateInput>
    /**
     * In case the WorkflowDefinition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowDefinitionUpdateInput, WorkflowDefinitionUncheckedUpdateInput>
  }

  /**
   * WorkflowDefinition delete
   */
  export type WorkflowDefinitionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinition
     */
    select?: WorkflowDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowDefinitionInclude<ExtArgs> | null
    /**
     * Filter which WorkflowDefinition to delete.
     */
    where: WorkflowDefinitionWhereUniqueInput
  }

  /**
   * WorkflowDefinition deleteMany
   */
  export type WorkflowDefinitionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowDefinitions to delete
     */
    where?: WorkflowDefinitionWhereInput
  }

  /**
   * WorkflowDefinition.steps
   */
  export type WorkflowDefinition$stepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    where?: WorkflowStepWhereInput
    orderBy?: WorkflowStepOrderByWithRelationInput | WorkflowStepOrderByWithRelationInput[]
    cursor?: WorkflowStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowStepScalarFieldEnum | WorkflowStepScalarFieldEnum[]
  }

  /**
   * WorkflowDefinition.instances
   */
  export type WorkflowDefinition$instancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
    where?: WorkflowInstanceWhereInput
    orderBy?: WorkflowInstanceOrderByWithRelationInput | WorkflowInstanceOrderByWithRelationInput[]
    cursor?: WorkflowInstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowInstanceScalarFieldEnum | WorkflowInstanceScalarFieldEnum[]
  }

  /**
   * WorkflowDefinition.templates
   */
  export type WorkflowDefinition$templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTemplateInclude<ExtArgs> | null
    where?: WorkflowTemplateWhereInput
    orderBy?: WorkflowTemplateOrderByWithRelationInput | WorkflowTemplateOrderByWithRelationInput[]
    cursor?: WorkflowTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowTemplateScalarFieldEnum | WorkflowTemplateScalarFieldEnum[]
  }

  /**
   * WorkflowDefinition without action
   */
  export type WorkflowDefinitionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinition
     */
    select?: WorkflowDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowDefinitionInclude<ExtArgs> | null
  }


  /**
   * Model WorkflowStep
   */

  export type AggregateWorkflowStep = {
    _count: WorkflowStepCountAggregateOutputType | null
    _avg: WorkflowStepAvgAggregateOutputType | null
    _sum: WorkflowStepSumAggregateOutputType | null
    _min: WorkflowStepMinAggregateOutputType | null
    _max: WorkflowStepMaxAggregateOutputType | null
  }

  export type WorkflowStepAvgAggregateOutputType = {
    position: number | null
    timeoutMinutes: number | null
  }

  export type WorkflowStepSumAggregateOutputType = {
    position: number | null
    timeoutMinutes: number | null
  }

  export type WorkflowStepMinAggregateOutputType = {
    id: string | null
    workflowId: string | null
    name: string | null
    description: string | null
    stepType: $Enums.WorkflowStepType | null
    position: number | null
    isRequired: boolean | null
    timeoutMinutes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowStepMaxAggregateOutputType = {
    id: string | null
    workflowId: string | null
    name: string | null
    description: string | null
    stepType: $Enums.WorkflowStepType | null
    position: number | null
    isRequired: boolean | null
    timeoutMinutes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowStepCountAggregateOutputType = {
    id: number
    workflowId: number
    name: number
    description: number
    stepType: number
    position: number
    configuration: number
    conditions: number
    isRequired: number
    timeoutMinutes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkflowStepAvgAggregateInputType = {
    position?: true
    timeoutMinutes?: true
  }

  export type WorkflowStepSumAggregateInputType = {
    position?: true
    timeoutMinutes?: true
  }

  export type WorkflowStepMinAggregateInputType = {
    id?: true
    workflowId?: true
    name?: true
    description?: true
    stepType?: true
    position?: true
    isRequired?: true
    timeoutMinutes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowStepMaxAggregateInputType = {
    id?: true
    workflowId?: true
    name?: true
    description?: true
    stepType?: true
    position?: true
    isRequired?: true
    timeoutMinutes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowStepCountAggregateInputType = {
    id?: true
    workflowId?: true
    name?: true
    description?: true
    stepType?: true
    position?: true
    configuration?: true
    conditions?: true
    isRequired?: true
    timeoutMinutes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkflowStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowStep to aggregate.
     */
    where?: WorkflowStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowSteps to fetch.
     */
    orderBy?: WorkflowStepOrderByWithRelationInput | WorkflowStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkflowSteps
    **/
    _count?: true | WorkflowStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkflowStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkflowStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowStepMaxAggregateInputType
  }

  export type GetWorkflowStepAggregateType<T extends WorkflowStepAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflowStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowStep[P]>
      : GetScalarType<T[P], AggregateWorkflowStep[P]>
  }




  export type WorkflowStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowStepWhereInput
    orderBy?: WorkflowStepOrderByWithAggregationInput | WorkflowStepOrderByWithAggregationInput[]
    by: WorkflowStepScalarFieldEnum[] | WorkflowStepScalarFieldEnum
    having?: WorkflowStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowStepCountAggregateInputType | true
    _avg?: WorkflowStepAvgAggregateInputType
    _sum?: WorkflowStepSumAggregateInputType
    _min?: WorkflowStepMinAggregateInputType
    _max?: WorkflowStepMaxAggregateInputType
  }

  export type WorkflowStepGroupByOutputType = {
    id: string
    workflowId: string
    name: string
    description: string | null
    stepType: $Enums.WorkflowStepType
    position: number
    configuration: JsonValue
    conditions: JsonValue | null
    isRequired: boolean
    timeoutMinutes: number | null
    createdAt: Date
    updatedAt: Date
    _count: WorkflowStepCountAggregateOutputType | null
    _avg: WorkflowStepAvgAggregateOutputType | null
    _sum: WorkflowStepSumAggregateOutputType | null
    _min: WorkflowStepMinAggregateOutputType | null
    _max: WorkflowStepMaxAggregateOutputType | null
  }

  type GetWorkflowStepGroupByPayload<T extends WorkflowStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowStepGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowStepGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    name?: boolean
    description?: boolean
    stepType?: boolean
    position?: boolean
    configuration?: boolean
    conditions?: boolean
    isRequired?: boolean
    timeoutMinutes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workflow?: boolean | WorkflowDefinitionDefaultArgs<ExtArgs>
    executions?: boolean | WorkflowStep$executionsArgs<ExtArgs>
    approvers?: boolean | WorkflowStep$approversArgs<ExtArgs>
    _count?: boolean | WorkflowStepCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowStep"]>

  export type WorkflowStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    name?: boolean
    description?: boolean
    stepType?: boolean
    position?: boolean
    configuration?: boolean
    conditions?: boolean
    isRequired?: boolean
    timeoutMinutes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workflow?: boolean | WorkflowDefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowStep"]>

  export type WorkflowStepSelectScalar = {
    id?: boolean
    workflowId?: boolean
    name?: boolean
    description?: boolean
    stepType?: boolean
    position?: boolean
    configuration?: boolean
    conditions?: boolean
    isRequired?: boolean
    timeoutMinutes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkflowStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefinitionDefaultArgs<ExtArgs>
    executions?: boolean | WorkflowStep$executionsArgs<ExtArgs>
    approvers?: boolean | WorkflowStep$approversArgs<ExtArgs>
    _count?: boolean | WorkflowStepCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkflowStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefinitionDefaultArgs<ExtArgs>
  }

  export type $WorkflowStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkflowStep"
    objects: {
      workflow: Prisma.$WorkflowDefinitionPayload<ExtArgs>
      executions: Prisma.$WorkflowStepExecutionPayload<ExtArgs>[]
      approvers: Prisma.$WorkflowStepApproverPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workflowId: string
      name: string
      description: string | null
      stepType: $Enums.WorkflowStepType
      position: number
      configuration: Prisma.JsonValue
      conditions: Prisma.JsonValue | null
      isRequired: boolean
      timeoutMinutes: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workflowStep"]>
    composites: {}
  }

  type WorkflowStepGetPayload<S extends boolean | null | undefined | WorkflowStepDefaultArgs> = $Result.GetResult<Prisma.$WorkflowStepPayload, S>

  type WorkflowStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkflowStepFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkflowStepCountAggregateInputType | true
    }

  export interface WorkflowStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkflowStep'], meta: { name: 'WorkflowStep' } }
    /**
     * Find zero or one WorkflowStep that matches the filter.
     * @param {WorkflowStepFindUniqueArgs} args - Arguments to find a WorkflowStep
     * @example
     * // Get one WorkflowStep
     * const workflowStep = await prisma.workflowStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowStepFindUniqueArgs>(args: SelectSubset<T, WorkflowStepFindUniqueArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkflowStep that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkflowStepFindUniqueOrThrowArgs} args - Arguments to find a WorkflowStep
     * @example
     * // Get one WorkflowStep
     * const workflowStep = await prisma.workflowStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowStepFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkflowStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepFindFirstArgs} args - Arguments to find a WorkflowStep
     * @example
     * // Get one WorkflowStep
     * const workflowStep = await prisma.workflowStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowStepFindFirstArgs>(args?: SelectSubset<T, WorkflowStepFindFirstArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkflowStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepFindFirstOrThrowArgs} args - Arguments to find a WorkflowStep
     * @example
     * // Get one WorkflowStep
     * const workflowStep = await prisma.workflowStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowStepFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkflowSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowSteps
     * const workflowSteps = await prisma.workflowStep.findMany()
     * 
     * // Get first 10 WorkflowSteps
     * const workflowSteps = await prisma.workflowStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowStepWithIdOnly = await prisma.workflowStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowStepFindManyArgs>(args?: SelectSubset<T, WorkflowStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkflowStep.
     * @param {WorkflowStepCreateArgs} args - Arguments to create a WorkflowStep.
     * @example
     * // Create one WorkflowStep
     * const WorkflowStep = await prisma.workflowStep.create({
     *   data: {
     *     // ... data to create a WorkflowStep
     *   }
     * })
     * 
     */
    create<T extends WorkflowStepCreateArgs>(args: SelectSubset<T, WorkflowStepCreateArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkflowSteps.
     * @param {WorkflowStepCreateManyArgs} args - Arguments to create many WorkflowSteps.
     * @example
     * // Create many WorkflowSteps
     * const workflowStep = await prisma.workflowStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowStepCreateManyArgs>(args?: SelectSubset<T, WorkflowStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkflowSteps and returns the data saved in the database.
     * @param {WorkflowStepCreateManyAndReturnArgs} args - Arguments to create many WorkflowSteps.
     * @example
     * // Create many WorkflowSteps
     * const workflowStep = await prisma.workflowStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkflowSteps and only return the `id`
     * const workflowStepWithIdOnly = await prisma.workflowStep.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowStepCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkflowStep.
     * @param {WorkflowStepDeleteArgs} args - Arguments to delete one WorkflowStep.
     * @example
     * // Delete one WorkflowStep
     * const WorkflowStep = await prisma.workflowStep.delete({
     *   where: {
     *     // ... filter to delete one WorkflowStep
     *   }
     * })
     * 
     */
    delete<T extends WorkflowStepDeleteArgs>(args: SelectSubset<T, WorkflowStepDeleteArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkflowStep.
     * @param {WorkflowStepUpdateArgs} args - Arguments to update one WorkflowStep.
     * @example
     * // Update one WorkflowStep
     * const workflowStep = await prisma.workflowStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowStepUpdateArgs>(args: SelectSubset<T, WorkflowStepUpdateArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkflowSteps.
     * @param {WorkflowStepDeleteManyArgs} args - Arguments to filter WorkflowSteps to delete.
     * @example
     * // Delete a few WorkflowSteps
     * const { count } = await prisma.workflowStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowStepDeleteManyArgs>(args?: SelectSubset<T, WorkflowStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowSteps
     * const workflowStep = await prisma.workflowStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowStepUpdateManyArgs>(args: SelectSubset<T, WorkflowStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkflowStep.
     * @param {WorkflowStepUpsertArgs} args - Arguments to update or create a WorkflowStep.
     * @example
     * // Update or create a WorkflowStep
     * const workflowStep = await prisma.workflowStep.upsert({
     *   create: {
     *     // ... data to create a WorkflowStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowStep we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowStepUpsertArgs>(args: SelectSubset<T, WorkflowStepUpsertArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkflowSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepCountArgs} args - Arguments to filter WorkflowSteps to count.
     * @example
     * // Count the number of WorkflowSteps
     * const count = await prisma.workflowStep.count({
     *   where: {
     *     // ... the filter for the WorkflowSteps we want to count
     *   }
     * })
    **/
    count<T extends WorkflowStepCountArgs>(
      args?: Subset<T, WorkflowStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkflowStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowStepAggregateArgs>(args: Subset<T, WorkflowStepAggregateArgs>): Prisma.PrismaPromise<GetWorkflowStepAggregateType<T>>

    /**
     * Group by WorkflowStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowStepGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkflowStep model
   */
  readonly fields: WorkflowStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workflow<T extends WorkflowDefinitionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowDefinitionDefaultArgs<ExtArgs>>): Prisma__WorkflowDefinitionClient<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    executions<T extends WorkflowStep$executionsArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowStep$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowStepExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    approvers<T extends WorkflowStep$approversArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowStep$approversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowStepApproverPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkflowStep model
   */ 
  interface WorkflowStepFieldRefs {
    readonly id: FieldRef<"WorkflowStep", 'String'>
    readonly workflowId: FieldRef<"WorkflowStep", 'String'>
    readonly name: FieldRef<"WorkflowStep", 'String'>
    readonly description: FieldRef<"WorkflowStep", 'String'>
    readonly stepType: FieldRef<"WorkflowStep", 'WorkflowStepType'>
    readonly position: FieldRef<"WorkflowStep", 'Int'>
    readonly configuration: FieldRef<"WorkflowStep", 'Json'>
    readonly conditions: FieldRef<"WorkflowStep", 'Json'>
    readonly isRequired: FieldRef<"WorkflowStep", 'Boolean'>
    readonly timeoutMinutes: FieldRef<"WorkflowStep", 'Int'>
    readonly createdAt: FieldRef<"WorkflowStep", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkflowStep", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkflowStep findUnique
   */
  export type WorkflowStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStep to fetch.
     */
    where: WorkflowStepWhereUniqueInput
  }

  /**
   * WorkflowStep findUniqueOrThrow
   */
  export type WorkflowStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStep to fetch.
     */
    where: WorkflowStepWhereUniqueInput
  }

  /**
   * WorkflowStep findFirst
   */
  export type WorkflowStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStep to fetch.
     */
    where?: WorkflowStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowSteps to fetch.
     */
    orderBy?: WorkflowStepOrderByWithRelationInput | WorkflowStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowSteps.
     */
    cursor?: WorkflowStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowSteps.
     */
    distinct?: WorkflowStepScalarFieldEnum | WorkflowStepScalarFieldEnum[]
  }

  /**
   * WorkflowStep findFirstOrThrow
   */
  export type WorkflowStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStep to fetch.
     */
    where?: WorkflowStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowSteps to fetch.
     */
    orderBy?: WorkflowStepOrderByWithRelationInput | WorkflowStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowSteps.
     */
    cursor?: WorkflowStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowSteps.
     */
    distinct?: WorkflowStepScalarFieldEnum | WorkflowStepScalarFieldEnum[]
  }

  /**
   * WorkflowStep findMany
   */
  export type WorkflowStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowSteps to fetch.
     */
    where?: WorkflowStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowSteps to fetch.
     */
    orderBy?: WorkflowStepOrderByWithRelationInput | WorkflowStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkflowSteps.
     */
    cursor?: WorkflowStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowSteps.
     */
    skip?: number
    distinct?: WorkflowStepScalarFieldEnum | WorkflowStepScalarFieldEnum[]
  }

  /**
   * WorkflowStep create
   */
  export type WorkflowStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkflowStep.
     */
    data: XOR<WorkflowStepCreateInput, WorkflowStepUncheckedCreateInput>
  }

  /**
   * WorkflowStep createMany
   */
  export type WorkflowStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkflowSteps.
     */
    data: WorkflowStepCreateManyInput | WorkflowStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkflowStep createManyAndReturn
   */
  export type WorkflowStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkflowSteps.
     */
    data: WorkflowStepCreateManyInput | WorkflowStepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkflowStep update
   */
  export type WorkflowStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkflowStep.
     */
    data: XOR<WorkflowStepUpdateInput, WorkflowStepUncheckedUpdateInput>
    /**
     * Choose, which WorkflowStep to update.
     */
    where: WorkflowStepWhereUniqueInput
  }

  /**
   * WorkflowStep updateMany
   */
  export type WorkflowStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkflowSteps.
     */
    data: XOR<WorkflowStepUpdateManyMutationInput, WorkflowStepUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowSteps to update
     */
    where?: WorkflowStepWhereInput
  }

  /**
   * WorkflowStep upsert
   */
  export type WorkflowStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkflowStep to update in case it exists.
     */
    where: WorkflowStepWhereUniqueInput
    /**
     * In case the WorkflowStep found by the `where` argument doesn't exist, create a new WorkflowStep with this data.
     */
    create: XOR<WorkflowStepCreateInput, WorkflowStepUncheckedCreateInput>
    /**
     * In case the WorkflowStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowStepUpdateInput, WorkflowStepUncheckedUpdateInput>
  }

  /**
   * WorkflowStep delete
   */
  export type WorkflowStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * Filter which WorkflowStep to delete.
     */
    where: WorkflowStepWhereUniqueInput
  }

  /**
   * WorkflowStep deleteMany
   */
  export type WorkflowStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowSteps to delete
     */
    where?: WorkflowStepWhereInput
  }

  /**
   * WorkflowStep.executions
   */
  export type WorkflowStep$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionInclude<ExtArgs> | null
    where?: WorkflowStepExecutionWhereInput
    orderBy?: WorkflowStepExecutionOrderByWithRelationInput | WorkflowStepExecutionOrderByWithRelationInput[]
    cursor?: WorkflowStepExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowStepExecutionScalarFieldEnum | WorkflowStepExecutionScalarFieldEnum[]
  }

  /**
   * WorkflowStep.approvers
   */
  export type WorkflowStep$approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepApprover
     */
    select?: WorkflowStepApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepApproverInclude<ExtArgs> | null
    where?: WorkflowStepApproverWhereInput
    orderBy?: WorkflowStepApproverOrderByWithRelationInput | WorkflowStepApproverOrderByWithRelationInput[]
    cursor?: WorkflowStepApproverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowStepApproverScalarFieldEnum | WorkflowStepApproverScalarFieldEnum[]
  }

  /**
   * WorkflowStep without action
   */
  export type WorkflowStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
  }


  /**
   * Model WorkflowStepApprover
   */

  export type AggregateWorkflowStepApprover = {
    _count: WorkflowStepApproverCountAggregateOutputType | null
    _avg: WorkflowStepApproverAvgAggregateOutputType | null
    _sum: WorkflowStepApproverSumAggregateOutputType | null
    _min: WorkflowStepApproverMinAggregateOutputType | null
    _max: WorkflowStepApproverMaxAggregateOutputType | null
  }

  export type WorkflowStepApproverAvgAggregateOutputType = {
    order: number | null
  }

  export type WorkflowStepApproverSumAggregateOutputType = {
    order: number | null
  }

  export type WorkflowStepApproverMinAggregateOutputType = {
    id: string | null
    stepId: string | null
    userId: string | null
    approverType: $Enums.ApproverType | null
    isRequired: boolean | null
    order: number | null
    createdAt: Date | null
  }

  export type WorkflowStepApproverMaxAggregateOutputType = {
    id: string | null
    stepId: string | null
    userId: string | null
    approverType: $Enums.ApproverType | null
    isRequired: boolean | null
    order: number | null
    createdAt: Date | null
  }

  export type WorkflowStepApproverCountAggregateOutputType = {
    id: number
    stepId: number
    userId: number
    approverType: number
    isRequired: number
    order: number
    createdAt: number
    _all: number
  }


  export type WorkflowStepApproverAvgAggregateInputType = {
    order?: true
  }

  export type WorkflowStepApproverSumAggregateInputType = {
    order?: true
  }

  export type WorkflowStepApproverMinAggregateInputType = {
    id?: true
    stepId?: true
    userId?: true
    approverType?: true
    isRequired?: true
    order?: true
    createdAt?: true
  }

  export type WorkflowStepApproverMaxAggregateInputType = {
    id?: true
    stepId?: true
    userId?: true
    approverType?: true
    isRequired?: true
    order?: true
    createdAt?: true
  }

  export type WorkflowStepApproverCountAggregateInputType = {
    id?: true
    stepId?: true
    userId?: true
    approverType?: true
    isRequired?: true
    order?: true
    createdAt?: true
    _all?: true
  }

  export type WorkflowStepApproverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowStepApprover to aggregate.
     */
    where?: WorkflowStepApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowStepApprovers to fetch.
     */
    orderBy?: WorkflowStepApproverOrderByWithRelationInput | WorkflowStepApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowStepApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowStepApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowStepApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkflowStepApprovers
    **/
    _count?: true | WorkflowStepApproverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkflowStepApproverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkflowStepApproverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowStepApproverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowStepApproverMaxAggregateInputType
  }

  export type GetWorkflowStepApproverAggregateType<T extends WorkflowStepApproverAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflowStepApprover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowStepApprover[P]>
      : GetScalarType<T[P], AggregateWorkflowStepApprover[P]>
  }




  export type WorkflowStepApproverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowStepApproverWhereInput
    orderBy?: WorkflowStepApproverOrderByWithAggregationInput | WorkflowStepApproverOrderByWithAggregationInput[]
    by: WorkflowStepApproverScalarFieldEnum[] | WorkflowStepApproverScalarFieldEnum
    having?: WorkflowStepApproverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowStepApproverCountAggregateInputType | true
    _avg?: WorkflowStepApproverAvgAggregateInputType
    _sum?: WorkflowStepApproverSumAggregateInputType
    _min?: WorkflowStepApproverMinAggregateInputType
    _max?: WorkflowStepApproverMaxAggregateInputType
  }

  export type WorkflowStepApproverGroupByOutputType = {
    id: string
    stepId: string
    userId: string
    approverType: $Enums.ApproverType
    isRequired: boolean
    order: number
    createdAt: Date
    _count: WorkflowStepApproverCountAggregateOutputType | null
    _avg: WorkflowStepApproverAvgAggregateOutputType | null
    _sum: WorkflowStepApproverSumAggregateOutputType | null
    _min: WorkflowStepApproverMinAggregateOutputType | null
    _max: WorkflowStepApproverMaxAggregateOutputType | null
  }

  type GetWorkflowStepApproverGroupByPayload<T extends WorkflowStepApproverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowStepApproverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowStepApproverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowStepApproverGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowStepApproverGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowStepApproverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stepId?: boolean
    userId?: boolean
    approverType?: boolean
    isRequired?: boolean
    order?: boolean
    createdAt?: boolean
    step?: boolean | WorkflowStepDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    approvals?: boolean | WorkflowStepApprover$approvalsArgs<ExtArgs>
    _count?: boolean | WorkflowStepApproverCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowStepApprover"]>

  export type WorkflowStepApproverSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stepId?: boolean
    userId?: boolean
    approverType?: boolean
    isRequired?: boolean
    order?: boolean
    createdAt?: boolean
    step?: boolean | WorkflowStepDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowStepApprover"]>

  export type WorkflowStepApproverSelectScalar = {
    id?: boolean
    stepId?: boolean
    userId?: boolean
    approverType?: boolean
    isRequired?: boolean
    order?: boolean
    createdAt?: boolean
  }

  export type WorkflowStepApproverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    step?: boolean | WorkflowStepDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    approvals?: boolean | WorkflowStepApprover$approvalsArgs<ExtArgs>
    _count?: boolean | WorkflowStepApproverCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkflowStepApproverIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    step?: boolean | WorkflowStepDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WorkflowStepApproverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkflowStepApprover"
    objects: {
      step: Prisma.$WorkflowStepPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      approvals: Prisma.$WorkflowApprovalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stepId: string
      userId: string
      approverType: $Enums.ApproverType
      isRequired: boolean
      order: number
      createdAt: Date
    }, ExtArgs["result"]["workflowStepApprover"]>
    composites: {}
  }

  type WorkflowStepApproverGetPayload<S extends boolean | null | undefined | WorkflowStepApproverDefaultArgs> = $Result.GetResult<Prisma.$WorkflowStepApproverPayload, S>

  type WorkflowStepApproverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkflowStepApproverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkflowStepApproverCountAggregateInputType | true
    }

  export interface WorkflowStepApproverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkflowStepApprover'], meta: { name: 'WorkflowStepApprover' } }
    /**
     * Find zero or one WorkflowStepApprover that matches the filter.
     * @param {WorkflowStepApproverFindUniqueArgs} args - Arguments to find a WorkflowStepApprover
     * @example
     * // Get one WorkflowStepApprover
     * const workflowStepApprover = await prisma.workflowStepApprover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowStepApproverFindUniqueArgs>(args: SelectSubset<T, WorkflowStepApproverFindUniqueArgs<ExtArgs>>): Prisma__WorkflowStepApproverClient<$Result.GetResult<Prisma.$WorkflowStepApproverPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkflowStepApprover that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkflowStepApproverFindUniqueOrThrowArgs} args - Arguments to find a WorkflowStepApprover
     * @example
     * // Get one WorkflowStepApprover
     * const workflowStepApprover = await prisma.workflowStepApprover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowStepApproverFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowStepApproverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowStepApproverClient<$Result.GetResult<Prisma.$WorkflowStepApproverPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkflowStepApprover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepApproverFindFirstArgs} args - Arguments to find a WorkflowStepApprover
     * @example
     * // Get one WorkflowStepApprover
     * const workflowStepApprover = await prisma.workflowStepApprover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowStepApproverFindFirstArgs>(args?: SelectSubset<T, WorkflowStepApproverFindFirstArgs<ExtArgs>>): Prisma__WorkflowStepApproverClient<$Result.GetResult<Prisma.$WorkflowStepApproverPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkflowStepApprover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepApproverFindFirstOrThrowArgs} args - Arguments to find a WorkflowStepApprover
     * @example
     * // Get one WorkflowStepApprover
     * const workflowStepApprover = await prisma.workflowStepApprover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowStepApproverFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowStepApproverFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowStepApproverClient<$Result.GetResult<Prisma.$WorkflowStepApproverPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkflowStepApprovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepApproverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowStepApprovers
     * const workflowStepApprovers = await prisma.workflowStepApprover.findMany()
     * 
     * // Get first 10 WorkflowStepApprovers
     * const workflowStepApprovers = await prisma.workflowStepApprover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowStepApproverWithIdOnly = await prisma.workflowStepApprover.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowStepApproverFindManyArgs>(args?: SelectSubset<T, WorkflowStepApproverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowStepApproverPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkflowStepApprover.
     * @param {WorkflowStepApproverCreateArgs} args - Arguments to create a WorkflowStepApprover.
     * @example
     * // Create one WorkflowStepApprover
     * const WorkflowStepApprover = await prisma.workflowStepApprover.create({
     *   data: {
     *     // ... data to create a WorkflowStepApprover
     *   }
     * })
     * 
     */
    create<T extends WorkflowStepApproverCreateArgs>(args: SelectSubset<T, WorkflowStepApproverCreateArgs<ExtArgs>>): Prisma__WorkflowStepApproverClient<$Result.GetResult<Prisma.$WorkflowStepApproverPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkflowStepApprovers.
     * @param {WorkflowStepApproverCreateManyArgs} args - Arguments to create many WorkflowStepApprovers.
     * @example
     * // Create many WorkflowStepApprovers
     * const workflowStepApprover = await prisma.workflowStepApprover.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowStepApproverCreateManyArgs>(args?: SelectSubset<T, WorkflowStepApproverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkflowStepApprovers and returns the data saved in the database.
     * @param {WorkflowStepApproverCreateManyAndReturnArgs} args - Arguments to create many WorkflowStepApprovers.
     * @example
     * // Create many WorkflowStepApprovers
     * const workflowStepApprover = await prisma.workflowStepApprover.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkflowStepApprovers and only return the `id`
     * const workflowStepApproverWithIdOnly = await prisma.workflowStepApprover.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowStepApproverCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowStepApproverCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowStepApproverPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkflowStepApprover.
     * @param {WorkflowStepApproverDeleteArgs} args - Arguments to delete one WorkflowStepApprover.
     * @example
     * // Delete one WorkflowStepApprover
     * const WorkflowStepApprover = await prisma.workflowStepApprover.delete({
     *   where: {
     *     // ... filter to delete one WorkflowStepApprover
     *   }
     * })
     * 
     */
    delete<T extends WorkflowStepApproverDeleteArgs>(args: SelectSubset<T, WorkflowStepApproverDeleteArgs<ExtArgs>>): Prisma__WorkflowStepApproverClient<$Result.GetResult<Prisma.$WorkflowStepApproverPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkflowStepApprover.
     * @param {WorkflowStepApproverUpdateArgs} args - Arguments to update one WorkflowStepApprover.
     * @example
     * // Update one WorkflowStepApprover
     * const workflowStepApprover = await prisma.workflowStepApprover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowStepApproverUpdateArgs>(args: SelectSubset<T, WorkflowStepApproverUpdateArgs<ExtArgs>>): Prisma__WorkflowStepApproverClient<$Result.GetResult<Prisma.$WorkflowStepApproverPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkflowStepApprovers.
     * @param {WorkflowStepApproverDeleteManyArgs} args - Arguments to filter WorkflowStepApprovers to delete.
     * @example
     * // Delete a few WorkflowStepApprovers
     * const { count } = await prisma.workflowStepApprover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowStepApproverDeleteManyArgs>(args?: SelectSubset<T, WorkflowStepApproverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowStepApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepApproverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowStepApprovers
     * const workflowStepApprover = await prisma.workflowStepApprover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowStepApproverUpdateManyArgs>(args: SelectSubset<T, WorkflowStepApproverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkflowStepApprover.
     * @param {WorkflowStepApproverUpsertArgs} args - Arguments to update or create a WorkflowStepApprover.
     * @example
     * // Update or create a WorkflowStepApprover
     * const workflowStepApprover = await prisma.workflowStepApprover.upsert({
     *   create: {
     *     // ... data to create a WorkflowStepApprover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowStepApprover we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowStepApproverUpsertArgs>(args: SelectSubset<T, WorkflowStepApproverUpsertArgs<ExtArgs>>): Prisma__WorkflowStepApproverClient<$Result.GetResult<Prisma.$WorkflowStepApproverPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkflowStepApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepApproverCountArgs} args - Arguments to filter WorkflowStepApprovers to count.
     * @example
     * // Count the number of WorkflowStepApprovers
     * const count = await prisma.workflowStepApprover.count({
     *   where: {
     *     // ... the filter for the WorkflowStepApprovers we want to count
     *   }
     * })
    **/
    count<T extends WorkflowStepApproverCountArgs>(
      args?: Subset<T, WorkflowStepApproverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowStepApproverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkflowStepApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepApproverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowStepApproverAggregateArgs>(args: Subset<T, WorkflowStepApproverAggregateArgs>): Prisma.PrismaPromise<GetWorkflowStepApproverAggregateType<T>>

    /**
     * Group by WorkflowStepApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepApproverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowStepApproverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowStepApproverGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowStepApproverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowStepApproverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowStepApproverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkflowStepApprover model
   */
  readonly fields: WorkflowStepApproverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowStepApprover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowStepApproverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    step<T extends WorkflowStepDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowStepDefaultArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    approvals<T extends WorkflowStepApprover$approvalsArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowStepApprover$approvalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowApprovalPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkflowStepApprover model
   */ 
  interface WorkflowStepApproverFieldRefs {
    readonly id: FieldRef<"WorkflowStepApprover", 'String'>
    readonly stepId: FieldRef<"WorkflowStepApprover", 'String'>
    readonly userId: FieldRef<"WorkflowStepApprover", 'String'>
    readonly approverType: FieldRef<"WorkflowStepApprover", 'ApproverType'>
    readonly isRequired: FieldRef<"WorkflowStepApprover", 'Boolean'>
    readonly order: FieldRef<"WorkflowStepApprover", 'Int'>
    readonly createdAt: FieldRef<"WorkflowStepApprover", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkflowStepApprover findUnique
   */
  export type WorkflowStepApproverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepApprover
     */
    select?: WorkflowStepApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepApproverInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStepApprover to fetch.
     */
    where: WorkflowStepApproverWhereUniqueInput
  }

  /**
   * WorkflowStepApprover findUniqueOrThrow
   */
  export type WorkflowStepApproverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepApprover
     */
    select?: WorkflowStepApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepApproverInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStepApprover to fetch.
     */
    where: WorkflowStepApproverWhereUniqueInput
  }

  /**
   * WorkflowStepApprover findFirst
   */
  export type WorkflowStepApproverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepApprover
     */
    select?: WorkflowStepApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepApproverInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStepApprover to fetch.
     */
    where?: WorkflowStepApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowStepApprovers to fetch.
     */
    orderBy?: WorkflowStepApproverOrderByWithRelationInput | WorkflowStepApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowStepApprovers.
     */
    cursor?: WorkflowStepApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowStepApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowStepApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowStepApprovers.
     */
    distinct?: WorkflowStepApproverScalarFieldEnum | WorkflowStepApproverScalarFieldEnum[]
  }

  /**
   * WorkflowStepApprover findFirstOrThrow
   */
  export type WorkflowStepApproverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepApprover
     */
    select?: WorkflowStepApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepApproverInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStepApprover to fetch.
     */
    where?: WorkflowStepApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowStepApprovers to fetch.
     */
    orderBy?: WorkflowStepApproverOrderByWithRelationInput | WorkflowStepApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowStepApprovers.
     */
    cursor?: WorkflowStepApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowStepApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowStepApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowStepApprovers.
     */
    distinct?: WorkflowStepApproverScalarFieldEnum | WorkflowStepApproverScalarFieldEnum[]
  }

  /**
   * WorkflowStepApprover findMany
   */
  export type WorkflowStepApproverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepApprover
     */
    select?: WorkflowStepApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepApproverInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStepApprovers to fetch.
     */
    where?: WorkflowStepApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowStepApprovers to fetch.
     */
    orderBy?: WorkflowStepApproverOrderByWithRelationInput | WorkflowStepApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkflowStepApprovers.
     */
    cursor?: WorkflowStepApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowStepApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowStepApprovers.
     */
    skip?: number
    distinct?: WorkflowStepApproverScalarFieldEnum | WorkflowStepApproverScalarFieldEnum[]
  }

  /**
   * WorkflowStepApprover create
   */
  export type WorkflowStepApproverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepApprover
     */
    select?: WorkflowStepApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepApproverInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkflowStepApprover.
     */
    data: XOR<WorkflowStepApproverCreateInput, WorkflowStepApproverUncheckedCreateInput>
  }

  /**
   * WorkflowStepApprover createMany
   */
  export type WorkflowStepApproverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkflowStepApprovers.
     */
    data: WorkflowStepApproverCreateManyInput | WorkflowStepApproverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkflowStepApprover createManyAndReturn
   */
  export type WorkflowStepApproverCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepApprover
     */
    select?: WorkflowStepApproverSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkflowStepApprovers.
     */
    data: WorkflowStepApproverCreateManyInput | WorkflowStepApproverCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepApproverIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkflowStepApprover update
   */
  export type WorkflowStepApproverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepApprover
     */
    select?: WorkflowStepApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepApproverInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkflowStepApprover.
     */
    data: XOR<WorkflowStepApproverUpdateInput, WorkflowStepApproverUncheckedUpdateInput>
    /**
     * Choose, which WorkflowStepApprover to update.
     */
    where: WorkflowStepApproverWhereUniqueInput
  }

  /**
   * WorkflowStepApprover updateMany
   */
  export type WorkflowStepApproverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkflowStepApprovers.
     */
    data: XOR<WorkflowStepApproverUpdateManyMutationInput, WorkflowStepApproverUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowStepApprovers to update
     */
    where?: WorkflowStepApproverWhereInput
  }

  /**
   * WorkflowStepApprover upsert
   */
  export type WorkflowStepApproverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepApprover
     */
    select?: WorkflowStepApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepApproverInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkflowStepApprover to update in case it exists.
     */
    where: WorkflowStepApproverWhereUniqueInput
    /**
     * In case the WorkflowStepApprover found by the `where` argument doesn't exist, create a new WorkflowStepApprover with this data.
     */
    create: XOR<WorkflowStepApproverCreateInput, WorkflowStepApproverUncheckedCreateInput>
    /**
     * In case the WorkflowStepApprover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowStepApproverUpdateInput, WorkflowStepApproverUncheckedUpdateInput>
  }

  /**
   * WorkflowStepApprover delete
   */
  export type WorkflowStepApproverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepApprover
     */
    select?: WorkflowStepApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepApproverInclude<ExtArgs> | null
    /**
     * Filter which WorkflowStepApprover to delete.
     */
    where: WorkflowStepApproverWhereUniqueInput
  }

  /**
   * WorkflowStepApprover deleteMany
   */
  export type WorkflowStepApproverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowStepApprovers to delete
     */
    where?: WorkflowStepApproverWhereInput
  }

  /**
   * WorkflowStepApprover.approvals
   */
  export type WorkflowStepApprover$approvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowApproval
     */
    select?: WorkflowApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowApprovalInclude<ExtArgs> | null
    where?: WorkflowApprovalWhereInput
    orderBy?: WorkflowApprovalOrderByWithRelationInput | WorkflowApprovalOrderByWithRelationInput[]
    cursor?: WorkflowApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowApprovalScalarFieldEnum | WorkflowApprovalScalarFieldEnum[]
  }

  /**
   * WorkflowStepApprover without action
   */
  export type WorkflowStepApproverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepApprover
     */
    select?: WorkflowStepApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepApproverInclude<ExtArgs> | null
  }


  /**
   * Model WorkflowInstance
   */

  export type AggregateWorkflowInstance = {
    _count: WorkflowInstanceCountAggregateOutputType | null
    _min: WorkflowInstanceMinAggregateOutputType | null
    _max: WorkflowInstanceMaxAggregateOutputType | null
  }

  export type WorkflowInstanceMinAggregateOutputType = {
    id: string | null
    workflowId: string | null
    entityType: string | null
    entityId: string | null
    status: $Enums.WorkflowStatus | null
    currentStepId: string | null
    priority: $Enums.Priority | null
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    accountId: string | null
    initiatedById: string | null
  }

  export type WorkflowInstanceMaxAggregateOutputType = {
    id: string | null
    workflowId: string | null
    entityType: string | null
    entityId: string | null
    status: $Enums.WorkflowStatus | null
    currentStepId: string | null
    priority: $Enums.Priority | null
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    accountId: string | null
    initiatedById: string | null
  }

  export type WorkflowInstanceCountAggregateOutputType = {
    id: number
    workflowId: number
    entityType: number
    entityId: number
    status: number
    currentStepId: number
    priority: number
    startedAt: number
    completedAt: number
    errorMessage: number
    metadata: number
    accountId: number
    initiatedById: number
    _all: number
  }


  export type WorkflowInstanceMinAggregateInputType = {
    id?: true
    workflowId?: true
    entityType?: true
    entityId?: true
    status?: true
    currentStepId?: true
    priority?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    accountId?: true
    initiatedById?: true
  }

  export type WorkflowInstanceMaxAggregateInputType = {
    id?: true
    workflowId?: true
    entityType?: true
    entityId?: true
    status?: true
    currentStepId?: true
    priority?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    accountId?: true
    initiatedById?: true
  }

  export type WorkflowInstanceCountAggregateInputType = {
    id?: true
    workflowId?: true
    entityType?: true
    entityId?: true
    status?: true
    currentStepId?: true
    priority?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    metadata?: true
    accountId?: true
    initiatedById?: true
    _all?: true
  }

  export type WorkflowInstanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowInstance to aggregate.
     */
    where?: WorkflowInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowInstances to fetch.
     */
    orderBy?: WorkflowInstanceOrderByWithRelationInput | WorkflowInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkflowInstances
    **/
    _count?: true | WorkflowInstanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowInstanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowInstanceMaxAggregateInputType
  }

  export type GetWorkflowInstanceAggregateType<T extends WorkflowInstanceAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflowInstance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowInstance[P]>
      : GetScalarType<T[P], AggregateWorkflowInstance[P]>
  }




  export type WorkflowInstanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowInstanceWhereInput
    orderBy?: WorkflowInstanceOrderByWithAggregationInput | WorkflowInstanceOrderByWithAggregationInput[]
    by: WorkflowInstanceScalarFieldEnum[] | WorkflowInstanceScalarFieldEnum
    having?: WorkflowInstanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowInstanceCountAggregateInputType | true
    _min?: WorkflowInstanceMinAggregateInputType
    _max?: WorkflowInstanceMaxAggregateInputType
  }

  export type WorkflowInstanceGroupByOutputType = {
    id: string
    workflowId: string
    entityType: string
    entityId: string
    status: $Enums.WorkflowStatus
    currentStepId: string | null
    priority: $Enums.Priority
    startedAt: Date
    completedAt: Date | null
    errorMessage: string | null
    metadata: JsonValue | null
    accountId: string
    initiatedById: string
    _count: WorkflowInstanceCountAggregateOutputType | null
    _min: WorkflowInstanceMinAggregateOutputType | null
    _max: WorkflowInstanceMaxAggregateOutputType | null
  }

  type GetWorkflowInstanceGroupByPayload<T extends WorkflowInstanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowInstanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowInstanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowInstanceGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowInstanceGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowInstanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    entityType?: boolean
    entityId?: boolean
    status?: boolean
    currentStepId?: boolean
    priority?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    metadata?: boolean
    accountId?: boolean
    initiatedById?: boolean
    workflow?: boolean | WorkflowDefinitionDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    initiatedBy?: boolean | UserDefaultArgs<ExtArgs>
    executions?: boolean | WorkflowInstance$executionsArgs<ExtArgs>
    approvals?: boolean | WorkflowInstance$approvalsArgs<ExtArgs>
    _count?: boolean | WorkflowInstanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowInstance"]>

  export type WorkflowInstanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    entityType?: boolean
    entityId?: boolean
    status?: boolean
    currentStepId?: boolean
    priority?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    metadata?: boolean
    accountId?: boolean
    initiatedById?: boolean
    workflow?: boolean | WorkflowDefinitionDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    initiatedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowInstance"]>

  export type WorkflowInstanceSelectScalar = {
    id?: boolean
    workflowId?: boolean
    entityType?: boolean
    entityId?: boolean
    status?: boolean
    currentStepId?: boolean
    priority?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    metadata?: boolean
    accountId?: boolean
    initiatedById?: boolean
  }

  export type WorkflowInstanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefinitionDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    initiatedBy?: boolean | UserDefaultArgs<ExtArgs>
    executions?: boolean | WorkflowInstance$executionsArgs<ExtArgs>
    approvals?: boolean | WorkflowInstance$approvalsArgs<ExtArgs>
    _count?: boolean | WorkflowInstanceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkflowInstanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefinitionDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    initiatedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WorkflowInstancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkflowInstance"
    objects: {
      workflow: Prisma.$WorkflowDefinitionPayload<ExtArgs>
      account: Prisma.$AccountPayload<ExtArgs>
      initiatedBy: Prisma.$UserPayload<ExtArgs>
      executions: Prisma.$WorkflowStepExecutionPayload<ExtArgs>[]
      approvals: Prisma.$WorkflowApprovalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workflowId: string
      entityType: string
      entityId: string
      status: $Enums.WorkflowStatus
      currentStepId: string | null
      priority: $Enums.Priority
      startedAt: Date
      completedAt: Date | null
      errorMessage: string | null
      metadata: Prisma.JsonValue | null
      accountId: string
      initiatedById: string
    }, ExtArgs["result"]["workflowInstance"]>
    composites: {}
  }

  type WorkflowInstanceGetPayload<S extends boolean | null | undefined | WorkflowInstanceDefaultArgs> = $Result.GetResult<Prisma.$WorkflowInstancePayload, S>

  type WorkflowInstanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkflowInstanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkflowInstanceCountAggregateInputType | true
    }

  export interface WorkflowInstanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkflowInstance'], meta: { name: 'WorkflowInstance' } }
    /**
     * Find zero or one WorkflowInstance that matches the filter.
     * @param {WorkflowInstanceFindUniqueArgs} args - Arguments to find a WorkflowInstance
     * @example
     * // Get one WorkflowInstance
     * const workflowInstance = await prisma.workflowInstance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowInstanceFindUniqueArgs>(args: SelectSubset<T, WorkflowInstanceFindUniqueArgs<ExtArgs>>): Prisma__WorkflowInstanceClient<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkflowInstance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkflowInstanceFindUniqueOrThrowArgs} args - Arguments to find a WorkflowInstance
     * @example
     * // Get one WorkflowInstance
     * const workflowInstance = await prisma.workflowInstance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowInstanceFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowInstanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowInstanceClient<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkflowInstance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowInstanceFindFirstArgs} args - Arguments to find a WorkflowInstance
     * @example
     * // Get one WorkflowInstance
     * const workflowInstance = await prisma.workflowInstance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowInstanceFindFirstArgs>(args?: SelectSubset<T, WorkflowInstanceFindFirstArgs<ExtArgs>>): Prisma__WorkflowInstanceClient<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkflowInstance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowInstanceFindFirstOrThrowArgs} args - Arguments to find a WorkflowInstance
     * @example
     * // Get one WorkflowInstance
     * const workflowInstance = await prisma.workflowInstance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowInstanceFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowInstanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowInstanceClient<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkflowInstances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowInstanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowInstances
     * const workflowInstances = await prisma.workflowInstance.findMany()
     * 
     * // Get first 10 WorkflowInstances
     * const workflowInstances = await prisma.workflowInstance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowInstanceWithIdOnly = await prisma.workflowInstance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowInstanceFindManyArgs>(args?: SelectSubset<T, WorkflowInstanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkflowInstance.
     * @param {WorkflowInstanceCreateArgs} args - Arguments to create a WorkflowInstance.
     * @example
     * // Create one WorkflowInstance
     * const WorkflowInstance = await prisma.workflowInstance.create({
     *   data: {
     *     // ... data to create a WorkflowInstance
     *   }
     * })
     * 
     */
    create<T extends WorkflowInstanceCreateArgs>(args: SelectSubset<T, WorkflowInstanceCreateArgs<ExtArgs>>): Prisma__WorkflowInstanceClient<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkflowInstances.
     * @param {WorkflowInstanceCreateManyArgs} args - Arguments to create many WorkflowInstances.
     * @example
     * // Create many WorkflowInstances
     * const workflowInstance = await prisma.workflowInstance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowInstanceCreateManyArgs>(args?: SelectSubset<T, WorkflowInstanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkflowInstances and returns the data saved in the database.
     * @param {WorkflowInstanceCreateManyAndReturnArgs} args - Arguments to create many WorkflowInstances.
     * @example
     * // Create many WorkflowInstances
     * const workflowInstance = await prisma.workflowInstance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkflowInstances and only return the `id`
     * const workflowInstanceWithIdOnly = await prisma.workflowInstance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowInstanceCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowInstanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkflowInstance.
     * @param {WorkflowInstanceDeleteArgs} args - Arguments to delete one WorkflowInstance.
     * @example
     * // Delete one WorkflowInstance
     * const WorkflowInstance = await prisma.workflowInstance.delete({
     *   where: {
     *     // ... filter to delete one WorkflowInstance
     *   }
     * })
     * 
     */
    delete<T extends WorkflowInstanceDeleteArgs>(args: SelectSubset<T, WorkflowInstanceDeleteArgs<ExtArgs>>): Prisma__WorkflowInstanceClient<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkflowInstance.
     * @param {WorkflowInstanceUpdateArgs} args - Arguments to update one WorkflowInstance.
     * @example
     * // Update one WorkflowInstance
     * const workflowInstance = await prisma.workflowInstance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowInstanceUpdateArgs>(args: SelectSubset<T, WorkflowInstanceUpdateArgs<ExtArgs>>): Prisma__WorkflowInstanceClient<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkflowInstances.
     * @param {WorkflowInstanceDeleteManyArgs} args - Arguments to filter WorkflowInstances to delete.
     * @example
     * // Delete a few WorkflowInstances
     * const { count } = await prisma.workflowInstance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowInstanceDeleteManyArgs>(args?: SelectSubset<T, WorkflowInstanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowInstances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowInstanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowInstances
     * const workflowInstance = await prisma.workflowInstance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowInstanceUpdateManyArgs>(args: SelectSubset<T, WorkflowInstanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkflowInstance.
     * @param {WorkflowInstanceUpsertArgs} args - Arguments to update or create a WorkflowInstance.
     * @example
     * // Update or create a WorkflowInstance
     * const workflowInstance = await prisma.workflowInstance.upsert({
     *   create: {
     *     // ... data to create a WorkflowInstance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowInstance we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowInstanceUpsertArgs>(args: SelectSubset<T, WorkflowInstanceUpsertArgs<ExtArgs>>): Prisma__WorkflowInstanceClient<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkflowInstances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowInstanceCountArgs} args - Arguments to filter WorkflowInstances to count.
     * @example
     * // Count the number of WorkflowInstances
     * const count = await prisma.workflowInstance.count({
     *   where: {
     *     // ... the filter for the WorkflowInstances we want to count
     *   }
     * })
    **/
    count<T extends WorkflowInstanceCountArgs>(
      args?: Subset<T, WorkflowInstanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowInstanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkflowInstance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowInstanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowInstanceAggregateArgs>(args: Subset<T, WorkflowInstanceAggregateArgs>): Prisma.PrismaPromise<GetWorkflowInstanceAggregateType<T>>

    /**
     * Group by WorkflowInstance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowInstanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowInstanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowInstanceGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowInstanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowInstanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowInstanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkflowInstance model
   */
  readonly fields: WorkflowInstanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowInstance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowInstanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workflow<T extends WorkflowDefinitionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowDefinitionDefaultArgs<ExtArgs>>): Prisma__WorkflowDefinitionClient<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    initiatedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    executions<T extends WorkflowInstance$executionsArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowInstance$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowStepExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    approvals<T extends WorkflowInstance$approvalsArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowInstance$approvalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowApprovalPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkflowInstance model
   */ 
  interface WorkflowInstanceFieldRefs {
    readonly id: FieldRef<"WorkflowInstance", 'String'>
    readonly workflowId: FieldRef<"WorkflowInstance", 'String'>
    readonly entityType: FieldRef<"WorkflowInstance", 'String'>
    readonly entityId: FieldRef<"WorkflowInstance", 'String'>
    readonly status: FieldRef<"WorkflowInstance", 'WorkflowStatus'>
    readonly currentStepId: FieldRef<"WorkflowInstance", 'String'>
    readonly priority: FieldRef<"WorkflowInstance", 'Priority'>
    readonly startedAt: FieldRef<"WorkflowInstance", 'DateTime'>
    readonly completedAt: FieldRef<"WorkflowInstance", 'DateTime'>
    readonly errorMessage: FieldRef<"WorkflowInstance", 'String'>
    readonly metadata: FieldRef<"WorkflowInstance", 'Json'>
    readonly accountId: FieldRef<"WorkflowInstance", 'String'>
    readonly initiatedById: FieldRef<"WorkflowInstance", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkflowInstance findUnique
   */
  export type WorkflowInstanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowInstance to fetch.
     */
    where: WorkflowInstanceWhereUniqueInput
  }

  /**
   * WorkflowInstance findUniqueOrThrow
   */
  export type WorkflowInstanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowInstance to fetch.
     */
    where: WorkflowInstanceWhereUniqueInput
  }

  /**
   * WorkflowInstance findFirst
   */
  export type WorkflowInstanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowInstance to fetch.
     */
    where?: WorkflowInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowInstances to fetch.
     */
    orderBy?: WorkflowInstanceOrderByWithRelationInput | WorkflowInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowInstances.
     */
    cursor?: WorkflowInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowInstances.
     */
    distinct?: WorkflowInstanceScalarFieldEnum | WorkflowInstanceScalarFieldEnum[]
  }

  /**
   * WorkflowInstance findFirstOrThrow
   */
  export type WorkflowInstanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowInstance to fetch.
     */
    where?: WorkflowInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowInstances to fetch.
     */
    orderBy?: WorkflowInstanceOrderByWithRelationInput | WorkflowInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowInstances.
     */
    cursor?: WorkflowInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowInstances.
     */
    distinct?: WorkflowInstanceScalarFieldEnum | WorkflowInstanceScalarFieldEnum[]
  }

  /**
   * WorkflowInstance findMany
   */
  export type WorkflowInstanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowInstances to fetch.
     */
    where?: WorkflowInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowInstances to fetch.
     */
    orderBy?: WorkflowInstanceOrderByWithRelationInput | WorkflowInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkflowInstances.
     */
    cursor?: WorkflowInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowInstances.
     */
    skip?: number
    distinct?: WorkflowInstanceScalarFieldEnum | WorkflowInstanceScalarFieldEnum[]
  }

  /**
   * WorkflowInstance create
   */
  export type WorkflowInstanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkflowInstance.
     */
    data: XOR<WorkflowInstanceCreateInput, WorkflowInstanceUncheckedCreateInput>
  }

  /**
   * WorkflowInstance createMany
   */
  export type WorkflowInstanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkflowInstances.
     */
    data: WorkflowInstanceCreateManyInput | WorkflowInstanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkflowInstance createManyAndReturn
   */
  export type WorkflowInstanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkflowInstances.
     */
    data: WorkflowInstanceCreateManyInput | WorkflowInstanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkflowInstance update
   */
  export type WorkflowInstanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkflowInstance.
     */
    data: XOR<WorkflowInstanceUpdateInput, WorkflowInstanceUncheckedUpdateInput>
    /**
     * Choose, which WorkflowInstance to update.
     */
    where: WorkflowInstanceWhereUniqueInput
  }

  /**
   * WorkflowInstance updateMany
   */
  export type WorkflowInstanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkflowInstances.
     */
    data: XOR<WorkflowInstanceUpdateManyMutationInput, WorkflowInstanceUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowInstances to update
     */
    where?: WorkflowInstanceWhereInput
  }

  /**
   * WorkflowInstance upsert
   */
  export type WorkflowInstanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkflowInstance to update in case it exists.
     */
    where: WorkflowInstanceWhereUniqueInput
    /**
     * In case the WorkflowInstance found by the `where` argument doesn't exist, create a new WorkflowInstance with this data.
     */
    create: XOR<WorkflowInstanceCreateInput, WorkflowInstanceUncheckedCreateInput>
    /**
     * In case the WorkflowInstance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowInstanceUpdateInput, WorkflowInstanceUncheckedUpdateInput>
  }

  /**
   * WorkflowInstance delete
   */
  export type WorkflowInstanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
    /**
     * Filter which WorkflowInstance to delete.
     */
    where: WorkflowInstanceWhereUniqueInput
  }

  /**
   * WorkflowInstance deleteMany
   */
  export type WorkflowInstanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowInstances to delete
     */
    where?: WorkflowInstanceWhereInput
  }

  /**
   * WorkflowInstance.executions
   */
  export type WorkflowInstance$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionInclude<ExtArgs> | null
    where?: WorkflowStepExecutionWhereInput
    orderBy?: WorkflowStepExecutionOrderByWithRelationInput | WorkflowStepExecutionOrderByWithRelationInput[]
    cursor?: WorkflowStepExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowStepExecutionScalarFieldEnum | WorkflowStepExecutionScalarFieldEnum[]
  }

  /**
   * WorkflowInstance.approvals
   */
  export type WorkflowInstance$approvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowApproval
     */
    select?: WorkflowApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowApprovalInclude<ExtArgs> | null
    where?: WorkflowApprovalWhereInput
    orderBy?: WorkflowApprovalOrderByWithRelationInput | WorkflowApprovalOrderByWithRelationInput[]
    cursor?: WorkflowApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowApprovalScalarFieldEnum | WorkflowApprovalScalarFieldEnum[]
  }

  /**
   * WorkflowInstance without action
   */
  export type WorkflowInstanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
  }


  /**
   * Model WorkflowStepExecution
   */

  export type AggregateWorkflowStepExecution = {
    _count: WorkflowStepExecutionCountAggregateOutputType | null
    _avg: WorkflowStepExecutionAvgAggregateOutputType | null
    _sum: WorkflowStepExecutionSumAggregateOutputType | null
    _min: WorkflowStepExecutionMinAggregateOutputType | null
    _max: WorkflowStepExecutionMaxAggregateOutputType | null
  }

  export type WorkflowStepExecutionAvgAggregateOutputType = {
    retryCount: number | null
  }

  export type WorkflowStepExecutionSumAggregateOutputType = {
    retryCount: number | null
  }

  export type WorkflowStepExecutionMinAggregateOutputType = {
    id: string | null
    instanceId: string | null
    stepId: string | null
    status: $Enums.WorkflowStepStatus | null
    startedAt: Date | null
    completedAt: Date | null
    assignedToId: string | null
    errorMessage: string | null
    retryCount: number | null
    isManual: boolean | null
  }

  export type WorkflowStepExecutionMaxAggregateOutputType = {
    id: string | null
    instanceId: string | null
    stepId: string | null
    status: $Enums.WorkflowStepStatus | null
    startedAt: Date | null
    completedAt: Date | null
    assignedToId: string | null
    errorMessage: string | null
    retryCount: number | null
    isManual: boolean | null
  }

  export type WorkflowStepExecutionCountAggregateOutputType = {
    id: number
    instanceId: number
    stepId: number
    status: number
    startedAt: number
    completedAt: number
    assignedToId: number
    result: number
    errorMessage: number
    retryCount: number
    isManual: number
    _all: number
  }


  export type WorkflowStepExecutionAvgAggregateInputType = {
    retryCount?: true
  }

  export type WorkflowStepExecutionSumAggregateInputType = {
    retryCount?: true
  }

  export type WorkflowStepExecutionMinAggregateInputType = {
    id?: true
    instanceId?: true
    stepId?: true
    status?: true
    startedAt?: true
    completedAt?: true
    assignedToId?: true
    errorMessage?: true
    retryCount?: true
    isManual?: true
  }

  export type WorkflowStepExecutionMaxAggregateInputType = {
    id?: true
    instanceId?: true
    stepId?: true
    status?: true
    startedAt?: true
    completedAt?: true
    assignedToId?: true
    errorMessage?: true
    retryCount?: true
    isManual?: true
  }

  export type WorkflowStepExecutionCountAggregateInputType = {
    id?: true
    instanceId?: true
    stepId?: true
    status?: true
    startedAt?: true
    completedAt?: true
    assignedToId?: true
    result?: true
    errorMessage?: true
    retryCount?: true
    isManual?: true
    _all?: true
  }

  export type WorkflowStepExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowStepExecution to aggregate.
     */
    where?: WorkflowStepExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowStepExecutions to fetch.
     */
    orderBy?: WorkflowStepExecutionOrderByWithRelationInput | WorkflowStepExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowStepExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowStepExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowStepExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkflowStepExecutions
    **/
    _count?: true | WorkflowStepExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkflowStepExecutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkflowStepExecutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowStepExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowStepExecutionMaxAggregateInputType
  }

  export type GetWorkflowStepExecutionAggregateType<T extends WorkflowStepExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflowStepExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowStepExecution[P]>
      : GetScalarType<T[P], AggregateWorkflowStepExecution[P]>
  }




  export type WorkflowStepExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowStepExecutionWhereInput
    orderBy?: WorkflowStepExecutionOrderByWithAggregationInput | WorkflowStepExecutionOrderByWithAggregationInput[]
    by: WorkflowStepExecutionScalarFieldEnum[] | WorkflowStepExecutionScalarFieldEnum
    having?: WorkflowStepExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowStepExecutionCountAggregateInputType | true
    _avg?: WorkflowStepExecutionAvgAggregateInputType
    _sum?: WorkflowStepExecutionSumAggregateInputType
    _min?: WorkflowStepExecutionMinAggregateInputType
    _max?: WorkflowStepExecutionMaxAggregateInputType
  }

  export type WorkflowStepExecutionGroupByOutputType = {
    id: string
    instanceId: string
    stepId: string
    status: $Enums.WorkflowStepStatus
    startedAt: Date
    completedAt: Date | null
    assignedToId: string | null
    result: JsonValue | null
    errorMessage: string | null
    retryCount: number
    isManual: boolean
    _count: WorkflowStepExecutionCountAggregateOutputType | null
    _avg: WorkflowStepExecutionAvgAggregateOutputType | null
    _sum: WorkflowStepExecutionSumAggregateOutputType | null
    _min: WorkflowStepExecutionMinAggregateOutputType | null
    _max: WorkflowStepExecutionMaxAggregateOutputType | null
  }

  type GetWorkflowStepExecutionGroupByPayload<T extends WorkflowStepExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowStepExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowStepExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowStepExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowStepExecutionGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowStepExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceId?: boolean
    stepId?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    assignedToId?: boolean
    result?: boolean
    errorMessage?: boolean
    retryCount?: boolean
    isManual?: boolean
    instance?: boolean | WorkflowInstanceDefaultArgs<ExtArgs>
    step?: boolean | WorkflowStepDefaultArgs<ExtArgs>
    assignedTo?: boolean | WorkflowStepExecution$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["workflowStepExecution"]>

  export type WorkflowStepExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceId?: boolean
    stepId?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    assignedToId?: boolean
    result?: boolean
    errorMessage?: boolean
    retryCount?: boolean
    isManual?: boolean
    instance?: boolean | WorkflowInstanceDefaultArgs<ExtArgs>
    step?: boolean | WorkflowStepDefaultArgs<ExtArgs>
    assignedTo?: boolean | WorkflowStepExecution$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["workflowStepExecution"]>

  export type WorkflowStepExecutionSelectScalar = {
    id?: boolean
    instanceId?: boolean
    stepId?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    assignedToId?: boolean
    result?: boolean
    errorMessage?: boolean
    retryCount?: boolean
    isManual?: boolean
  }

  export type WorkflowStepExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | WorkflowInstanceDefaultArgs<ExtArgs>
    step?: boolean | WorkflowStepDefaultArgs<ExtArgs>
    assignedTo?: boolean | WorkflowStepExecution$assignedToArgs<ExtArgs>
  }
  export type WorkflowStepExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | WorkflowInstanceDefaultArgs<ExtArgs>
    step?: boolean | WorkflowStepDefaultArgs<ExtArgs>
    assignedTo?: boolean | WorkflowStepExecution$assignedToArgs<ExtArgs>
  }

  export type $WorkflowStepExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkflowStepExecution"
    objects: {
      instance: Prisma.$WorkflowInstancePayload<ExtArgs>
      step: Prisma.$WorkflowStepPayload<ExtArgs>
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      instanceId: string
      stepId: string
      status: $Enums.WorkflowStepStatus
      startedAt: Date
      completedAt: Date | null
      assignedToId: string | null
      result: Prisma.JsonValue | null
      errorMessage: string | null
      retryCount: number
      isManual: boolean
    }, ExtArgs["result"]["workflowStepExecution"]>
    composites: {}
  }

  type WorkflowStepExecutionGetPayload<S extends boolean | null | undefined | WorkflowStepExecutionDefaultArgs> = $Result.GetResult<Prisma.$WorkflowStepExecutionPayload, S>

  type WorkflowStepExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkflowStepExecutionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkflowStepExecutionCountAggregateInputType | true
    }

  export interface WorkflowStepExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkflowStepExecution'], meta: { name: 'WorkflowStepExecution' } }
    /**
     * Find zero or one WorkflowStepExecution that matches the filter.
     * @param {WorkflowStepExecutionFindUniqueArgs} args - Arguments to find a WorkflowStepExecution
     * @example
     * // Get one WorkflowStepExecution
     * const workflowStepExecution = await prisma.workflowStepExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowStepExecutionFindUniqueArgs>(args: SelectSubset<T, WorkflowStepExecutionFindUniqueArgs<ExtArgs>>): Prisma__WorkflowStepExecutionClient<$Result.GetResult<Prisma.$WorkflowStepExecutionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkflowStepExecution that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkflowStepExecutionFindUniqueOrThrowArgs} args - Arguments to find a WorkflowStepExecution
     * @example
     * // Get one WorkflowStepExecution
     * const workflowStepExecution = await prisma.workflowStepExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowStepExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowStepExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowStepExecutionClient<$Result.GetResult<Prisma.$WorkflowStepExecutionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkflowStepExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepExecutionFindFirstArgs} args - Arguments to find a WorkflowStepExecution
     * @example
     * // Get one WorkflowStepExecution
     * const workflowStepExecution = await prisma.workflowStepExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowStepExecutionFindFirstArgs>(args?: SelectSubset<T, WorkflowStepExecutionFindFirstArgs<ExtArgs>>): Prisma__WorkflowStepExecutionClient<$Result.GetResult<Prisma.$WorkflowStepExecutionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkflowStepExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepExecutionFindFirstOrThrowArgs} args - Arguments to find a WorkflowStepExecution
     * @example
     * // Get one WorkflowStepExecution
     * const workflowStepExecution = await prisma.workflowStepExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowStepExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowStepExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowStepExecutionClient<$Result.GetResult<Prisma.$WorkflowStepExecutionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkflowStepExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowStepExecutions
     * const workflowStepExecutions = await prisma.workflowStepExecution.findMany()
     * 
     * // Get first 10 WorkflowStepExecutions
     * const workflowStepExecutions = await prisma.workflowStepExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowStepExecutionWithIdOnly = await prisma.workflowStepExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowStepExecutionFindManyArgs>(args?: SelectSubset<T, WorkflowStepExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowStepExecutionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkflowStepExecution.
     * @param {WorkflowStepExecutionCreateArgs} args - Arguments to create a WorkflowStepExecution.
     * @example
     * // Create one WorkflowStepExecution
     * const WorkflowStepExecution = await prisma.workflowStepExecution.create({
     *   data: {
     *     // ... data to create a WorkflowStepExecution
     *   }
     * })
     * 
     */
    create<T extends WorkflowStepExecutionCreateArgs>(args: SelectSubset<T, WorkflowStepExecutionCreateArgs<ExtArgs>>): Prisma__WorkflowStepExecutionClient<$Result.GetResult<Prisma.$WorkflowStepExecutionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkflowStepExecutions.
     * @param {WorkflowStepExecutionCreateManyArgs} args - Arguments to create many WorkflowStepExecutions.
     * @example
     * // Create many WorkflowStepExecutions
     * const workflowStepExecution = await prisma.workflowStepExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowStepExecutionCreateManyArgs>(args?: SelectSubset<T, WorkflowStepExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkflowStepExecutions and returns the data saved in the database.
     * @param {WorkflowStepExecutionCreateManyAndReturnArgs} args - Arguments to create many WorkflowStepExecutions.
     * @example
     * // Create many WorkflowStepExecutions
     * const workflowStepExecution = await prisma.workflowStepExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkflowStepExecutions and only return the `id`
     * const workflowStepExecutionWithIdOnly = await prisma.workflowStepExecution.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowStepExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowStepExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowStepExecutionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkflowStepExecution.
     * @param {WorkflowStepExecutionDeleteArgs} args - Arguments to delete one WorkflowStepExecution.
     * @example
     * // Delete one WorkflowStepExecution
     * const WorkflowStepExecution = await prisma.workflowStepExecution.delete({
     *   where: {
     *     // ... filter to delete one WorkflowStepExecution
     *   }
     * })
     * 
     */
    delete<T extends WorkflowStepExecutionDeleteArgs>(args: SelectSubset<T, WorkflowStepExecutionDeleteArgs<ExtArgs>>): Prisma__WorkflowStepExecutionClient<$Result.GetResult<Prisma.$WorkflowStepExecutionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkflowStepExecution.
     * @param {WorkflowStepExecutionUpdateArgs} args - Arguments to update one WorkflowStepExecution.
     * @example
     * // Update one WorkflowStepExecution
     * const workflowStepExecution = await prisma.workflowStepExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowStepExecutionUpdateArgs>(args: SelectSubset<T, WorkflowStepExecutionUpdateArgs<ExtArgs>>): Prisma__WorkflowStepExecutionClient<$Result.GetResult<Prisma.$WorkflowStepExecutionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkflowStepExecutions.
     * @param {WorkflowStepExecutionDeleteManyArgs} args - Arguments to filter WorkflowStepExecutions to delete.
     * @example
     * // Delete a few WorkflowStepExecutions
     * const { count } = await prisma.workflowStepExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowStepExecutionDeleteManyArgs>(args?: SelectSubset<T, WorkflowStepExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowStepExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowStepExecutions
     * const workflowStepExecution = await prisma.workflowStepExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowStepExecutionUpdateManyArgs>(args: SelectSubset<T, WorkflowStepExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkflowStepExecution.
     * @param {WorkflowStepExecutionUpsertArgs} args - Arguments to update or create a WorkflowStepExecution.
     * @example
     * // Update or create a WorkflowStepExecution
     * const workflowStepExecution = await prisma.workflowStepExecution.upsert({
     *   create: {
     *     // ... data to create a WorkflowStepExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowStepExecution we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowStepExecutionUpsertArgs>(args: SelectSubset<T, WorkflowStepExecutionUpsertArgs<ExtArgs>>): Prisma__WorkflowStepExecutionClient<$Result.GetResult<Prisma.$WorkflowStepExecutionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkflowStepExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepExecutionCountArgs} args - Arguments to filter WorkflowStepExecutions to count.
     * @example
     * // Count the number of WorkflowStepExecutions
     * const count = await prisma.workflowStepExecution.count({
     *   where: {
     *     // ... the filter for the WorkflowStepExecutions we want to count
     *   }
     * })
    **/
    count<T extends WorkflowStepExecutionCountArgs>(
      args?: Subset<T, WorkflowStepExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowStepExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkflowStepExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowStepExecutionAggregateArgs>(args: Subset<T, WorkflowStepExecutionAggregateArgs>): Prisma.PrismaPromise<GetWorkflowStepExecutionAggregateType<T>>

    /**
     * Group by WorkflowStepExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowStepExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowStepExecutionGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowStepExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowStepExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowStepExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkflowStepExecution model
   */
  readonly fields: WorkflowStepExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowStepExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowStepExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instance<T extends WorkflowInstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowInstanceDefaultArgs<ExtArgs>>): Prisma__WorkflowInstanceClient<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    step<T extends WorkflowStepDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowStepDefaultArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assignedTo<T extends WorkflowStepExecution$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowStepExecution$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkflowStepExecution model
   */ 
  interface WorkflowStepExecutionFieldRefs {
    readonly id: FieldRef<"WorkflowStepExecution", 'String'>
    readonly instanceId: FieldRef<"WorkflowStepExecution", 'String'>
    readonly stepId: FieldRef<"WorkflowStepExecution", 'String'>
    readonly status: FieldRef<"WorkflowStepExecution", 'WorkflowStepStatus'>
    readonly startedAt: FieldRef<"WorkflowStepExecution", 'DateTime'>
    readonly completedAt: FieldRef<"WorkflowStepExecution", 'DateTime'>
    readonly assignedToId: FieldRef<"WorkflowStepExecution", 'String'>
    readonly result: FieldRef<"WorkflowStepExecution", 'Json'>
    readonly errorMessage: FieldRef<"WorkflowStepExecution", 'String'>
    readonly retryCount: FieldRef<"WorkflowStepExecution", 'Int'>
    readonly isManual: FieldRef<"WorkflowStepExecution", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * WorkflowStepExecution findUnique
   */
  export type WorkflowStepExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStepExecution to fetch.
     */
    where: WorkflowStepExecutionWhereUniqueInput
  }

  /**
   * WorkflowStepExecution findUniqueOrThrow
   */
  export type WorkflowStepExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStepExecution to fetch.
     */
    where: WorkflowStepExecutionWhereUniqueInput
  }

  /**
   * WorkflowStepExecution findFirst
   */
  export type WorkflowStepExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStepExecution to fetch.
     */
    where?: WorkflowStepExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowStepExecutions to fetch.
     */
    orderBy?: WorkflowStepExecutionOrderByWithRelationInput | WorkflowStepExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowStepExecutions.
     */
    cursor?: WorkflowStepExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowStepExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowStepExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowStepExecutions.
     */
    distinct?: WorkflowStepExecutionScalarFieldEnum | WorkflowStepExecutionScalarFieldEnum[]
  }

  /**
   * WorkflowStepExecution findFirstOrThrow
   */
  export type WorkflowStepExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStepExecution to fetch.
     */
    where?: WorkflowStepExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowStepExecutions to fetch.
     */
    orderBy?: WorkflowStepExecutionOrderByWithRelationInput | WorkflowStepExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowStepExecutions.
     */
    cursor?: WorkflowStepExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowStepExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowStepExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowStepExecutions.
     */
    distinct?: WorkflowStepExecutionScalarFieldEnum | WorkflowStepExecutionScalarFieldEnum[]
  }

  /**
   * WorkflowStepExecution findMany
   */
  export type WorkflowStepExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStepExecutions to fetch.
     */
    where?: WorkflowStepExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowStepExecutions to fetch.
     */
    orderBy?: WorkflowStepExecutionOrderByWithRelationInput | WorkflowStepExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkflowStepExecutions.
     */
    cursor?: WorkflowStepExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowStepExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowStepExecutions.
     */
    skip?: number
    distinct?: WorkflowStepExecutionScalarFieldEnum | WorkflowStepExecutionScalarFieldEnum[]
  }

  /**
   * WorkflowStepExecution create
   */
  export type WorkflowStepExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkflowStepExecution.
     */
    data: XOR<WorkflowStepExecutionCreateInput, WorkflowStepExecutionUncheckedCreateInput>
  }

  /**
   * WorkflowStepExecution createMany
   */
  export type WorkflowStepExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkflowStepExecutions.
     */
    data: WorkflowStepExecutionCreateManyInput | WorkflowStepExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkflowStepExecution createManyAndReturn
   */
  export type WorkflowStepExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkflowStepExecutions.
     */
    data: WorkflowStepExecutionCreateManyInput | WorkflowStepExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkflowStepExecution update
   */
  export type WorkflowStepExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkflowStepExecution.
     */
    data: XOR<WorkflowStepExecutionUpdateInput, WorkflowStepExecutionUncheckedUpdateInput>
    /**
     * Choose, which WorkflowStepExecution to update.
     */
    where: WorkflowStepExecutionWhereUniqueInput
  }

  /**
   * WorkflowStepExecution updateMany
   */
  export type WorkflowStepExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkflowStepExecutions.
     */
    data: XOR<WorkflowStepExecutionUpdateManyMutationInput, WorkflowStepExecutionUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowStepExecutions to update
     */
    where?: WorkflowStepExecutionWhereInput
  }

  /**
   * WorkflowStepExecution upsert
   */
  export type WorkflowStepExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkflowStepExecution to update in case it exists.
     */
    where: WorkflowStepExecutionWhereUniqueInput
    /**
     * In case the WorkflowStepExecution found by the `where` argument doesn't exist, create a new WorkflowStepExecution with this data.
     */
    create: XOR<WorkflowStepExecutionCreateInput, WorkflowStepExecutionUncheckedCreateInput>
    /**
     * In case the WorkflowStepExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowStepExecutionUpdateInput, WorkflowStepExecutionUncheckedUpdateInput>
  }

  /**
   * WorkflowStepExecution delete
   */
  export type WorkflowStepExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionInclude<ExtArgs> | null
    /**
     * Filter which WorkflowStepExecution to delete.
     */
    where: WorkflowStepExecutionWhereUniqueInput
  }

  /**
   * WorkflowStepExecution deleteMany
   */
  export type WorkflowStepExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowStepExecutions to delete
     */
    where?: WorkflowStepExecutionWhereInput
  }

  /**
   * WorkflowStepExecution.assignedTo
   */
  export type WorkflowStepExecution$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * WorkflowStepExecution without action
   */
  export type WorkflowStepExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionInclude<ExtArgs> | null
  }


  /**
   * Model WorkflowApproval
   */

  export type AggregateWorkflowApproval = {
    _count: WorkflowApprovalCountAggregateOutputType | null
    _avg: WorkflowApprovalAvgAggregateOutputType | null
    _sum: WorkflowApprovalSumAggregateOutputType | null
    _min: WorkflowApprovalMinAggregateOutputType | null
    _max: WorkflowApprovalMaxAggregateOutputType | null
  }

  export type WorkflowApprovalAvgAggregateOutputType = {
    remindersSent: number | null
  }

  export type WorkflowApprovalSumAggregateOutputType = {
    remindersSent: number | null
  }

  export type WorkflowApprovalMinAggregateOutputType = {
    id: string | null
    instanceId: string | null
    approverId: string | null
    stepApproverId: string | null
    status: $Enums.ApprovalStatus | null
    comments: string | null
    approvedAt: Date | null
    rejectedAt: Date | null
    requestedAt: Date | null
    remindersSent: number | null
    lastReminderAt: Date | null
  }

  export type WorkflowApprovalMaxAggregateOutputType = {
    id: string | null
    instanceId: string | null
    approverId: string | null
    stepApproverId: string | null
    status: $Enums.ApprovalStatus | null
    comments: string | null
    approvedAt: Date | null
    rejectedAt: Date | null
    requestedAt: Date | null
    remindersSent: number | null
    lastReminderAt: Date | null
  }

  export type WorkflowApprovalCountAggregateOutputType = {
    id: number
    instanceId: number
    approverId: number
    stepApproverId: number
    status: number
    comments: number
    approvedAt: number
    rejectedAt: number
    requestedAt: number
    remindersSent: number
    lastReminderAt: number
    _all: number
  }


  export type WorkflowApprovalAvgAggregateInputType = {
    remindersSent?: true
  }

  export type WorkflowApprovalSumAggregateInputType = {
    remindersSent?: true
  }

  export type WorkflowApprovalMinAggregateInputType = {
    id?: true
    instanceId?: true
    approverId?: true
    stepApproverId?: true
    status?: true
    comments?: true
    approvedAt?: true
    rejectedAt?: true
    requestedAt?: true
    remindersSent?: true
    lastReminderAt?: true
  }

  export type WorkflowApprovalMaxAggregateInputType = {
    id?: true
    instanceId?: true
    approverId?: true
    stepApproverId?: true
    status?: true
    comments?: true
    approvedAt?: true
    rejectedAt?: true
    requestedAt?: true
    remindersSent?: true
    lastReminderAt?: true
  }

  export type WorkflowApprovalCountAggregateInputType = {
    id?: true
    instanceId?: true
    approverId?: true
    stepApproverId?: true
    status?: true
    comments?: true
    approvedAt?: true
    rejectedAt?: true
    requestedAt?: true
    remindersSent?: true
    lastReminderAt?: true
    _all?: true
  }

  export type WorkflowApprovalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowApproval to aggregate.
     */
    where?: WorkflowApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowApprovals to fetch.
     */
    orderBy?: WorkflowApprovalOrderByWithRelationInput | WorkflowApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkflowApprovals
    **/
    _count?: true | WorkflowApprovalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkflowApprovalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkflowApprovalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowApprovalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowApprovalMaxAggregateInputType
  }

  export type GetWorkflowApprovalAggregateType<T extends WorkflowApprovalAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflowApproval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowApproval[P]>
      : GetScalarType<T[P], AggregateWorkflowApproval[P]>
  }




  export type WorkflowApprovalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowApprovalWhereInput
    orderBy?: WorkflowApprovalOrderByWithAggregationInput | WorkflowApprovalOrderByWithAggregationInput[]
    by: WorkflowApprovalScalarFieldEnum[] | WorkflowApprovalScalarFieldEnum
    having?: WorkflowApprovalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowApprovalCountAggregateInputType | true
    _avg?: WorkflowApprovalAvgAggregateInputType
    _sum?: WorkflowApprovalSumAggregateInputType
    _min?: WorkflowApprovalMinAggregateInputType
    _max?: WorkflowApprovalMaxAggregateInputType
  }

  export type WorkflowApprovalGroupByOutputType = {
    id: string
    instanceId: string
    approverId: string
    stepApproverId: string
    status: $Enums.ApprovalStatus
    comments: string | null
    approvedAt: Date | null
    rejectedAt: Date | null
    requestedAt: Date
    remindersSent: number
    lastReminderAt: Date | null
    _count: WorkflowApprovalCountAggregateOutputType | null
    _avg: WorkflowApprovalAvgAggregateOutputType | null
    _sum: WorkflowApprovalSumAggregateOutputType | null
    _min: WorkflowApprovalMinAggregateOutputType | null
    _max: WorkflowApprovalMaxAggregateOutputType | null
  }

  type GetWorkflowApprovalGroupByPayload<T extends WorkflowApprovalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowApprovalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowApprovalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowApprovalGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowApprovalGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowApprovalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceId?: boolean
    approverId?: boolean
    stepApproverId?: boolean
    status?: boolean
    comments?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    requestedAt?: boolean
    remindersSent?: boolean
    lastReminderAt?: boolean
    instance?: boolean | WorkflowInstanceDefaultArgs<ExtArgs>
    approver?: boolean | UserDefaultArgs<ExtArgs>
    stepApprover?: boolean | WorkflowStepApproverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowApproval"]>

  export type WorkflowApprovalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceId?: boolean
    approverId?: boolean
    stepApproverId?: boolean
    status?: boolean
    comments?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    requestedAt?: boolean
    remindersSent?: boolean
    lastReminderAt?: boolean
    instance?: boolean | WorkflowInstanceDefaultArgs<ExtArgs>
    approver?: boolean | UserDefaultArgs<ExtArgs>
    stepApprover?: boolean | WorkflowStepApproverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowApproval"]>

  export type WorkflowApprovalSelectScalar = {
    id?: boolean
    instanceId?: boolean
    approverId?: boolean
    stepApproverId?: boolean
    status?: boolean
    comments?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    requestedAt?: boolean
    remindersSent?: boolean
    lastReminderAt?: boolean
  }

  export type WorkflowApprovalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | WorkflowInstanceDefaultArgs<ExtArgs>
    approver?: boolean | UserDefaultArgs<ExtArgs>
    stepApprover?: boolean | WorkflowStepApproverDefaultArgs<ExtArgs>
  }
  export type WorkflowApprovalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | WorkflowInstanceDefaultArgs<ExtArgs>
    approver?: boolean | UserDefaultArgs<ExtArgs>
    stepApprover?: boolean | WorkflowStepApproverDefaultArgs<ExtArgs>
  }

  export type $WorkflowApprovalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkflowApproval"
    objects: {
      instance: Prisma.$WorkflowInstancePayload<ExtArgs>
      approver: Prisma.$UserPayload<ExtArgs>
      stepApprover: Prisma.$WorkflowStepApproverPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      instanceId: string
      approverId: string
      stepApproverId: string
      status: $Enums.ApprovalStatus
      comments: string | null
      approvedAt: Date | null
      rejectedAt: Date | null
      requestedAt: Date
      remindersSent: number
      lastReminderAt: Date | null
    }, ExtArgs["result"]["workflowApproval"]>
    composites: {}
  }

  type WorkflowApprovalGetPayload<S extends boolean | null | undefined | WorkflowApprovalDefaultArgs> = $Result.GetResult<Prisma.$WorkflowApprovalPayload, S>

  type WorkflowApprovalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkflowApprovalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkflowApprovalCountAggregateInputType | true
    }

  export interface WorkflowApprovalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkflowApproval'], meta: { name: 'WorkflowApproval' } }
    /**
     * Find zero or one WorkflowApproval that matches the filter.
     * @param {WorkflowApprovalFindUniqueArgs} args - Arguments to find a WorkflowApproval
     * @example
     * // Get one WorkflowApproval
     * const workflowApproval = await prisma.workflowApproval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowApprovalFindUniqueArgs>(args: SelectSubset<T, WorkflowApprovalFindUniqueArgs<ExtArgs>>): Prisma__WorkflowApprovalClient<$Result.GetResult<Prisma.$WorkflowApprovalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkflowApproval that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkflowApprovalFindUniqueOrThrowArgs} args - Arguments to find a WorkflowApproval
     * @example
     * // Get one WorkflowApproval
     * const workflowApproval = await prisma.workflowApproval.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowApprovalFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowApprovalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowApprovalClient<$Result.GetResult<Prisma.$WorkflowApprovalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkflowApproval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowApprovalFindFirstArgs} args - Arguments to find a WorkflowApproval
     * @example
     * // Get one WorkflowApproval
     * const workflowApproval = await prisma.workflowApproval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowApprovalFindFirstArgs>(args?: SelectSubset<T, WorkflowApprovalFindFirstArgs<ExtArgs>>): Prisma__WorkflowApprovalClient<$Result.GetResult<Prisma.$WorkflowApprovalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkflowApproval that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowApprovalFindFirstOrThrowArgs} args - Arguments to find a WorkflowApproval
     * @example
     * // Get one WorkflowApproval
     * const workflowApproval = await prisma.workflowApproval.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowApprovalFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowApprovalFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowApprovalClient<$Result.GetResult<Prisma.$WorkflowApprovalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkflowApprovals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowApprovalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowApprovals
     * const workflowApprovals = await prisma.workflowApproval.findMany()
     * 
     * // Get first 10 WorkflowApprovals
     * const workflowApprovals = await prisma.workflowApproval.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowApprovalWithIdOnly = await prisma.workflowApproval.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowApprovalFindManyArgs>(args?: SelectSubset<T, WorkflowApprovalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowApprovalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkflowApproval.
     * @param {WorkflowApprovalCreateArgs} args - Arguments to create a WorkflowApproval.
     * @example
     * // Create one WorkflowApproval
     * const WorkflowApproval = await prisma.workflowApproval.create({
     *   data: {
     *     // ... data to create a WorkflowApproval
     *   }
     * })
     * 
     */
    create<T extends WorkflowApprovalCreateArgs>(args: SelectSubset<T, WorkflowApprovalCreateArgs<ExtArgs>>): Prisma__WorkflowApprovalClient<$Result.GetResult<Prisma.$WorkflowApprovalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkflowApprovals.
     * @param {WorkflowApprovalCreateManyArgs} args - Arguments to create many WorkflowApprovals.
     * @example
     * // Create many WorkflowApprovals
     * const workflowApproval = await prisma.workflowApproval.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowApprovalCreateManyArgs>(args?: SelectSubset<T, WorkflowApprovalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkflowApprovals and returns the data saved in the database.
     * @param {WorkflowApprovalCreateManyAndReturnArgs} args - Arguments to create many WorkflowApprovals.
     * @example
     * // Create many WorkflowApprovals
     * const workflowApproval = await prisma.workflowApproval.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkflowApprovals and only return the `id`
     * const workflowApprovalWithIdOnly = await prisma.workflowApproval.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowApprovalCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowApprovalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowApprovalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkflowApproval.
     * @param {WorkflowApprovalDeleteArgs} args - Arguments to delete one WorkflowApproval.
     * @example
     * // Delete one WorkflowApproval
     * const WorkflowApproval = await prisma.workflowApproval.delete({
     *   where: {
     *     // ... filter to delete one WorkflowApproval
     *   }
     * })
     * 
     */
    delete<T extends WorkflowApprovalDeleteArgs>(args: SelectSubset<T, WorkflowApprovalDeleteArgs<ExtArgs>>): Prisma__WorkflowApprovalClient<$Result.GetResult<Prisma.$WorkflowApprovalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkflowApproval.
     * @param {WorkflowApprovalUpdateArgs} args - Arguments to update one WorkflowApproval.
     * @example
     * // Update one WorkflowApproval
     * const workflowApproval = await prisma.workflowApproval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowApprovalUpdateArgs>(args: SelectSubset<T, WorkflowApprovalUpdateArgs<ExtArgs>>): Prisma__WorkflowApprovalClient<$Result.GetResult<Prisma.$WorkflowApprovalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkflowApprovals.
     * @param {WorkflowApprovalDeleteManyArgs} args - Arguments to filter WorkflowApprovals to delete.
     * @example
     * // Delete a few WorkflowApprovals
     * const { count } = await prisma.workflowApproval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowApprovalDeleteManyArgs>(args?: SelectSubset<T, WorkflowApprovalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowApprovalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowApprovals
     * const workflowApproval = await prisma.workflowApproval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowApprovalUpdateManyArgs>(args: SelectSubset<T, WorkflowApprovalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkflowApproval.
     * @param {WorkflowApprovalUpsertArgs} args - Arguments to update or create a WorkflowApproval.
     * @example
     * // Update or create a WorkflowApproval
     * const workflowApproval = await prisma.workflowApproval.upsert({
     *   create: {
     *     // ... data to create a WorkflowApproval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowApproval we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowApprovalUpsertArgs>(args: SelectSubset<T, WorkflowApprovalUpsertArgs<ExtArgs>>): Prisma__WorkflowApprovalClient<$Result.GetResult<Prisma.$WorkflowApprovalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkflowApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowApprovalCountArgs} args - Arguments to filter WorkflowApprovals to count.
     * @example
     * // Count the number of WorkflowApprovals
     * const count = await prisma.workflowApproval.count({
     *   where: {
     *     // ... the filter for the WorkflowApprovals we want to count
     *   }
     * })
    **/
    count<T extends WorkflowApprovalCountArgs>(
      args?: Subset<T, WorkflowApprovalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowApprovalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkflowApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowApprovalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowApprovalAggregateArgs>(args: Subset<T, WorkflowApprovalAggregateArgs>): Prisma.PrismaPromise<GetWorkflowApprovalAggregateType<T>>

    /**
     * Group by WorkflowApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowApprovalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowApprovalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowApprovalGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowApprovalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowApprovalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowApprovalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkflowApproval model
   */
  readonly fields: WorkflowApprovalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowApproval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowApprovalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instance<T extends WorkflowInstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowInstanceDefaultArgs<ExtArgs>>): Prisma__WorkflowInstanceClient<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    approver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    stepApprover<T extends WorkflowStepApproverDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowStepApproverDefaultArgs<ExtArgs>>): Prisma__WorkflowStepApproverClient<$Result.GetResult<Prisma.$WorkflowStepApproverPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkflowApproval model
   */ 
  interface WorkflowApprovalFieldRefs {
    readonly id: FieldRef<"WorkflowApproval", 'String'>
    readonly instanceId: FieldRef<"WorkflowApproval", 'String'>
    readonly approverId: FieldRef<"WorkflowApproval", 'String'>
    readonly stepApproverId: FieldRef<"WorkflowApproval", 'String'>
    readonly status: FieldRef<"WorkflowApproval", 'ApprovalStatus'>
    readonly comments: FieldRef<"WorkflowApproval", 'String'>
    readonly approvedAt: FieldRef<"WorkflowApproval", 'DateTime'>
    readonly rejectedAt: FieldRef<"WorkflowApproval", 'DateTime'>
    readonly requestedAt: FieldRef<"WorkflowApproval", 'DateTime'>
    readonly remindersSent: FieldRef<"WorkflowApproval", 'Int'>
    readonly lastReminderAt: FieldRef<"WorkflowApproval", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkflowApproval findUnique
   */
  export type WorkflowApprovalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowApproval
     */
    select?: WorkflowApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowApprovalInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowApproval to fetch.
     */
    where: WorkflowApprovalWhereUniqueInput
  }

  /**
   * WorkflowApproval findUniqueOrThrow
   */
  export type WorkflowApprovalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowApproval
     */
    select?: WorkflowApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowApprovalInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowApproval to fetch.
     */
    where: WorkflowApprovalWhereUniqueInput
  }

  /**
   * WorkflowApproval findFirst
   */
  export type WorkflowApprovalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowApproval
     */
    select?: WorkflowApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowApprovalInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowApproval to fetch.
     */
    where?: WorkflowApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowApprovals to fetch.
     */
    orderBy?: WorkflowApprovalOrderByWithRelationInput | WorkflowApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowApprovals.
     */
    cursor?: WorkflowApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowApprovals.
     */
    distinct?: WorkflowApprovalScalarFieldEnum | WorkflowApprovalScalarFieldEnum[]
  }

  /**
   * WorkflowApproval findFirstOrThrow
   */
  export type WorkflowApprovalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowApproval
     */
    select?: WorkflowApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowApprovalInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowApproval to fetch.
     */
    where?: WorkflowApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowApprovals to fetch.
     */
    orderBy?: WorkflowApprovalOrderByWithRelationInput | WorkflowApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowApprovals.
     */
    cursor?: WorkflowApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowApprovals.
     */
    distinct?: WorkflowApprovalScalarFieldEnum | WorkflowApprovalScalarFieldEnum[]
  }

  /**
   * WorkflowApproval findMany
   */
  export type WorkflowApprovalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowApproval
     */
    select?: WorkflowApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowApprovalInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowApprovals to fetch.
     */
    where?: WorkflowApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowApprovals to fetch.
     */
    orderBy?: WorkflowApprovalOrderByWithRelationInput | WorkflowApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkflowApprovals.
     */
    cursor?: WorkflowApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowApprovals.
     */
    skip?: number
    distinct?: WorkflowApprovalScalarFieldEnum | WorkflowApprovalScalarFieldEnum[]
  }

  /**
   * WorkflowApproval create
   */
  export type WorkflowApprovalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowApproval
     */
    select?: WorkflowApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowApprovalInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkflowApproval.
     */
    data: XOR<WorkflowApprovalCreateInput, WorkflowApprovalUncheckedCreateInput>
  }

  /**
   * WorkflowApproval createMany
   */
  export type WorkflowApprovalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkflowApprovals.
     */
    data: WorkflowApprovalCreateManyInput | WorkflowApprovalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkflowApproval createManyAndReturn
   */
  export type WorkflowApprovalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowApproval
     */
    select?: WorkflowApprovalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkflowApprovals.
     */
    data: WorkflowApprovalCreateManyInput | WorkflowApprovalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowApprovalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkflowApproval update
   */
  export type WorkflowApprovalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowApproval
     */
    select?: WorkflowApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowApprovalInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkflowApproval.
     */
    data: XOR<WorkflowApprovalUpdateInput, WorkflowApprovalUncheckedUpdateInput>
    /**
     * Choose, which WorkflowApproval to update.
     */
    where: WorkflowApprovalWhereUniqueInput
  }

  /**
   * WorkflowApproval updateMany
   */
  export type WorkflowApprovalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkflowApprovals.
     */
    data: XOR<WorkflowApprovalUpdateManyMutationInput, WorkflowApprovalUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowApprovals to update
     */
    where?: WorkflowApprovalWhereInput
  }

  /**
   * WorkflowApproval upsert
   */
  export type WorkflowApprovalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowApproval
     */
    select?: WorkflowApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowApprovalInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkflowApproval to update in case it exists.
     */
    where: WorkflowApprovalWhereUniqueInput
    /**
     * In case the WorkflowApproval found by the `where` argument doesn't exist, create a new WorkflowApproval with this data.
     */
    create: XOR<WorkflowApprovalCreateInput, WorkflowApprovalUncheckedCreateInput>
    /**
     * In case the WorkflowApproval was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowApprovalUpdateInput, WorkflowApprovalUncheckedUpdateInput>
  }

  /**
   * WorkflowApproval delete
   */
  export type WorkflowApprovalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowApproval
     */
    select?: WorkflowApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowApprovalInclude<ExtArgs> | null
    /**
     * Filter which WorkflowApproval to delete.
     */
    where: WorkflowApprovalWhereUniqueInput
  }

  /**
   * WorkflowApproval deleteMany
   */
  export type WorkflowApprovalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowApprovals to delete
     */
    where?: WorkflowApprovalWhereInput
  }

  /**
   * WorkflowApproval without action
   */
  export type WorkflowApprovalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowApproval
     */
    select?: WorkflowApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowApprovalInclude<ExtArgs> | null
  }


  /**
   * Model WorkflowTemplate
   */

  export type AggregateWorkflowTemplate = {
    _count: WorkflowTemplateCountAggregateOutputType | null
    _avg: WorkflowTemplateAvgAggregateOutputType | null
    _sum: WorkflowTemplateSumAggregateOutputType | null
    _min: WorkflowTemplateMinAggregateOutputType | null
    _max: WorkflowTemplateMaxAggregateOutputType | null
  }

  export type WorkflowTemplateAvgAggregateOutputType = {
    usageCount: number | null
    rating: number | null
  }

  export type WorkflowTemplateSumAggregateOutputType = {
    usageCount: number | null
    rating: number | null
  }

  export type WorkflowTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    industry: string | null
    isPublic: boolean | null
    usageCount: number | null
    rating: number | null
    accountId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    workflowId: string | null
  }

  export type WorkflowTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    industry: string | null
    isPublic: boolean | null
    usageCount: number | null
    rating: number | null
    accountId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    workflowId: string | null
  }

  export type WorkflowTemplateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    industry: number
    templateData: number
    isPublic: number
    usageCount: number
    rating: number
    accountId: number
    createdById: number
    createdAt: number
    updatedAt: number
    workflowId: number
    _all: number
  }


  export type WorkflowTemplateAvgAggregateInputType = {
    usageCount?: true
    rating?: true
  }

  export type WorkflowTemplateSumAggregateInputType = {
    usageCount?: true
    rating?: true
  }

  export type WorkflowTemplateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    industry?: true
    isPublic?: true
    usageCount?: true
    rating?: true
    accountId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    workflowId?: true
  }

  export type WorkflowTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    industry?: true
    isPublic?: true
    usageCount?: true
    rating?: true
    accountId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    workflowId?: true
  }

  export type WorkflowTemplateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    industry?: true
    templateData?: true
    isPublic?: true
    usageCount?: true
    rating?: true
    accountId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    workflowId?: true
    _all?: true
  }

  export type WorkflowTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowTemplate to aggregate.
     */
    where?: WorkflowTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowTemplates to fetch.
     */
    orderBy?: WorkflowTemplateOrderByWithRelationInput | WorkflowTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkflowTemplates
    **/
    _count?: true | WorkflowTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkflowTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkflowTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowTemplateMaxAggregateInputType
  }

  export type GetWorkflowTemplateAggregateType<T extends WorkflowTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflowTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowTemplate[P]>
      : GetScalarType<T[P], AggregateWorkflowTemplate[P]>
  }




  export type WorkflowTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowTemplateWhereInput
    orderBy?: WorkflowTemplateOrderByWithAggregationInput | WorkflowTemplateOrderByWithAggregationInput[]
    by: WorkflowTemplateScalarFieldEnum[] | WorkflowTemplateScalarFieldEnum
    having?: WorkflowTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowTemplateCountAggregateInputType | true
    _avg?: WorkflowTemplateAvgAggregateInputType
    _sum?: WorkflowTemplateSumAggregateInputType
    _min?: WorkflowTemplateMinAggregateInputType
    _max?: WorkflowTemplateMaxAggregateInputType
  }

  export type WorkflowTemplateGroupByOutputType = {
    id: string
    name: string
    description: string | null
    category: string
    industry: string
    templateData: JsonValue
    isPublic: boolean
    usageCount: number
    rating: number | null
    accountId: string | null
    createdById: string
    createdAt: Date
    updatedAt: Date
    workflowId: string | null
    _count: WorkflowTemplateCountAggregateOutputType | null
    _avg: WorkflowTemplateAvgAggregateOutputType | null
    _sum: WorkflowTemplateSumAggregateOutputType | null
    _min: WorkflowTemplateMinAggregateOutputType | null
    _max: WorkflowTemplateMaxAggregateOutputType | null
  }

  type GetWorkflowTemplateGroupByPayload<T extends WorkflowTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowTemplateGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    industry?: boolean
    templateData?: boolean
    isPublic?: boolean
    usageCount?: boolean
    rating?: boolean
    accountId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workflowId?: boolean
    account?: boolean | WorkflowTemplate$accountArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    workflow?: boolean | WorkflowTemplate$workflowArgs<ExtArgs>
  }, ExtArgs["result"]["workflowTemplate"]>

  export type WorkflowTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    industry?: boolean
    templateData?: boolean
    isPublic?: boolean
    usageCount?: boolean
    rating?: boolean
    accountId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workflowId?: boolean
    account?: boolean | WorkflowTemplate$accountArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    workflow?: boolean | WorkflowTemplate$workflowArgs<ExtArgs>
  }, ExtArgs["result"]["workflowTemplate"]>

  export type WorkflowTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    industry?: boolean
    templateData?: boolean
    isPublic?: boolean
    usageCount?: boolean
    rating?: boolean
    accountId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workflowId?: boolean
  }

  export type WorkflowTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | WorkflowTemplate$accountArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    workflow?: boolean | WorkflowTemplate$workflowArgs<ExtArgs>
  }
  export type WorkflowTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | WorkflowTemplate$accountArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    workflow?: boolean | WorkflowTemplate$workflowArgs<ExtArgs>
  }

  export type $WorkflowTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkflowTemplate"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
      workflow: Prisma.$WorkflowDefinitionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      category: string
      industry: string
      templateData: Prisma.JsonValue
      isPublic: boolean
      usageCount: number
      rating: number | null
      accountId: string | null
      createdById: string
      createdAt: Date
      updatedAt: Date
      workflowId: string | null
    }, ExtArgs["result"]["workflowTemplate"]>
    composites: {}
  }

  type WorkflowTemplateGetPayload<S extends boolean | null | undefined | WorkflowTemplateDefaultArgs> = $Result.GetResult<Prisma.$WorkflowTemplatePayload, S>

  type WorkflowTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkflowTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkflowTemplateCountAggregateInputType | true
    }

  export interface WorkflowTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkflowTemplate'], meta: { name: 'WorkflowTemplate' } }
    /**
     * Find zero or one WorkflowTemplate that matches the filter.
     * @param {WorkflowTemplateFindUniqueArgs} args - Arguments to find a WorkflowTemplate
     * @example
     * // Get one WorkflowTemplate
     * const workflowTemplate = await prisma.workflowTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowTemplateFindUniqueArgs>(args: SelectSubset<T, WorkflowTemplateFindUniqueArgs<ExtArgs>>): Prisma__WorkflowTemplateClient<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkflowTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkflowTemplateFindUniqueOrThrowArgs} args - Arguments to find a WorkflowTemplate
     * @example
     * // Get one WorkflowTemplate
     * const workflowTemplate = await prisma.workflowTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowTemplateClient<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkflowTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTemplateFindFirstArgs} args - Arguments to find a WorkflowTemplate
     * @example
     * // Get one WorkflowTemplate
     * const workflowTemplate = await prisma.workflowTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowTemplateFindFirstArgs>(args?: SelectSubset<T, WorkflowTemplateFindFirstArgs<ExtArgs>>): Prisma__WorkflowTemplateClient<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkflowTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTemplateFindFirstOrThrowArgs} args - Arguments to find a WorkflowTemplate
     * @example
     * // Get one WorkflowTemplate
     * const workflowTemplate = await prisma.workflowTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowTemplateClient<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkflowTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowTemplates
     * const workflowTemplates = await prisma.workflowTemplate.findMany()
     * 
     * // Get first 10 WorkflowTemplates
     * const workflowTemplates = await prisma.workflowTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowTemplateWithIdOnly = await prisma.workflowTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowTemplateFindManyArgs>(args?: SelectSubset<T, WorkflowTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkflowTemplate.
     * @param {WorkflowTemplateCreateArgs} args - Arguments to create a WorkflowTemplate.
     * @example
     * // Create one WorkflowTemplate
     * const WorkflowTemplate = await prisma.workflowTemplate.create({
     *   data: {
     *     // ... data to create a WorkflowTemplate
     *   }
     * })
     * 
     */
    create<T extends WorkflowTemplateCreateArgs>(args: SelectSubset<T, WorkflowTemplateCreateArgs<ExtArgs>>): Prisma__WorkflowTemplateClient<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkflowTemplates.
     * @param {WorkflowTemplateCreateManyArgs} args - Arguments to create many WorkflowTemplates.
     * @example
     * // Create many WorkflowTemplates
     * const workflowTemplate = await prisma.workflowTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowTemplateCreateManyArgs>(args?: SelectSubset<T, WorkflowTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkflowTemplates and returns the data saved in the database.
     * @param {WorkflowTemplateCreateManyAndReturnArgs} args - Arguments to create many WorkflowTemplates.
     * @example
     * // Create many WorkflowTemplates
     * const workflowTemplate = await prisma.workflowTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkflowTemplates and only return the `id`
     * const workflowTemplateWithIdOnly = await prisma.workflowTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkflowTemplate.
     * @param {WorkflowTemplateDeleteArgs} args - Arguments to delete one WorkflowTemplate.
     * @example
     * // Delete one WorkflowTemplate
     * const WorkflowTemplate = await prisma.workflowTemplate.delete({
     *   where: {
     *     // ... filter to delete one WorkflowTemplate
     *   }
     * })
     * 
     */
    delete<T extends WorkflowTemplateDeleteArgs>(args: SelectSubset<T, WorkflowTemplateDeleteArgs<ExtArgs>>): Prisma__WorkflowTemplateClient<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkflowTemplate.
     * @param {WorkflowTemplateUpdateArgs} args - Arguments to update one WorkflowTemplate.
     * @example
     * // Update one WorkflowTemplate
     * const workflowTemplate = await prisma.workflowTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowTemplateUpdateArgs>(args: SelectSubset<T, WorkflowTemplateUpdateArgs<ExtArgs>>): Prisma__WorkflowTemplateClient<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkflowTemplates.
     * @param {WorkflowTemplateDeleteManyArgs} args - Arguments to filter WorkflowTemplates to delete.
     * @example
     * // Delete a few WorkflowTemplates
     * const { count } = await prisma.workflowTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowTemplateDeleteManyArgs>(args?: SelectSubset<T, WorkflowTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowTemplates
     * const workflowTemplate = await prisma.workflowTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowTemplateUpdateManyArgs>(args: SelectSubset<T, WorkflowTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkflowTemplate.
     * @param {WorkflowTemplateUpsertArgs} args - Arguments to update or create a WorkflowTemplate.
     * @example
     * // Update or create a WorkflowTemplate
     * const workflowTemplate = await prisma.workflowTemplate.upsert({
     *   create: {
     *     // ... data to create a WorkflowTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowTemplate we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowTemplateUpsertArgs>(args: SelectSubset<T, WorkflowTemplateUpsertArgs<ExtArgs>>): Prisma__WorkflowTemplateClient<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkflowTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTemplateCountArgs} args - Arguments to filter WorkflowTemplates to count.
     * @example
     * // Count the number of WorkflowTemplates
     * const count = await prisma.workflowTemplate.count({
     *   where: {
     *     // ... the filter for the WorkflowTemplates we want to count
     *   }
     * })
    **/
    count<T extends WorkflowTemplateCountArgs>(
      args?: Subset<T, WorkflowTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkflowTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowTemplateAggregateArgs>(args: Subset<T, WorkflowTemplateAggregateArgs>): Prisma.PrismaPromise<GetWorkflowTemplateAggregateType<T>>

    /**
     * Group by WorkflowTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowTemplateGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkflowTemplate model
   */
  readonly fields: WorkflowTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends WorkflowTemplate$accountArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowTemplate$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    workflow<T extends WorkflowTemplate$workflowArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowTemplate$workflowArgs<ExtArgs>>): Prisma__WorkflowDefinitionClient<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkflowTemplate model
   */ 
  interface WorkflowTemplateFieldRefs {
    readonly id: FieldRef<"WorkflowTemplate", 'String'>
    readonly name: FieldRef<"WorkflowTemplate", 'String'>
    readonly description: FieldRef<"WorkflowTemplate", 'String'>
    readonly category: FieldRef<"WorkflowTemplate", 'String'>
    readonly industry: FieldRef<"WorkflowTemplate", 'String'>
    readonly templateData: FieldRef<"WorkflowTemplate", 'Json'>
    readonly isPublic: FieldRef<"WorkflowTemplate", 'Boolean'>
    readonly usageCount: FieldRef<"WorkflowTemplate", 'Int'>
    readonly rating: FieldRef<"WorkflowTemplate", 'Float'>
    readonly accountId: FieldRef<"WorkflowTemplate", 'String'>
    readonly createdById: FieldRef<"WorkflowTemplate", 'String'>
    readonly createdAt: FieldRef<"WorkflowTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkflowTemplate", 'DateTime'>
    readonly workflowId: FieldRef<"WorkflowTemplate", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkflowTemplate findUnique
   */
  export type WorkflowTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTemplateInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowTemplate to fetch.
     */
    where: WorkflowTemplateWhereUniqueInput
  }

  /**
   * WorkflowTemplate findUniqueOrThrow
   */
  export type WorkflowTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTemplateInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowTemplate to fetch.
     */
    where: WorkflowTemplateWhereUniqueInput
  }

  /**
   * WorkflowTemplate findFirst
   */
  export type WorkflowTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTemplateInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowTemplate to fetch.
     */
    where?: WorkflowTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowTemplates to fetch.
     */
    orderBy?: WorkflowTemplateOrderByWithRelationInput | WorkflowTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowTemplates.
     */
    cursor?: WorkflowTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowTemplates.
     */
    distinct?: WorkflowTemplateScalarFieldEnum | WorkflowTemplateScalarFieldEnum[]
  }

  /**
   * WorkflowTemplate findFirstOrThrow
   */
  export type WorkflowTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTemplateInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowTemplate to fetch.
     */
    where?: WorkflowTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowTemplates to fetch.
     */
    orderBy?: WorkflowTemplateOrderByWithRelationInput | WorkflowTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowTemplates.
     */
    cursor?: WorkflowTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowTemplates.
     */
    distinct?: WorkflowTemplateScalarFieldEnum | WorkflowTemplateScalarFieldEnum[]
  }

  /**
   * WorkflowTemplate findMany
   */
  export type WorkflowTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTemplateInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowTemplates to fetch.
     */
    where?: WorkflowTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowTemplates to fetch.
     */
    orderBy?: WorkflowTemplateOrderByWithRelationInput | WorkflowTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkflowTemplates.
     */
    cursor?: WorkflowTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowTemplates.
     */
    skip?: number
    distinct?: WorkflowTemplateScalarFieldEnum | WorkflowTemplateScalarFieldEnum[]
  }

  /**
   * WorkflowTemplate create
   */
  export type WorkflowTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkflowTemplate.
     */
    data: XOR<WorkflowTemplateCreateInput, WorkflowTemplateUncheckedCreateInput>
  }

  /**
   * WorkflowTemplate createMany
   */
  export type WorkflowTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkflowTemplates.
     */
    data: WorkflowTemplateCreateManyInput | WorkflowTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkflowTemplate createManyAndReturn
   */
  export type WorkflowTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkflowTemplates.
     */
    data: WorkflowTemplateCreateManyInput | WorkflowTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkflowTemplate update
   */
  export type WorkflowTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkflowTemplate.
     */
    data: XOR<WorkflowTemplateUpdateInput, WorkflowTemplateUncheckedUpdateInput>
    /**
     * Choose, which WorkflowTemplate to update.
     */
    where: WorkflowTemplateWhereUniqueInput
  }

  /**
   * WorkflowTemplate updateMany
   */
  export type WorkflowTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkflowTemplates.
     */
    data: XOR<WorkflowTemplateUpdateManyMutationInput, WorkflowTemplateUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowTemplates to update
     */
    where?: WorkflowTemplateWhereInput
  }

  /**
   * WorkflowTemplate upsert
   */
  export type WorkflowTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkflowTemplate to update in case it exists.
     */
    where: WorkflowTemplateWhereUniqueInput
    /**
     * In case the WorkflowTemplate found by the `where` argument doesn't exist, create a new WorkflowTemplate with this data.
     */
    create: XOR<WorkflowTemplateCreateInput, WorkflowTemplateUncheckedCreateInput>
    /**
     * In case the WorkflowTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowTemplateUpdateInput, WorkflowTemplateUncheckedUpdateInput>
  }

  /**
   * WorkflowTemplate delete
   */
  export type WorkflowTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTemplateInclude<ExtArgs> | null
    /**
     * Filter which WorkflowTemplate to delete.
     */
    where: WorkflowTemplateWhereUniqueInput
  }

  /**
   * WorkflowTemplate deleteMany
   */
  export type WorkflowTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowTemplates to delete
     */
    where?: WorkflowTemplateWhereInput
  }

  /**
   * WorkflowTemplate.account
   */
  export type WorkflowTemplate$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * WorkflowTemplate.workflow
   */
  export type WorkflowTemplate$workflowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinition
     */
    select?: WorkflowDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowDefinitionInclude<ExtArgs> | null
    where?: WorkflowDefinitionWhereInput
  }

  /**
   * WorkflowTemplate without action
   */
  export type WorkflowTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTemplateInclude<ExtArgs> | null
  }


  /**
   * Model AutomationRule
   */

  export type AggregateAutomationRule = {
    _count: AutomationRuleCountAggregateOutputType | null
    _avg: AutomationRuleAvgAggregateOutputType | null
    _sum: AutomationRuleSumAggregateOutputType | null
    _min: AutomationRuleMinAggregateOutputType | null
    _max: AutomationRuleMaxAggregateOutputType | null
  }

  export type AutomationRuleAvgAggregateOutputType = {
    priority: number | null
    executionCount: number | null
  }

  export type AutomationRuleSumAggregateOutputType = {
    priority: number | null
    executionCount: number | null
  }

  export type AutomationRuleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    triggerEvent: string | null
    isActive: boolean | null
    priority: number | null
    executionCount: number | null
    lastExecutedAt: Date | null
    accountId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AutomationRuleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    triggerEvent: string | null
    isActive: boolean | null
    priority: number | null
    executionCount: number | null
    lastExecutedAt: Date | null
    accountId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AutomationRuleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    triggerEvent: number
    conditions: number
    actions: number
    isActive: number
    priority: number
    executionCount: number
    lastExecutedAt: number
    accountId: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AutomationRuleAvgAggregateInputType = {
    priority?: true
    executionCount?: true
  }

  export type AutomationRuleSumAggregateInputType = {
    priority?: true
    executionCount?: true
  }

  export type AutomationRuleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    triggerEvent?: true
    isActive?: true
    priority?: true
    executionCount?: true
    lastExecutedAt?: true
    accountId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AutomationRuleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    triggerEvent?: true
    isActive?: true
    priority?: true
    executionCount?: true
    lastExecutedAt?: true
    accountId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AutomationRuleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    triggerEvent?: true
    conditions?: true
    actions?: true
    isActive?: true
    priority?: true
    executionCount?: true
    lastExecutedAt?: true
    accountId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AutomationRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationRule to aggregate.
     */
    where?: AutomationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationRules to fetch.
     */
    orderBy?: AutomationRuleOrderByWithRelationInput | AutomationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutomationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutomationRules
    **/
    _count?: true | AutomationRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutomationRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutomationRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutomationRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutomationRuleMaxAggregateInputType
  }

  export type GetAutomationRuleAggregateType<T extends AutomationRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateAutomationRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutomationRule[P]>
      : GetScalarType<T[P], AggregateAutomationRule[P]>
  }




  export type AutomationRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationRuleWhereInput
    orderBy?: AutomationRuleOrderByWithAggregationInput | AutomationRuleOrderByWithAggregationInput[]
    by: AutomationRuleScalarFieldEnum[] | AutomationRuleScalarFieldEnum
    having?: AutomationRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutomationRuleCountAggregateInputType | true
    _avg?: AutomationRuleAvgAggregateInputType
    _sum?: AutomationRuleSumAggregateInputType
    _min?: AutomationRuleMinAggregateInputType
    _max?: AutomationRuleMaxAggregateInputType
  }

  export type AutomationRuleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    triggerEvent: string
    conditions: JsonValue
    actions: JsonValue
    isActive: boolean
    priority: number
    executionCount: number
    lastExecutedAt: Date | null
    accountId: string
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: AutomationRuleCountAggregateOutputType | null
    _avg: AutomationRuleAvgAggregateOutputType | null
    _sum: AutomationRuleSumAggregateOutputType | null
    _min: AutomationRuleMinAggregateOutputType | null
    _max: AutomationRuleMaxAggregateOutputType | null
  }

  type GetAutomationRuleGroupByPayload<T extends AutomationRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutomationRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutomationRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutomationRuleGroupByOutputType[P]>
            : GetScalarType<T[P], AutomationRuleGroupByOutputType[P]>
        }
      >
    >


  export type AutomationRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    triggerEvent?: boolean
    conditions?: boolean
    actions?: boolean
    isActive?: boolean
    priority?: boolean
    executionCount?: boolean
    lastExecutedAt?: boolean
    accountId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    executions?: boolean | AutomationRule$executionsArgs<ExtArgs>
    _count?: boolean | AutomationRuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationRule"]>

  export type AutomationRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    triggerEvent?: boolean
    conditions?: boolean
    actions?: boolean
    isActive?: boolean
    priority?: boolean
    executionCount?: boolean
    lastExecutedAt?: boolean
    accountId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationRule"]>

  export type AutomationRuleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    triggerEvent?: boolean
    conditions?: boolean
    actions?: boolean
    isActive?: boolean
    priority?: boolean
    executionCount?: boolean
    lastExecutedAt?: boolean
    accountId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AutomationRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    executions?: boolean | AutomationRule$executionsArgs<ExtArgs>
    _count?: boolean | AutomationRuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AutomationRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AutomationRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutomationRule"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      executions: Prisma.$AutomationExecutionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      triggerEvent: string
      conditions: Prisma.JsonValue
      actions: Prisma.JsonValue
      isActive: boolean
      priority: number
      executionCount: number
      lastExecutedAt: Date | null
      accountId: string
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["automationRule"]>
    composites: {}
  }

  type AutomationRuleGetPayload<S extends boolean | null | undefined | AutomationRuleDefaultArgs> = $Result.GetResult<Prisma.$AutomationRulePayload, S>

  type AutomationRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AutomationRuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AutomationRuleCountAggregateInputType | true
    }

  export interface AutomationRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutomationRule'], meta: { name: 'AutomationRule' } }
    /**
     * Find zero or one AutomationRule that matches the filter.
     * @param {AutomationRuleFindUniqueArgs} args - Arguments to find a AutomationRule
     * @example
     * // Get one AutomationRule
     * const automationRule = await prisma.automationRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutomationRuleFindUniqueArgs>(args: SelectSubset<T, AutomationRuleFindUniqueArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AutomationRule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AutomationRuleFindUniqueOrThrowArgs} args - Arguments to find a AutomationRule
     * @example
     * // Get one AutomationRule
     * const automationRule = await prisma.automationRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutomationRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, AutomationRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AutomationRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleFindFirstArgs} args - Arguments to find a AutomationRule
     * @example
     * // Get one AutomationRule
     * const automationRule = await prisma.automationRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutomationRuleFindFirstArgs>(args?: SelectSubset<T, AutomationRuleFindFirstArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AutomationRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleFindFirstOrThrowArgs} args - Arguments to find a AutomationRule
     * @example
     * // Get one AutomationRule
     * const automationRule = await prisma.automationRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutomationRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, AutomationRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AutomationRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutomationRules
     * const automationRules = await prisma.automationRule.findMany()
     * 
     * // Get first 10 AutomationRules
     * const automationRules = await prisma.automationRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const automationRuleWithIdOnly = await prisma.automationRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutomationRuleFindManyArgs>(args?: SelectSubset<T, AutomationRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AutomationRule.
     * @param {AutomationRuleCreateArgs} args - Arguments to create a AutomationRule.
     * @example
     * // Create one AutomationRule
     * const AutomationRule = await prisma.automationRule.create({
     *   data: {
     *     // ... data to create a AutomationRule
     *   }
     * })
     * 
     */
    create<T extends AutomationRuleCreateArgs>(args: SelectSubset<T, AutomationRuleCreateArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AutomationRules.
     * @param {AutomationRuleCreateManyArgs} args - Arguments to create many AutomationRules.
     * @example
     * // Create many AutomationRules
     * const automationRule = await prisma.automationRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutomationRuleCreateManyArgs>(args?: SelectSubset<T, AutomationRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AutomationRules and returns the data saved in the database.
     * @param {AutomationRuleCreateManyAndReturnArgs} args - Arguments to create many AutomationRules.
     * @example
     * // Create many AutomationRules
     * const automationRule = await prisma.automationRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AutomationRules and only return the `id`
     * const automationRuleWithIdOnly = await prisma.automationRule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutomationRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, AutomationRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AutomationRule.
     * @param {AutomationRuleDeleteArgs} args - Arguments to delete one AutomationRule.
     * @example
     * // Delete one AutomationRule
     * const AutomationRule = await prisma.automationRule.delete({
     *   where: {
     *     // ... filter to delete one AutomationRule
     *   }
     * })
     * 
     */
    delete<T extends AutomationRuleDeleteArgs>(args: SelectSubset<T, AutomationRuleDeleteArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AutomationRule.
     * @param {AutomationRuleUpdateArgs} args - Arguments to update one AutomationRule.
     * @example
     * // Update one AutomationRule
     * const automationRule = await prisma.automationRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutomationRuleUpdateArgs>(args: SelectSubset<T, AutomationRuleUpdateArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AutomationRules.
     * @param {AutomationRuleDeleteManyArgs} args - Arguments to filter AutomationRules to delete.
     * @example
     * // Delete a few AutomationRules
     * const { count } = await prisma.automationRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutomationRuleDeleteManyArgs>(args?: SelectSubset<T, AutomationRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutomationRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutomationRules
     * const automationRule = await prisma.automationRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutomationRuleUpdateManyArgs>(args: SelectSubset<T, AutomationRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AutomationRule.
     * @param {AutomationRuleUpsertArgs} args - Arguments to update or create a AutomationRule.
     * @example
     * // Update or create a AutomationRule
     * const automationRule = await prisma.automationRule.upsert({
     *   create: {
     *     // ... data to create a AutomationRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutomationRule we want to update
     *   }
     * })
     */
    upsert<T extends AutomationRuleUpsertArgs>(args: SelectSubset<T, AutomationRuleUpsertArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AutomationRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleCountArgs} args - Arguments to filter AutomationRules to count.
     * @example
     * // Count the number of AutomationRules
     * const count = await prisma.automationRule.count({
     *   where: {
     *     // ... the filter for the AutomationRules we want to count
     *   }
     * })
    **/
    count<T extends AutomationRuleCountArgs>(
      args?: Subset<T, AutomationRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutomationRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutomationRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutomationRuleAggregateArgs>(args: Subset<T, AutomationRuleAggregateArgs>): Prisma.PrismaPromise<GetAutomationRuleAggregateType<T>>

    /**
     * Group by AutomationRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutomationRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutomationRuleGroupByArgs['orderBy'] }
        : { orderBy?: AutomationRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutomationRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutomationRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutomationRule model
   */
  readonly fields: AutomationRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutomationRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutomationRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    executions<T extends AutomationRule$executionsArgs<ExtArgs> = {}>(args?: Subset<T, AutomationRule$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutomationRule model
   */ 
  interface AutomationRuleFieldRefs {
    readonly id: FieldRef<"AutomationRule", 'String'>
    readonly name: FieldRef<"AutomationRule", 'String'>
    readonly description: FieldRef<"AutomationRule", 'String'>
    readonly triggerEvent: FieldRef<"AutomationRule", 'String'>
    readonly conditions: FieldRef<"AutomationRule", 'Json'>
    readonly actions: FieldRef<"AutomationRule", 'Json'>
    readonly isActive: FieldRef<"AutomationRule", 'Boolean'>
    readonly priority: FieldRef<"AutomationRule", 'Int'>
    readonly executionCount: FieldRef<"AutomationRule", 'Int'>
    readonly lastExecutedAt: FieldRef<"AutomationRule", 'DateTime'>
    readonly accountId: FieldRef<"AutomationRule", 'String'>
    readonly createdById: FieldRef<"AutomationRule", 'String'>
    readonly createdAt: FieldRef<"AutomationRule", 'DateTime'>
    readonly updatedAt: FieldRef<"AutomationRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AutomationRule findUnique
   */
  export type AutomationRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * Filter, which AutomationRule to fetch.
     */
    where: AutomationRuleWhereUniqueInput
  }

  /**
   * AutomationRule findUniqueOrThrow
   */
  export type AutomationRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * Filter, which AutomationRule to fetch.
     */
    where: AutomationRuleWhereUniqueInput
  }

  /**
   * AutomationRule findFirst
   */
  export type AutomationRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * Filter, which AutomationRule to fetch.
     */
    where?: AutomationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationRules to fetch.
     */
    orderBy?: AutomationRuleOrderByWithRelationInput | AutomationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationRules.
     */
    cursor?: AutomationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationRules.
     */
    distinct?: AutomationRuleScalarFieldEnum | AutomationRuleScalarFieldEnum[]
  }

  /**
   * AutomationRule findFirstOrThrow
   */
  export type AutomationRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * Filter, which AutomationRule to fetch.
     */
    where?: AutomationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationRules to fetch.
     */
    orderBy?: AutomationRuleOrderByWithRelationInput | AutomationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationRules.
     */
    cursor?: AutomationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationRules.
     */
    distinct?: AutomationRuleScalarFieldEnum | AutomationRuleScalarFieldEnum[]
  }

  /**
   * AutomationRule findMany
   */
  export type AutomationRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * Filter, which AutomationRules to fetch.
     */
    where?: AutomationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationRules to fetch.
     */
    orderBy?: AutomationRuleOrderByWithRelationInput | AutomationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutomationRules.
     */
    cursor?: AutomationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationRules.
     */
    skip?: number
    distinct?: AutomationRuleScalarFieldEnum | AutomationRuleScalarFieldEnum[]
  }

  /**
   * AutomationRule create
   */
  export type AutomationRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a AutomationRule.
     */
    data: XOR<AutomationRuleCreateInput, AutomationRuleUncheckedCreateInput>
  }

  /**
   * AutomationRule createMany
   */
  export type AutomationRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutomationRules.
     */
    data: AutomationRuleCreateManyInput | AutomationRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutomationRule createManyAndReturn
   */
  export type AutomationRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AutomationRules.
     */
    data: AutomationRuleCreateManyInput | AutomationRuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutomationRule update
   */
  export type AutomationRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a AutomationRule.
     */
    data: XOR<AutomationRuleUpdateInput, AutomationRuleUncheckedUpdateInput>
    /**
     * Choose, which AutomationRule to update.
     */
    where: AutomationRuleWhereUniqueInput
  }

  /**
   * AutomationRule updateMany
   */
  export type AutomationRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutomationRules.
     */
    data: XOR<AutomationRuleUpdateManyMutationInput, AutomationRuleUncheckedUpdateManyInput>
    /**
     * Filter which AutomationRules to update
     */
    where?: AutomationRuleWhereInput
  }

  /**
   * AutomationRule upsert
   */
  export type AutomationRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the AutomationRule to update in case it exists.
     */
    where: AutomationRuleWhereUniqueInput
    /**
     * In case the AutomationRule found by the `where` argument doesn't exist, create a new AutomationRule with this data.
     */
    create: XOR<AutomationRuleCreateInput, AutomationRuleUncheckedCreateInput>
    /**
     * In case the AutomationRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutomationRuleUpdateInput, AutomationRuleUncheckedUpdateInput>
  }

  /**
   * AutomationRule delete
   */
  export type AutomationRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * Filter which AutomationRule to delete.
     */
    where: AutomationRuleWhereUniqueInput
  }

  /**
   * AutomationRule deleteMany
   */
  export type AutomationRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationRules to delete
     */
    where?: AutomationRuleWhereInput
  }

  /**
   * AutomationRule.executions
   */
  export type AutomationRule$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    where?: AutomationExecutionWhereInput
    orderBy?: AutomationExecutionOrderByWithRelationInput | AutomationExecutionOrderByWithRelationInput[]
    cursor?: AutomationExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationExecutionScalarFieldEnum | AutomationExecutionScalarFieldEnum[]
  }

  /**
   * AutomationRule without action
   */
  export type AutomationRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
  }


  /**
   * Model AutomationExecution
   */

  export type AggregateAutomationExecution = {
    _count: AutomationExecutionCountAggregateOutputType | null
    _avg: AutomationExecutionAvgAggregateOutputType | null
    _sum: AutomationExecutionSumAggregateOutputType | null
    _min: AutomationExecutionMinAggregateOutputType | null
    _max: AutomationExecutionMaxAggregateOutputType | null
  }

  export type AutomationExecutionAvgAggregateOutputType = {
    durationMs: number | null
  }

  export type AutomationExecutionSumAggregateOutputType = {
    durationMs: number | null
  }

  export type AutomationExecutionMinAggregateOutputType = {
    id: string | null
    ruleId: string | null
    status: $Enums.AutomationStatus | null
    errorMessage: string | null
    executedAt: Date | null
    durationMs: number | null
  }

  export type AutomationExecutionMaxAggregateOutputType = {
    id: string | null
    ruleId: string | null
    status: $Enums.AutomationStatus | null
    errorMessage: string | null
    executedAt: Date | null
    durationMs: number | null
  }

  export type AutomationExecutionCountAggregateOutputType = {
    id: number
    ruleId: number
    triggerData: number
    result: number
    status: number
    errorMessage: number
    executedAt: number
    durationMs: number
    _all: number
  }


  export type AutomationExecutionAvgAggregateInputType = {
    durationMs?: true
  }

  export type AutomationExecutionSumAggregateInputType = {
    durationMs?: true
  }

  export type AutomationExecutionMinAggregateInputType = {
    id?: true
    ruleId?: true
    status?: true
    errorMessage?: true
    executedAt?: true
    durationMs?: true
  }

  export type AutomationExecutionMaxAggregateInputType = {
    id?: true
    ruleId?: true
    status?: true
    errorMessage?: true
    executedAt?: true
    durationMs?: true
  }

  export type AutomationExecutionCountAggregateInputType = {
    id?: true
    ruleId?: true
    triggerData?: true
    result?: true
    status?: true
    errorMessage?: true
    executedAt?: true
    durationMs?: true
    _all?: true
  }

  export type AutomationExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationExecution to aggregate.
     */
    where?: AutomationExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationExecutions to fetch.
     */
    orderBy?: AutomationExecutionOrderByWithRelationInput | AutomationExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutomationExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutomationExecutions
    **/
    _count?: true | AutomationExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutomationExecutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutomationExecutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutomationExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutomationExecutionMaxAggregateInputType
  }

  export type GetAutomationExecutionAggregateType<T extends AutomationExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateAutomationExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutomationExecution[P]>
      : GetScalarType<T[P], AggregateAutomationExecution[P]>
  }




  export type AutomationExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationExecutionWhereInput
    orderBy?: AutomationExecutionOrderByWithAggregationInput | AutomationExecutionOrderByWithAggregationInput[]
    by: AutomationExecutionScalarFieldEnum[] | AutomationExecutionScalarFieldEnum
    having?: AutomationExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutomationExecutionCountAggregateInputType | true
    _avg?: AutomationExecutionAvgAggregateInputType
    _sum?: AutomationExecutionSumAggregateInputType
    _min?: AutomationExecutionMinAggregateInputType
    _max?: AutomationExecutionMaxAggregateInputType
  }

  export type AutomationExecutionGroupByOutputType = {
    id: string
    ruleId: string
    triggerData: JsonValue
    result: JsonValue | null
    status: $Enums.AutomationStatus
    errorMessage: string | null
    executedAt: Date
    durationMs: number | null
    _count: AutomationExecutionCountAggregateOutputType | null
    _avg: AutomationExecutionAvgAggregateOutputType | null
    _sum: AutomationExecutionSumAggregateOutputType | null
    _min: AutomationExecutionMinAggregateOutputType | null
    _max: AutomationExecutionMaxAggregateOutputType | null
  }

  type GetAutomationExecutionGroupByPayload<T extends AutomationExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutomationExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutomationExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutomationExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], AutomationExecutionGroupByOutputType[P]>
        }
      >
    >


  export type AutomationExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ruleId?: boolean
    triggerData?: boolean
    result?: boolean
    status?: boolean
    errorMessage?: boolean
    executedAt?: boolean
    durationMs?: boolean
    rule?: boolean | AutomationRuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationExecution"]>

  export type AutomationExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ruleId?: boolean
    triggerData?: boolean
    result?: boolean
    status?: boolean
    errorMessage?: boolean
    executedAt?: boolean
    durationMs?: boolean
    rule?: boolean | AutomationRuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationExecution"]>

  export type AutomationExecutionSelectScalar = {
    id?: boolean
    ruleId?: boolean
    triggerData?: boolean
    result?: boolean
    status?: boolean
    errorMessage?: boolean
    executedAt?: boolean
    durationMs?: boolean
  }

  export type AutomationExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rule?: boolean | AutomationRuleDefaultArgs<ExtArgs>
  }
  export type AutomationExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rule?: boolean | AutomationRuleDefaultArgs<ExtArgs>
  }

  export type $AutomationExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutomationExecution"
    objects: {
      rule: Prisma.$AutomationRulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ruleId: string
      triggerData: Prisma.JsonValue
      result: Prisma.JsonValue | null
      status: $Enums.AutomationStatus
      errorMessage: string | null
      executedAt: Date
      durationMs: number | null
    }, ExtArgs["result"]["automationExecution"]>
    composites: {}
  }

  type AutomationExecutionGetPayload<S extends boolean | null | undefined | AutomationExecutionDefaultArgs> = $Result.GetResult<Prisma.$AutomationExecutionPayload, S>

  type AutomationExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AutomationExecutionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AutomationExecutionCountAggregateInputType | true
    }

  export interface AutomationExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutomationExecution'], meta: { name: 'AutomationExecution' } }
    /**
     * Find zero or one AutomationExecution that matches the filter.
     * @param {AutomationExecutionFindUniqueArgs} args - Arguments to find a AutomationExecution
     * @example
     * // Get one AutomationExecution
     * const automationExecution = await prisma.automationExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutomationExecutionFindUniqueArgs>(args: SelectSubset<T, AutomationExecutionFindUniqueArgs<ExtArgs>>): Prisma__AutomationExecutionClient<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AutomationExecution that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AutomationExecutionFindUniqueOrThrowArgs} args - Arguments to find a AutomationExecution
     * @example
     * // Get one AutomationExecution
     * const automationExecution = await prisma.automationExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutomationExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, AutomationExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutomationExecutionClient<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AutomationExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationExecutionFindFirstArgs} args - Arguments to find a AutomationExecution
     * @example
     * // Get one AutomationExecution
     * const automationExecution = await prisma.automationExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutomationExecutionFindFirstArgs>(args?: SelectSubset<T, AutomationExecutionFindFirstArgs<ExtArgs>>): Prisma__AutomationExecutionClient<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AutomationExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationExecutionFindFirstOrThrowArgs} args - Arguments to find a AutomationExecution
     * @example
     * // Get one AutomationExecution
     * const automationExecution = await prisma.automationExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutomationExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, AutomationExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutomationExecutionClient<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AutomationExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutomationExecutions
     * const automationExecutions = await prisma.automationExecution.findMany()
     * 
     * // Get first 10 AutomationExecutions
     * const automationExecutions = await prisma.automationExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const automationExecutionWithIdOnly = await prisma.automationExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutomationExecutionFindManyArgs>(args?: SelectSubset<T, AutomationExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AutomationExecution.
     * @param {AutomationExecutionCreateArgs} args - Arguments to create a AutomationExecution.
     * @example
     * // Create one AutomationExecution
     * const AutomationExecution = await prisma.automationExecution.create({
     *   data: {
     *     // ... data to create a AutomationExecution
     *   }
     * })
     * 
     */
    create<T extends AutomationExecutionCreateArgs>(args: SelectSubset<T, AutomationExecutionCreateArgs<ExtArgs>>): Prisma__AutomationExecutionClient<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AutomationExecutions.
     * @param {AutomationExecutionCreateManyArgs} args - Arguments to create many AutomationExecutions.
     * @example
     * // Create many AutomationExecutions
     * const automationExecution = await prisma.automationExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutomationExecutionCreateManyArgs>(args?: SelectSubset<T, AutomationExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AutomationExecutions and returns the data saved in the database.
     * @param {AutomationExecutionCreateManyAndReturnArgs} args - Arguments to create many AutomationExecutions.
     * @example
     * // Create many AutomationExecutions
     * const automationExecution = await prisma.automationExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AutomationExecutions and only return the `id`
     * const automationExecutionWithIdOnly = await prisma.automationExecution.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutomationExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, AutomationExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AutomationExecution.
     * @param {AutomationExecutionDeleteArgs} args - Arguments to delete one AutomationExecution.
     * @example
     * // Delete one AutomationExecution
     * const AutomationExecution = await prisma.automationExecution.delete({
     *   where: {
     *     // ... filter to delete one AutomationExecution
     *   }
     * })
     * 
     */
    delete<T extends AutomationExecutionDeleteArgs>(args: SelectSubset<T, AutomationExecutionDeleteArgs<ExtArgs>>): Prisma__AutomationExecutionClient<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AutomationExecution.
     * @param {AutomationExecutionUpdateArgs} args - Arguments to update one AutomationExecution.
     * @example
     * // Update one AutomationExecution
     * const automationExecution = await prisma.automationExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutomationExecutionUpdateArgs>(args: SelectSubset<T, AutomationExecutionUpdateArgs<ExtArgs>>): Prisma__AutomationExecutionClient<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AutomationExecutions.
     * @param {AutomationExecutionDeleteManyArgs} args - Arguments to filter AutomationExecutions to delete.
     * @example
     * // Delete a few AutomationExecutions
     * const { count } = await prisma.automationExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutomationExecutionDeleteManyArgs>(args?: SelectSubset<T, AutomationExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutomationExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutomationExecutions
     * const automationExecution = await prisma.automationExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutomationExecutionUpdateManyArgs>(args: SelectSubset<T, AutomationExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AutomationExecution.
     * @param {AutomationExecutionUpsertArgs} args - Arguments to update or create a AutomationExecution.
     * @example
     * // Update or create a AutomationExecution
     * const automationExecution = await prisma.automationExecution.upsert({
     *   create: {
     *     // ... data to create a AutomationExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutomationExecution we want to update
     *   }
     * })
     */
    upsert<T extends AutomationExecutionUpsertArgs>(args: SelectSubset<T, AutomationExecutionUpsertArgs<ExtArgs>>): Prisma__AutomationExecutionClient<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AutomationExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationExecutionCountArgs} args - Arguments to filter AutomationExecutions to count.
     * @example
     * // Count the number of AutomationExecutions
     * const count = await prisma.automationExecution.count({
     *   where: {
     *     // ... the filter for the AutomationExecutions we want to count
     *   }
     * })
    **/
    count<T extends AutomationExecutionCountArgs>(
      args?: Subset<T, AutomationExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutomationExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutomationExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutomationExecutionAggregateArgs>(args: Subset<T, AutomationExecutionAggregateArgs>): Prisma.PrismaPromise<GetAutomationExecutionAggregateType<T>>

    /**
     * Group by AutomationExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutomationExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutomationExecutionGroupByArgs['orderBy'] }
        : { orderBy?: AutomationExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutomationExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutomationExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutomationExecution model
   */
  readonly fields: AutomationExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutomationExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutomationExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rule<T extends AutomationRuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AutomationRuleDefaultArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutomationExecution model
   */ 
  interface AutomationExecutionFieldRefs {
    readonly id: FieldRef<"AutomationExecution", 'String'>
    readonly ruleId: FieldRef<"AutomationExecution", 'String'>
    readonly triggerData: FieldRef<"AutomationExecution", 'Json'>
    readonly result: FieldRef<"AutomationExecution", 'Json'>
    readonly status: FieldRef<"AutomationExecution", 'AutomationStatus'>
    readonly errorMessage: FieldRef<"AutomationExecution", 'String'>
    readonly executedAt: FieldRef<"AutomationExecution", 'DateTime'>
    readonly durationMs: FieldRef<"AutomationExecution", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AutomationExecution findUnique
   */
  export type AutomationExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * Filter, which AutomationExecution to fetch.
     */
    where: AutomationExecutionWhereUniqueInput
  }

  /**
   * AutomationExecution findUniqueOrThrow
   */
  export type AutomationExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * Filter, which AutomationExecution to fetch.
     */
    where: AutomationExecutionWhereUniqueInput
  }

  /**
   * AutomationExecution findFirst
   */
  export type AutomationExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * Filter, which AutomationExecution to fetch.
     */
    where?: AutomationExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationExecutions to fetch.
     */
    orderBy?: AutomationExecutionOrderByWithRelationInput | AutomationExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationExecutions.
     */
    cursor?: AutomationExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationExecutions.
     */
    distinct?: AutomationExecutionScalarFieldEnum | AutomationExecutionScalarFieldEnum[]
  }

  /**
   * AutomationExecution findFirstOrThrow
   */
  export type AutomationExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * Filter, which AutomationExecution to fetch.
     */
    where?: AutomationExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationExecutions to fetch.
     */
    orderBy?: AutomationExecutionOrderByWithRelationInput | AutomationExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationExecutions.
     */
    cursor?: AutomationExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationExecutions.
     */
    distinct?: AutomationExecutionScalarFieldEnum | AutomationExecutionScalarFieldEnum[]
  }

  /**
   * AutomationExecution findMany
   */
  export type AutomationExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * Filter, which AutomationExecutions to fetch.
     */
    where?: AutomationExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationExecutions to fetch.
     */
    orderBy?: AutomationExecutionOrderByWithRelationInput | AutomationExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutomationExecutions.
     */
    cursor?: AutomationExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationExecutions.
     */
    skip?: number
    distinct?: AutomationExecutionScalarFieldEnum | AutomationExecutionScalarFieldEnum[]
  }

  /**
   * AutomationExecution create
   */
  export type AutomationExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a AutomationExecution.
     */
    data: XOR<AutomationExecutionCreateInput, AutomationExecutionUncheckedCreateInput>
  }

  /**
   * AutomationExecution createMany
   */
  export type AutomationExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutomationExecutions.
     */
    data: AutomationExecutionCreateManyInput | AutomationExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutomationExecution createManyAndReturn
   */
  export type AutomationExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AutomationExecutions.
     */
    data: AutomationExecutionCreateManyInput | AutomationExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutomationExecution update
   */
  export type AutomationExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a AutomationExecution.
     */
    data: XOR<AutomationExecutionUpdateInput, AutomationExecutionUncheckedUpdateInput>
    /**
     * Choose, which AutomationExecution to update.
     */
    where: AutomationExecutionWhereUniqueInput
  }

  /**
   * AutomationExecution updateMany
   */
  export type AutomationExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutomationExecutions.
     */
    data: XOR<AutomationExecutionUpdateManyMutationInput, AutomationExecutionUncheckedUpdateManyInput>
    /**
     * Filter which AutomationExecutions to update
     */
    where?: AutomationExecutionWhereInput
  }

  /**
   * AutomationExecution upsert
   */
  export type AutomationExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the AutomationExecution to update in case it exists.
     */
    where: AutomationExecutionWhereUniqueInput
    /**
     * In case the AutomationExecution found by the `where` argument doesn't exist, create a new AutomationExecution with this data.
     */
    create: XOR<AutomationExecutionCreateInput, AutomationExecutionUncheckedCreateInput>
    /**
     * In case the AutomationExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutomationExecutionUpdateInput, AutomationExecutionUncheckedUpdateInput>
  }

  /**
   * AutomationExecution delete
   */
  export type AutomationExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * Filter which AutomationExecution to delete.
     */
    where: AutomationExecutionWhereUniqueInput
  }

  /**
   * AutomationExecution deleteMany
   */
  export type AutomationExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationExecutions to delete
     */
    where?: AutomationExecutionWhereInput
  }

  /**
   * AutomationExecution without action
   */
  export type AutomationExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
  }


  /**
   * Model TestPlan
   */

  export type AggregateTestPlan = {
    _count: TestPlanCountAggregateOutputType | null
    _min: TestPlanMinAggregateOutputType | null
    _max: TestPlanMaxAggregateOutputType | null
  }

  export type TestPlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    version: string | null
    status: $Enums.TestPlanStatus | null
    projectId: string | null
    feature: string | null
    environment: string | null
    startDate: Date | null
    endDate: Date | null
    createdById: string | null
    assignedToId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestPlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    version: string | null
    status: $Enums.TestPlanStatus | null
    projectId: string | null
    feature: string | null
    environment: string | null
    startDate: Date | null
    endDate: Date | null
    createdById: string | null
    assignedToId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestPlanCountAggregateOutputType = {
    id: number
    name: number
    description: number
    version: number
    status: number
    projectId: number
    feature: number
    environment: number
    startDate: number
    endDate: number
    createdById: number
    assignedToId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TestPlanMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    version?: true
    status?: true
    projectId?: true
    feature?: true
    environment?: true
    startDate?: true
    endDate?: true
    createdById?: true
    assignedToId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestPlanMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    version?: true
    status?: true
    projectId?: true
    feature?: true
    environment?: true
    startDate?: true
    endDate?: true
    createdById?: true
    assignedToId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestPlanCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    version?: true
    status?: true
    projectId?: true
    feature?: true
    environment?: true
    startDate?: true
    endDate?: true
    createdById?: true
    assignedToId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TestPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestPlan to aggregate.
     */
    where?: TestPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestPlans to fetch.
     */
    orderBy?: TestPlanOrderByWithRelationInput | TestPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestPlans
    **/
    _count?: true | TestPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestPlanMaxAggregateInputType
  }

  export type GetTestPlanAggregateType<T extends TestPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateTestPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestPlan[P]>
      : GetScalarType<T[P], AggregateTestPlan[P]>
  }




  export type TestPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestPlanWhereInput
    orderBy?: TestPlanOrderByWithAggregationInput | TestPlanOrderByWithAggregationInput[]
    by: TestPlanScalarFieldEnum[] | TestPlanScalarFieldEnum
    having?: TestPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestPlanCountAggregateInputType | true
    _min?: TestPlanMinAggregateInputType
    _max?: TestPlanMaxAggregateInputType
  }

  export type TestPlanGroupByOutputType = {
    id: string
    name: string
    description: string | null
    version: string
    status: $Enums.TestPlanStatus
    projectId: string | null
    feature: string | null
    environment: string | null
    startDate: Date | null
    endDate: Date | null
    createdById: string
    assignedToId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TestPlanCountAggregateOutputType | null
    _min: TestPlanMinAggregateOutputType | null
    _max: TestPlanMaxAggregateOutputType | null
  }

  type GetTestPlanGroupByPayload<T extends TestPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestPlanGroupByOutputType[P]>
            : GetScalarType<T[P], TestPlanGroupByOutputType[P]>
        }
      >
    >


  export type TestPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    status?: boolean
    projectId?: boolean
    feature?: boolean
    environment?: boolean
    startDate?: boolean
    endDate?: boolean
    createdById?: boolean
    assignedToId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | TestPlan$assignedToArgs<ExtArgs>
    testCases?: boolean | TestPlan$testCasesArgs<ExtArgs>
    executions?: boolean | TestPlan$executionsArgs<ExtArgs>
    reviews?: boolean | TestPlan$reviewsArgs<ExtArgs>
    _count?: boolean | TestPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testPlan"]>

  export type TestPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    status?: boolean
    projectId?: boolean
    feature?: boolean
    environment?: boolean
    startDate?: boolean
    endDate?: boolean
    createdById?: boolean
    assignedToId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | TestPlan$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["testPlan"]>

  export type TestPlanSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    status?: boolean
    projectId?: boolean
    feature?: boolean
    environment?: boolean
    startDate?: boolean
    endDate?: boolean
    createdById?: boolean
    assignedToId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TestPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | TestPlan$assignedToArgs<ExtArgs>
    testCases?: boolean | TestPlan$testCasesArgs<ExtArgs>
    executions?: boolean | TestPlan$executionsArgs<ExtArgs>
    reviews?: boolean | TestPlan$reviewsArgs<ExtArgs>
    _count?: boolean | TestPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TestPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | TestPlan$assignedToArgs<ExtArgs>
  }

  export type $TestPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestPlan"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
      testCases: Prisma.$TestCasePayload<ExtArgs>[]
      executions: Prisma.$TestExecutionPayload<ExtArgs>[]
      reviews: Prisma.$QAReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      version: string
      status: $Enums.TestPlanStatus
      projectId: string | null
      feature: string | null
      environment: string | null
      startDate: Date | null
      endDate: Date | null
      createdById: string
      assignedToId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["testPlan"]>
    composites: {}
  }

  type TestPlanGetPayload<S extends boolean | null | undefined | TestPlanDefaultArgs> = $Result.GetResult<Prisma.$TestPlanPayload, S>

  type TestPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TestPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TestPlanCountAggregateInputType | true
    }

  export interface TestPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestPlan'], meta: { name: 'TestPlan' } }
    /**
     * Find zero or one TestPlan that matches the filter.
     * @param {TestPlanFindUniqueArgs} args - Arguments to find a TestPlan
     * @example
     * // Get one TestPlan
     * const testPlan = await prisma.testPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestPlanFindUniqueArgs>(args: SelectSubset<T, TestPlanFindUniqueArgs<ExtArgs>>): Prisma__TestPlanClient<$Result.GetResult<Prisma.$TestPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TestPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TestPlanFindUniqueOrThrowArgs} args - Arguments to find a TestPlan
     * @example
     * // Get one TestPlan
     * const testPlan = await prisma.testPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, TestPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestPlanClient<$Result.GetResult<Prisma.$TestPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TestPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestPlanFindFirstArgs} args - Arguments to find a TestPlan
     * @example
     * // Get one TestPlan
     * const testPlan = await prisma.testPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestPlanFindFirstArgs>(args?: SelectSubset<T, TestPlanFindFirstArgs<ExtArgs>>): Prisma__TestPlanClient<$Result.GetResult<Prisma.$TestPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TestPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestPlanFindFirstOrThrowArgs} args - Arguments to find a TestPlan
     * @example
     * // Get one TestPlan
     * const testPlan = await prisma.testPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, TestPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestPlanClient<$Result.GetResult<Prisma.$TestPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TestPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestPlans
     * const testPlans = await prisma.testPlan.findMany()
     * 
     * // Get first 10 TestPlans
     * const testPlans = await prisma.testPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testPlanWithIdOnly = await prisma.testPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestPlanFindManyArgs>(args?: SelectSubset<T, TestPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TestPlan.
     * @param {TestPlanCreateArgs} args - Arguments to create a TestPlan.
     * @example
     * // Create one TestPlan
     * const TestPlan = await prisma.testPlan.create({
     *   data: {
     *     // ... data to create a TestPlan
     *   }
     * })
     * 
     */
    create<T extends TestPlanCreateArgs>(args: SelectSubset<T, TestPlanCreateArgs<ExtArgs>>): Prisma__TestPlanClient<$Result.GetResult<Prisma.$TestPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TestPlans.
     * @param {TestPlanCreateManyArgs} args - Arguments to create many TestPlans.
     * @example
     * // Create many TestPlans
     * const testPlan = await prisma.testPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestPlanCreateManyArgs>(args?: SelectSubset<T, TestPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestPlans and returns the data saved in the database.
     * @param {TestPlanCreateManyAndReturnArgs} args - Arguments to create many TestPlans.
     * @example
     * // Create many TestPlans
     * const testPlan = await prisma.testPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestPlans and only return the `id`
     * const testPlanWithIdOnly = await prisma.testPlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, TestPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestPlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TestPlan.
     * @param {TestPlanDeleteArgs} args - Arguments to delete one TestPlan.
     * @example
     * // Delete one TestPlan
     * const TestPlan = await prisma.testPlan.delete({
     *   where: {
     *     // ... filter to delete one TestPlan
     *   }
     * })
     * 
     */
    delete<T extends TestPlanDeleteArgs>(args: SelectSubset<T, TestPlanDeleteArgs<ExtArgs>>): Prisma__TestPlanClient<$Result.GetResult<Prisma.$TestPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TestPlan.
     * @param {TestPlanUpdateArgs} args - Arguments to update one TestPlan.
     * @example
     * // Update one TestPlan
     * const testPlan = await prisma.testPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestPlanUpdateArgs>(args: SelectSubset<T, TestPlanUpdateArgs<ExtArgs>>): Prisma__TestPlanClient<$Result.GetResult<Prisma.$TestPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TestPlans.
     * @param {TestPlanDeleteManyArgs} args - Arguments to filter TestPlans to delete.
     * @example
     * // Delete a few TestPlans
     * const { count } = await prisma.testPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestPlanDeleteManyArgs>(args?: SelectSubset<T, TestPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestPlans
     * const testPlan = await prisma.testPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestPlanUpdateManyArgs>(args: SelectSubset<T, TestPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TestPlan.
     * @param {TestPlanUpsertArgs} args - Arguments to update or create a TestPlan.
     * @example
     * // Update or create a TestPlan
     * const testPlan = await prisma.testPlan.upsert({
     *   create: {
     *     // ... data to create a TestPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestPlan we want to update
     *   }
     * })
     */
    upsert<T extends TestPlanUpsertArgs>(args: SelectSubset<T, TestPlanUpsertArgs<ExtArgs>>): Prisma__TestPlanClient<$Result.GetResult<Prisma.$TestPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TestPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestPlanCountArgs} args - Arguments to filter TestPlans to count.
     * @example
     * // Count the number of TestPlans
     * const count = await prisma.testPlan.count({
     *   where: {
     *     // ... the filter for the TestPlans we want to count
     *   }
     * })
    **/
    count<T extends TestPlanCountArgs>(
      args?: Subset<T, TestPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestPlanAggregateArgs>(args: Subset<T, TestPlanAggregateArgs>): Prisma.PrismaPromise<GetTestPlanAggregateType<T>>

    /**
     * Group by TestPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestPlanGroupByArgs['orderBy'] }
        : { orderBy?: TestPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestPlan model
   */
  readonly fields: TestPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assignedTo<T extends TestPlan$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, TestPlan$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    testCases<T extends TestPlan$testCasesArgs<ExtArgs> = {}>(args?: Subset<T, TestPlan$testCasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "findMany"> | Null>
    executions<T extends TestPlan$executionsArgs<ExtArgs> = {}>(args?: Subset<T, TestPlan$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    reviews<T extends TestPlan$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, TestPlan$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QAReviewPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestPlan model
   */ 
  interface TestPlanFieldRefs {
    readonly id: FieldRef<"TestPlan", 'String'>
    readonly name: FieldRef<"TestPlan", 'String'>
    readonly description: FieldRef<"TestPlan", 'String'>
    readonly version: FieldRef<"TestPlan", 'String'>
    readonly status: FieldRef<"TestPlan", 'TestPlanStatus'>
    readonly projectId: FieldRef<"TestPlan", 'String'>
    readonly feature: FieldRef<"TestPlan", 'String'>
    readonly environment: FieldRef<"TestPlan", 'String'>
    readonly startDate: FieldRef<"TestPlan", 'DateTime'>
    readonly endDate: FieldRef<"TestPlan", 'DateTime'>
    readonly createdById: FieldRef<"TestPlan", 'String'>
    readonly assignedToId: FieldRef<"TestPlan", 'String'>
    readonly createdAt: FieldRef<"TestPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"TestPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TestPlan findUnique
   */
  export type TestPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPlan
     */
    select?: TestPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPlanInclude<ExtArgs> | null
    /**
     * Filter, which TestPlan to fetch.
     */
    where: TestPlanWhereUniqueInput
  }

  /**
   * TestPlan findUniqueOrThrow
   */
  export type TestPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPlan
     */
    select?: TestPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPlanInclude<ExtArgs> | null
    /**
     * Filter, which TestPlan to fetch.
     */
    where: TestPlanWhereUniqueInput
  }

  /**
   * TestPlan findFirst
   */
  export type TestPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPlan
     */
    select?: TestPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPlanInclude<ExtArgs> | null
    /**
     * Filter, which TestPlan to fetch.
     */
    where?: TestPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestPlans to fetch.
     */
    orderBy?: TestPlanOrderByWithRelationInput | TestPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestPlans.
     */
    cursor?: TestPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestPlans.
     */
    distinct?: TestPlanScalarFieldEnum | TestPlanScalarFieldEnum[]
  }

  /**
   * TestPlan findFirstOrThrow
   */
  export type TestPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPlan
     */
    select?: TestPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPlanInclude<ExtArgs> | null
    /**
     * Filter, which TestPlan to fetch.
     */
    where?: TestPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestPlans to fetch.
     */
    orderBy?: TestPlanOrderByWithRelationInput | TestPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestPlans.
     */
    cursor?: TestPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestPlans.
     */
    distinct?: TestPlanScalarFieldEnum | TestPlanScalarFieldEnum[]
  }

  /**
   * TestPlan findMany
   */
  export type TestPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPlan
     */
    select?: TestPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPlanInclude<ExtArgs> | null
    /**
     * Filter, which TestPlans to fetch.
     */
    where?: TestPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestPlans to fetch.
     */
    orderBy?: TestPlanOrderByWithRelationInput | TestPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestPlans.
     */
    cursor?: TestPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestPlans.
     */
    skip?: number
    distinct?: TestPlanScalarFieldEnum | TestPlanScalarFieldEnum[]
  }

  /**
   * TestPlan create
   */
  export type TestPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPlan
     */
    select?: TestPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a TestPlan.
     */
    data: XOR<TestPlanCreateInput, TestPlanUncheckedCreateInput>
  }

  /**
   * TestPlan createMany
   */
  export type TestPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestPlans.
     */
    data: TestPlanCreateManyInput | TestPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestPlan createManyAndReturn
   */
  export type TestPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPlan
     */
    select?: TestPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TestPlans.
     */
    data: TestPlanCreateManyInput | TestPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestPlan update
   */
  export type TestPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPlan
     */
    select?: TestPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a TestPlan.
     */
    data: XOR<TestPlanUpdateInput, TestPlanUncheckedUpdateInput>
    /**
     * Choose, which TestPlan to update.
     */
    where: TestPlanWhereUniqueInput
  }

  /**
   * TestPlan updateMany
   */
  export type TestPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestPlans.
     */
    data: XOR<TestPlanUpdateManyMutationInput, TestPlanUncheckedUpdateManyInput>
    /**
     * Filter which TestPlans to update
     */
    where?: TestPlanWhereInput
  }

  /**
   * TestPlan upsert
   */
  export type TestPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPlan
     */
    select?: TestPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the TestPlan to update in case it exists.
     */
    where: TestPlanWhereUniqueInput
    /**
     * In case the TestPlan found by the `where` argument doesn't exist, create a new TestPlan with this data.
     */
    create: XOR<TestPlanCreateInput, TestPlanUncheckedCreateInput>
    /**
     * In case the TestPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestPlanUpdateInput, TestPlanUncheckedUpdateInput>
  }

  /**
   * TestPlan delete
   */
  export type TestPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPlan
     */
    select?: TestPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPlanInclude<ExtArgs> | null
    /**
     * Filter which TestPlan to delete.
     */
    where: TestPlanWhereUniqueInput
  }

  /**
   * TestPlan deleteMany
   */
  export type TestPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestPlans to delete
     */
    where?: TestPlanWhereInput
  }

  /**
   * TestPlan.assignedTo
   */
  export type TestPlan$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TestPlan.testCases
   */
  export type TestPlan$testCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseInclude<ExtArgs> | null
    where?: TestCaseWhereInput
    orderBy?: TestCaseOrderByWithRelationInput | TestCaseOrderByWithRelationInput[]
    cursor?: TestCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestCaseScalarFieldEnum | TestCaseScalarFieldEnum[]
  }

  /**
   * TestPlan.executions
   */
  export type TestPlan$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestExecution
     */
    select?: TestExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestExecutionInclude<ExtArgs> | null
    where?: TestExecutionWhereInput
    orderBy?: TestExecutionOrderByWithRelationInput | TestExecutionOrderByWithRelationInput[]
    cursor?: TestExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestExecutionScalarFieldEnum | TestExecutionScalarFieldEnum[]
  }

  /**
   * TestPlan.reviews
   */
  export type TestPlan$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAReview
     */
    select?: QAReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAReviewInclude<ExtArgs> | null
    where?: QAReviewWhereInput
    orderBy?: QAReviewOrderByWithRelationInput | QAReviewOrderByWithRelationInput[]
    cursor?: QAReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QAReviewScalarFieldEnum | QAReviewScalarFieldEnum[]
  }

  /**
   * TestPlan without action
   */
  export type TestPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPlan
     */
    select?: TestPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPlanInclude<ExtArgs> | null
  }


  /**
   * Model TestCase
   */

  export type AggregateTestCase = {
    _count: TestCaseCountAggregateOutputType | null
    _avg: TestCaseAvgAggregateOutputType | null
    _sum: TestCaseSumAggregateOutputType | null
    _min: TestCaseMinAggregateOutputType | null
    _max: TestCaseMaxAggregateOutputType | null
  }

  export type TestCaseAvgAggregateOutputType = {
    estimatedTime: number | null
  }

  export type TestCaseSumAggregateOutputType = {
    estimatedTime: number | null
  }

  export type TestCaseMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    preconditions: string | null
    expectedResult: string | null
    priority: $Enums.TestCasePriority | null
    status: $Enums.TestCaseStatus | null
    automatable: boolean | null
    estimatedTime: number | null
    testPlanId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestCaseMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    preconditions: string | null
    expectedResult: string | null
    priority: $Enums.TestCasePriority | null
    status: $Enums.TestCaseStatus | null
    automatable: boolean | null
    estimatedTime: number | null
    testPlanId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestCaseCountAggregateOutputType = {
    id: number
    title: number
    description: number
    preconditions: number
    steps: number
    expectedResult: number
    priority: number
    status: number
    tags: number
    automatable: number
    estimatedTime: number
    testPlanId: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TestCaseAvgAggregateInputType = {
    estimatedTime?: true
  }

  export type TestCaseSumAggregateInputType = {
    estimatedTime?: true
  }

  export type TestCaseMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    preconditions?: true
    expectedResult?: true
    priority?: true
    status?: true
    automatable?: true
    estimatedTime?: true
    testPlanId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestCaseMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    preconditions?: true
    expectedResult?: true
    priority?: true
    status?: true
    automatable?: true
    estimatedTime?: true
    testPlanId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestCaseCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    preconditions?: true
    steps?: true
    expectedResult?: true
    priority?: true
    status?: true
    tags?: true
    automatable?: true
    estimatedTime?: true
    testPlanId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TestCaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestCase to aggregate.
     */
    where?: TestCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestCases to fetch.
     */
    orderBy?: TestCaseOrderByWithRelationInput | TestCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestCases
    **/
    _count?: true | TestCaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestCaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestCaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestCaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestCaseMaxAggregateInputType
  }

  export type GetTestCaseAggregateType<T extends TestCaseAggregateArgs> = {
        [P in keyof T & keyof AggregateTestCase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestCase[P]>
      : GetScalarType<T[P], AggregateTestCase[P]>
  }




  export type TestCaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestCaseWhereInput
    orderBy?: TestCaseOrderByWithAggregationInput | TestCaseOrderByWithAggregationInput[]
    by: TestCaseScalarFieldEnum[] | TestCaseScalarFieldEnum
    having?: TestCaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestCaseCountAggregateInputType | true
    _avg?: TestCaseAvgAggregateInputType
    _sum?: TestCaseSumAggregateInputType
    _min?: TestCaseMinAggregateInputType
    _max?: TestCaseMaxAggregateInputType
  }

  export type TestCaseGroupByOutputType = {
    id: string
    title: string
    description: string | null
    preconditions: string | null
    steps: JsonValue
    expectedResult: string | null
    priority: $Enums.TestCasePriority
    status: $Enums.TestCaseStatus
    tags: string[]
    automatable: boolean
    estimatedTime: number | null
    testPlanId: string
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: TestCaseCountAggregateOutputType | null
    _avg: TestCaseAvgAggregateOutputType | null
    _sum: TestCaseSumAggregateOutputType | null
    _min: TestCaseMinAggregateOutputType | null
    _max: TestCaseMaxAggregateOutputType | null
  }

  type GetTestCaseGroupByPayload<T extends TestCaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestCaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestCaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestCaseGroupByOutputType[P]>
            : GetScalarType<T[P], TestCaseGroupByOutputType[P]>
        }
      >
    >


  export type TestCaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    preconditions?: boolean
    steps?: boolean
    expectedResult?: boolean
    priority?: boolean
    status?: boolean
    tags?: boolean
    automatable?: boolean
    estimatedTime?: boolean
    testPlanId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    testPlan?: boolean | TestPlanDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    executions?: boolean | TestCase$executionsArgs<ExtArgs>
    defects?: boolean | TestCase$defectsArgs<ExtArgs>
    _count?: boolean | TestCaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testCase"]>

  export type TestCaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    preconditions?: boolean
    steps?: boolean
    expectedResult?: boolean
    priority?: boolean
    status?: boolean
    tags?: boolean
    automatable?: boolean
    estimatedTime?: boolean
    testPlanId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    testPlan?: boolean | TestPlanDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testCase"]>

  export type TestCaseSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    preconditions?: boolean
    steps?: boolean
    expectedResult?: boolean
    priority?: boolean
    status?: boolean
    tags?: boolean
    automatable?: boolean
    estimatedTime?: boolean
    testPlanId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TestCaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testPlan?: boolean | TestPlanDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    executions?: boolean | TestCase$executionsArgs<ExtArgs>
    defects?: boolean | TestCase$defectsArgs<ExtArgs>
    _count?: boolean | TestCaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TestCaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testPlan?: boolean | TestPlanDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TestCasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestCase"
    objects: {
      testPlan: Prisma.$TestPlanPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      executions: Prisma.$TestExecutionPayload<ExtArgs>[]
      defects: Prisma.$DefectTestCasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      preconditions: string | null
      steps: Prisma.JsonValue
      expectedResult: string | null
      priority: $Enums.TestCasePriority
      status: $Enums.TestCaseStatus
      tags: string[]
      automatable: boolean
      estimatedTime: number | null
      testPlanId: string
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["testCase"]>
    composites: {}
  }

  type TestCaseGetPayload<S extends boolean | null | undefined | TestCaseDefaultArgs> = $Result.GetResult<Prisma.$TestCasePayload, S>

  type TestCaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TestCaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TestCaseCountAggregateInputType | true
    }

  export interface TestCaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestCase'], meta: { name: 'TestCase' } }
    /**
     * Find zero or one TestCase that matches the filter.
     * @param {TestCaseFindUniqueArgs} args - Arguments to find a TestCase
     * @example
     * // Get one TestCase
     * const testCase = await prisma.testCase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestCaseFindUniqueArgs>(args: SelectSubset<T, TestCaseFindUniqueArgs<ExtArgs>>): Prisma__TestCaseClient<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TestCase that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TestCaseFindUniqueOrThrowArgs} args - Arguments to find a TestCase
     * @example
     * // Get one TestCase
     * const testCase = await prisma.testCase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestCaseFindUniqueOrThrowArgs>(args: SelectSubset<T, TestCaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestCaseClient<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TestCase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCaseFindFirstArgs} args - Arguments to find a TestCase
     * @example
     * // Get one TestCase
     * const testCase = await prisma.testCase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestCaseFindFirstArgs>(args?: SelectSubset<T, TestCaseFindFirstArgs<ExtArgs>>): Prisma__TestCaseClient<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TestCase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCaseFindFirstOrThrowArgs} args - Arguments to find a TestCase
     * @example
     * // Get one TestCase
     * const testCase = await prisma.testCase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestCaseFindFirstOrThrowArgs>(args?: SelectSubset<T, TestCaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestCaseClient<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TestCases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestCases
     * const testCases = await prisma.testCase.findMany()
     * 
     * // Get first 10 TestCases
     * const testCases = await prisma.testCase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testCaseWithIdOnly = await prisma.testCase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestCaseFindManyArgs>(args?: SelectSubset<T, TestCaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TestCase.
     * @param {TestCaseCreateArgs} args - Arguments to create a TestCase.
     * @example
     * // Create one TestCase
     * const TestCase = await prisma.testCase.create({
     *   data: {
     *     // ... data to create a TestCase
     *   }
     * })
     * 
     */
    create<T extends TestCaseCreateArgs>(args: SelectSubset<T, TestCaseCreateArgs<ExtArgs>>): Prisma__TestCaseClient<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TestCases.
     * @param {TestCaseCreateManyArgs} args - Arguments to create many TestCases.
     * @example
     * // Create many TestCases
     * const testCase = await prisma.testCase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestCaseCreateManyArgs>(args?: SelectSubset<T, TestCaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestCases and returns the data saved in the database.
     * @param {TestCaseCreateManyAndReturnArgs} args - Arguments to create many TestCases.
     * @example
     * // Create many TestCases
     * const testCase = await prisma.testCase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestCases and only return the `id`
     * const testCaseWithIdOnly = await prisma.testCase.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestCaseCreateManyAndReturnArgs>(args?: SelectSubset<T, TestCaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TestCase.
     * @param {TestCaseDeleteArgs} args - Arguments to delete one TestCase.
     * @example
     * // Delete one TestCase
     * const TestCase = await prisma.testCase.delete({
     *   where: {
     *     // ... filter to delete one TestCase
     *   }
     * })
     * 
     */
    delete<T extends TestCaseDeleteArgs>(args: SelectSubset<T, TestCaseDeleteArgs<ExtArgs>>): Prisma__TestCaseClient<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TestCase.
     * @param {TestCaseUpdateArgs} args - Arguments to update one TestCase.
     * @example
     * // Update one TestCase
     * const testCase = await prisma.testCase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestCaseUpdateArgs>(args: SelectSubset<T, TestCaseUpdateArgs<ExtArgs>>): Prisma__TestCaseClient<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TestCases.
     * @param {TestCaseDeleteManyArgs} args - Arguments to filter TestCases to delete.
     * @example
     * // Delete a few TestCases
     * const { count } = await prisma.testCase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestCaseDeleteManyArgs>(args?: SelectSubset<T, TestCaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestCases
     * const testCase = await prisma.testCase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestCaseUpdateManyArgs>(args: SelectSubset<T, TestCaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TestCase.
     * @param {TestCaseUpsertArgs} args - Arguments to update or create a TestCase.
     * @example
     * // Update or create a TestCase
     * const testCase = await prisma.testCase.upsert({
     *   create: {
     *     // ... data to create a TestCase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestCase we want to update
     *   }
     * })
     */
    upsert<T extends TestCaseUpsertArgs>(args: SelectSubset<T, TestCaseUpsertArgs<ExtArgs>>): Prisma__TestCaseClient<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TestCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCaseCountArgs} args - Arguments to filter TestCases to count.
     * @example
     * // Count the number of TestCases
     * const count = await prisma.testCase.count({
     *   where: {
     *     // ... the filter for the TestCases we want to count
     *   }
     * })
    **/
    count<T extends TestCaseCountArgs>(
      args?: Subset<T, TestCaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestCaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestCaseAggregateArgs>(args: Subset<T, TestCaseAggregateArgs>): Prisma.PrismaPromise<GetTestCaseAggregateType<T>>

    /**
     * Group by TestCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestCaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestCaseGroupByArgs['orderBy'] }
        : { orderBy?: TestCaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestCaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestCaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestCase model
   */
  readonly fields: TestCaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestCase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestCaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    testPlan<T extends TestPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestPlanDefaultArgs<ExtArgs>>): Prisma__TestPlanClient<$Result.GetResult<Prisma.$TestPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    executions<T extends TestCase$executionsArgs<ExtArgs> = {}>(args?: Subset<T, TestCase$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    defects<T extends TestCase$defectsArgs<ExtArgs> = {}>(args?: Subset<T, TestCase$defectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefectTestCasePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestCase model
   */ 
  interface TestCaseFieldRefs {
    readonly id: FieldRef<"TestCase", 'String'>
    readonly title: FieldRef<"TestCase", 'String'>
    readonly description: FieldRef<"TestCase", 'String'>
    readonly preconditions: FieldRef<"TestCase", 'String'>
    readonly steps: FieldRef<"TestCase", 'Json'>
    readonly expectedResult: FieldRef<"TestCase", 'String'>
    readonly priority: FieldRef<"TestCase", 'TestCasePriority'>
    readonly status: FieldRef<"TestCase", 'TestCaseStatus'>
    readonly tags: FieldRef<"TestCase", 'String[]'>
    readonly automatable: FieldRef<"TestCase", 'Boolean'>
    readonly estimatedTime: FieldRef<"TestCase", 'Int'>
    readonly testPlanId: FieldRef<"TestCase", 'String'>
    readonly createdById: FieldRef<"TestCase", 'String'>
    readonly createdAt: FieldRef<"TestCase", 'DateTime'>
    readonly updatedAt: FieldRef<"TestCase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TestCase findUnique
   */
  export type TestCaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseInclude<ExtArgs> | null
    /**
     * Filter, which TestCase to fetch.
     */
    where: TestCaseWhereUniqueInput
  }

  /**
   * TestCase findUniqueOrThrow
   */
  export type TestCaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseInclude<ExtArgs> | null
    /**
     * Filter, which TestCase to fetch.
     */
    where: TestCaseWhereUniqueInput
  }

  /**
   * TestCase findFirst
   */
  export type TestCaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseInclude<ExtArgs> | null
    /**
     * Filter, which TestCase to fetch.
     */
    where?: TestCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestCases to fetch.
     */
    orderBy?: TestCaseOrderByWithRelationInput | TestCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestCases.
     */
    cursor?: TestCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestCases.
     */
    distinct?: TestCaseScalarFieldEnum | TestCaseScalarFieldEnum[]
  }

  /**
   * TestCase findFirstOrThrow
   */
  export type TestCaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseInclude<ExtArgs> | null
    /**
     * Filter, which TestCase to fetch.
     */
    where?: TestCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestCases to fetch.
     */
    orderBy?: TestCaseOrderByWithRelationInput | TestCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestCases.
     */
    cursor?: TestCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestCases.
     */
    distinct?: TestCaseScalarFieldEnum | TestCaseScalarFieldEnum[]
  }

  /**
   * TestCase findMany
   */
  export type TestCaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseInclude<ExtArgs> | null
    /**
     * Filter, which TestCases to fetch.
     */
    where?: TestCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestCases to fetch.
     */
    orderBy?: TestCaseOrderByWithRelationInput | TestCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestCases.
     */
    cursor?: TestCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestCases.
     */
    skip?: number
    distinct?: TestCaseScalarFieldEnum | TestCaseScalarFieldEnum[]
  }

  /**
   * TestCase create
   */
  export type TestCaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseInclude<ExtArgs> | null
    /**
     * The data needed to create a TestCase.
     */
    data: XOR<TestCaseCreateInput, TestCaseUncheckedCreateInput>
  }

  /**
   * TestCase createMany
   */
  export type TestCaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestCases.
     */
    data: TestCaseCreateManyInput | TestCaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestCase createManyAndReturn
   */
  export type TestCaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TestCases.
     */
    data: TestCaseCreateManyInput | TestCaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestCase update
   */
  export type TestCaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseInclude<ExtArgs> | null
    /**
     * The data needed to update a TestCase.
     */
    data: XOR<TestCaseUpdateInput, TestCaseUncheckedUpdateInput>
    /**
     * Choose, which TestCase to update.
     */
    where: TestCaseWhereUniqueInput
  }

  /**
   * TestCase updateMany
   */
  export type TestCaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestCases.
     */
    data: XOR<TestCaseUpdateManyMutationInput, TestCaseUncheckedUpdateManyInput>
    /**
     * Filter which TestCases to update
     */
    where?: TestCaseWhereInput
  }

  /**
   * TestCase upsert
   */
  export type TestCaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseInclude<ExtArgs> | null
    /**
     * The filter to search for the TestCase to update in case it exists.
     */
    where: TestCaseWhereUniqueInput
    /**
     * In case the TestCase found by the `where` argument doesn't exist, create a new TestCase with this data.
     */
    create: XOR<TestCaseCreateInput, TestCaseUncheckedCreateInput>
    /**
     * In case the TestCase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestCaseUpdateInput, TestCaseUncheckedUpdateInput>
  }

  /**
   * TestCase delete
   */
  export type TestCaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseInclude<ExtArgs> | null
    /**
     * Filter which TestCase to delete.
     */
    where: TestCaseWhereUniqueInput
  }

  /**
   * TestCase deleteMany
   */
  export type TestCaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestCases to delete
     */
    where?: TestCaseWhereInput
  }

  /**
   * TestCase.executions
   */
  export type TestCase$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestExecution
     */
    select?: TestExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestExecutionInclude<ExtArgs> | null
    where?: TestExecutionWhereInput
    orderBy?: TestExecutionOrderByWithRelationInput | TestExecutionOrderByWithRelationInput[]
    cursor?: TestExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestExecutionScalarFieldEnum | TestExecutionScalarFieldEnum[]
  }

  /**
   * TestCase.defects
   */
  export type TestCase$defectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectTestCase
     */
    select?: DefectTestCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectTestCaseInclude<ExtArgs> | null
    where?: DefectTestCaseWhereInput
    orderBy?: DefectTestCaseOrderByWithRelationInput | DefectTestCaseOrderByWithRelationInput[]
    cursor?: DefectTestCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DefectTestCaseScalarFieldEnum | DefectTestCaseScalarFieldEnum[]
  }

  /**
   * TestCase without action
   */
  export type TestCaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseInclude<ExtArgs> | null
  }


  /**
   * Model TestExecution
   */

  export type AggregateTestExecution = {
    _count: TestExecutionCountAggregateOutputType | null
    _avg: TestExecutionAvgAggregateOutputType | null
    _sum: TestExecutionSumAggregateOutputType | null
    _min: TestExecutionMinAggregateOutputType | null
    _max: TestExecutionMaxAggregateOutputType | null
  }

  export type TestExecutionAvgAggregateOutputType = {
    executionTime: number | null
  }

  export type TestExecutionSumAggregateOutputType = {
    executionTime: number | null
  }

  export type TestExecutionMinAggregateOutputType = {
    id: string | null
    testPlanId: string | null
    testCaseId: string | null
    status: $Enums.TestExecutionStatus | null
    result: string | null
    actualResult: string | null
    executionTime: number | null
    environment: string | null
    browserVersion: string | null
    osVersion: string | null
    notes: string | null
    executedById: string | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestExecutionMaxAggregateOutputType = {
    id: string | null
    testPlanId: string | null
    testCaseId: string | null
    status: $Enums.TestExecutionStatus | null
    result: string | null
    actualResult: string | null
    executionTime: number | null
    environment: string | null
    browserVersion: string | null
    osVersion: string | null
    notes: string | null
    executedById: string | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestExecutionCountAggregateOutputType = {
    id: number
    testPlanId: number
    testCaseId: number
    status: number
    result: number
    actualResult: number
    evidence: number
    executionTime: number
    environment: number
    browserVersion: number
    osVersion: number
    notes: number
    executedById: number
    startedAt: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TestExecutionAvgAggregateInputType = {
    executionTime?: true
  }

  export type TestExecutionSumAggregateInputType = {
    executionTime?: true
  }

  export type TestExecutionMinAggregateInputType = {
    id?: true
    testPlanId?: true
    testCaseId?: true
    status?: true
    result?: true
    actualResult?: true
    executionTime?: true
    environment?: true
    browserVersion?: true
    osVersion?: true
    notes?: true
    executedById?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestExecutionMaxAggregateInputType = {
    id?: true
    testPlanId?: true
    testCaseId?: true
    status?: true
    result?: true
    actualResult?: true
    executionTime?: true
    environment?: true
    browserVersion?: true
    osVersion?: true
    notes?: true
    executedById?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestExecutionCountAggregateInputType = {
    id?: true
    testPlanId?: true
    testCaseId?: true
    status?: true
    result?: true
    actualResult?: true
    evidence?: true
    executionTime?: true
    environment?: true
    browserVersion?: true
    osVersion?: true
    notes?: true
    executedById?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TestExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestExecution to aggregate.
     */
    where?: TestExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestExecutions to fetch.
     */
    orderBy?: TestExecutionOrderByWithRelationInput | TestExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestExecutions
    **/
    _count?: true | TestExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestExecutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestExecutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestExecutionMaxAggregateInputType
  }

  export type GetTestExecutionAggregateType<T extends TestExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateTestExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestExecution[P]>
      : GetScalarType<T[P], AggregateTestExecution[P]>
  }




  export type TestExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestExecutionWhereInput
    orderBy?: TestExecutionOrderByWithAggregationInput | TestExecutionOrderByWithAggregationInput[]
    by: TestExecutionScalarFieldEnum[] | TestExecutionScalarFieldEnum
    having?: TestExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestExecutionCountAggregateInputType | true
    _avg?: TestExecutionAvgAggregateInputType
    _sum?: TestExecutionSumAggregateInputType
    _min?: TestExecutionMinAggregateInputType
    _max?: TestExecutionMaxAggregateInputType
  }

  export type TestExecutionGroupByOutputType = {
    id: string
    testPlanId: string
    testCaseId: string
    status: $Enums.TestExecutionStatus
    result: string | null
    actualResult: string | null
    evidence: JsonValue | null
    executionTime: number | null
    environment: string | null
    browserVersion: string | null
    osVersion: string | null
    notes: string | null
    executedById: string
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TestExecutionCountAggregateOutputType | null
    _avg: TestExecutionAvgAggregateOutputType | null
    _sum: TestExecutionSumAggregateOutputType | null
    _min: TestExecutionMinAggregateOutputType | null
    _max: TestExecutionMaxAggregateOutputType | null
  }

  type GetTestExecutionGroupByPayload<T extends TestExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], TestExecutionGroupByOutputType[P]>
        }
      >
    >


  export type TestExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testPlanId?: boolean
    testCaseId?: boolean
    status?: boolean
    result?: boolean
    actualResult?: boolean
    evidence?: boolean
    executionTime?: boolean
    environment?: boolean
    browserVersion?: boolean
    osVersion?: boolean
    notes?: boolean
    executedById?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    testPlan?: boolean | TestPlanDefaultArgs<ExtArgs>
    testCase?: boolean | TestCaseDefaultArgs<ExtArgs>
    executedBy?: boolean | UserDefaultArgs<ExtArgs>
    defects?: boolean | TestExecution$defectsArgs<ExtArgs>
    _count?: boolean | TestExecutionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testExecution"]>

  export type TestExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testPlanId?: boolean
    testCaseId?: boolean
    status?: boolean
    result?: boolean
    actualResult?: boolean
    evidence?: boolean
    executionTime?: boolean
    environment?: boolean
    browserVersion?: boolean
    osVersion?: boolean
    notes?: boolean
    executedById?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    testPlan?: boolean | TestPlanDefaultArgs<ExtArgs>
    testCase?: boolean | TestCaseDefaultArgs<ExtArgs>
    executedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testExecution"]>

  export type TestExecutionSelectScalar = {
    id?: boolean
    testPlanId?: boolean
    testCaseId?: boolean
    status?: boolean
    result?: boolean
    actualResult?: boolean
    evidence?: boolean
    executionTime?: boolean
    environment?: boolean
    browserVersion?: boolean
    osVersion?: boolean
    notes?: boolean
    executedById?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TestExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testPlan?: boolean | TestPlanDefaultArgs<ExtArgs>
    testCase?: boolean | TestCaseDefaultArgs<ExtArgs>
    executedBy?: boolean | UserDefaultArgs<ExtArgs>
    defects?: boolean | TestExecution$defectsArgs<ExtArgs>
    _count?: boolean | TestExecutionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TestExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testPlan?: boolean | TestPlanDefaultArgs<ExtArgs>
    testCase?: boolean | TestCaseDefaultArgs<ExtArgs>
    executedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TestExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestExecution"
    objects: {
      testPlan: Prisma.$TestPlanPayload<ExtArgs>
      testCase: Prisma.$TestCasePayload<ExtArgs>
      executedBy: Prisma.$UserPayload<ExtArgs>
      defects: Prisma.$DefectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      testPlanId: string
      testCaseId: string
      status: $Enums.TestExecutionStatus
      result: string | null
      actualResult: string | null
      evidence: Prisma.JsonValue | null
      executionTime: number | null
      environment: string | null
      browserVersion: string | null
      osVersion: string | null
      notes: string | null
      executedById: string
      startedAt: Date | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["testExecution"]>
    composites: {}
  }

  type TestExecutionGetPayload<S extends boolean | null | undefined | TestExecutionDefaultArgs> = $Result.GetResult<Prisma.$TestExecutionPayload, S>

  type TestExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TestExecutionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TestExecutionCountAggregateInputType | true
    }

  export interface TestExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestExecution'], meta: { name: 'TestExecution' } }
    /**
     * Find zero or one TestExecution that matches the filter.
     * @param {TestExecutionFindUniqueArgs} args - Arguments to find a TestExecution
     * @example
     * // Get one TestExecution
     * const testExecution = await prisma.testExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestExecutionFindUniqueArgs>(args: SelectSubset<T, TestExecutionFindUniqueArgs<ExtArgs>>): Prisma__TestExecutionClient<$Result.GetResult<Prisma.$TestExecutionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TestExecution that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TestExecutionFindUniqueOrThrowArgs} args - Arguments to find a TestExecution
     * @example
     * // Get one TestExecution
     * const testExecution = await prisma.testExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, TestExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestExecutionClient<$Result.GetResult<Prisma.$TestExecutionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TestExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestExecutionFindFirstArgs} args - Arguments to find a TestExecution
     * @example
     * // Get one TestExecution
     * const testExecution = await prisma.testExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestExecutionFindFirstArgs>(args?: SelectSubset<T, TestExecutionFindFirstArgs<ExtArgs>>): Prisma__TestExecutionClient<$Result.GetResult<Prisma.$TestExecutionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TestExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestExecutionFindFirstOrThrowArgs} args - Arguments to find a TestExecution
     * @example
     * // Get one TestExecution
     * const testExecution = await prisma.testExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, TestExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestExecutionClient<$Result.GetResult<Prisma.$TestExecutionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TestExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestExecutions
     * const testExecutions = await prisma.testExecution.findMany()
     * 
     * // Get first 10 TestExecutions
     * const testExecutions = await prisma.testExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testExecutionWithIdOnly = await prisma.testExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestExecutionFindManyArgs>(args?: SelectSubset<T, TestExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestExecutionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TestExecution.
     * @param {TestExecutionCreateArgs} args - Arguments to create a TestExecution.
     * @example
     * // Create one TestExecution
     * const TestExecution = await prisma.testExecution.create({
     *   data: {
     *     // ... data to create a TestExecution
     *   }
     * })
     * 
     */
    create<T extends TestExecutionCreateArgs>(args: SelectSubset<T, TestExecutionCreateArgs<ExtArgs>>): Prisma__TestExecutionClient<$Result.GetResult<Prisma.$TestExecutionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TestExecutions.
     * @param {TestExecutionCreateManyArgs} args - Arguments to create many TestExecutions.
     * @example
     * // Create many TestExecutions
     * const testExecution = await prisma.testExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestExecutionCreateManyArgs>(args?: SelectSubset<T, TestExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestExecutions and returns the data saved in the database.
     * @param {TestExecutionCreateManyAndReturnArgs} args - Arguments to create many TestExecutions.
     * @example
     * // Create many TestExecutions
     * const testExecution = await prisma.testExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestExecutions and only return the `id`
     * const testExecutionWithIdOnly = await prisma.testExecution.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, TestExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestExecutionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TestExecution.
     * @param {TestExecutionDeleteArgs} args - Arguments to delete one TestExecution.
     * @example
     * // Delete one TestExecution
     * const TestExecution = await prisma.testExecution.delete({
     *   where: {
     *     // ... filter to delete one TestExecution
     *   }
     * })
     * 
     */
    delete<T extends TestExecutionDeleteArgs>(args: SelectSubset<T, TestExecutionDeleteArgs<ExtArgs>>): Prisma__TestExecutionClient<$Result.GetResult<Prisma.$TestExecutionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TestExecution.
     * @param {TestExecutionUpdateArgs} args - Arguments to update one TestExecution.
     * @example
     * // Update one TestExecution
     * const testExecution = await prisma.testExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestExecutionUpdateArgs>(args: SelectSubset<T, TestExecutionUpdateArgs<ExtArgs>>): Prisma__TestExecutionClient<$Result.GetResult<Prisma.$TestExecutionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TestExecutions.
     * @param {TestExecutionDeleteManyArgs} args - Arguments to filter TestExecutions to delete.
     * @example
     * // Delete a few TestExecutions
     * const { count } = await prisma.testExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestExecutionDeleteManyArgs>(args?: SelectSubset<T, TestExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestExecutions
     * const testExecution = await prisma.testExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestExecutionUpdateManyArgs>(args: SelectSubset<T, TestExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TestExecution.
     * @param {TestExecutionUpsertArgs} args - Arguments to update or create a TestExecution.
     * @example
     * // Update or create a TestExecution
     * const testExecution = await prisma.testExecution.upsert({
     *   create: {
     *     // ... data to create a TestExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestExecution we want to update
     *   }
     * })
     */
    upsert<T extends TestExecutionUpsertArgs>(args: SelectSubset<T, TestExecutionUpsertArgs<ExtArgs>>): Prisma__TestExecutionClient<$Result.GetResult<Prisma.$TestExecutionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TestExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestExecutionCountArgs} args - Arguments to filter TestExecutions to count.
     * @example
     * // Count the number of TestExecutions
     * const count = await prisma.testExecution.count({
     *   where: {
     *     // ... the filter for the TestExecutions we want to count
     *   }
     * })
    **/
    count<T extends TestExecutionCountArgs>(
      args?: Subset<T, TestExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestExecutionAggregateArgs>(args: Subset<T, TestExecutionAggregateArgs>): Prisma.PrismaPromise<GetTestExecutionAggregateType<T>>

    /**
     * Group by TestExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestExecutionGroupByArgs['orderBy'] }
        : { orderBy?: TestExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestExecution model
   */
  readonly fields: TestExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    testPlan<T extends TestPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestPlanDefaultArgs<ExtArgs>>): Prisma__TestPlanClient<$Result.GetResult<Prisma.$TestPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    testCase<T extends TestCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestCaseDefaultArgs<ExtArgs>>): Prisma__TestCaseClient<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    executedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    defects<T extends TestExecution$defectsArgs<ExtArgs> = {}>(args?: Subset<T, TestExecution$defectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefectPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestExecution model
   */ 
  interface TestExecutionFieldRefs {
    readonly id: FieldRef<"TestExecution", 'String'>
    readonly testPlanId: FieldRef<"TestExecution", 'String'>
    readonly testCaseId: FieldRef<"TestExecution", 'String'>
    readonly status: FieldRef<"TestExecution", 'TestExecutionStatus'>
    readonly result: FieldRef<"TestExecution", 'String'>
    readonly actualResult: FieldRef<"TestExecution", 'String'>
    readonly evidence: FieldRef<"TestExecution", 'Json'>
    readonly executionTime: FieldRef<"TestExecution", 'Int'>
    readonly environment: FieldRef<"TestExecution", 'String'>
    readonly browserVersion: FieldRef<"TestExecution", 'String'>
    readonly osVersion: FieldRef<"TestExecution", 'String'>
    readonly notes: FieldRef<"TestExecution", 'String'>
    readonly executedById: FieldRef<"TestExecution", 'String'>
    readonly startedAt: FieldRef<"TestExecution", 'DateTime'>
    readonly completedAt: FieldRef<"TestExecution", 'DateTime'>
    readonly createdAt: FieldRef<"TestExecution", 'DateTime'>
    readonly updatedAt: FieldRef<"TestExecution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TestExecution findUnique
   */
  export type TestExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestExecution
     */
    select?: TestExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestExecutionInclude<ExtArgs> | null
    /**
     * Filter, which TestExecution to fetch.
     */
    where: TestExecutionWhereUniqueInput
  }

  /**
   * TestExecution findUniqueOrThrow
   */
  export type TestExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestExecution
     */
    select?: TestExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestExecutionInclude<ExtArgs> | null
    /**
     * Filter, which TestExecution to fetch.
     */
    where: TestExecutionWhereUniqueInput
  }

  /**
   * TestExecution findFirst
   */
  export type TestExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestExecution
     */
    select?: TestExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestExecutionInclude<ExtArgs> | null
    /**
     * Filter, which TestExecution to fetch.
     */
    where?: TestExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestExecutions to fetch.
     */
    orderBy?: TestExecutionOrderByWithRelationInput | TestExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestExecutions.
     */
    cursor?: TestExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestExecutions.
     */
    distinct?: TestExecutionScalarFieldEnum | TestExecutionScalarFieldEnum[]
  }

  /**
   * TestExecution findFirstOrThrow
   */
  export type TestExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestExecution
     */
    select?: TestExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestExecutionInclude<ExtArgs> | null
    /**
     * Filter, which TestExecution to fetch.
     */
    where?: TestExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestExecutions to fetch.
     */
    orderBy?: TestExecutionOrderByWithRelationInput | TestExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestExecutions.
     */
    cursor?: TestExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestExecutions.
     */
    distinct?: TestExecutionScalarFieldEnum | TestExecutionScalarFieldEnum[]
  }

  /**
   * TestExecution findMany
   */
  export type TestExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestExecution
     */
    select?: TestExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestExecutionInclude<ExtArgs> | null
    /**
     * Filter, which TestExecutions to fetch.
     */
    where?: TestExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestExecutions to fetch.
     */
    orderBy?: TestExecutionOrderByWithRelationInput | TestExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestExecutions.
     */
    cursor?: TestExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestExecutions.
     */
    skip?: number
    distinct?: TestExecutionScalarFieldEnum | TestExecutionScalarFieldEnum[]
  }

  /**
   * TestExecution create
   */
  export type TestExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestExecution
     */
    select?: TestExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a TestExecution.
     */
    data: XOR<TestExecutionCreateInput, TestExecutionUncheckedCreateInput>
  }

  /**
   * TestExecution createMany
   */
  export type TestExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestExecutions.
     */
    data: TestExecutionCreateManyInput | TestExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestExecution createManyAndReturn
   */
  export type TestExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestExecution
     */
    select?: TestExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TestExecutions.
     */
    data: TestExecutionCreateManyInput | TestExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestExecution update
   */
  export type TestExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestExecution
     */
    select?: TestExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a TestExecution.
     */
    data: XOR<TestExecutionUpdateInput, TestExecutionUncheckedUpdateInput>
    /**
     * Choose, which TestExecution to update.
     */
    where: TestExecutionWhereUniqueInput
  }

  /**
   * TestExecution updateMany
   */
  export type TestExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestExecutions.
     */
    data: XOR<TestExecutionUpdateManyMutationInput, TestExecutionUncheckedUpdateManyInput>
    /**
     * Filter which TestExecutions to update
     */
    where?: TestExecutionWhereInput
  }

  /**
   * TestExecution upsert
   */
  export type TestExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestExecution
     */
    select?: TestExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the TestExecution to update in case it exists.
     */
    where: TestExecutionWhereUniqueInput
    /**
     * In case the TestExecution found by the `where` argument doesn't exist, create a new TestExecution with this data.
     */
    create: XOR<TestExecutionCreateInput, TestExecutionUncheckedCreateInput>
    /**
     * In case the TestExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestExecutionUpdateInput, TestExecutionUncheckedUpdateInput>
  }

  /**
   * TestExecution delete
   */
  export type TestExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestExecution
     */
    select?: TestExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestExecutionInclude<ExtArgs> | null
    /**
     * Filter which TestExecution to delete.
     */
    where: TestExecutionWhereUniqueInput
  }

  /**
   * TestExecution deleteMany
   */
  export type TestExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestExecutions to delete
     */
    where?: TestExecutionWhereInput
  }

  /**
   * TestExecution.defects
   */
  export type TestExecution$defectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defect
     */
    select?: DefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectInclude<ExtArgs> | null
    where?: DefectWhereInput
    orderBy?: DefectOrderByWithRelationInput | DefectOrderByWithRelationInput[]
    cursor?: DefectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DefectScalarFieldEnum | DefectScalarFieldEnum[]
  }

  /**
   * TestExecution without action
   */
  export type TestExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestExecution
     */
    select?: TestExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestExecutionInclude<ExtArgs> | null
  }


  /**
   * Model Defect
   */

  export type AggregateDefect = {
    _count: DefectCountAggregateOutputType | null
    _min: DefectMinAggregateOutputType | null
    _max: DefectMaxAggregateOutputType | null
  }

  export type DefectMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    steps: string | null
    expectedBehavior: string | null
    actualBehavior: string | null
    severity: $Enums.DefectSeverity | null
    priority: $Enums.DefectPriority | null
    status: $Enums.DefectStatus | null
    environment: string | null
    browserVersion: string | null
    osVersion: string | null
    reproducible: boolean | null
    regression: boolean | null
    testExecutionId: string | null
    reportedById: string | null
    assignedToId: string | null
    reportedAt: Date | null
    resolvedAt: Date | null
    closedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DefectMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    steps: string | null
    expectedBehavior: string | null
    actualBehavior: string | null
    severity: $Enums.DefectSeverity | null
    priority: $Enums.DefectPriority | null
    status: $Enums.DefectStatus | null
    environment: string | null
    browserVersion: string | null
    osVersion: string | null
    reproducible: boolean | null
    regression: boolean | null
    testExecutionId: string | null
    reportedById: string | null
    assignedToId: string | null
    reportedAt: Date | null
    resolvedAt: Date | null
    closedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DefectCountAggregateOutputType = {
    id: number
    title: number
    description: number
    steps: number
    expectedBehavior: number
    actualBehavior: number
    severity: number
    priority: number
    status: number
    environment: number
    browserVersion: number
    osVersion: number
    attachments: number
    reproducible: number
    regression: number
    testExecutionId: number
    reportedById: number
    assignedToId: number
    reportedAt: number
    resolvedAt: number
    closedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DefectMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    steps?: true
    expectedBehavior?: true
    actualBehavior?: true
    severity?: true
    priority?: true
    status?: true
    environment?: true
    browserVersion?: true
    osVersion?: true
    reproducible?: true
    regression?: true
    testExecutionId?: true
    reportedById?: true
    assignedToId?: true
    reportedAt?: true
    resolvedAt?: true
    closedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DefectMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    steps?: true
    expectedBehavior?: true
    actualBehavior?: true
    severity?: true
    priority?: true
    status?: true
    environment?: true
    browserVersion?: true
    osVersion?: true
    reproducible?: true
    regression?: true
    testExecutionId?: true
    reportedById?: true
    assignedToId?: true
    reportedAt?: true
    resolvedAt?: true
    closedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DefectCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    steps?: true
    expectedBehavior?: true
    actualBehavior?: true
    severity?: true
    priority?: true
    status?: true
    environment?: true
    browserVersion?: true
    osVersion?: true
    attachments?: true
    reproducible?: true
    regression?: true
    testExecutionId?: true
    reportedById?: true
    assignedToId?: true
    reportedAt?: true
    resolvedAt?: true
    closedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DefectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Defect to aggregate.
     */
    where?: DefectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Defects to fetch.
     */
    orderBy?: DefectOrderByWithRelationInput | DefectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DefectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Defects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Defects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Defects
    **/
    _count?: true | DefectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DefectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DefectMaxAggregateInputType
  }

  export type GetDefectAggregateType<T extends DefectAggregateArgs> = {
        [P in keyof T & keyof AggregateDefect]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDefect[P]>
      : GetScalarType<T[P], AggregateDefect[P]>
  }




  export type DefectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefectWhereInput
    orderBy?: DefectOrderByWithAggregationInput | DefectOrderByWithAggregationInput[]
    by: DefectScalarFieldEnum[] | DefectScalarFieldEnum
    having?: DefectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DefectCountAggregateInputType | true
    _min?: DefectMinAggregateInputType
    _max?: DefectMaxAggregateInputType
  }

  export type DefectGroupByOutputType = {
    id: string
    title: string
    description: string
    steps: string | null
    expectedBehavior: string | null
    actualBehavior: string | null
    severity: $Enums.DefectSeverity
    priority: $Enums.DefectPriority
    status: $Enums.DefectStatus
    environment: string | null
    browserVersion: string | null
    osVersion: string | null
    attachments: JsonValue | null
    reproducible: boolean
    regression: boolean
    testExecutionId: string | null
    reportedById: string
    assignedToId: string | null
    reportedAt: Date
    resolvedAt: Date | null
    closedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DefectCountAggregateOutputType | null
    _min: DefectMinAggregateOutputType | null
    _max: DefectMaxAggregateOutputType | null
  }

  type GetDefectGroupByPayload<T extends DefectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DefectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DefectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DefectGroupByOutputType[P]>
            : GetScalarType<T[P], DefectGroupByOutputType[P]>
        }
      >
    >


  export type DefectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    steps?: boolean
    expectedBehavior?: boolean
    actualBehavior?: boolean
    severity?: boolean
    priority?: boolean
    status?: boolean
    environment?: boolean
    browserVersion?: boolean
    osVersion?: boolean
    attachments?: boolean
    reproducible?: boolean
    regression?: boolean
    testExecutionId?: boolean
    reportedById?: boolean
    assignedToId?: boolean
    reportedAt?: boolean
    resolvedAt?: boolean
    closedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    testExecution?: boolean | Defect$testExecutionArgs<ExtArgs>
    reportedBy?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Defect$assignedToArgs<ExtArgs>
    testCases?: boolean | Defect$testCasesArgs<ExtArgs>
    comments?: boolean | Defect$commentsArgs<ExtArgs>
    _count?: boolean | DefectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["defect"]>

  export type DefectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    steps?: boolean
    expectedBehavior?: boolean
    actualBehavior?: boolean
    severity?: boolean
    priority?: boolean
    status?: boolean
    environment?: boolean
    browserVersion?: boolean
    osVersion?: boolean
    attachments?: boolean
    reproducible?: boolean
    regression?: boolean
    testExecutionId?: boolean
    reportedById?: boolean
    assignedToId?: boolean
    reportedAt?: boolean
    resolvedAt?: boolean
    closedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    testExecution?: boolean | Defect$testExecutionArgs<ExtArgs>
    reportedBy?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Defect$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["defect"]>

  export type DefectSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    steps?: boolean
    expectedBehavior?: boolean
    actualBehavior?: boolean
    severity?: boolean
    priority?: boolean
    status?: boolean
    environment?: boolean
    browserVersion?: boolean
    osVersion?: boolean
    attachments?: boolean
    reproducible?: boolean
    regression?: boolean
    testExecutionId?: boolean
    reportedById?: boolean
    assignedToId?: boolean
    reportedAt?: boolean
    resolvedAt?: boolean
    closedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DefectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testExecution?: boolean | Defect$testExecutionArgs<ExtArgs>
    reportedBy?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Defect$assignedToArgs<ExtArgs>
    testCases?: boolean | Defect$testCasesArgs<ExtArgs>
    comments?: boolean | Defect$commentsArgs<ExtArgs>
    _count?: boolean | DefectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DefectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testExecution?: boolean | Defect$testExecutionArgs<ExtArgs>
    reportedBy?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Defect$assignedToArgs<ExtArgs>
  }

  export type $DefectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Defect"
    objects: {
      testExecution: Prisma.$TestExecutionPayload<ExtArgs> | null
      reportedBy: Prisma.$UserPayload<ExtArgs>
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
      testCases: Prisma.$DefectTestCasePayload<ExtArgs>[]
      comments: Prisma.$DefectCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      steps: string | null
      expectedBehavior: string | null
      actualBehavior: string | null
      severity: $Enums.DefectSeverity
      priority: $Enums.DefectPriority
      status: $Enums.DefectStatus
      environment: string | null
      browserVersion: string | null
      osVersion: string | null
      attachments: Prisma.JsonValue | null
      reproducible: boolean
      regression: boolean
      testExecutionId: string | null
      reportedById: string
      assignedToId: string | null
      reportedAt: Date
      resolvedAt: Date | null
      closedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["defect"]>
    composites: {}
  }

  type DefectGetPayload<S extends boolean | null | undefined | DefectDefaultArgs> = $Result.GetResult<Prisma.$DefectPayload, S>

  type DefectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DefectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DefectCountAggregateInputType | true
    }

  export interface DefectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Defect'], meta: { name: 'Defect' } }
    /**
     * Find zero or one Defect that matches the filter.
     * @param {DefectFindUniqueArgs} args - Arguments to find a Defect
     * @example
     * // Get one Defect
     * const defect = await prisma.defect.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DefectFindUniqueArgs>(args: SelectSubset<T, DefectFindUniqueArgs<ExtArgs>>): Prisma__DefectClient<$Result.GetResult<Prisma.$DefectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Defect that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DefectFindUniqueOrThrowArgs} args - Arguments to find a Defect
     * @example
     * // Get one Defect
     * const defect = await prisma.defect.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DefectFindUniqueOrThrowArgs>(args: SelectSubset<T, DefectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DefectClient<$Result.GetResult<Prisma.$DefectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Defect that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectFindFirstArgs} args - Arguments to find a Defect
     * @example
     * // Get one Defect
     * const defect = await prisma.defect.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DefectFindFirstArgs>(args?: SelectSubset<T, DefectFindFirstArgs<ExtArgs>>): Prisma__DefectClient<$Result.GetResult<Prisma.$DefectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Defect that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectFindFirstOrThrowArgs} args - Arguments to find a Defect
     * @example
     * // Get one Defect
     * const defect = await prisma.defect.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DefectFindFirstOrThrowArgs>(args?: SelectSubset<T, DefectFindFirstOrThrowArgs<ExtArgs>>): Prisma__DefectClient<$Result.GetResult<Prisma.$DefectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Defects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Defects
     * const defects = await prisma.defect.findMany()
     * 
     * // Get first 10 Defects
     * const defects = await prisma.defect.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const defectWithIdOnly = await prisma.defect.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DefectFindManyArgs>(args?: SelectSubset<T, DefectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Defect.
     * @param {DefectCreateArgs} args - Arguments to create a Defect.
     * @example
     * // Create one Defect
     * const Defect = await prisma.defect.create({
     *   data: {
     *     // ... data to create a Defect
     *   }
     * })
     * 
     */
    create<T extends DefectCreateArgs>(args: SelectSubset<T, DefectCreateArgs<ExtArgs>>): Prisma__DefectClient<$Result.GetResult<Prisma.$DefectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Defects.
     * @param {DefectCreateManyArgs} args - Arguments to create many Defects.
     * @example
     * // Create many Defects
     * const defect = await prisma.defect.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DefectCreateManyArgs>(args?: SelectSubset<T, DefectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Defects and returns the data saved in the database.
     * @param {DefectCreateManyAndReturnArgs} args - Arguments to create many Defects.
     * @example
     * // Create many Defects
     * const defect = await prisma.defect.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Defects and only return the `id`
     * const defectWithIdOnly = await prisma.defect.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DefectCreateManyAndReturnArgs>(args?: SelectSubset<T, DefectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Defect.
     * @param {DefectDeleteArgs} args - Arguments to delete one Defect.
     * @example
     * // Delete one Defect
     * const Defect = await prisma.defect.delete({
     *   where: {
     *     // ... filter to delete one Defect
     *   }
     * })
     * 
     */
    delete<T extends DefectDeleteArgs>(args: SelectSubset<T, DefectDeleteArgs<ExtArgs>>): Prisma__DefectClient<$Result.GetResult<Prisma.$DefectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Defect.
     * @param {DefectUpdateArgs} args - Arguments to update one Defect.
     * @example
     * // Update one Defect
     * const defect = await prisma.defect.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DefectUpdateArgs>(args: SelectSubset<T, DefectUpdateArgs<ExtArgs>>): Prisma__DefectClient<$Result.GetResult<Prisma.$DefectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Defects.
     * @param {DefectDeleteManyArgs} args - Arguments to filter Defects to delete.
     * @example
     * // Delete a few Defects
     * const { count } = await prisma.defect.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DefectDeleteManyArgs>(args?: SelectSubset<T, DefectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Defects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Defects
     * const defect = await prisma.defect.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DefectUpdateManyArgs>(args: SelectSubset<T, DefectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Defect.
     * @param {DefectUpsertArgs} args - Arguments to update or create a Defect.
     * @example
     * // Update or create a Defect
     * const defect = await prisma.defect.upsert({
     *   create: {
     *     // ... data to create a Defect
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Defect we want to update
     *   }
     * })
     */
    upsert<T extends DefectUpsertArgs>(args: SelectSubset<T, DefectUpsertArgs<ExtArgs>>): Prisma__DefectClient<$Result.GetResult<Prisma.$DefectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Defects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectCountArgs} args - Arguments to filter Defects to count.
     * @example
     * // Count the number of Defects
     * const count = await prisma.defect.count({
     *   where: {
     *     // ... the filter for the Defects we want to count
     *   }
     * })
    **/
    count<T extends DefectCountArgs>(
      args?: Subset<T, DefectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DefectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Defect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DefectAggregateArgs>(args: Subset<T, DefectAggregateArgs>): Prisma.PrismaPromise<GetDefectAggregateType<T>>

    /**
     * Group by Defect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DefectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DefectGroupByArgs['orderBy'] }
        : { orderBy?: DefectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DefectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDefectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Defect model
   */
  readonly fields: DefectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Defect.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DefectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    testExecution<T extends Defect$testExecutionArgs<ExtArgs> = {}>(args?: Subset<T, Defect$testExecutionArgs<ExtArgs>>): Prisma__TestExecutionClient<$Result.GetResult<Prisma.$TestExecutionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    reportedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assignedTo<T extends Defect$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, Defect$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    testCases<T extends Defect$testCasesArgs<ExtArgs> = {}>(args?: Subset<T, Defect$testCasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefectTestCasePayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends Defect$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Defect$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefectCommentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Defect model
   */ 
  interface DefectFieldRefs {
    readonly id: FieldRef<"Defect", 'String'>
    readonly title: FieldRef<"Defect", 'String'>
    readonly description: FieldRef<"Defect", 'String'>
    readonly steps: FieldRef<"Defect", 'String'>
    readonly expectedBehavior: FieldRef<"Defect", 'String'>
    readonly actualBehavior: FieldRef<"Defect", 'String'>
    readonly severity: FieldRef<"Defect", 'DefectSeverity'>
    readonly priority: FieldRef<"Defect", 'DefectPriority'>
    readonly status: FieldRef<"Defect", 'DefectStatus'>
    readonly environment: FieldRef<"Defect", 'String'>
    readonly browserVersion: FieldRef<"Defect", 'String'>
    readonly osVersion: FieldRef<"Defect", 'String'>
    readonly attachments: FieldRef<"Defect", 'Json'>
    readonly reproducible: FieldRef<"Defect", 'Boolean'>
    readonly regression: FieldRef<"Defect", 'Boolean'>
    readonly testExecutionId: FieldRef<"Defect", 'String'>
    readonly reportedById: FieldRef<"Defect", 'String'>
    readonly assignedToId: FieldRef<"Defect", 'String'>
    readonly reportedAt: FieldRef<"Defect", 'DateTime'>
    readonly resolvedAt: FieldRef<"Defect", 'DateTime'>
    readonly closedAt: FieldRef<"Defect", 'DateTime'>
    readonly createdAt: FieldRef<"Defect", 'DateTime'>
    readonly updatedAt: FieldRef<"Defect", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Defect findUnique
   */
  export type DefectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defect
     */
    select?: DefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectInclude<ExtArgs> | null
    /**
     * Filter, which Defect to fetch.
     */
    where: DefectWhereUniqueInput
  }

  /**
   * Defect findUniqueOrThrow
   */
  export type DefectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defect
     */
    select?: DefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectInclude<ExtArgs> | null
    /**
     * Filter, which Defect to fetch.
     */
    where: DefectWhereUniqueInput
  }

  /**
   * Defect findFirst
   */
  export type DefectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defect
     */
    select?: DefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectInclude<ExtArgs> | null
    /**
     * Filter, which Defect to fetch.
     */
    where?: DefectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Defects to fetch.
     */
    orderBy?: DefectOrderByWithRelationInput | DefectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Defects.
     */
    cursor?: DefectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Defects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Defects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Defects.
     */
    distinct?: DefectScalarFieldEnum | DefectScalarFieldEnum[]
  }

  /**
   * Defect findFirstOrThrow
   */
  export type DefectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defect
     */
    select?: DefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectInclude<ExtArgs> | null
    /**
     * Filter, which Defect to fetch.
     */
    where?: DefectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Defects to fetch.
     */
    orderBy?: DefectOrderByWithRelationInput | DefectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Defects.
     */
    cursor?: DefectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Defects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Defects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Defects.
     */
    distinct?: DefectScalarFieldEnum | DefectScalarFieldEnum[]
  }

  /**
   * Defect findMany
   */
  export type DefectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defect
     */
    select?: DefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectInclude<ExtArgs> | null
    /**
     * Filter, which Defects to fetch.
     */
    where?: DefectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Defects to fetch.
     */
    orderBy?: DefectOrderByWithRelationInput | DefectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Defects.
     */
    cursor?: DefectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Defects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Defects.
     */
    skip?: number
    distinct?: DefectScalarFieldEnum | DefectScalarFieldEnum[]
  }

  /**
   * Defect create
   */
  export type DefectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defect
     */
    select?: DefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectInclude<ExtArgs> | null
    /**
     * The data needed to create a Defect.
     */
    data: XOR<DefectCreateInput, DefectUncheckedCreateInput>
  }

  /**
   * Defect createMany
   */
  export type DefectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Defects.
     */
    data: DefectCreateManyInput | DefectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Defect createManyAndReturn
   */
  export type DefectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defect
     */
    select?: DefectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Defects.
     */
    data: DefectCreateManyInput | DefectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Defect update
   */
  export type DefectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defect
     */
    select?: DefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectInclude<ExtArgs> | null
    /**
     * The data needed to update a Defect.
     */
    data: XOR<DefectUpdateInput, DefectUncheckedUpdateInput>
    /**
     * Choose, which Defect to update.
     */
    where: DefectWhereUniqueInput
  }

  /**
   * Defect updateMany
   */
  export type DefectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Defects.
     */
    data: XOR<DefectUpdateManyMutationInput, DefectUncheckedUpdateManyInput>
    /**
     * Filter which Defects to update
     */
    where?: DefectWhereInput
  }

  /**
   * Defect upsert
   */
  export type DefectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defect
     */
    select?: DefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectInclude<ExtArgs> | null
    /**
     * The filter to search for the Defect to update in case it exists.
     */
    where: DefectWhereUniqueInput
    /**
     * In case the Defect found by the `where` argument doesn't exist, create a new Defect with this data.
     */
    create: XOR<DefectCreateInput, DefectUncheckedCreateInput>
    /**
     * In case the Defect was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DefectUpdateInput, DefectUncheckedUpdateInput>
  }

  /**
   * Defect delete
   */
  export type DefectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defect
     */
    select?: DefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectInclude<ExtArgs> | null
    /**
     * Filter which Defect to delete.
     */
    where: DefectWhereUniqueInput
  }

  /**
   * Defect deleteMany
   */
  export type DefectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Defects to delete
     */
    where?: DefectWhereInput
  }

  /**
   * Defect.testExecution
   */
  export type Defect$testExecutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestExecution
     */
    select?: TestExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestExecutionInclude<ExtArgs> | null
    where?: TestExecutionWhereInput
  }

  /**
   * Defect.assignedTo
   */
  export type Defect$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Defect.testCases
   */
  export type Defect$testCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectTestCase
     */
    select?: DefectTestCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectTestCaseInclude<ExtArgs> | null
    where?: DefectTestCaseWhereInput
    orderBy?: DefectTestCaseOrderByWithRelationInput | DefectTestCaseOrderByWithRelationInput[]
    cursor?: DefectTestCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DefectTestCaseScalarFieldEnum | DefectTestCaseScalarFieldEnum[]
  }

  /**
   * Defect.comments
   */
  export type Defect$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectComment
     */
    select?: DefectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectCommentInclude<ExtArgs> | null
    where?: DefectCommentWhereInput
    orderBy?: DefectCommentOrderByWithRelationInput | DefectCommentOrderByWithRelationInput[]
    cursor?: DefectCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DefectCommentScalarFieldEnum | DefectCommentScalarFieldEnum[]
  }

  /**
   * Defect without action
   */
  export type DefectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defect
     */
    select?: DefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectInclude<ExtArgs> | null
  }


  /**
   * Model DefectTestCase
   */

  export type AggregateDefectTestCase = {
    _count: DefectTestCaseCountAggregateOutputType | null
    _min: DefectTestCaseMinAggregateOutputType | null
    _max: DefectTestCaseMaxAggregateOutputType | null
  }

  export type DefectTestCaseMinAggregateOutputType = {
    id: string | null
    defectId: string | null
    testCaseId: string | null
    createdAt: Date | null
  }

  export type DefectTestCaseMaxAggregateOutputType = {
    id: string | null
    defectId: string | null
    testCaseId: string | null
    createdAt: Date | null
  }

  export type DefectTestCaseCountAggregateOutputType = {
    id: number
    defectId: number
    testCaseId: number
    createdAt: number
    _all: number
  }


  export type DefectTestCaseMinAggregateInputType = {
    id?: true
    defectId?: true
    testCaseId?: true
    createdAt?: true
  }

  export type DefectTestCaseMaxAggregateInputType = {
    id?: true
    defectId?: true
    testCaseId?: true
    createdAt?: true
  }

  export type DefectTestCaseCountAggregateInputType = {
    id?: true
    defectId?: true
    testCaseId?: true
    createdAt?: true
    _all?: true
  }

  export type DefectTestCaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DefectTestCase to aggregate.
     */
    where?: DefectTestCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefectTestCases to fetch.
     */
    orderBy?: DefectTestCaseOrderByWithRelationInput | DefectTestCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DefectTestCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefectTestCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefectTestCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DefectTestCases
    **/
    _count?: true | DefectTestCaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DefectTestCaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DefectTestCaseMaxAggregateInputType
  }

  export type GetDefectTestCaseAggregateType<T extends DefectTestCaseAggregateArgs> = {
        [P in keyof T & keyof AggregateDefectTestCase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDefectTestCase[P]>
      : GetScalarType<T[P], AggregateDefectTestCase[P]>
  }




  export type DefectTestCaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefectTestCaseWhereInput
    orderBy?: DefectTestCaseOrderByWithAggregationInput | DefectTestCaseOrderByWithAggregationInput[]
    by: DefectTestCaseScalarFieldEnum[] | DefectTestCaseScalarFieldEnum
    having?: DefectTestCaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DefectTestCaseCountAggregateInputType | true
    _min?: DefectTestCaseMinAggregateInputType
    _max?: DefectTestCaseMaxAggregateInputType
  }

  export type DefectTestCaseGroupByOutputType = {
    id: string
    defectId: string
    testCaseId: string
    createdAt: Date
    _count: DefectTestCaseCountAggregateOutputType | null
    _min: DefectTestCaseMinAggregateOutputType | null
    _max: DefectTestCaseMaxAggregateOutputType | null
  }

  type GetDefectTestCaseGroupByPayload<T extends DefectTestCaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DefectTestCaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DefectTestCaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DefectTestCaseGroupByOutputType[P]>
            : GetScalarType<T[P], DefectTestCaseGroupByOutputType[P]>
        }
      >
    >


  export type DefectTestCaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    defectId?: boolean
    testCaseId?: boolean
    createdAt?: boolean
    defect?: boolean | DefectDefaultArgs<ExtArgs>
    testCase?: boolean | TestCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["defectTestCase"]>

  export type DefectTestCaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    defectId?: boolean
    testCaseId?: boolean
    createdAt?: boolean
    defect?: boolean | DefectDefaultArgs<ExtArgs>
    testCase?: boolean | TestCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["defectTestCase"]>

  export type DefectTestCaseSelectScalar = {
    id?: boolean
    defectId?: boolean
    testCaseId?: boolean
    createdAt?: boolean
  }

  export type DefectTestCaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defect?: boolean | DefectDefaultArgs<ExtArgs>
    testCase?: boolean | TestCaseDefaultArgs<ExtArgs>
  }
  export type DefectTestCaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defect?: boolean | DefectDefaultArgs<ExtArgs>
    testCase?: boolean | TestCaseDefaultArgs<ExtArgs>
  }

  export type $DefectTestCasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DefectTestCase"
    objects: {
      defect: Prisma.$DefectPayload<ExtArgs>
      testCase: Prisma.$TestCasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      defectId: string
      testCaseId: string
      createdAt: Date
    }, ExtArgs["result"]["defectTestCase"]>
    composites: {}
  }

  type DefectTestCaseGetPayload<S extends boolean | null | undefined | DefectTestCaseDefaultArgs> = $Result.GetResult<Prisma.$DefectTestCasePayload, S>

  type DefectTestCaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DefectTestCaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DefectTestCaseCountAggregateInputType | true
    }

  export interface DefectTestCaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DefectTestCase'], meta: { name: 'DefectTestCase' } }
    /**
     * Find zero or one DefectTestCase that matches the filter.
     * @param {DefectTestCaseFindUniqueArgs} args - Arguments to find a DefectTestCase
     * @example
     * // Get one DefectTestCase
     * const defectTestCase = await prisma.defectTestCase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DefectTestCaseFindUniqueArgs>(args: SelectSubset<T, DefectTestCaseFindUniqueArgs<ExtArgs>>): Prisma__DefectTestCaseClient<$Result.GetResult<Prisma.$DefectTestCasePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DefectTestCase that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DefectTestCaseFindUniqueOrThrowArgs} args - Arguments to find a DefectTestCase
     * @example
     * // Get one DefectTestCase
     * const defectTestCase = await prisma.defectTestCase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DefectTestCaseFindUniqueOrThrowArgs>(args: SelectSubset<T, DefectTestCaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DefectTestCaseClient<$Result.GetResult<Prisma.$DefectTestCasePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DefectTestCase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectTestCaseFindFirstArgs} args - Arguments to find a DefectTestCase
     * @example
     * // Get one DefectTestCase
     * const defectTestCase = await prisma.defectTestCase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DefectTestCaseFindFirstArgs>(args?: SelectSubset<T, DefectTestCaseFindFirstArgs<ExtArgs>>): Prisma__DefectTestCaseClient<$Result.GetResult<Prisma.$DefectTestCasePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DefectTestCase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectTestCaseFindFirstOrThrowArgs} args - Arguments to find a DefectTestCase
     * @example
     * // Get one DefectTestCase
     * const defectTestCase = await prisma.defectTestCase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DefectTestCaseFindFirstOrThrowArgs>(args?: SelectSubset<T, DefectTestCaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__DefectTestCaseClient<$Result.GetResult<Prisma.$DefectTestCasePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DefectTestCases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectTestCaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DefectTestCases
     * const defectTestCases = await prisma.defectTestCase.findMany()
     * 
     * // Get first 10 DefectTestCases
     * const defectTestCases = await prisma.defectTestCase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const defectTestCaseWithIdOnly = await prisma.defectTestCase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DefectTestCaseFindManyArgs>(args?: SelectSubset<T, DefectTestCaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefectTestCasePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DefectTestCase.
     * @param {DefectTestCaseCreateArgs} args - Arguments to create a DefectTestCase.
     * @example
     * // Create one DefectTestCase
     * const DefectTestCase = await prisma.defectTestCase.create({
     *   data: {
     *     // ... data to create a DefectTestCase
     *   }
     * })
     * 
     */
    create<T extends DefectTestCaseCreateArgs>(args: SelectSubset<T, DefectTestCaseCreateArgs<ExtArgs>>): Prisma__DefectTestCaseClient<$Result.GetResult<Prisma.$DefectTestCasePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DefectTestCases.
     * @param {DefectTestCaseCreateManyArgs} args - Arguments to create many DefectTestCases.
     * @example
     * // Create many DefectTestCases
     * const defectTestCase = await prisma.defectTestCase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DefectTestCaseCreateManyArgs>(args?: SelectSubset<T, DefectTestCaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DefectTestCases and returns the data saved in the database.
     * @param {DefectTestCaseCreateManyAndReturnArgs} args - Arguments to create many DefectTestCases.
     * @example
     * // Create many DefectTestCases
     * const defectTestCase = await prisma.defectTestCase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DefectTestCases and only return the `id`
     * const defectTestCaseWithIdOnly = await prisma.defectTestCase.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DefectTestCaseCreateManyAndReturnArgs>(args?: SelectSubset<T, DefectTestCaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefectTestCasePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DefectTestCase.
     * @param {DefectTestCaseDeleteArgs} args - Arguments to delete one DefectTestCase.
     * @example
     * // Delete one DefectTestCase
     * const DefectTestCase = await prisma.defectTestCase.delete({
     *   where: {
     *     // ... filter to delete one DefectTestCase
     *   }
     * })
     * 
     */
    delete<T extends DefectTestCaseDeleteArgs>(args: SelectSubset<T, DefectTestCaseDeleteArgs<ExtArgs>>): Prisma__DefectTestCaseClient<$Result.GetResult<Prisma.$DefectTestCasePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DefectTestCase.
     * @param {DefectTestCaseUpdateArgs} args - Arguments to update one DefectTestCase.
     * @example
     * // Update one DefectTestCase
     * const defectTestCase = await prisma.defectTestCase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DefectTestCaseUpdateArgs>(args: SelectSubset<T, DefectTestCaseUpdateArgs<ExtArgs>>): Prisma__DefectTestCaseClient<$Result.GetResult<Prisma.$DefectTestCasePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DefectTestCases.
     * @param {DefectTestCaseDeleteManyArgs} args - Arguments to filter DefectTestCases to delete.
     * @example
     * // Delete a few DefectTestCases
     * const { count } = await prisma.defectTestCase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DefectTestCaseDeleteManyArgs>(args?: SelectSubset<T, DefectTestCaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DefectTestCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectTestCaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DefectTestCases
     * const defectTestCase = await prisma.defectTestCase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DefectTestCaseUpdateManyArgs>(args: SelectSubset<T, DefectTestCaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DefectTestCase.
     * @param {DefectTestCaseUpsertArgs} args - Arguments to update or create a DefectTestCase.
     * @example
     * // Update or create a DefectTestCase
     * const defectTestCase = await prisma.defectTestCase.upsert({
     *   create: {
     *     // ... data to create a DefectTestCase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DefectTestCase we want to update
     *   }
     * })
     */
    upsert<T extends DefectTestCaseUpsertArgs>(args: SelectSubset<T, DefectTestCaseUpsertArgs<ExtArgs>>): Prisma__DefectTestCaseClient<$Result.GetResult<Prisma.$DefectTestCasePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DefectTestCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectTestCaseCountArgs} args - Arguments to filter DefectTestCases to count.
     * @example
     * // Count the number of DefectTestCases
     * const count = await prisma.defectTestCase.count({
     *   where: {
     *     // ... the filter for the DefectTestCases we want to count
     *   }
     * })
    **/
    count<T extends DefectTestCaseCountArgs>(
      args?: Subset<T, DefectTestCaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DefectTestCaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DefectTestCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectTestCaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DefectTestCaseAggregateArgs>(args: Subset<T, DefectTestCaseAggregateArgs>): Prisma.PrismaPromise<GetDefectTestCaseAggregateType<T>>

    /**
     * Group by DefectTestCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectTestCaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DefectTestCaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DefectTestCaseGroupByArgs['orderBy'] }
        : { orderBy?: DefectTestCaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DefectTestCaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDefectTestCaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DefectTestCase model
   */
  readonly fields: DefectTestCaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DefectTestCase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DefectTestCaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    defect<T extends DefectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DefectDefaultArgs<ExtArgs>>): Prisma__DefectClient<$Result.GetResult<Prisma.$DefectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    testCase<T extends TestCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestCaseDefaultArgs<ExtArgs>>): Prisma__TestCaseClient<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DefectTestCase model
   */ 
  interface DefectTestCaseFieldRefs {
    readonly id: FieldRef<"DefectTestCase", 'String'>
    readonly defectId: FieldRef<"DefectTestCase", 'String'>
    readonly testCaseId: FieldRef<"DefectTestCase", 'String'>
    readonly createdAt: FieldRef<"DefectTestCase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DefectTestCase findUnique
   */
  export type DefectTestCaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectTestCase
     */
    select?: DefectTestCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectTestCaseInclude<ExtArgs> | null
    /**
     * Filter, which DefectTestCase to fetch.
     */
    where: DefectTestCaseWhereUniqueInput
  }

  /**
   * DefectTestCase findUniqueOrThrow
   */
  export type DefectTestCaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectTestCase
     */
    select?: DefectTestCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectTestCaseInclude<ExtArgs> | null
    /**
     * Filter, which DefectTestCase to fetch.
     */
    where: DefectTestCaseWhereUniqueInput
  }

  /**
   * DefectTestCase findFirst
   */
  export type DefectTestCaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectTestCase
     */
    select?: DefectTestCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectTestCaseInclude<ExtArgs> | null
    /**
     * Filter, which DefectTestCase to fetch.
     */
    where?: DefectTestCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefectTestCases to fetch.
     */
    orderBy?: DefectTestCaseOrderByWithRelationInput | DefectTestCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DefectTestCases.
     */
    cursor?: DefectTestCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefectTestCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefectTestCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DefectTestCases.
     */
    distinct?: DefectTestCaseScalarFieldEnum | DefectTestCaseScalarFieldEnum[]
  }

  /**
   * DefectTestCase findFirstOrThrow
   */
  export type DefectTestCaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectTestCase
     */
    select?: DefectTestCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectTestCaseInclude<ExtArgs> | null
    /**
     * Filter, which DefectTestCase to fetch.
     */
    where?: DefectTestCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefectTestCases to fetch.
     */
    orderBy?: DefectTestCaseOrderByWithRelationInput | DefectTestCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DefectTestCases.
     */
    cursor?: DefectTestCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefectTestCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefectTestCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DefectTestCases.
     */
    distinct?: DefectTestCaseScalarFieldEnum | DefectTestCaseScalarFieldEnum[]
  }

  /**
   * DefectTestCase findMany
   */
  export type DefectTestCaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectTestCase
     */
    select?: DefectTestCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectTestCaseInclude<ExtArgs> | null
    /**
     * Filter, which DefectTestCases to fetch.
     */
    where?: DefectTestCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefectTestCases to fetch.
     */
    orderBy?: DefectTestCaseOrderByWithRelationInput | DefectTestCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DefectTestCases.
     */
    cursor?: DefectTestCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefectTestCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefectTestCases.
     */
    skip?: number
    distinct?: DefectTestCaseScalarFieldEnum | DefectTestCaseScalarFieldEnum[]
  }

  /**
   * DefectTestCase create
   */
  export type DefectTestCaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectTestCase
     */
    select?: DefectTestCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectTestCaseInclude<ExtArgs> | null
    /**
     * The data needed to create a DefectTestCase.
     */
    data: XOR<DefectTestCaseCreateInput, DefectTestCaseUncheckedCreateInput>
  }

  /**
   * DefectTestCase createMany
   */
  export type DefectTestCaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DefectTestCases.
     */
    data: DefectTestCaseCreateManyInput | DefectTestCaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DefectTestCase createManyAndReturn
   */
  export type DefectTestCaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectTestCase
     */
    select?: DefectTestCaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DefectTestCases.
     */
    data: DefectTestCaseCreateManyInput | DefectTestCaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectTestCaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DefectTestCase update
   */
  export type DefectTestCaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectTestCase
     */
    select?: DefectTestCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectTestCaseInclude<ExtArgs> | null
    /**
     * The data needed to update a DefectTestCase.
     */
    data: XOR<DefectTestCaseUpdateInput, DefectTestCaseUncheckedUpdateInput>
    /**
     * Choose, which DefectTestCase to update.
     */
    where: DefectTestCaseWhereUniqueInput
  }

  /**
   * DefectTestCase updateMany
   */
  export type DefectTestCaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DefectTestCases.
     */
    data: XOR<DefectTestCaseUpdateManyMutationInput, DefectTestCaseUncheckedUpdateManyInput>
    /**
     * Filter which DefectTestCases to update
     */
    where?: DefectTestCaseWhereInput
  }

  /**
   * DefectTestCase upsert
   */
  export type DefectTestCaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectTestCase
     */
    select?: DefectTestCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectTestCaseInclude<ExtArgs> | null
    /**
     * The filter to search for the DefectTestCase to update in case it exists.
     */
    where: DefectTestCaseWhereUniqueInput
    /**
     * In case the DefectTestCase found by the `where` argument doesn't exist, create a new DefectTestCase with this data.
     */
    create: XOR<DefectTestCaseCreateInput, DefectTestCaseUncheckedCreateInput>
    /**
     * In case the DefectTestCase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DefectTestCaseUpdateInput, DefectTestCaseUncheckedUpdateInput>
  }

  /**
   * DefectTestCase delete
   */
  export type DefectTestCaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectTestCase
     */
    select?: DefectTestCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectTestCaseInclude<ExtArgs> | null
    /**
     * Filter which DefectTestCase to delete.
     */
    where: DefectTestCaseWhereUniqueInput
  }

  /**
   * DefectTestCase deleteMany
   */
  export type DefectTestCaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DefectTestCases to delete
     */
    where?: DefectTestCaseWhereInput
  }

  /**
   * DefectTestCase without action
   */
  export type DefectTestCaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectTestCase
     */
    select?: DefectTestCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectTestCaseInclude<ExtArgs> | null
  }


  /**
   * Model DefectComment
   */

  export type AggregateDefectComment = {
    _count: DefectCommentCountAggregateOutputType | null
    _min: DefectCommentMinAggregateOutputType | null
    _max: DefectCommentMaxAggregateOutputType | null
  }

  export type DefectCommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    defectId: string | null
    authorId: string | null
    isInternal: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DefectCommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    defectId: string | null
    authorId: string | null
    isInternal: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DefectCommentCountAggregateOutputType = {
    id: number
    content: number
    defectId: number
    authorId: number
    isInternal: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DefectCommentMinAggregateInputType = {
    id?: true
    content?: true
    defectId?: true
    authorId?: true
    isInternal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DefectCommentMaxAggregateInputType = {
    id?: true
    content?: true
    defectId?: true
    authorId?: true
    isInternal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DefectCommentCountAggregateInputType = {
    id?: true
    content?: true
    defectId?: true
    authorId?: true
    isInternal?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DefectCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DefectComment to aggregate.
     */
    where?: DefectCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefectComments to fetch.
     */
    orderBy?: DefectCommentOrderByWithRelationInput | DefectCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DefectCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefectComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefectComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DefectComments
    **/
    _count?: true | DefectCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DefectCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DefectCommentMaxAggregateInputType
  }

  export type GetDefectCommentAggregateType<T extends DefectCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateDefectComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDefectComment[P]>
      : GetScalarType<T[P], AggregateDefectComment[P]>
  }




  export type DefectCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefectCommentWhereInput
    orderBy?: DefectCommentOrderByWithAggregationInput | DefectCommentOrderByWithAggregationInput[]
    by: DefectCommentScalarFieldEnum[] | DefectCommentScalarFieldEnum
    having?: DefectCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DefectCommentCountAggregateInputType | true
    _min?: DefectCommentMinAggregateInputType
    _max?: DefectCommentMaxAggregateInputType
  }

  export type DefectCommentGroupByOutputType = {
    id: string
    content: string
    defectId: string
    authorId: string
    isInternal: boolean
    createdAt: Date
    updatedAt: Date
    _count: DefectCommentCountAggregateOutputType | null
    _min: DefectCommentMinAggregateOutputType | null
    _max: DefectCommentMaxAggregateOutputType | null
  }

  type GetDefectCommentGroupByPayload<T extends DefectCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DefectCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DefectCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DefectCommentGroupByOutputType[P]>
            : GetScalarType<T[P], DefectCommentGroupByOutputType[P]>
        }
      >
    >


  export type DefectCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    defectId?: boolean
    authorId?: boolean
    isInternal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    defect?: boolean | DefectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["defectComment"]>

  export type DefectCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    defectId?: boolean
    authorId?: boolean
    isInternal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    defect?: boolean | DefectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["defectComment"]>

  export type DefectCommentSelectScalar = {
    id?: boolean
    content?: boolean
    defectId?: boolean
    authorId?: boolean
    isInternal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DefectCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defect?: boolean | DefectDefaultArgs<ExtArgs>
  }
  export type DefectCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defect?: boolean | DefectDefaultArgs<ExtArgs>
  }

  export type $DefectCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DefectComment"
    objects: {
      defect: Prisma.$DefectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      defectId: string
      authorId: string
      isInternal: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["defectComment"]>
    composites: {}
  }

  type DefectCommentGetPayload<S extends boolean | null | undefined | DefectCommentDefaultArgs> = $Result.GetResult<Prisma.$DefectCommentPayload, S>

  type DefectCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DefectCommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DefectCommentCountAggregateInputType | true
    }

  export interface DefectCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DefectComment'], meta: { name: 'DefectComment' } }
    /**
     * Find zero or one DefectComment that matches the filter.
     * @param {DefectCommentFindUniqueArgs} args - Arguments to find a DefectComment
     * @example
     * // Get one DefectComment
     * const defectComment = await prisma.defectComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DefectCommentFindUniqueArgs>(args: SelectSubset<T, DefectCommentFindUniqueArgs<ExtArgs>>): Prisma__DefectCommentClient<$Result.GetResult<Prisma.$DefectCommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DefectComment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DefectCommentFindUniqueOrThrowArgs} args - Arguments to find a DefectComment
     * @example
     * // Get one DefectComment
     * const defectComment = await prisma.defectComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DefectCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, DefectCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DefectCommentClient<$Result.GetResult<Prisma.$DefectCommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DefectComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectCommentFindFirstArgs} args - Arguments to find a DefectComment
     * @example
     * // Get one DefectComment
     * const defectComment = await prisma.defectComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DefectCommentFindFirstArgs>(args?: SelectSubset<T, DefectCommentFindFirstArgs<ExtArgs>>): Prisma__DefectCommentClient<$Result.GetResult<Prisma.$DefectCommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DefectComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectCommentFindFirstOrThrowArgs} args - Arguments to find a DefectComment
     * @example
     * // Get one DefectComment
     * const defectComment = await prisma.defectComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DefectCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, DefectCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DefectCommentClient<$Result.GetResult<Prisma.$DefectCommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DefectComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DefectComments
     * const defectComments = await prisma.defectComment.findMany()
     * 
     * // Get first 10 DefectComments
     * const defectComments = await prisma.defectComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const defectCommentWithIdOnly = await prisma.defectComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DefectCommentFindManyArgs>(args?: SelectSubset<T, DefectCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefectCommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DefectComment.
     * @param {DefectCommentCreateArgs} args - Arguments to create a DefectComment.
     * @example
     * // Create one DefectComment
     * const DefectComment = await prisma.defectComment.create({
     *   data: {
     *     // ... data to create a DefectComment
     *   }
     * })
     * 
     */
    create<T extends DefectCommentCreateArgs>(args: SelectSubset<T, DefectCommentCreateArgs<ExtArgs>>): Prisma__DefectCommentClient<$Result.GetResult<Prisma.$DefectCommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DefectComments.
     * @param {DefectCommentCreateManyArgs} args - Arguments to create many DefectComments.
     * @example
     * // Create many DefectComments
     * const defectComment = await prisma.defectComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DefectCommentCreateManyArgs>(args?: SelectSubset<T, DefectCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DefectComments and returns the data saved in the database.
     * @param {DefectCommentCreateManyAndReturnArgs} args - Arguments to create many DefectComments.
     * @example
     * // Create many DefectComments
     * const defectComment = await prisma.defectComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DefectComments and only return the `id`
     * const defectCommentWithIdOnly = await prisma.defectComment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DefectCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, DefectCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefectCommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DefectComment.
     * @param {DefectCommentDeleteArgs} args - Arguments to delete one DefectComment.
     * @example
     * // Delete one DefectComment
     * const DefectComment = await prisma.defectComment.delete({
     *   where: {
     *     // ... filter to delete one DefectComment
     *   }
     * })
     * 
     */
    delete<T extends DefectCommentDeleteArgs>(args: SelectSubset<T, DefectCommentDeleteArgs<ExtArgs>>): Prisma__DefectCommentClient<$Result.GetResult<Prisma.$DefectCommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DefectComment.
     * @param {DefectCommentUpdateArgs} args - Arguments to update one DefectComment.
     * @example
     * // Update one DefectComment
     * const defectComment = await prisma.defectComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DefectCommentUpdateArgs>(args: SelectSubset<T, DefectCommentUpdateArgs<ExtArgs>>): Prisma__DefectCommentClient<$Result.GetResult<Prisma.$DefectCommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DefectComments.
     * @param {DefectCommentDeleteManyArgs} args - Arguments to filter DefectComments to delete.
     * @example
     * // Delete a few DefectComments
     * const { count } = await prisma.defectComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DefectCommentDeleteManyArgs>(args?: SelectSubset<T, DefectCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DefectComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DefectComments
     * const defectComment = await prisma.defectComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DefectCommentUpdateManyArgs>(args: SelectSubset<T, DefectCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DefectComment.
     * @param {DefectCommentUpsertArgs} args - Arguments to update or create a DefectComment.
     * @example
     * // Update or create a DefectComment
     * const defectComment = await prisma.defectComment.upsert({
     *   create: {
     *     // ... data to create a DefectComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DefectComment we want to update
     *   }
     * })
     */
    upsert<T extends DefectCommentUpsertArgs>(args: SelectSubset<T, DefectCommentUpsertArgs<ExtArgs>>): Prisma__DefectCommentClient<$Result.GetResult<Prisma.$DefectCommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DefectComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectCommentCountArgs} args - Arguments to filter DefectComments to count.
     * @example
     * // Count the number of DefectComments
     * const count = await prisma.defectComment.count({
     *   where: {
     *     // ... the filter for the DefectComments we want to count
     *   }
     * })
    **/
    count<T extends DefectCommentCountArgs>(
      args?: Subset<T, DefectCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DefectCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DefectComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DefectCommentAggregateArgs>(args: Subset<T, DefectCommentAggregateArgs>): Prisma.PrismaPromise<GetDefectCommentAggregateType<T>>

    /**
     * Group by DefectComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DefectCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DefectCommentGroupByArgs['orderBy'] }
        : { orderBy?: DefectCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DefectCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDefectCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DefectComment model
   */
  readonly fields: DefectCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DefectComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DefectCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    defect<T extends DefectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DefectDefaultArgs<ExtArgs>>): Prisma__DefectClient<$Result.GetResult<Prisma.$DefectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DefectComment model
   */ 
  interface DefectCommentFieldRefs {
    readonly id: FieldRef<"DefectComment", 'String'>
    readonly content: FieldRef<"DefectComment", 'String'>
    readonly defectId: FieldRef<"DefectComment", 'String'>
    readonly authorId: FieldRef<"DefectComment", 'String'>
    readonly isInternal: FieldRef<"DefectComment", 'Boolean'>
    readonly createdAt: FieldRef<"DefectComment", 'DateTime'>
    readonly updatedAt: FieldRef<"DefectComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DefectComment findUnique
   */
  export type DefectCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectComment
     */
    select?: DefectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectCommentInclude<ExtArgs> | null
    /**
     * Filter, which DefectComment to fetch.
     */
    where: DefectCommentWhereUniqueInput
  }

  /**
   * DefectComment findUniqueOrThrow
   */
  export type DefectCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectComment
     */
    select?: DefectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectCommentInclude<ExtArgs> | null
    /**
     * Filter, which DefectComment to fetch.
     */
    where: DefectCommentWhereUniqueInput
  }

  /**
   * DefectComment findFirst
   */
  export type DefectCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectComment
     */
    select?: DefectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectCommentInclude<ExtArgs> | null
    /**
     * Filter, which DefectComment to fetch.
     */
    where?: DefectCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefectComments to fetch.
     */
    orderBy?: DefectCommentOrderByWithRelationInput | DefectCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DefectComments.
     */
    cursor?: DefectCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefectComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefectComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DefectComments.
     */
    distinct?: DefectCommentScalarFieldEnum | DefectCommentScalarFieldEnum[]
  }

  /**
   * DefectComment findFirstOrThrow
   */
  export type DefectCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectComment
     */
    select?: DefectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectCommentInclude<ExtArgs> | null
    /**
     * Filter, which DefectComment to fetch.
     */
    where?: DefectCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefectComments to fetch.
     */
    orderBy?: DefectCommentOrderByWithRelationInput | DefectCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DefectComments.
     */
    cursor?: DefectCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefectComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefectComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DefectComments.
     */
    distinct?: DefectCommentScalarFieldEnum | DefectCommentScalarFieldEnum[]
  }

  /**
   * DefectComment findMany
   */
  export type DefectCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectComment
     */
    select?: DefectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectCommentInclude<ExtArgs> | null
    /**
     * Filter, which DefectComments to fetch.
     */
    where?: DefectCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefectComments to fetch.
     */
    orderBy?: DefectCommentOrderByWithRelationInput | DefectCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DefectComments.
     */
    cursor?: DefectCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefectComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefectComments.
     */
    skip?: number
    distinct?: DefectCommentScalarFieldEnum | DefectCommentScalarFieldEnum[]
  }

  /**
   * DefectComment create
   */
  export type DefectCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectComment
     */
    select?: DefectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a DefectComment.
     */
    data: XOR<DefectCommentCreateInput, DefectCommentUncheckedCreateInput>
  }

  /**
   * DefectComment createMany
   */
  export type DefectCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DefectComments.
     */
    data: DefectCommentCreateManyInput | DefectCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DefectComment createManyAndReturn
   */
  export type DefectCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectComment
     */
    select?: DefectCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DefectComments.
     */
    data: DefectCommentCreateManyInput | DefectCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DefectComment update
   */
  export type DefectCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectComment
     */
    select?: DefectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a DefectComment.
     */
    data: XOR<DefectCommentUpdateInput, DefectCommentUncheckedUpdateInput>
    /**
     * Choose, which DefectComment to update.
     */
    where: DefectCommentWhereUniqueInput
  }

  /**
   * DefectComment updateMany
   */
  export type DefectCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DefectComments.
     */
    data: XOR<DefectCommentUpdateManyMutationInput, DefectCommentUncheckedUpdateManyInput>
    /**
     * Filter which DefectComments to update
     */
    where?: DefectCommentWhereInput
  }

  /**
   * DefectComment upsert
   */
  export type DefectCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectComment
     */
    select?: DefectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the DefectComment to update in case it exists.
     */
    where: DefectCommentWhereUniqueInput
    /**
     * In case the DefectComment found by the `where` argument doesn't exist, create a new DefectComment with this data.
     */
    create: XOR<DefectCommentCreateInput, DefectCommentUncheckedCreateInput>
    /**
     * In case the DefectComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DefectCommentUpdateInput, DefectCommentUncheckedUpdateInput>
  }

  /**
   * DefectComment delete
   */
  export type DefectCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectComment
     */
    select?: DefectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectCommentInclude<ExtArgs> | null
    /**
     * Filter which DefectComment to delete.
     */
    where: DefectCommentWhereUniqueInput
  }

  /**
   * DefectComment deleteMany
   */
  export type DefectCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DefectComments to delete
     */
    where?: DefectCommentWhereInput
  }

  /**
   * DefectComment without action
   */
  export type DefectCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefectComment
     */
    select?: DefectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectCommentInclude<ExtArgs> | null
  }


  /**
   * Model QAReview
   */

  export type AggregateQAReview = {
    _count: QAReviewCountAggregateOutputType | null
    _min: QAReviewMinAggregateOutputType | null
    _max: QAReviewMaxAggregateOutputType | null
  }

  export type QAReviewMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: string | null
    entityId: string | null
    status: $Enums.QAReviewStatus | null
    findings: string | null
    recommendations: string | null
    approved: boolean | null
    testPlanId: string | null
    reviewerId: string | null
    reviewedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QAReviewMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: string | null
    entityId: string | null
    status: $Enums.QAReviewStatus | null
    findings: string | null
    recommendations: string | null
    approved: boolean | null
    testPlanId: string | null
    reviewerId: string | null
    reviewedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QAReviewCountAggregateOutputType = {
    id: number
    title: number
    description: number
    type: number
    entityId: number
    status: number
    criteria: number
    findings: number
    recommendations: number
    approved: number
    testPlanId: number
    reviewerId: number
    reviewedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QAReviewMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    entityId?: true
    status?: true
    findings?: true
    recommendations?: true
    approved?: true
    testPlanId?: true
    reviewerId?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QAReviewMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    entityId?: true
    status?: true
    findings?: true
    recommendations?: true
    approved?: true
    testPlanId?: true
    reviewerId?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QAReviewCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    entityId?: true
    status?: true
    criteria?: true
    findings?: true
    recommendations?: true
    approved?: true
    testPlanId?: true
    reviewerId?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QAReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QAReview to aggregate.
     */
    where?: QAReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QAReviews to fetch.
     */
    orderBy?: QAReviewOrderByWithRelationInput | QAReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QAReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QAReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QAReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QAReviews
    **/
    _count?: true | QAReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QAReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QAReviewMaxAggregateInputType
  }

  export type GetQAReviewAggregateType<T extends QAReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateQAReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQAReview[P]>
      : GetScalarType<T[P], AggregateQAReview[P]>
  }




  export type QAReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QAReviewWhereInput
    orderBy?: QAReviewOrderByWithAggregationInput | QAReviewOrderByWithAggregationInput[]
    by: QAReviewScalarFieldEnum[] | QAReviewScalarFieldEnum
    having?: QAReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QAReviewCountAggregateInputType | true
    _min?: QAReviewMinAggregateInputType
    _max?: QAReviewMaxAggregateInputType
  }

  export type QAReviewGroupByOutputType = {
    id: string
    title: string
    description: string | null
    type: string
    entityId: string
    status: $Enums.QAReviewStatus
    criteria: JsonValue | null
    findings: string | null
    recommendations: string | null
    approved: boolean | null
    testPlanId: string | null
    reviewerId: string
    reviewedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: QAReviewCountAggregateOutputType | null
    _min: QAReviewMinAggregateOutputType | null
    _max: QAReviewMaxAggregateOutputType | null
  }

  type GetQAReviewGroupByPayload<T extends QAReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QAReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QAReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QAReviewGroupByOutputType[P]>
            : GetScalarType<T[P], QAReviewGroupByOutputType[P]>
        }
      >
    >


  export type QAReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    entityId?: boolean
    status?: boolean
    criteria?: boolean
    findings?: boolean
    recommendations?: boolean
    approved?: boolean
    testPlanId?: boolean
    reviewerId?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    testPlan?: boolean | QAReview$testPlanArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qAReview"]>

  export type QAReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    entityId?: boolean
    status?: boolean
    criteria?: boolean
    findings?: boolean
    recommendations?: boolean
    approved?: boolean
    testPlanId?: boolean
    reviewerId?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    testPlan?: boolean | QAReview$testPlanArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qAReview"]>

  export type QAReviewSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    entityId?: boolean
    status?: boolean
    criteria?: boolean
    findings?: boolean
    recommendations?: boolean
    approved?: boolean
    testPlanId?: boolean
    reviewerId?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QAReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testPlan?: boolean | QAReview$testPlanArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QAReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testPlan?: boolean | QAReview$testPlanArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $QAReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QAReview"
    objects: {
      testPlan: Prisma.$TestPlanPayload<ExtArgs> | null
      reviewer: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      type: string
      entityId: string
      status: $Enums.QAReviewStatus
      criteria: Prisma.JsonValue | null
      findings: string | null
      recommendations: string | null
      approved: boolean | null
      testPlanId: string | null
      reviewerId: string
      reviewedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["qAReview"]>
    composites: {}
  }

  type QAReviewGetPayload<S extends boolean | null | undefined | QAReviewDefaultArgs> = $Result.GetResult<Prisma.$QAReviewPayload, S>

  type QAReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QAReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QAReviewCountAggregateInputType | true
    }

  export interface QAReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QAReview'], meta: { name: 'QAReview' } }
    /**
     * Find zero or one QAReview that matches the filter.
     * @param {QAReviewFindUniqueArgs} args - Arguments to find a QAReview
     * @example
     * // Get one QAReview
     * const qAReview = await prisma.qAReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QAReviewFindUniqueArgs>(args: SelectSubset<T, QAReviewFindUniqueArgs<ExtArgs>>): Prisma__QAReviewClient<$Result.GetResult<Prisma.$QAReviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QAReview that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QAReviewFindUniqueOrThrowArgs} args - Arguments to find a QAReview
     * @example
     * // Get one QAReview
     * const qAReview = await prisma.qAReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QAReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, QAReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QAReviewClient<$Result.GetResult<Prisma.$QAReviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QAReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QAReviewFindFirstArgs} args - Arguments to find a QAReview
     * @example
     * // Get one QAReview
     * const qAReview = await prisma.qAReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QAReviewFindFirstArgs>(args?: SelectSubset<T, QAReviewFindFirstArgs<ExtArgs>>): Prisma__QAReviewClient<$Result.GetResult<Prisma.$QAReviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QAReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QAReviewFindFirstOrThrowArgs} args - Arguments to find a QAReview
     * @example
     * // Get one QAReview
     * const qAReview = await prisma.qAReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QAReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, QAReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__QAReviewClient<$Result.GetResult<Prisma.$QAReviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QAReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QAReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QAReviews
     * const qAReviews = await prisma.qAReview.findMany()
     * 
     * // Get first 10 QAReviews
     * const qAReviews = await prisma.qAReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qAReviewWithIdOnly = await prisma.qAReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QAReviewFindManyArgs>(args?: SelectSubset<T, QAReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QAReviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QAReview.
     * @param {QAReviewCreateArgs} args - Arguments to create a QAReview.
     * @example
     * // Create one QAReview
     * const QAReview = await prisma.qAReview.create({
     *   data: {
     *     // ... data to create a QAReview
     *   }
     * })
     * 
     */
    create<T extends QAReviewCreateArgs>(args: SelectSubset<T, QAReviewCreateArgs<ExtArgs>>): Prisma__QAReviewClient<$Result.GetResult<Prisma.$QAReviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QAReviews.
     * @param {QAReviewCreateManyArgs} args - Arguments to create many QAReviews.
     * @example
     * // Create many QAReviews
     * const qAReview = await prisma.qAReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QAReviewCreateManyArgs>(args?: SelectSubset<T, QAReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QAReviews and returns the data saved in the database.
     * @param {QAReviewCreateManyAndReturnArgs} args - Arguments to create many QAReviews.
     * @example
     * // Create many QAReviews
     * const qAReview = await prisma.qAReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QAReviews and only return the `id`
     * const qAReviewWithIdOnly = await prisma.qAReview.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QAReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, QAReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QAReviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QAReview.
     * @param {QAReviewDeleteArgs} args - Arguments to delete one QAReview.
     * @example
     * // Delete one QAReview
     * const QAReview = await prisma.qAReview.delete({
     *   where: {
     *     // ... filter to delete one QAReview
     *   }
     * })
     * 
     */
    delete<T extends QAReviewDeleteArgs>(args: SelectSubset<T, QAReviewDeleteArgs<ExtArgs>>): Prisma__QAReviewClient<$Result.GetResult<Prisma.$QAReviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QAReview.
     * @param {QAReviewUpdateArgs} args - Arguments to update one QAReview.
     * @example
     * // Update one QAReview
     * const qAReview = await prisma.qAReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QAReviewUpdateArgs>(args: SelectSubset<T, QAReviewUpdateArgs<ExtArgs>>): Prisma__QAReviewClient<$Result.GetResult<Prisma.$QAReviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QAReviews.
     * @param {QAReviewDeleteManyArgs} args - Arguments to filter QAReviews to delete.
     * @example
     * // Delete a few QAReviews
     * const { count } = await prisma.qAReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QAReviewDeleteManyArgs>(args?: SelectSubset<T, QAReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QAReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QAReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QAReviews
     * const qAReview = await prisma.qAReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QAReviewUpdateManyArgs>(args: SelectSubset<T, QAReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QAReview.
     * @param {QAReviewUpsertArgs} args - Arguments to update or create a QAReview.
     * @example
     * // Update or create a QAReview
     * const qAReview = await prisma.qAReview.upsert({
     *   create: {
     *     // ... data to create a QAReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QAReview we want to update
     *   }
     * })
     */
    upsert<T extends QAReviewUpsertArgs>(args: SelectSubset<T, QAReviewUpsertArgs<ExtArgs>>): Prisma__QAReviewClient<$Result.GetResult<Prisma.$QAReviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QAReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QAReviewCountArgs} args - Arguments to filter QAReviews to count.
     * @example
     * // Count the number of QAReviews
     * const count = await prisma.qAReview.count({
     *   where: {
     *     // ... the filter for the QAReviews we want to count
     *   }
     * })
    **/
    count<T extends QAReviewCountArgs>(
      args?: Subset<T, QAReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QAReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QAReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QAReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QAReviewAggregateArgs>(args: Subset<T, QAReviewAggregateArgs>): Prisma.PrismaPromise<GetQAReviewAggregateType<T>>

    /**
     * Group by QAReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QAReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QAReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QAReviewGroupByArgs['orderBy'] }
        : { orderBy?: QAReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QAReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQAReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QAReview model
   */
  readonly fields: QAReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QAReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QAReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    testPlan<T extends QAReview$testPlanArgs<ExtArgs> = {}>(args?: Subset<T, QAReview$testPlanArgs<ExtArgs>>): Prisma__TestPlanClient<$Result.GetResult<Prisma.$TestPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    reviewer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QAReview model
   */ 
  interface QAReviewFieldRefs {
    readonly id: FieldRef<"QAReview", 'String'>
    readonly title: FieldRef<"QAReview", 'String'>
    readonly description: FieldRef<"QAReview", 'String'>
    readonly type: FieldRef<"QAReview", 'String'>
    readonly entityId: FieldRef<"QAReview", 'String'>
    readonly status: FieldRef<"QAReview", 'QAReviewStatus'>
    readonly criteria: FieldRef<"QAReview", 'Json'>
    readonly findings: FieldRef<"QAReview", 'String'>
    readonly recommendations: FieldRef<"QAReview", 'String'>
    readonly approved: FieldRef<"QAReview", 'Boolean'>
    readonly testPlanId: FieldRef<"QAReview", 'String'>
    readonly reviewerId: FieldRef<"QAReview", 'String'>
    readonly reviewedAt: FieldRef<"QAReview", 'DateTime'>
    readonly createdAt: FieldRef<"QAReview", 'DateTime'>
    readonly updatedAt: FieldRef<"QAReview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QAReview findUnique
   */
  export type QAReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAReview
     */
    select?: QAReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAReviewInclude<ExtArgs> | null
    /**
     * Filter, which QAReview to fetch.
     */
    where: QAReviewWhereUniqueInput
  }

  /**
   * QAReview findUniqueOrThrow
   */
  export type QAReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAReview
     */
    select?: QAReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAReviewInclude<ExtArgs> | null
    /**
     * Filter, which QAReview to fetch.
     */
    where: QAReviewWhereUniqueInput
  }

  /**
   * QAReview findFirst
   */
  export type QAReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAReview
     */
    select?: QAReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAReviewInclude<ExtArgs> | null
    /**
     * Filter, which QAReview to fetch.
     */
    where?: QAReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QAReviews to fetch.
     */
    orderBy?: QAReviewOrderByWithRelationInput | QAReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QAReviews.
     */
    cursor?: QAReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QAReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QAReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QAReviews.
     */
    distinct?: QAReviewScalarFieldEnum | QAReviewScalarFieldEnum[]
  }

  /**
   * QAReview findFirstOrThrow
   */
  export type QAReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAReview
     */
    select?: QAReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAReviewInclude<ExtArgs> | null
    /**
     * Filter, which QAReview to fetch.
     */
    where?: QAReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QAReviews to fetch.
     */
    orderBy?: QAReviewOrderByWithRelationInput | QAReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QAReviews.
     */
    cursor?: QAReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QAReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QAReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QAReviews.
     */
    distinct?: QAReviewScalarFieldEnum | QAReviewScalarFieldEnum[]
  }

  /**
   * QAReview findMany
   */
  export type QAReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAReview
     */
    select?: QAReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAReviewInclude<ExtArgs> | null
    /**
     * Filter, which QAReviews to fetch.
     */
    where?: QAReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QAReviews to fetch.
     */
    orderBy?: QAReviewOrderByWithRelationInput | QAReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QAReviews.
     */
    cursor?: QAReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QAReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QAReviews.
     */
    skip?: number
    distinct?: QAReviewScalarFieldEnum | QAReviewScalarFieldEnum[]
  }

  /**
   * QAReview create
   */
  export type QAReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAReview
     */
    select?: QAReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a QAReview.
     */
    data: XOR<QAReviewCreateInput, QAReviewUncheckedCreateInput>
  }

  /**
   * QAReview createMany
   */
  export type QAReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QAReviews.
     */
    data: QAReviewCreateManyInput | QAReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QAReview createManyAndReturn
   */
  export type QAReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAReview
     */
    select?: QAReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QAReviews.
     */
    data: QAReviewCreateManyInput | QAReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QAReview update
   */
  export type QAReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAReview
     */
    select?: QAReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a QAReview.
     */
    data: XOR<QAReviewUpdateInput, QAReviewUncheckedUpdateInput>
    /**
     * Choose, which QAReview to update.
     */
    where: QAReviewWhereUniqueInput
  }

  /**
   * QAReview updateMany
   */
  export type QAReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QAReviews.
     */
    data: XOR<QAReviewUpdateManyMutationInput, QAReviewUncheckedUpdateManyInput>
    /**
     * Filter which QAReviews to update
     */
    where?: QAReviewWhereInput
  }

  /**
   * QAReview upsert
   */
  export type QAReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAReview
     */
    select?: QAReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the QAReview to update in case it exists.
     */
    where: QAReviewWhereUniqueInput
    /**
     * In case the QAReview found by the `where` argument doesn't exist, create a new QAReview with this data.
     */
    create: XOR<QAReviewCreateInput, QAReviewUncheckedCreateInput>
    /**
     * In case the QAReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QAReviewUpdateInput, QAReviewUncheckedUpdateInput>
  }

  /**
   * QAReview delete
   */
  export type QAReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAReview
     */
    select?: QAReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAReviewInclude<ExtArgs> | null
    /**
     * Filter which QAReview to delete.
     */
    where: QAReviewWhereUniqueInput
  }

  /**
   * QAReview deleteMany
   */
  export type QAReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QAReviews to delete
     */
    where?: QAReviewWhereInput
  }

  /**
   * QAReview.testPlan
   */
  export type QAReview$testPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPlan
     */
    select?: TestPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPlanInclude<ExtArgs> | null
    where?: TestPlanWhereInput
  }

  /**
   * QAReview without action
   */
  export type QAReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAReview
     */
    select?: QAReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAReviewInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    role: 'role',
    isActive: 'isActive',
    lastLoginAt: 'lastLoginAt',
    emailVerifiedAt: 'emailVerifiedAt',
    twoFactorSecret: 'twoFactorSecret',
    twoFactorEnabled: 'twoFactorEnabled',
    avatarUrl: 'avatarUrl',
    timezone: 'timezone',
    preferences: 'preferences',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    updatedById: 'updatedById'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    name: 'name',
    legalName: 'legalName',
    emails: 'emails',
    phones: 'phones',
    billingAddress: 'billingAddress',
    siteAddresses: 'siteAddresses',
    ownerId: 'ownerId',
    tags: 'tags',
    status: 'status',
    portalToken: 'portalToken',
    designFeePaid: 'designFeePaid',
    consentMarketing: 'consentMarketing',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    createdById: 'createdById',
    updatedById: 'updatedById'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const EnquiryScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    source: 'source',
    campaign: 'campaign',
    medium: 'medium',
    estimatedValue: 'estimatedValue',
    contactMethod: 'contactMethod',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    mobile: 'mobile',
    company: 'company',
    message: 'message',
    accountId: 'accountId',
    ownerId: 'ownerId',
    leadId: 'leadId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    updatedById: 'updatedById'
  };

  export type EnquiryScalarFieldEnum = (typeof EnquiryScalarFieldEnum)[keyof typeof EnquiryScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    name: 'name',
    role: 'role',
    email: 'email',
    phone: 'phone',
    isPrimary: 'isPrimary',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const LeadScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    estimatedValue: 'estimatedValue',
    probability: 'probability',
    expectedCloseDate: 'expectedCloseDate',
    source: 'source',
    campaign: 'campaign',
    medium: 'medium',
    firstResponseAt: 'firstResponseAt',
    responseTime: 'responseTime',
    accountId: 'accountId',
    ownerId: 'ownerId',
    enquiryId: 'enquiryId',
    projectId: 'projectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    updatedById: 'updatedById'
  };

  export type LeadScalarFieldEnum = (typeof LeadScalarFieldEnum)[keyof typeof LeadScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    type: 'type',
    status: 'status',
    accountId: 'accountId',
    ownerId: 'ownerId',
    amountGrossIncVat: 'amountGrossIncVat',
    vatRate: 'vatRate',
    probability: 'probability',
    source: 'source',
    utm: 'utm',
    leadId: 'leadId',
    completedProjectId: 'completedProjectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const CompletedProjectScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    projectId: 'projectId',
    ownerId: 'ownerId',
    title: 'title',
    description: 'description',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompletedProjectScalarFieldEnum = (typeof CompletedProjectScalarFieldEnum)[keyof typeof CompletedProjectScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    enquiryId: 'enquiryId',
    leadId: 'leadId',
    projectId: 'projectId',
    userId: 'userId',
    type: 'type',
    threadKey: 'threadKey',
    summary: 'summary',
    body: 'body',
    attachments: 'attachments',
    durations: 'durations',
    metadata: 'metadata',
    occurredAt: 'occurredAt',
    createdAt: 'createdAt'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    dueDate: 'dueDate',
    completedAt: 'completedAt',
    assigneeId: 'assigneeId',
    accountId: 'accountId',
    enquiryId: 'enquiryId',
    leadId: 'leadId',
    projectId: 'projectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    projectId: 'projectId',
    title: 'title',
    description: 'description',
    type: 'type',
    startTime: 'startTime',
    endTime: 'endTime',
    location: 'location',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    projectId: 'projectId',
    filename: 'filename',
    fileUrl: 'fileUrl',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    type: 'type',
    uploadedBy: 'uploadedBy',
    createdAt: 'createdAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const SnagScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    projectId: 'projectId',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    assigneeId: 'assigneeId',
    dueAt: 'dueAt',
    photos: 'photos',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SnagScalarFieldEnum = (typeof SnagScalarFieldEnum)[keyof typeof SnagScalarFieldEnum]


  export const EventLogScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    actorId: 'actorId',
    entity: 'entity',
    entityId: 'entityId',
    action: 'action',
    before: 'before',
    after: 'after',
    createdAt: 'createdAt'
  };

  export type EventLogScalarFieldEnum = (typeof EventLogScalarFieldEnum)[keyof typeof EventLogScalarFieldEnum]


  export const WorkflowDefinitionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    version: 'version',
    isActive: 'isActive',
    triggerType: 'triggerType',
    triggerConditions: 'triggerConditions',
    accountId: 'accountId',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkflowDefinitionScalarFieldEnum = (typeof WorkflowDefinitionScalarFieldEnum)[keyof typeof WorkflowDefinitionScalarFieldEnum]


  export const WorkflowStepScalarFieldEnum: {
    id: 'id',
    workflowId: 'workflowId',
    name: 'name',
    description: 'description',
    stepType: 'stepType',
    position: 'position',
    configuration: 'configuration',
    conditions: 'conditions',
    isRequired: 'isRequired',
    timeoutMinutes: 'timeoutMinutes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkflowStepScalarFieldEnum = (typeof WorkflowStepScalarFieldEnum)[keyof typeof WorkflowStepScalarFieldEnum]


  export const WorkflowStepApproverScalarFieldEnum: {
    id: 'id',
    stepId: 'stepId',
    userId: 'userId',
    approverType: 'approverType',
    isRequired: 'isRequired',
    order: 'order',
    createdAt: 'createdAt'
  };

  export type WorkflowStepApproverScalarFieldEnum = (typeof WorkflowStepApproverScalarFieldEnum)[keyof typeof WorkflowStepApproverScalarFieldEnum]


  export const WorkflowInstanceScalarFieldEnum: {
    id: 'id',
    workflowId: 'workflowId',
    entityType: 'entityType',
    entityId: 'entityId',
    status: 'status',
    currentStepId: 'currentStepId',
    priority: 'priority',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    errorMessage: 'errorMessage',
    metadata: 'metadata',
    accountId: 'accountId',
    initiatedById: 'initiatedById'
  };

  export type WorkflowInstanceScalarFieldEnum = (typeof WorkflowInstanceScalarFieldEnum)[keyof typeof WorkflowInstanceScalarFieldEnum]


  export const WorkflowStepExecutionScalarFieldEnum: {
    id: 'id',
    instanceId: 'instanceId',
    stepId: 'stepId',
    status: 'status',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    assignedToId: 'assignedToId',
    result: 'result',
    errorMessage: 'errorMessage',
    retryCount: 'retryCount',
    isManual: 'isManual'
  };

  export type WorkflowStepExecutionScalarFieldEnum = (typeof WorkflowStepExecutionScalarFieldEnum)[keyof typeof WorkflowStepExecutionScalarFieldEnum]


  export const WorkflowApprovalScalarFieldEnum: {
    id: 'id',
    instanceId: 'instanceId',
    approverId: 'approverId',
    stepApproverId: 'stepApproverId',
    status: 'status',
    comments: 'comments',
    approvedAt: 'approvedAt',
    rejectedAt: 'rejectedAt',
    requestedAt: 'requestedAt',
    remindersSent: 'remindersSent',
    lastReminderAt: 'lastReminderAt'
  };

  export type WorkflowApprovalScalarFieldEnum = (typeof WorkflowApprovalScalarFieldEnum)[keyof typeof WorkflowApprovalScalarFieldEnum]


  export const WorkflowTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    industry: 'industry',
    templateData: 'templateData',
    isPublic: 'isPublic',
    usageCount: 'usageCount',
    rating: 'rating',
    accountId: 'accountId',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    workflowId: 'workflowId'
  };

  export type WorkflowTemplateScalarFieldEnum = (typeof WorkflowTemplateScalarFieldEnum)[keyof typeof WorkflowTemplateScalarFieldEnum]


  export const AutomationRuleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    triggerEvent: 'triggerEvent',
    conditions: 'conditions',
    actions: 'actions',
    isActive: 'isActive',
    priority: 'priority',
    executionCount: 'executionCount',
    lastExecutedAt: 'lastExecutedAt',
    accountId: 'accountId',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AutomationRuleScalarFieldEnum = (typeof AutomationRuleScalarFieldEnum)[keyof typeof AutomationRuleScalarFieldEnum]


  export const AutomationExecutionScalarFieldEnum: {
    id: 'id',
    ruleId: 'ruleId',
    triggerData: 'triggerData',
    result: 'result',
    status: 'status',
    errorMessage: 'errorMessage',
    executedAt: 'executedAt',
    durationMs: 'durationMs'
  };

  export type AutomationExecutionScalarFieldEnum = (typeof AutomationExecutionScalarFieldEnum)[keyof typeof AutomationExecutionScalarFieldEnum]


  export const TestPlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    version: 'version',
    status: 'status',
    projectId: 'projectId',
    feature: 'feature',
    environment: 'environment',
    startDate: 'startDate',
    endDate: 'endDate',
    createdById: 'createdById',
    assignedToId: 'assignedToId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TestPlanScalarFieldEnum = (typeof TestPlanScalarFieldEnum)[keyof typeof TestPlanScalarFieldEnum]


  export const TestCaseScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    preconditions: 'preconditions',
    steps: 'steps',
    expectedResult: 'expectedResult',
    priority: 'priority',
    status: 'status',
    tags: 'tags',
    automatable: 'automatable',
    estimatedTime: 'estimatedTime',
    testPlanId: 'testPlanId',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TestCaseScalarFieldEnum = (typeof TestCaseScalarFieldEnum)[keyof typeof TestCaseScalarFieldEnum]


  export const TestExecutionScalarFieldEnum: {
    id: 'id',
    testPlanId: 'testPlanId',
    testCaseId: 'testCaseId',
    status: 'status',
    result: 'result',
    actualResult: 'actualResult',
    evidence: 'evidence',
    executionTime: 'executionTime',
    environment: 'environment',
    browserVersion: 'browserVersion',
    osVersion: 'osVersion',
    notes: 'notes',
    executedById: 'executedById',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TestExecutionScalarFieldEnum = (typeof TestExecutionScalarFieldEnum)[keyof typeof TestExecutionScalarFieldEnum]


  export const DefectScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    steps: 'steps',
    expectedBehavior: 'expectedBehavior',
    actualBehavior: 'actualBehavior',
    severity: 'severity',
    priority: 'priority',
    status: 'status',
    environment: 'environment',
    browserVersion: 'browserVersion',
    osVersion: 'osVersion',
    attachments: 'attachments',
    reproducible: 'reproducible',
    regression: 'regression',
    testExecutionId: 'testExecutionId',
    reportedById: 'reportedById',
    assignedToId: 'assignedToId',
    reportedAt: 'reportedAt',
    resolvedAt: 'resolvedAt',
    closedAt: 'closedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DefectScalarFieldEnum = (typeof DefectScalarFieldEnum)[keyof typeof DefectScalarFieldEnum]


  export const DefectTestCaseScalarFieldEnum: {
    id: 'id',
    defectId: 'defectId',
    testCaseId: 'testCaseId',
    createdAt: 'createdAt'
  };

  export type DefectTestCaseScalarFieldEnum = (typeof DefectTestCaseScalarFieldEnum)[keyof typeof DefectTestCaseScalarFieldEnum]


  export const DefectCommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    defectId: 'defectId',
    authorId: 'authorId',
    isInternal: 'isInternal',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DefectCommentScalarFieldEnum = (typeof DefectCommentScalarFieldEnum)[keyof typeof DefectCommentScalarFieldEnum]


  export const QAReviewScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    type: 'type',
    entityId: 'entityId',
    status: 'status',
    criteria: 'criteria',
    findings: 'findings',
    recommendations: 'recommendations',
    approved: 'approved',
    testPlanId: 'testPlanId',
    reviewerId: 'reviewerId',
    reviewedAt: 'reviewedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QAReviewScalarFieldEnum = (typeof QAReviewScalarFieldEnum)[keyof typeof QAReviewScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'AccountStatus'
   */
  export type EnumAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountStatus'>
    


  /**
   * Reference to a field of type 'AccountStatus[]'
   */
  export type ListEnumAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountStatus[]'>
    


  /**
   * Reference to a field of type 'EnquiryStatus'
   */
  export type EnumEnquiryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnquiryStatus'>
    


  /**
   * Reference to a field of type 'EnquiryStatus[]'
   */
  export type ListEnumEnquiryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnquiryStatus[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'LeadStatus'
   */
  export type EnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus'>
    


  /**
   * Reference to a field of type 'LeadStatus[]'
   */
  export type ListEnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ProjectType'
   */
  export type EnumProjectTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectType'>
    


  /**
   * Reference to a field of type 'ProjectType[]'
   */
  export type ListEnumProjectTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectType[]'>
    


  /**
   * Reference to a field of type 'ProjectStatus'
   */
  export type EnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus'>
    


  /**
   * Reference to a field of type 'ProjectStatus[]'
   */
  export type ListEnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'CompletedProjectStatus'
   */
  export type EnumCompletedProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompletedProjectStatus'>
    


  /**
   * Reference to a field of type 'CompletedProjectStatus[]'
   */
  export type ListEnumCompletedProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompletedProjectStatus[]'>
    


  /**
   * Reference to a field of type 'ActivityType'
   */
  export type EnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType'>
    


  /**
   * Reference to a field of type 'ActivityType[]'
   */
  export type ListEnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType[]'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'TaskStatus[]'
   */
  export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus[]'>
    


  /**
   * Reference to a field of type 'AppointmentType'
   */
  export type EnumAppointmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentType'>
    


  /**
   * Reference to a field of type 'AppointmentType[]'
   */
  export type ListEnumAppointmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentType[]'>
    


  /**
   * Reference to a field of type 'AppointmentStatus'
   */
  export type EnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus'>
    


  /**
   * Reference to a field of type 'AppointmentStatus[]'
   */
  export type ListEnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'SnagStatus'
   */
  export type EnumSnagStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SnagStatus'>
    


  /**
   * Reference to a field of type 'SnagStatus[]'
   */
  export type ListEnumSnagStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SnagStatus[]'>
    


  /**
   * Reference to a field of type 'WorkflowTriggerType'
   */
  export type EnumWorkflowTriggerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowTriggerType'>
    


  /**
   * Reference to a field of type 'WorkflowTriggerType[]'
   */
  export type ListEnumWorkflowTriggerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowTriggerType[]'>
    


  /**
   * Reference to a field of type 'WorkflowStepType'
   */
  export type EnumWorkflowStepTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowStepType'>
    


  /**
   * Reference to a field of type 'WorkflowStepType[]'
   */
  export type ListEnumWorkflowStepTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowStepType[]'>
    


  /**
   * Reference to a field of type 'ApproverType'
   */
  export type EnumApproverTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApproverType'>
    


  /**
   * Reference to a field of type 'ApproverType[]'
   */
  export type ListEnumApproverTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApproverType[]'>
    


  /**
   * Reference to a field of type 'WorkflowStatus'
   */
  export type EnumWorkflowStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowStatus'>
    


  /**
   * Reference to a field of type 'WorkflowStatus[]'
   */
  export type ListEnumWorkflowStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowStatus[]'>
    


  /**
   * Reference to a field of type 'WorkflowStepStatus'
   */
  export type EnumWorkflowStepStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowStepStatus'>
    


  /**
   * Reference to a field of type 'WorkflowStepStatus[]'
   */
  export type ListEnumWorkflowStepStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowStepStatus[]'>
    


  /**
   * Reference to a field of type 'ApprovalStatus'
   */
  export type EnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus'>
    


  /**
   * Reference to a field of type 'ApprovalStatus[]'
   */
  export type ListEnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus[]'>
    


  /**
   * Reference to a field of type 'AutomationStatus'
   */
  export type EnumAutomationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutomationStatus'>
    


  /**
   * Reference to a field of type 'AutomationStatus[]'
   */
  export type ListEnumAutomationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutomationStatus[]'>
    


  /**
   * Reference to a field of type 'TestPlanStatus'
   */
  export type EnumTestPlanStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TestPlanStatus'>
    


  /**
   * Reference to a field of type 'TestPlanStatus[]'
   */
  export type ListEnumTestPlanStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TestPlanStatus[]'>
    


  /**
   * Reference to a field of type 'TestCasePriority'
   */
  export type EnumTestCasePriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TestCasePriority'>
    


  /**
   * Reference to a field of type 'TestCasePriority[]'
   */
  export type ListEnumTestCasePriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TestCasePriority[]'>
    


  /**
   * Reference to a field of type 'TestCaseStatus'
   */
  export type EnumTestCaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TestCaseStatus'>
    


  /**
   * Reference to a field of type 'TestCaseStatus[]'
   */
  export type ListEnumTestCaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TestCaseStatus[]'>
    


  /**
   * Reference to a field of type 'TestExecutionStatus'
   */
  export type EnumTestExecutionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TestExecutionStatus'>
    


  /**
   * Reference to a field of type 'TestExecutionStatus[]'
   */
  export type ListEnumTestExecutionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TestExecutionStatus[]'>
    


  /**
   * Reference to a field of type 'DefectSeverity'
   */
  export type EnumDefectSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DefectSeverity'>
    


  /**
   * Reference to a field of type 'DefectSeverity[]'
   */
  export type ListEnumDefectSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DefectSeverity[]'>
    


  /**
   * Reference to a field of type 'DefectPriority'
   */
  export type EnumDefectPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DefectPriority'>
    


  /**
   * Reference to a field of type 'DefectPriority[]'
   */
  export type ListEnumDefectPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DefectPriority[]'>
    


  /**
   * Reference to a field of type 'DefectStatus'
   */
  export type EnumDefectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DefectStatus'>
    


  /**
   * Reference to a field of type 'DefectStatus[]'
   */
  export type ListEnumDefectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DefectStatus[]'>
    


  /**
   * Reference to a field of type 'QAReviewStatus'
   */
  export type EnumQAReviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QAReviewStatus'>
    


  /**
   * Reference to a field of type 'QAReviewStatus[]'
   */
  export type ListEnumQAReviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QAReviewStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    avatarUrl?: StringNullableFilter<"User"> | string | null
    timezone?: StringFilter<"User"> | string
    preferences?: JsonFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdById?: StringNullableFilter<"User"> | string | null
    updatedById?: StringNullableFilter<"User"> | string | null
    ownedAccounts?: AccountListRelationFilter
    activities?: ActivityListRelationFilter
    ownedCompletedProjects?: CompletedProjectListRelationFilter
    ownedEnquiries?: EnquiryListRelationFilter
    ownedLeads?: LeadListRelationFilter
    ownedProjects?: ProjectListRelationFilter
    assignedTasks?: TaskListRelationFilter
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    createdUsers?: UserListRelationFilter
    updatedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    updatedUsers?: UserListRelationFilter
    createdWorkflows?: WorkflowDefinitionListRelationFilter
    initiatedWorkflows?: WorkflowInstanceListRelationFilter
    assignedSteps?: WorkflowStepExecutionListRelationFilter
    approverSteps?: WorkflowStepApproverListRelationFilter
    approvals?: WorkflowApprovalListRelationFilter
    createdTemplates?: WorkflowTemplateListRelationFilter
    createdRules?: AutomationRuleListRelationFilter
    createdTestPlans?: TestPlanListRelationFilter
    assignedTestPlans?: TestPlanListRelationFilter
    createdTestCases?: TestCaseListRelationFilter
    testExecutions?: TestExecutionListRelationFilter
    reportedDefects?: DefectListRelationFilter
    assignedDefects?: DefectListRelationFilter
    qaReviews?: QAReviewListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    timezone?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    ownedAccounts?: AccountOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
    ownedCompletedProjects?: CompletedProjectOrderByRelationAggregateInput
    ownedEnquiries?: EnquiryOrderByRelationAggregateInput
    ownedLeads?: LeadOrderByRelationAggregateInput
    ownedProjects?: ProjectOrderByRelationAggregateInput
    assignedTasks?: TaskOrderByRelationAggregateInput
    createdBy?: UserOrderByWithRelationInput
    createdUsers?: UserOrderByRelationAggregateInput
    updatedBy?: UserOrderByWithRelationInput
    updatedUsers?: UserOrderByRelationAggregateInput
    createdWorkflows?: WorkflowDefinitionOrderByRelationAggregateInput
    initiatedWorkflows?: WorkflowInstanceOrderByRelationAggregateInput
    assignedSteps?: WorkflowStepExecutionOrderByRelationAggregateInput
    approverSteps?: WorkflowStepApproverOrderByRelationAggregateInput
    approvals?: WorkflowApprovalOrderByRelationAggregateInput
    createdTemplates?: WorkflowTemplateOrderByRelationAggregateInput
    createdRules?: AutomationRuleOrderByRelationAggregateInput
    createdTestPlans?: TestPlanOrderByRelationAggregateInput
    assignedTestPlans?: TestPlanOrderByRelationAggregateInput
    createdTestCases?: TestCaseOrderByRelationAggregateInput
    testExecutions?: TestExecutionOrderByRelationAggregateInput
    reportedDefects?: DefectOrderByRelationAggregateInput
    assignedDefects?: DefectOrderByRelationAggregateInput
    qaReviews?: QAReviewOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    avatarUrl?: StringNullableFilter<"User"> | string | null
    timezone?: StringFilter<"User"> | string
    preferences?: JsonFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdById?: StringNullableFilter<"User"> | string | null
    updatedById?: StringNullableFilter<"User"> | string | null
    ownedAccounts?: AccountListRelationFilter
    activities?: ActivityListRelationFilter
    ownedCompletedProjects?: CompletedProjectListRelationFilter
    ownedEnquiries?: EnquiryListRelationFilter
    ownedLeads?: LeadListRelationFilter
    ownedProjects?: ProjectListRelationFilter
    assignedTasks?: TaskListRelationFilter
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    createdUsers?: UserListRelationFilter
    updatedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    updatedUsers?: UserListRelationFilter
    createdWorkflows?: WorkflowDefinitionListRelationFilter
    initiatedWorkflows?: WorkflowInstanceListRelationFilter
    assignedSteps?: WorkflowStepExecutionListRelationFilter
    approverSteps?: WorkflowStepApproverListRelationFilter
    approvals?: WorkflowApprovalListRelationFilter
    createdTemplates?: WorkflowTemplateListRelationFilter
    createdRules?: AutomationRuleListRelationFilter
    createdTestPlans?: TestPlanListRelationFilter
    assignedTestPlans?: TestPlanListRelationFilter
    createdTestCases?: TestCaseListRelationFilter
    testExecutions?: TestExecutionListRelationFilter
    reportedDefects?: DefectListRelationFilter
    assignedDefects?: DefectListRelationFilter
    qaReviews?: QAReviewListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    timezone?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    emailVerifiedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    twoFactorSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    twoFactorEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    timezone?: StringWithAggregatesFilter<"User"> | string
    preferences?: JsonWithAggregatesFilter<"User">
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"User"> | string | null
    updatedById?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    orgId?: StringNullableFilter<"Account"> | string | null
    name?: StringFilter<"Account"> | string
    legalName?: StringNullableFilter<"Account"> | string | null
    emails?: StringNullableListFilter<"Account">
    phones?: StringNullableListFilter<"Account">
    billingAddress?: JsonNullableFilter<"Account">
    siteAddresses?: JsonNullableFilter<"Account">
    ownerId?: StringFilter<"Account"> | string
    tags?: StringNullableListFilter<"Account">
    status?: EnumAccountStatusFilter<"Account"> | $Enums.AccountStatus
    portalToken?: StringFilter<"Account"> | string
    designFeePaid?: BoolFilter<"Account"> | boolean
    consentMarketing?: BoolFilter<"Account"> | boolean
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    createdById?: StringNullableFilter<"Account"> | string | null
    updatedById?: StringNullableFilter<"Account"> | string | null
    owner?: XOR<UserRelationFilter, UserWhereInput>
    activities?: ActivityListRelationFilter
    appointments?: AppointmentListRelationFilter
    completedProjects?: CompletedProjectListRelationFilter
    contacts?: ContactListRelationFilter
    documents?: DocumentListRelationFilter
    enquiries?: EnquiryListRelationFilter
    events?: EventLogListRelationFilter
    leads?: LeadListRelationFilter
    projects?: ProjectListRelationFilter
    snags?: SnagListRelationFilter
    tasks?: TaskListRelationFilter
    workflows?: WorkflowDefinitionListRelationFilter
    workflowInstances?: WorkflowInstanceListRelationFilter
    workflowTemplates?: WorkflowTemplateListRelationFilter
    automationRules?: AutomationRuleListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrderInput | SortOrder
    name?: SortOrder
    legalName?: SortOrderInput | SortOrder
    emails?: SortOrder
    phones?: SortOrder
    billingAddress?: SortOrderInput | SortOrder
    siteAddresses?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    tags?: SortOrder
    status?: SortOrder
    portalToken?: SortOrder
    designFeePaid?: SortOrder
    consentMarketing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    owner?: UserOrderByWithRelationInput
    activities?: ActivityOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    completedProjects?: CompletedProjectOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    enquiries?: EnquiryOrderByRelationAggregateInput
    events?: EventLogOrderByRelationAggregateInput
    leads?: LeadOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
    snags?: SnagOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    workflows?: WorkflowDefinitionOrderByRelationAggregateInput
    workflowInstances?: WorkflowInstanceOrderByRelationAggregateInput
    workflowTemplates?: WorkflowTemplateOrderByRelationAggregateInput
    automationRules?: AutomationRuleOrderByRelationAggregateInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    portalToken?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    orgId?: StringNullableFilter<"Account"> | string | null
    name?: StringFilter<"Account"> | string
    legalName?: StringNullableFilter<"Account"> | string | null
    emails?: StringNullableListFilter<"Account">
    phones?: StringNullableListFilter<"Account">
    billingAddress?: JsonNullableFilter<"Account">
    siteAddresses?: JsonNullableFilter<"Account">
    ownerId?: StringFilter<"Account"> | string
    tags?: StringNullableListFilter<"Account">
    status?: EnumAccountStatusFilter<"Account"> | $Enums.AccountStatus
    designFeePaid?: BoolFilter<"Account"> | boolean
    consentMarketing?: BoolFilter<"Account"> | boolean
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    createdById?: StringNullableFilter<"Account"> | string | null
    updatedById?: StringNullableFilter<"Account"> | string | null
    owner?: XOR<UserRelationFilter, UserWhereInput>
    activities?: ActivityListRelationFilter
    appointments?: AppointmentListRelationFilter
    completedProjects?: CompletedProjectListRelationFilter
    contacts?: ContactListRelationFilter
    documents?: DocumentListRelationFilter
    enquiries?: EnquiryListRelationFilter
    events?: EventLogListRelationFilter
    leads?: LeadListRelationFilter
    projects?: ProjectListRelationFilter
    snags?: SnagListRelationFilter
    tasks?: TaskListRelationFilter
    workflows?: WorkflowDefinitionListRelationFilter
    workflowInstances?: WorkflowInstanceListRelationFilter
    workflowTemplates?: WorkflowTemplateListRelationFilter
    automationRules?: AutomationRuleListRelationFilter
  }, "id" | "portalToken">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrderInput | SortOrder
    name?: SortOrder
    legalName?: SortOrderInput | SortOrder
    emails?: SortOrder
    phones?: SortOrder
    billingAddress?: SortOrderInput | SortOrder
    siteAddresses?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    tags?: SortOrder
    status?: SortOrder
    portalToken?: SortOrder
    designFeePaid?: SortOrder
    consentMarketing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    orgId?: StringNullableWithAggregatesFilter<"Account"> | string | null
    name?: StringWithAggregatesFilter<"Account"> | string
    legalName?: StringNullableWithAggregatesFilter<"Account"> | string | null
    emails?: StringNullableListFilter<"Account">
    phones?: StringNullableListFilter<"Account">
    billingAddress?: JsonNullableWithAggregatesFilter<"Account">
    siteAddresses?: JsonNullableWithAggregatesFilter<"Account">
    ownerId?: StringWithAggregatesFilter<"Account"> | string
    tags?: StringNullableListFilter<"Account">
    status?: EnumAccountStatusWithAggregatesFilter<"Account"> | $Enums.AccountStatus
    portalToken?: StringWithAggregatesFilter<"Account"> | string
    designFeePaid?: BoolWithAggregatesFilter<"Account"> | boolean
    consentMarketing?: BoolWithAggregatesFilter<"Account"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    createdById?: StringNullableWithAggregatesFilter<"Account"> | string | null
    updatedById?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type EnquiryWhereInput = {
    AND?: EnquiryWhereInput | EnquiryWhereInput[]
    OR?: EnquiryWhereInput[]
    NOT?: EnquiryWhereInput | EnquiryWhereInput[]
    id?: StringFilter<"Enquiry"> | string
    title?: StringFilter<"Enquiry"> | string
    description?: StringNullableFilter<"Enquiry"> | string | null
    status?: EnumEnquiryStatusFilter<"Enquiry"> | $Enums.EnquiryStatus
    priority?: EnumPriorityFilter<"Enquiry"> | $Enums.Priority
    source?: StringNullableFilter<"Enquiry"> | string | null
    campaign?: StringNullableFilter<"Enquiry"> | string | null
    medium?: StringNullableFilter<"Enquiry"> | string | null
    estimatedValue?: DecimalNullableFilter<"Enquiry"> | Decimal | DecimalJsLike | number | string | null
    contactMethod?: StringNullableFilter<"Enquiry"> | string | null
    firstName?: StringFilter<"Enquiry"> | string
    lastName?: StringFilter<"Enquiry"> | string
    email?: StringNullableFilter<"Enquiry"> | string | null
    phone?: StringNullableFilter<"Enquiry"> | string | null
    mobile?: StringNullableFilter<"Enquiry"> | string | null
    company?: StringNullableFilter<"Enquiry"> | string | null
    message?: StringNullableFilter<"Enquiry"> | string | null
    accountId?: StringNullableFilter<"Enquiry"> | string | null
    ownerId?: StringFilter<"Enquiry"> | string
    leadId?: StringNullableFilter<"Enquiry"> | string | null
    createdAt?: DateTimeFilter<"Enquiry"> | Date | string
    updatedAt?: DateTimeFilter<"Enquiry"> | Date | string
    createdById?: StringNullableFilter<"Enquiry"> | string | null
    updatedById?: StringNullableFilter<"Enquiry"> | string | null
    activities?: ActivityListRelationFilter
    account?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    owner?: XOR<UserRelationFilter, UserWhereInput>
    lead?: XOR<LeadNullableRelationFilter, LeadWhereInput> | null
    tasks?: TaskListRelationFilter
  }

  export type EnquiryOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    source?: SortOrderInput | SortOrder
    campaign?: SortOrderInput | SortOrder
    medium?: SortOrderInput | SortOrder
    estimatedValue?: SortOrderInput | SortOrder
    contactMethod?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    leadId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    activities?: ActivityOrderByRelationAggregateInput
    account?: AccountOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    lead?: LeadOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type EnquiryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    leadId?: string
    AND?: EnquiryWhereInput | EnquiryWhereInput[]
    OR?: EnquiryWhereInput[]
    NOT?: EnquiryWhereInput | EnquiryWhereInput[]
    title?: StringFilter<"Enquiry"> | string
    description?: StringNullableFilter<"Enquiry"> | string | null
    status?: EnumEnquiryStatusFilter<"Enquiry"> | $Enums.EnquiryStatus
    priority?: EnumPriorityFilter<"Enquiry"> | $Enums.Priority
    source?: StringNullableFilter<"Enquiry"> | string | null
    campaign?: StringNullableFilter<"Enquiry"> | string | null
    medium?: StringNullableFilter<"Enquiry"> | string | null
    estimatedValue?: DecimalNullableFilter<"Enquiry"> | Decimal | DecimalJsLike | number | string | null
    contactMethod?: StringNullableFilter<"Enquiry"> | string | null
    firstName?: StringFilter<"Enquiry"> | string
    lastName?: StringFilter<"Enquiry"> | string
    email?: StringNullableFilter<"Enquiry"> | string | null
    phone?: StringNullableFilter<"Enquiry"> | string | null
    mobile?: StringNullableFilter<"Enquiry"> | string | null
    company?: StringNullableFilter<"Enquiry"> | string | null
    message?: StringNullableFilter<"Enquiry"> | string | null
    accountId?: StringNullableFilter<"Enquiry"> | string | null
    ownerId?: StringFilter<"Enquiry"> | string
    createdAt?: DateTimeFilter<"Enquiry"> | Date | string
    updatedAt?: DateTimeFilter<"Enquiry"> | Date | string
    createdById?: StringNullableFilter<"Enquiry"> | string | null
    updatedById?: StringNullableFilter<"Enquiry"> | string | null
    activities?: ActivityListRelationFilter
    account?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    owner?: XOR<UserRelationFilter, UserWhereInput>
    lead?: XOR<LeadNullableRelationFilter, LeadWhereInput> | null
    tasks?: TaskListRelationFilter
  }, "id" | "leadId">

  export type EnquiryOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    source?: SortOrderInput | SortOrder
    campaign?: SortOrderInput | SortOrder
    medium?: SortOrderInput | SortOrder
    estimatedValue?: SortOrderInput | SortOrder
    contactMethod?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    leadId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    _count?: EnquiryCountOrderByAggregateInput
    _avg?: EnquiryAvgOrderByAggregateInput
    _max?: EnquiryMaxOrderByAggregateInput
    _min?: EnquiryMinOrderByAggregateInput
    _sum?: EnquirySumOrderByAggregateInput
  }

  export type EnquiryScalarWhereWithAggregatesInput = {
    AND?: EnquiryScalarWhereWithAggregatesInput | EnquiryScalarWhereWithAggregatesInput[]
    OR?: EnquiryScalarWhereWithAggregatesInput[]
    NOT?: EnquiryScalarWhereWithAggregatesInput | EnquiryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Enquiry"> | string
    title?: StringWithAggregatesFilter<"Enquiry"> | string
    description?: StringNullableWithAggregatesFilter<"Enquiry"> | string | null
    status?: EnumEnquiryStatusWithAggregatesFilter<"Enquiry"> | $Enums.EnquiryStatus
    priority?: EnumPriorityWithAggregatesFilter<"Enquiry"> | $Enums.Priority
    source?: StringNullableWithAggregatesFilter<"Enquiry"> | string | null
    campaign?: StringNullableWithAggregatesFilter<"Enquiry"> | string | null
    medium?: StringNullableWithAggregatesFilter<"Enquiry"> | string | null
    estimatedValue?: DecimalNullableWithAggregatesFilter<"Enquiry"> | Decimal | DecimalJsLike | number | string | null
    contactMethod?: StringNullableWithAggregatesFilter<"Enquiry"> | string | null
    firstName?: StringWithAggregatesFilter<"Enquiry"> | string
    lastName?: StringWithAggregatesFilter<"Enquiry"> | string
    email?: StringNullableWithAggregatesFilter<"Enquiry"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Enquiry"> | string | null
    mobile?: StringNullableWithAggregatesFilter<"Enquiry"> | string | null
    company?: StringNullableWithAggregatesFilter<"Enquiry"> | string | null
    message?: StringNullableWithAggregatesFilter<"Enquiry"> | string | null
    accountId?: StringNullableWithAggregatesFilter<"Enquiry"> | string | null
    ownerId?: StringWithAggregatesFilter<"Enquiry"> | string
    leadId?: StringNullableWithAggregatesFilter<"Enquiry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Enquiry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Enquiry"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"Enquiry"> | string | null
    updatedById?: StringNullableWithAggregatesFilter<"Enquiry"> | string | null
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    accountId?: StringFilter<"Contact"> | string
    name?: StringFilter<"Contact"> | string
    role?: StringNullableFilter<"Contact"> | string | null
    email?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    isPrimary?: BoolFilter<"Contact"> | boolean
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    role?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    accountId?: StringFilter<"Contact"> | string
    name?: StringFilter<"Contact"> | string
    role?: StringNullableFilter<"Contact"> | string | null
    email?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    isPrimary?: BoolFilter<"Contact"> | boolean
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
  }, "id">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    role?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    accountId?: StringWithAggregatesFilter<"Contact"> | string
    name?: StringWithAggregatesFilter<"Contact"> | string
    role?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    email?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    isPrimary?: BoolWithAggregatesFilter<"Contact"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
  }

  export type LeadWhereInput = {
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    id?: StringFilter<"Lead"> | string
    title?: StringFilter<"Lead"> | string
    description?: StringNullableFilter<"Lead"> | string | null
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    priority?: EnumPriorityFilter<"Lead"> | $Enums.Priority
    estimatedValue?: DecimalNullableFilter<"Lead"> | Decimal | DecimalJsLike | number | string | null
    probability?: IntFilter<"Lead"> | number
    expectedCloseDate?: DateTimeNullableFilter<"Lead"> | Date | string | null
    source?: StringNullableFilter<"Lead"> | string | null
    campaign?: StringNullableFilter<"Lead"> | string | null
    medium?: StringNullableFilter<"Lead"> | string | null
    firstResponseAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    responseTime?: IntNullableFilter<"Lead"> | number | null
    accountId?: StringFilter<"Lead"> | string
    ownerId?: StringFilter<"Lead"> | string
    enquiryId?: StringNullableFilter<"Lead"> | string | null
    projectId?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    createdById?: StringNullableFilter<"Lead"> | string | null
    updatedById?: StringNullableFilter<"Lead"> | string | null
    activities?: ActivityListRelationFilter
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    enquiry?: XOR<EnquiryNullableRelationFilter, EnquiryWhereInput> | null
    owner?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    tasks?: TaskListRelationFilter
  }

  export type LeadOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    estimatedValue?: SortOrderInput | SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    campaign?: SortOrderInput | SortOrder
    medium?: SortOrderInput | SortOrder
    firstResponseAt?: SortOrderInput | SortOrder
    responseTime?: SortOrderInput | SortOrder
    accountId?: SortOrder
    ownerId?: SortOrder
    enquiryId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    activities?: ActivityOrderByRelationAggregateInput
    account?: AccountOrderByWithRelationInput
    enquiry?: EnquiryOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type LeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    enquiryId?: string
    projectId?: string
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    title?: StringFilter<"Lead"> | string
    description?: StringNullableFilter<"Lead"> | string | null
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    priority?: EnumPriorityFilter<"Lead"> | $Enums.Priority
    estimatedValue?: DecimalNullableFilter<"Lead"> | Decimal | DecimalJsLike | number | string | null
    probability?: IntFilter<"Lead"> | number
    expectedCloseDate?: DateTimeNullableFilter<"Lead"> | Date | string | null
    source?: StringNullableFilter<"Lead"> | string | null
    campaign?: StringNullableFilter<"Lead"> | string | null
    medium?: StringNullableFilter<"Lead"> | string | null
    firstResponseAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    responseTime?: IntNullableFilter<"Lead"> | number | null
    accountId?: StringFilter<"Lead"> | string
    ownerId?: StringFilter<"Lead"> | string
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    createdById?: StringNullableFilter<"Lead"> | string | null
    updatedById?: StringNullableFilter<"Lead"> | string | null
    activities?: ActivityListRelationFilter
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    enquiry?: XOR<EnquiryNullableRelationFilter, EnquiryWhereInput> | null
    owner?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    tasks?: TaskListRelationFilter
  }, "id" | "enquiryId" | "projectId">

  export type LeadOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    estimatedValue?: SortOrderInput | SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    campaign?: SortOrderInput | SortOrder
    medium?: SortOrderInput | SortOrder
    firstResponseAt?: SortOrderInput | SortOrder
    responseTime?: SortOrderInput | SortOrder
    accountId?: SortOrder
    ownerId?: SortOrder
    enquiryId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    _count?: LeadCountOrderByAggregateInput
    _avg?: LeadAvgOrderByAggregateInput
    _max?: LeadMaxOrderByAggregateInput
    _min?: LeadMinOrderByAggregateInput
    _sum?: LeadSumOrderByAggregateInput
  }

  export type LeadScalarWhereWithAggregatesInput = {
    AND?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    OR?: LeadScalarWhereWithAggregatesInput[]
    NOT?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lead"> | string
    title?: StringWithAggregatesFilter<"Lead"> | string
    description?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    status?: EnumLeadStatusWithAggregatesFilter<"Lead"> | $Enums.LeadStatus
    priority?: EnumPriorityWithAggregatesFilter<"Lead"> | $Enums.Priority
    estimatedValue?: DecimalNullableWithAggregatesFilter<"Lead"> | Decimal | DecimalJsLike | number | string | null
    probability?: IntWithAggregatesFilter<"Lead"> | number
    expectedCloseDate?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    source?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    campaign?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    medium?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    firstResponseAt?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    responseTime?: IntNullableWithAggregatesFilter<"Lead"> | number | null
    accountId?: StringWithAggregatesFilter<"Lead"> | string
    ownerId?: StringWithAggregatesFilter<"Lead"> | string
    enquiryId?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    projectId?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    updatedById?: StringNullableWithAggregatesFilter<"Lead"> | string | null
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    title?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    type?: EnumProjectTypeFilter<"Project"> | $Enums.ProjectType
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    accountId?: StringFilter<"Project"> | string
    ownerId?: StringFilter<"Project"> | string
    amountGrossIncVat?: IntFilter<"Project"> | number
    vatRate?: FloatFilter<"Project"> | number
    probability?: IntFilter<"Project"> | number
    source?: StringNullableFilter<"Project"> | string | null
    utm?: JsonNullableFilter<"Project">
    leadId?: StringNullableFilter<"Project"> | string | null
    completedProjectId?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    activities?: ActivityListRelationFilter
    appointments?: AppointmentListRelationFilter
    completedProject?: XOR<CompletedProjectNullableRelationFilter, CompletedProjectWhereInput> | null
    documents?: DocumentListRelationFilter
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    lead?: XOR<LeadNullableRelationFilter, LeadWhereInput> | null
    owner?: XOR<UserRelationFilter, UserWhereInput>
    snags?: SnagListRelationFilter
    tasks?: TaskListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    accountId?: SortOrder
    ownerId?: SortOrder
    amountGrossIncVat?: SortOrder
    vatRate?: SortOrder
    probability?: SortOrder
    source?: SortOrderInput | SortOrder
    utm?: SortOrderInput | SortOrder
    leadId?: SortOrderInput | SortOrder
    completedProjectId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    activities?: ActivityOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    completedProject?: CompletedProjectOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
    account?: AccountOrderByWithRelationInput
    lead?: LeadOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    snags?: SnagOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    leadId?: string
    completedProjectId?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    title?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    type?: EnumProjectTypeFilter<"Project"> | $Enums.ProjectType
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    accountId?: StringFilter<"Project"> | string
    ownerId?: StringFilter<"Project"> | string
    amountGrossIncVat?: IntFilter<"Project"> | number
    vatRate?: FloatFilter<"Project"> | number
    probability?: IntFilter<"Project"> | number
    source?: StringNullableFilter<"Project"> | string | null
    utm?: JsonNullableFilter<"Project">
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    activities?: ActivityListRelationFilter
    appointments?: AppointmentListRelationFilter
    completedProject?: XOR<CompletedProjectNullableRelationFilter, CompletedProjectWhereInput> | null
    documents?: DocumentListRelationFilter
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    lead?: XOR<LeadNullableRelationFilter, LeadWhereInput> | null
    owner?: XOR<UserRelationFilter, UserWhereInput>
    snags?: SnagListRelationFilter
    tasks?: TaskListRelationFilter
  }, "id" | "leadId" | "completedProjectId">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    accountId?: SortOrder
    ownerId?: SortOrder
    amountGrossIncVat?: SortOrder
    vatRate?: SortOrder
    probability?: SortOrder
    source?: SortOrderInput | SortOrder
    utm?: SortOrderInput | SortOrder
    leadId?: SortOrderInput | SortOrder
    completedProjectId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    title?: StringWithAggregatesFilter<"Project"> | string
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    type?: EnumProjectTypeWithAggregatesFilter<"Project"> | $Enums.ProjectType
    status?: EnumProjectStatusWithAggregatesFilter<"Project"> | $Enums.ProjectStatus
    accountId?: StringWithAggregatesFilter<"Project"> | string
    ownerId?: StringWithAggregatesFilter<"Project"> | string
    amountGrossIncVat?: IntWithAggregatesFilter<"Project"> | number
    vatRate?: FloatWithAggregatesFilter<"Project"> | number
    probability?: IntWithAggregatesFilter<"Project"> | number
    source?: StringNullableWithAggregatesFilter<"Project"> | string | null
    utm?: JsonNullableWithAggregatesFilter<"Project">
    leadId?: StringNullableWithAggregatesFilter<"Project"> | string | null
    completedProjectId?: StringNullableWithAggregatesFilter<"Project"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type CompletedProjectWhereInput = {
    AND?: CompletedProjectWhereInput | CompletedProjectWhereInput[]
    OR?: CompletedProjectWhereInput[]
    NOT?: CompletedProjectWhereInput | CompletedProjectWhereInput[]
    id?: StringFilter<"CompletedProject"> | string
    accountId?: StringFilter<"CompletedProject"> | string
    projectId?: StringNullableFilter<"CompletedProject"> | string | null
    ownerId?: StringFilter<"CompletedProject"> | string
    title?: StringFilter<"CompletedProject"> | string
    description?: StringNullableFilter<"CompletedProject"> | string | null
    status?: EnumCompletedProjectStatusFilter<"CompletedProject"> | $Enums.CompletedProjectStatus
    startDate?: DateTimeNullableFilter<"CompletedProject"> | Date | string | null
    endDate?: DateTimeNullableFilter<"CompletedProject"> | Date | string | null
    createdAt?: DateTimeFilter<"CompletedProject"> | Date | string
    updatedAt?: DateTimeFilter<"CompletedProject"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    owner?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
  }

  export type CompletedProjectOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    projectId?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type CompletedProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId?: string
    AND?: CompletedProjectWhereInput | CompletedProjectWhereInput[]
    OR?: CompletedProjectWhereInput[]
    NOT?: CompletedProjectWhereInput | CompletedProjectWhereInput[]
    accountId?: StringFilter<"CompletedProject"> | string
    ownerId?: StringFilter<"CompletedProject"> | string
    title?: StringFilter<"CompletedProject"> | string
    description?: StringNullableFilter<"CompletedProject"> | string | null
    status?: EnumCompletedProjectStatusFilter<"CompletedProject"> | $Enums.CompletedProjectStatus
    startDate?: DateTimeNullableFilter<"CompletedProject"> | Date | string | null
    endDate?: DateTimeNullableFilter<"CompletedProject"> | Date | string | null
    createdAt?: DateTimeFilter<"CompletedProject"> | Date | string
    updatedAt?: DateTimeFilter<"CompletedProject"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    owner?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
  }, "id" | "projectId">

  export type CompletedProjectOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    projectId?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompletedProjectCountOrderByAggregateInput
    _max?: CompletedProjectMaxOrderByAggregateInput
    _min?: CompletedProjectMinOrderByAggregateInput
  }

  export type CompletedProjectScalarWhereWithAggregatesInput = {
    AND?: CompletedProjectScalarWhereWithAggregatesInput | CompletedProjectScalarWhereWithAggregatesInput[]
    OR?: CompletedProjectScalarWhereWithAggregatesInput[]
    NOT?: CompletedProjectScalarWhereWithAggregatesInput | CompletedProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompletedProject"> | string
    accountId?: StringWithAggregatesFilter<"CompletedProject"> | string
    projectId?: StringNullableWithAggregatesFilter<"CompletedProject"> | string | null
    ownerId?: StringWithAggregatesFilter<"CompletedProject"> | string
    title?: StringWithAggregatesFilter<"CompletedProject"> | string
    description?: StringNullableWithAggregatesFilter<"CompletedProject"> | string | null
    status?: EnumCompletedProjectStatusWithAggregatesFilter<"CompletedProject"> | $Enums.CompletedProjectStatus
    startDate?: DateTimeNullableWithAggregatesFilter<"CompletedProject"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"CompletedProject"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CompletedProject"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompletedProject"> | Date | string
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: StringFilter<"Activity"> | string
    accountId?: StringFilter<"Activity"> | string
    enquiryId?: StringNullableFilter<"Activity"> | string | null
    leadId?: StringNullableFilter<"Activity"> | string | null
    projectId?: StringNullableFilter<"Activity"> | string | null
    userId?: StringNullableFilter<"Activity"> | string | null
    type?: EnumActivityTypeFilter<"Activity"> | $Enums.ActivityType
    threadKey?: StringNullableFilter<"Activity"> | string | null
    summary?: StringNullableFilter<"Activity"> | string | null
    body?: StringNullableFilter<"Activity"> | string | null
    attachments?: JsonNullableFilter<"Activity">
    durations?: JsonNullableFilter<"Activity">
    metadata?: JsonNullableFilter<"Activity">
    occurredAt?: DateTimeFilter<"Activity"> | Date | string
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    enquiry?: XOR<EnquiryNullableRelationFilter, EnquiryWhereInput> | null
    lead?: XOR<LeadNullableRelationFilter, LeadWhereInput> | null
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    enquiryId?: SortOrderInput | SortOrder
    leadId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    type?: SortOrder
    threadKey?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    body?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    durations?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    occurredAt?: SortOrder
    createdAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    enquiry?: EnquiryOrderByWithRelationInput
    lead?: LeadOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    accountId?: StringFilter<"Activity"> | string
    enquiryId?: StringNullableFilter<"Activity"> | string | null
    leadId?: StringNullableFilter<"Activity"> | string | null
    projectId?: StringNullableFilter<"Activity"> | string | null
    userId?: StringNullableFilter<"Activity"> | string | null
    type?: EnumActivityTypeFilter<"Activity"> | $Enums.ActivityType
    threadKey?: StringNullableFilter<"Activity"> | string | null
    summary?: StringNullableFilter<"Activity"> | string | null
    body?: StringNullableFilter<"Activity"> | string | null
    attachments?: JsonNullableFilter<"Activity">
    durations?: JsonNullableFilter<"Activity">
    metadata?: JsonNullableFilter<"Activity">
    occurredAt?: DateTimeFilter<"Activity"> | Date | string
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    enquiry?: XOR<EnquiryNullableRelationFilter, EnquiryWhereInput> | null
    lead?: XOR<LeadNullableRelationFilter, LeadWhereInput> | null
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    enquiryId?: SortOrderInput | SortOrder
    leadId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    type?: SortOrder
    threadKey?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    body?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    durations?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    occurredAt?: SortOrder
    createdAt?: SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Activity"> | string
    accountId?: StringWithAggregatesFilter<"Activity"> | string
    enquiryId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    leadId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    projectId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    type?: EnumActivityTypeWithAggregatesFilter<"Activity"> | $Enums.ActivityType
    threadKey?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    summary?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    body?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    attachments?: JsonNullableWithAggregatesFilter<"Activity">
    durations?: JsonNullableWithAggregatesFilter<"Activity">
    metadata?: JsonNullableWithAggregatesFilter<"Activity">
    occurredAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    priority?: EnumPriorityFilter<"Task"> | $Enums.Priority
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    assigneeId?: StringFilter<"Task"> | string
    accountId?: StringFilter<"Task"> | string
    enquiryId?: StringNullableFilter<"Task"> | string | null
    leadId?: StringNullableFilter<"Task"> | string | null
    projectId?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    assignee?: XOR<UserRelationFilter, UserWhereInput>
    enquiry?: XOR<EnquiryNullableRelationFilter, EnquiryWhereInput> | null
    lead?: XOR<LeadNullableRelationFilter, LeadWhereInput> | null
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    assigneeId?: SortOrder
    accountId?: SortOrder
    enquiryId?: SortOrderInput | SortOrder
    leadId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    assignee?: UserOrderByWithRelationInput
    enquiry?: EnquiryOrderByWithRelationInput
    lead?: LeadOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    priority?: EnumPriorityFilter<"Task"> | $Enums.Priority
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    assigneeId?: StringFilter<"Task"> | string
    accountId?: StringFilter<"Task"> | string
    enquiryId?: StringNullableFilter<"Task"> | string | null
    leadId?: StringNullableFilter<"Task"> | string | null
    projectId?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    assignee?: XOR<UserRelationFilter, UserWhereInput>
    enquiry?: XOR<EnquiryNullableRelationFilter, EnquiryWhereInput> | null
    lead?: XOR<LeadNullableRelationFilter, LeadWhereInput> | null
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    assigneeId?: SortOrder
    accountId?: SortOrder
    enquiryId?: SortOrderInput | SortOrder
    leadId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    status?: EnumTaskStatusWithAggregatesFilter<"Task"> | $Enums.TaskStatus
    priority?: EnumPriorityWithAggregatesFilter<"Task"> | $Enums.Priority
    dueDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    assigneeId?: StringWithAggregatesFilter<"Task"> | string
    accountId?: StringWithAggregatesFilter<"Task"> | string
    enquiryId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    leadId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    projectId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: StringFilter<"Appointment"> | string
    accountId?: StringFilter<"Appointment"> | string
    projectId?: StringNullableFilter<"Appointment"> | string | null
    title?: StringFilter<"Appointment"> | string
    description?: StringNullableFilter<"Appointment"> | string | null
    type?: EnumAppointmentTypeFilter<"Appointment"> | $Enums.AppointmentType
    startTime?: DateTimeFilter<"Appointment"> | Date | string
    endTime?: DateTimeFilter<"Appointment"> | Date | string
    location?: StringNullableFilter<"Appointment"> | string | null
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    projectId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    accountId?: StringFilter<"Appointment"> | string
    projectId?: StringNullableFilter<"Appointment"> | string | null
    title?: StringFilter<"Appointment"> | string
    description?: StringNullableFilter<"Appointment"> | string | null
    type?: EnumAppointmentTypeFilter<"Appointment"> | $Enums.AppointmentType
    startTime?: DateTimeFilter<"Appointment"> | Date | string
    endTime?: DateTimeFilter<"Appointment"> | Date | string
    location?: StringNullableFilter<"Appointment"> | string | null
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
  }, "id">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    projectId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Appointment"> | string
    accountId?: StringWithAggregatesFilter<"Appointment"> | string
    projectId?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    title?: StringWithAggregatesFilter<"Appointment"> | string
    description?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    type?: EnumAppointmentTypeWithAggregatesFilter<"Appointment"> | $Enums.AppointmentType
    startTime?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    location?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    status?: EnumAppointmentStatusWithAggregatesFilter<"Appointment"> | $Enums.AppointmentStatus
    createdAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    accountId?: StringFilter<"Document"> | string
    projectId?: StringNullableFilter<"Document"> | string | null
    filename?: StringFilter<"Document"> | string
    fileUrl?: StringFilter<"Document"> | string
    fileSize?: IntNullableFilter<"Document"> | number | null
    mimeType?: StringNullableFilter<"Document"> | string | null
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    uploadedBy?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    projectId?: SortOrderInput | SortOrder
    filename?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    type?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    accountId?: StringFilter<"Document"> | string
    projectId?: StringNullableFilter<"Document"> | string | null
    filename?: StringFilter<"Document"> | string
    fileUrl?: StringFilter<"Document"> | string
    fileSize?: IntNullableFilter<"Document"> | number | null
    mimeType?: StringNullableFilter<"Document"> | string | null
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    uploadedBy?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    projectId?: SortOrderInput | SortOrder
    filename?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    type?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    accountId?: StringWithAggregatesFilter<"Document"> | string
    projectId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    filename?: StringWithAggregatesFilter<"Document"> | string
    fileUrl?: StringWithAggregatesFilter<"Document"> | string
    fileSize?: IntNullableWithAggregatesFilter<"Document"> | number | null
    mimeType?: StringNullableWithAggregatesFilter<"Document"> | string | null
    type?: EnumDocumentTypeWithAggregatesFilter<"Document"> | $Enums.DocumentType
    uploadedBy?: StringNullableWithAggregatesFilter<"Document"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type SnagWhereInput = {
    AND?: SnagWhereInput | SnagWhereInput[]
    OR?: SnagWhereInput[]
    NOT?: SnagWhereInput | SnagWhereInput[]
    id?: StringFilter<"Snag"> | string
    accountId?: StringFilter<"Snag"> | string
    projectId?: StringFilter<"Snag"> | string
    title?: StringFilter<"Snag"> | string
    description?: StringFilter<"Snag"> | string
    status?: EnumSnagStatusFilter<"Snag"> | $Enums.SnagStatus
    priority?: EnumPriorityFilter<"Snag"> | $Enums.Priority
    assigneeId?: StringNullableFilter<"Snag"> | string | null
    dueAt?: DateTimeNullableFilter<"Snag"> | Date | string | null
    photos?: JsonNullableFilter<"Snag">
    createdAt?: DateTimeFilter<"Snag"> | Date | string
    updatedAt?: DateTimeFilter<"Snag"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type SnagOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assigneeId?: SortOrderInput | SortOrder
    dueAt?: SortOrderInput | SortOrder
    photos?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type SnagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SnagWhereInput | SnagWhereInput[]
    OR?: SnagWhereInput[]
    NOT?: SnagWhereInput | SnagWhereInput[]
    accountId?: StringFilter<"Snag"> | string
    projectId?: StringFilter<"Snag"> | string
    title?: StringFilter<"Snag"> | string
    description?: StringFilter<"Snag"> | string
    status?: EnumSnagStatusFilter<"Snag"> | $Enums.SnagStatus
    priority?: EnumPriorityFilter<"Snag"> | $Enums.Priority
    assigneeId?: StringNullableFilter<"Snag"> | string | null
    dueAt?: DateTimeNullableFilter<"Snag"> | Date | string | null
    photos?: JsonNullableFilter<"Snag">
    createdAt?: DateTimeFilter<"Snag"> | Date | string
    updatedAt?: DateTimeFilter<"Snag"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id">

  export type SnagOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assigneeId?: SortOrderInput | SortOrder
    dueAt?: SortOrderInput | SortOrder
    photos?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SnagCountOrderByAggregateInput
    _max?: SnagMaxOrderByAggregateInput
    _min?: SnagMinOrderByAggregateInput
  }

  export type SnagScalarWhereWithAggregatesInput = {
    AND?: SnagScalarWhereWithAggregatesInput | SnagScalarWhereWithAggregatesInput[]
    OR?: SnagScalarWhereWithAggregatesInput[]
    NOT?: SnagScalarWhereWithAggregatesInput | SnagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Snag"> | string
    accountId?: StringWithAggregatesFilter<"Snag"> | string
    projectId?: StringWithAggregatesFilter<"Snag"> | string
    title?: StringWithAggregatesFilter<"Snag"> | string
    description?: StringWithAggregatesFilter<"Snag"> | string
    status?: EnumSnagStatusWithAggregatesFilter<"Snag"> | $Enums.SnagStatus
    priority?: EnumPriorityWithAggregatesFilter<"Snag"> | $Enums.Priority
    assigneeId?: StringNullableWithAggregatesFilter<"Snag"> | string | null
    dueAt?: DateTimeNullableWithAggregatesFilter<"Snag"> | Date | string | null
    photos?: JsonNullableWithAggregatesFilter<"Snag">
    createdAt?: DateTimeWithAggregatesFilter<"Snag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Snag"> | Date | string
  }

  export type EventLogWhereInput = {
    AND?: EventLogWhereInput | EventLogWhereInput[]
    OR?: EventLogWhereInput[]
    NOT?: EventLogWhereInput | EventLogWhereInput[]
    id?: StringFilter<"EventLog"> | string
    accountId?: StringNullableFilter<"EventLog"> | string | null
    actorId?: StringNullableFilter<"EventLog"> | string | null
    entity?: StringFilter<"EventLog"> | string
    entityId?: StringFilter<"EventLog"> | string
    action?: StringFilter<"EventLog"> | string
    before?: JsonNullableFilter<"EventLog">
    after?: JsonNullableFilter<"EventLog">
    createdAt?: DateTimeFilter<"EventLog"> | Date | string
    account?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
  }

  export type EventLogOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrderInput | SortOrder
    actorId?: SortOrderInput | SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    before?: SortOrderInput | SortOrder
    after?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    account?: AccountOrderByWithRelationInput
  }

  export type EventLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventLogWhereInput | EventLogWhereInput[]
    OR?: EventLogWhereInput[]
    NOT?: EventLogWhereInput | EventLogWhereInput[]
    accountId?: StringNullableFilter<"EventLog"> | string | null
    actorId?: StringNullableFilter<"EventLog"> | string | null
    entity?: StringFilter<"EventLog"> | string
    entityId?: StringFilter<"EventLog"> | string
    action?: StringFilter<"EventLog"> | string
    before?: JsonNullableFilter<"EventLog">
    after?: JsonNullableFilter<"EventLog">
    createdAt?: DateTimeFilter<"EventLog"> | Date | string
    account?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
  }, "id">

  export type EventLogOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrderInput | SortOrder
    actorId?: SortOrderInput | SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    before?: SortOrderInput | SortOrder
    after?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EventLogCountOrderByAggregateInput
    _max?: EventLogMaxOrderByAggregateInput
    _min?: EventLogMinOrderByAggregateInput
  }

  export type EventLogScalarWhereWithAggregatesInput = {
    AND?: EventLogScalarWhereWithAggregatesInput | EventLogScalarWhereWithAggregatesInput[]
    OR?: EventLogScalarWhereWithAggregatesInput[]
    NOT?: EventLogScalarWhereWithAggregatesInput | EventLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventLog"> | string
    accountId?: StringNullableWithAggregatesFilter<"EventLog"> | string | null
    actorId?: StringNullableWithAggregatesFilter<"EventLog"> | string | null
    entity?: StringWithAggregatesFilter<"EventLog"> | string
    entityId?: StringWithAggregatesFilter<"EventLog"> | string
    action?: StringWithAggregatesFilter<"EventLog"> | string
    before?: JsonNullableWithAggregatesFilter<"EventLog">
    after?: JsonNullableWithAggregatesFilter<"EventLog">
    createdAt?: DateTimeWithAggregatesFilter<"EventLog"> | Date | string
  }

  export type WorkflowDefinitionWhereInput = {
    AND?: WorkflowDefinitionWhereInput | WorkflowDefinitionWhereInput[]
    OR?: WorkflowDefinitionWhereInput[]
    NOT?: WorkflowDefinitionWhereInput | WorkflowDefinitionWhereInput[]
    id?: StringFilter<"WorkflowDefinition"> | string
    name?: StringFilter<"WorkflowDefinition"> | string
    description?: StringNullableFilter<"WorkflowDefinition"> | string | null
    version?: IntFilter<"WorkflowDefinition"> | number
    isActive?: BoolFilter<"WorkflowDefinition"> | boolean
    triggerType?: EnumWorkflowTriggerTypeFilter<"WorkflowDefinition"> | $Enums.WorkflowTriggerType
    triggerConditions?: JsonFilter<"WorkflowDefinition">
    accountId?: StringFilter<"WorkflowDefinition"> | string
    createdById?: StringFilter<"WorkflowDefinition"> | string
    createdAt?: DateTimeFilter<"WorkflowDefinition"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowDefinition"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    steps?: WorkflowStepListRelationFilter
    instances?: WorkflowInstanceListRelationFilter
    templates?: WorkflowTemplateListRelationFilter
  }

  export type WorkflowDefinitionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrder
    isActive?: SortOrder
    triggerType?: SortOrder
    triggerConditions?: SortOrder
    accountId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    steps?: WorkflowStepOrderByRelationAggregateInput
    instances?: WorkflowInstanceOrderByRelationAggregateInput
    templates?: WorkflowTemplateOrderByRelationAggregateInput
  }

  export type WorkflowDefinitionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowDefinitionWhereInput | WorkflowDefinitionWhereInput[]
    OR?: WorkflowDefinitionWhereInput[]
    NOT?: WorkflowDefinitionWhereInput | WorkflowDefinitionWhereInput[]
    name?: StringFilter<"WorkflowDefinition"> | string
    description?: StringNullableFilter<"WorkflowDefinition"> | string | null
    version?: IntFilter<"WorkflowDefinition"> | number
    isActive?: BoolFilter<"WorkflowDefinition"> | boolean
    triggerType?: EnumWorkflowTriggerTypeFilter<"WorkflowDefinition"> | $Enums.WorkflowTriggerType
    triggerConditions?: JsonFilter<"WorkflowDefinition">
    accountId?: StringFilter<"WorkflowDefinition"> | string
    createdById?: StringFilter<"WorkflowDefinition"> | string
    createdAt?: DateTimeFilter<"WorkflowDefinition"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowDefinition"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    steps?: WorkflowStepListRelationFilter
    instances?: WorkflowInstanceListRelationFilter
    templates?: WorkflowTemplateListRelationFilter
  }, "id">

  export type WorkflowDefinitionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrder
    isActive?: SortOrder
    triggerType?: SortOrder
    triggerConditions?: SortOrder
    accountId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkflowDefinitionCountOrderByAggregateInput
    _avg?: WorkflowDefinitionAvgOrderByAggregateInput
    _max?: WorkflowDefinitionMaxOrderByAggregateInput
    _min?: WorkflowDefinitionMinOrderByAggregateInput
    _sum?: WorkflowDefinitionSumOrderByAggregateInput
  }

  export type WorkflowDefinitionScalarWhereWithAggregatesInput = {
    AND?: WorkflowDefinitionScalarWhereWithAggregatesInput | WorkflowDefinitionScalarWhereWithAggregatesInput[]
    OR?: WorkflowDefinitionScalarWhereWithAggregatesInput[]
    NOT?: WorkflowDefinitionScalarWhereWithAggregatesInput | WorkflowDefinitionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkflowDefinition"> | string
    name?: StringWithAggregatesFilter<"WorkflowDefinition"> | string
    description?: StringNullableWithAggregatesFilter<"WorkflowDefinition"> | string | null
    version?: IntWithAggregatesFilter<"WorkflowDefinition"> | number
    isActive?: BoolWithAggregatesFilter<"WorkflowDefinition"> | boolean
    triggerType?: EnumWorkflowTriggerTypeWithAggregatesFilter<"WorkflowDefinition"> | $Enums.WorkflowTriggerType
    triggerConditions?: JsonWithAggregatesFilter<"WorkflowDefinition">
    accountId?: StringWithAggregatesFilter<"WorkflowDefinition"> | string
    createdById?: StringWithAggregatesFilter<"WorkflowDefinition"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WorkflowDefinition"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkflowDefinition"> | Date | string
  }

  export type WorkflowStepWhereInput = {
    AND?: WorkflowStepWhereInput | WorkflowStepWhereInput[]
    OR?: WorkflowStepWhereInput[]
    NOT?: WorkflowStepWhereInput | WorkflowStepWhereInput[]
    id?: StringFilter<"WorkflowStep"> | string
    workflowId?: StringFilter<"WorkflowStep"> | string
    name?: StringFilter<"WorkflowStep"> | string
    description?: StringNullableFilter<"WorkflowStep"> | string | null
    stepType?: EnumWorkflowStepTypeFilter<"WorkflowStep"> | $Enums.WorkflowStepType
    position?: IntFilter<"WorkflowStep"> | number
    configuration?: JsonFilter<"WorkflowStep">
    conditions?: JsonNullableFilter<"WorkflowStep">
    isRequired?: BoolFilter<"WorkflowStep"> | boolean
    timeoutMinutes?: IntNullableFilter<"WorkflowStep"> | number | null
    createdAt?: DateTimeFilter<"WorkflowStep"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowStep"> | Date | string
    workflow?: XOR<WorkflowDefinitionRelationFilter, WorkflowDefinitionWhereInput>
    executions?: WorkflowStepExecutionListRelationFilter
    approvers?: WorkflowStepApproverListRelationFilter
  }

  export type WorkflowStepOrderByWithRelationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    stepType?: SortOrder
    position?: SortOrder
    configuration?: SortOrder
    conditions?: SortOrderInput | SortOrder
    isRequired?: SortOrder
    timeoutMinutes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workflow?: WorkflowDefinitionOrderByWithRelationInput
    executions?: WorkflowStepExecutionOrderByRelationAggregateInput
    approvers?: WorkflowStepApproverOrderByRelationAggregateInput
  }

  export type WorkflowStepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowStepWhereInput | WorkflowStepWhereInput[]
    OR?: WorkflowStepWhereInput[]
    NOT?: WorkflowStepWhereInput | WorkflowStepWhereInput[]
    workflowId?: StringFilter<"WorkflowStep"> | string
    name?: StringFilter<"WorkflowStep"> | string
    description?: StringNullableFilter<"WorkflowStep"> | string | null
    stepType?: EnumWorkflowStepTypeFilter<"WorkflowStep"> | $Enums.WorkflowStepType
    position?: IntFilter<"WorkflowStep"> | number
    configuration?: JsonFilter<"WorkflowStep">
    conditions?: JsonNullableFilter<"WorkflowStep">
    isRequired?: BoolFilter<"WorkflowStep"> | boolean
    timeoutMinutes?: IntNullableFilter<"WorkflowStep"> | number | null
    createdAt?: DateTimeFilter<"WorkflowStep"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowStep"> | Date | string
    workflow?: XOR<WorkflowDefinitionRelationFilter, WorkflowDefinitionWhereInput>
    executions?: WorkflowStepExecutionListRelationFilter
    approvers?: WorkflowStepApproverListRelationFilter
  }, "id">

  export type WorkflowStepOrderByWithAggregationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    stepType?: SortOrder
    position?: SortOrder
    configuration?: SortOrder
    conditions?: SortOrderInput | SortOrder
    isRequired?: SortOrder
    timeoutMinutes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkflowStepCountOrderByAggregateInput
    _avg?: WorkflowStepAvgOrderByAggregateInput
    _max?: WorkflowStepMaxOrderByAggregateInput
    _min?: WorkflowStepMinOrderByAggregateInput
    _sum?: WorkflowStepSumOrderByAggregateInput
  }

  export type WorkflowStepScalarWhereWithAggregatesInput = {
    AND?: WorkflowStepScalarWhereWithAggregatesInput | WorkflowStepScalarWhereWithAggregatesInput[]
    OR?: WorkflowStepScalarWhereWithAggregatesInput[]
    NOT?: WorkflowStepScalarWhereWithAggregatesInput | WorkflowStepScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkflowStep"> | string
    workflowId?: StringWithAggregatesFilter<"WorkflowStep"> | string
    name?: StringWithAggregatesFilter<"WorkflowStep"> | string
    description?: StringNullableWithAggregatesFilter<"WorkflowStep"> | string | null
    stepType?: EnumWorkflowStepTypeWithAggregatesFilter<"WorkflowStep"> | $Enums.WorkflowStepType
    position?: IntWithAggregatesFilter<"WorkflowStep"> | number
    configuration?: JsonWithAggregatesFilter<"WorkflowStep">
    conditions?: JsonNullableWithAggregatesFilter<"WorkflowStep">
    isRequired?: BoolWithAggregatesFilter<"WorkflowStep"> | boolean
    timeoutMinutes?: IntNullableWithAggregatesFilter<"WorkflowStep"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"WorkflowStep"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkflowStep"> | Date | string
  }

  export type WorkflowStepApproverWhereInput = {
    AND?: WorkflowStepApproverWhereInput | WorkflowStepApproverWhereInput[]
    OR?: WorkflowStepApproverWhereInput[]
    NOT?: WorkflowStepApproverWhereInput | WorkflowStepApproverWhereInput[]
    id?: StringFilter<"WorkflowStepApprover"> | string
    stepId?: StringFilter<"WorkflowStepApprover"> | string
    userId?: StringFilter<"WorkflowStepApprover"> | string
    approverType?: EnumApproverTypeFilter<"WorkflowStepApprover"> | $Enums.ApproverType
    isRequired?: BoolFilter<"WorkflowStepApprover"> | boolean
    order?: IntFilter<"WorkflowStepApprover"> | number
    createdAt?: DateTimeFilter<"WorkflowStepApprover"> | Date | string
    step?: XOR<WorkflowStepRelationFilter, WorkflowStepWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    approvals?: WorkflowApprovalListRelationFilter
  }

  export type WorkflowStepApproverOrderByWithRelationInput = {
    id?: SortOrder
    stepId?: SortOrder
    userId?: SortOrder
    approverType?: SortOrder
    isRequired?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    step?: WorkflowStepOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    approvals?: WorkflowApprovalOrderByRelationAggregateInput
  }

  export type WorkflowStepApproverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stepId_userId?: WorkflowStepApproverStepIdUserIdCompoundUniqueInput
    AND?: WorkflowStepApproverWhereInput | WorkflowStepApproverWhereInput[]
    OR?: WorkflowStepApproverWhereInput[]
    NOT?: WorkflowStepApproverWhereInput | WorkflowStepApproverWhereInput[]
    stepId?: StringFilter<"WorkflowStepApprover"> | string
    userId?: StringFilter<"WorkflowStepApprover"> | string
    approverType?: EnumApproverTypeFilter<"WorkflowStepApprover"> | $Enums.ApproverType
    isRequired?: BoolFilter<"WorkflowStepApprover"> | boolean
    order?: IntFilter<"WorkflowStepApprover"> | number
    createdAt?: DateTimeFilter<"WorkflowStepApprover"> | Date | string
    step?: XOR<WorkflowStepRelationFilter, WorkflowStepWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    approvals?: WorkflowApprovalListRelationFilter
  }, "id" | "stepId_userId">

  export type WorkflowStepApproverOrderByWithAggregationInput = {
    id?: SortOrder
    stepId?: SortOrder
    userId?: SortOrder
    approverType?: SortOrder
    isRequired?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    _count?: WorkflowStepApproverCountOrderByAggregateInput
    _avg?: WorkflowStepApproverAvgOrderByAggregateInput
    _max?: WorkflowStepApproverMaxOrderByAggregateInput
    _min?: WorkflowStepApproverMinOrderByAggregateInput
    _sum?: WorkflowStepApproverSumOrderByAggregateInput
  }

  export type WorkflowStepApproverScalarWhereWithAggregatesInput = {
    AND?: WorkflowStepApproverScalarWhereWithAggregatesInput | WorkflowStepApproverScalarWhereWithAggregatesInput[]
    OR?: WorkflowStepApproverScalarWhereWithAggregatesInput[]
    NOT?: WorkflowStepApproverScalarWhereWithAggregatesInput | WorkflowStepApproverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkflowStepApprover"> | string
    stepId?: StringWithAggregatesFilter<"WorkflowStepApprover"> | string
    userId?: StringWithAggregatesFilter<"WorkflowStepApprover"> | string
    approverType?: EnumApproverTypeWithAggregatesFilter<"WorkflowStepApprover"> | $Enums.ApproverType
    isRequired?: BoolWithAggregatesFilter<"WorkflowStepApprover"> | boolean
    order?: IntWithAggregatesFilter<"WorkflowStepApprover"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WorkflowStepApprover"> | Date | string
  }

  export type WorkflowInstanceWhereInput = {
    AND?: WorkflowInstanceWhereInput | WorkflowInstanceWhereInput[]
    OR?: WorkflowInstanceWhereInput[]
    NOT?: WorkflowInstanceWhereInput | WorkflowInstanceWhereInput[]
    id?: StringFilter<"WorkflowInstance"> | string
    workflowId?: StringFilter<"WorkflowInstance"> | string
    entityType?: StringFilter<"WorkflowInstance"> | string
    entityId?: StringFilter<"WorkflowInstance"> | string
    status?: EnumWorkflowStatusFilter<"WorkflowInstance"> | $Enums.WorkflowStatus
    currentStepId?: StringNullableFilter<"WorkflowInstance"> | string | null
    priority?: EnumPriorityFilter<"WorkflowInstance"> | $Enums.Priority
    startedAt?: DateTimeFilter<"WorkflowInstance"> | Date | string
    completedAt?: DateTimeNullableFilter<"WorkflowInstance"> | Date | string | null
    errorMessage?: StringNullableFilter<"WorkflowInstance"> | string | null
    metadata?: JsonNullableFilter<"WorkflowInstance">
    accountId?: StringFilter<"WorkflowInstance"> | string
    initiatedById?: StringFilter<"WorkflowInstance"> | string
    workflow?: XOR<WorkflowDefinitionRelationFilter, WorkflowDefinitionWhereInput>
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    initiatedBy?: XOR<UserRelationFilter, UserWhereInput>
    executions?: WorkflowStepExecutionListRelationFilter
    approvals?: WorkflowApprovalListRelationFilter
  }

  export type WorkflowInstanceOrderByWithRelationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    status?: SortOrder
    currentStepId?: SortOrderInput | SortOrder
    priority?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    accountId?: SortOrder
    initiatedById?: SortOrder
    workflow?: WorkflowDefinitionOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
    initiatedBy?: UserOrderByWithRelationInput
    executions?: WorkflowStepExecutionOrderByRelationAggregateInput
    approvals?: WorkflowApprovalOrderByRelationAggregateInput
  }

  export type WorkflowInstanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowInstanceWhereInput | WorkflowInstanceWhereInput[]
    OR?: WorkflowInstanceWhereInput[]
    NOT?: WorkflowInstanceWhereInput | WorkflowInstanceWhereInput[]
    workflowId?: StringFilter<"WorkflowInstance"> | string
    entityType?: StringFilter<"WorkflowInstance"> | string
    entityId?: StringFilter<"WorkflowInstance"> | string
    status?: EnumWorkflowStatusFilter<"WorkflowInstance"> | $Enums.WorkflowStatus
    currentStepId?: StringNullableFilter<"WorkflowInstance"> | string | null
    priority?: EnumPriorityFilter<"WorkflowInstance"> | $Enums.Priority
    startedAt?: DateTimeFilter<"WorkflowInstance"> | Date | string
    completedAt?: DateTimeNullableFilter<"WorkflowInstance"> | Date | string | null
    errorMessage?: StringNullableFilter<"WorkflowInstance"> | string | null
    metadata?: JsonNullableFilter<"WorkflowInstance">
    accountId?: StringFilter<"WorkflowInstance"> | string
    initiatedById?: StringFilter<"WorkflowInstance"> | string
    workflow?: XOR<WorkflowDefinitionRelationFilter, WorkflowDefinitionWhereInput>
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    initiatedBy?: XOR<UserRelationFilter, UserWhereInput>
    executions?: WorkflowStepExecutionListRelationFilter
    approvals?: WorkflowApprovalListRelationFilter
  }, "id">

  export type WorkflowInstanceOrderByWithAggregationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    status?: SortOrder
    currentStepId?: SortOrderInput | SortOrder
    priority?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    accountId?: SortOrder
    initiatedById?: SortOrder
    _count?: WorkflowInstanceCountOrderByAggregateInput
    _max?: WorkflowInstanceMaxOrderByAggregateInput
    _min?: WorkflowInstanceMinOrderByAggregateInput
  }

  export type WorkflowInstanceScalarWhereWithAggregatesInput = {
    AND?: WorkflowInstanceScalarWhereWithAggregatesInput | WorkflowInstanceScalarWhereWithAggregatesInput[]
    OR?: WorkflowInstanceScalarWhereWithAggregatesInput[]
    NOT?: WorkflowInstanceScalarWhereWithAggregatesInput | WorkflowInstanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkflowInstance"> | string
    workflowId?: StringWithAggregatesFilter<"WorkflowInstance"> | string
    entityType?: StringWithAggregatesFilter<"WorkflowInstance"> | string
    entityId?: StringWithAggregatesFilter<"WorkflowInstance"> | string
    status?: EnumWorkflowStatusWithAggregatesFilter<"WorkflowInstance"> | $Enums.WorkflowStatus
    currentStepId?: StringNullableWithAggregatesFilter<"WorkflowInstance"> | string | null
    priority?: EnumPriorityWithAggregatesFilter<"WorkflowInstance"> | $Enums.Priority
    startedAt?: DateTimeWithAggregatesFilter<"WorkflowInstance"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"WorkflowInstance"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"WorkflowInstance"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"WorkflowInstance">
    accountId?: StringWithAggregatesFilter<"WorkflowInstance"> | string
    initiatedById?: StringWithAggregatesFilter<"WorkflowInstance"> | string
  }

  export type WorkflowStepExecutionWhereInput = {
    AND?: WorkflowStepExecutionWhereInput | WorkflowStepExecutionWhereInput[]
    OR?: WorkflowStepExecutionWhereInput[]
    NOT?: WorkflowStepExecutionWhereInput | WorkflowStepExecutionWhereInput[]
    id?: StringFilter<"WorkflowStepExecution"> | string
    instanceId?: StringFilter<"WorkflowStepExecution"> | string
    stepId?: StringFilter<"WorkflowStepExecution"> | string
    status?: EnumWorkflowStepStatusFilter<"WorkflowStepExecution"> | $Enums.WorkflowStepStatus
    startedAt?: DateTimeFilter<"WorkflowStepExecution"> | Date | string
    completedAt?: DateTimeNullableFilter<"WorkflowStepExecution"> | Date | string | null
    assignedToId?: StringNullableFilter<"WorkflowStepExecution"> | string | null
    result?: JsonNullableFilter<"WorkflowStepExecution">
    errorMessage?: StringNullableFilter<"WorkflowStepExecution"> | string | null
    retryCount?: IntFilter<"WorkflowStepExecution"> | number
    isManual?: BoolFilter<"WorkflowStepExecution"> | boolean
    instance?: XOR<WorkflowInstanceRelationFilter, WorkflowInstanceWhereInput>
    step?: XOR<WorkflowStepRelationFilter, WorkflowStepWhereInput>
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type WorkflowStepExecutionOrderByWithRelationInput = {
    id?: SortOrder
    instanceId?: SortOrder
    stepId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    assignedToId?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    isManual?: SortOrder
    instance?: WorkflowInstanceOrderByWithRelationInput
    step?: WorkflowStepOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
  }

  export type WorkflowStepExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowStepExecutionWhereInput | WorkflowStepExecutionWhereInput[]
    OR?: WorkflowStepExecutionWhereInput[]
    NOT?: WorkflowStepExecutionWhereInput | WorkflowStepExecutionWhereInput[]
    instanceId?: StringFilter<"WorkflowStepExecution"> | string
    stepId?: StringFilter<"WorkflowStepExecution"> | string
    status?: EnumWorkflowStepStatusFilter<"WorkflowStepExecution"> | $Enums.WorkflowStepStatus
    startedAt?: DateTimeFilter<"WorkflowStepExecution"> | Date | string
    completedAt?: DateTimeNullableFilter<"WorkflowStepExecution"> | Date | string | null
    assignedToId?: StringNullableFilter<"WorkflowStepExecution"> | string | null
    result?: JsonNullableFilter<"WorkflowStepExecution">
    errorMessage?: StringNullableFilter<"WorkflowStepExecution"> | string | null
    retryCount?: IntFilter<"WorkflowStepExecution"> | number
    isManual?: BoolFilter<"WorkflowStepExecution"> | boolean
    instance?: XOR<WorkflowInstanceRelationFilter, WorkflowInstanceWhereInput>
    step?: XOR<WorkflowStepRelationFilter, WorkflowStepWhereInput>
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type WorkflowStepExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    instanceId?: SortOrder
    stepId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    assignedToId?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    isManual?: SortOrder
    _count?: WorkflowStepExecutionCountOrderByAggregateInput
    _avg?: WorkflowStepExecutionAvgOrderByAggregateInput
    _max?: WorkflowStepExecutionMaxOrderByAggregateInput
    _min?: WorkflowStepExecutionMinOrderByAggregateInput
    _sum?: WorkflowStepExecutionSumOrderByAggregateInput
  }

  export type WorkflowStepExecutionScalarWhereWithAggregatesInput = {
    AND?: WorkflowStepExecutionScalarWhereWithAggregatesInput | WorkflowStepExecutionScalarWhereWithAggregatesInput[]
    OR?: WorkflowStepExecutionScalarWhereWithAggregatesInput[]
    NOT?: WorkflowStepExecutionScalarWhereWithAggregatesInput | WorkflowStepExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkflowStepExecution"> | string
    instanceId?: StringWithAggregatesFilter<"WorkflowStepExecution"> | string
    stepId?: StringWithAggregatesFilter<"WorkflowStepExecution"> | string
    status?: EnumWorkflowStepStatusWithAggregatesFilter<"WorkflowStepExecution"> | $Enums.WorkflowStepStatus
    startedAt?: DateTimeWithAggregatesFilter<"WorkflowStepExecution"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"WorkflowStepExecution"> | Date | string | null
    assignedToId?: StringNullableWithAggregatesFilter<"WorkflowStepExecution"> | string | null
    result?: JsonNullableWithAggregatesFilter<"WorkflowStepExecution">
    errorMessage?: StringNullableWithAggregatesFilter<"WorkflowStepExecution"> | string | null
    retryCount?: IntWithAggregatesFilter<"WorkflowStepExecution"> | number
    isManual?: BoolWithAggregatesFilter<"WorkflowStepExecution"> | boolean
  }

  export type WorkflowApprovalWhereInput = {
    AND?: WorkflowApprovalWhereInput | WorkflowApprovalWhereInput[]
    OR?: WorkflowApprovalWhereInput[]
    NOT?: WorkflowApprovalWhereInput | WorkflowApprovalWhereInput[]
    id?: StringFilter<"WorkflowApproval"> | string
    instanceId?: StringFilter<"WorkflowApproval"> | string
    approverId?: StringFilter<"WorkflowApproval"> | string
    stepApproverId?: StringFilter<"WorkflowApproval"> | string
    status?: EnumApprovalStatusFilter<"WorkflowApproval"> | $Enums.ApprovalStatus
    comments?: StringNullableFilter<"WorkflowApproval"> | string | null
    approvedAt?: DateTimeNullableFilter<"WorkflowApproval"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"WorkflowApproval"> | Date | string | null
    requestedAt?: DateTimeFilter<"WorkflowApproval"> | Date | string
    remindersSent?: IntFilter<"WorkflowApproval"> | number
    lastReminderAt?: DateTimeNullableFilter<"WorkflowApproval"> | Date | string | null
    instance?: XOR<WorkflowInstanceRelationFilter, WorkflowInstanceWhereInput>
    approver?: XOR<UserRelationFilter, UserWhereInput>
    stepApprover?: XOR<WorkflowStepApproverRelationFilter, WorkflowStepApproverWhereInput>
  }

  export type WorkflowApprovalOrderByWithRelationInput = {
    id?: SortOrder
    instanceId?: SortOrder
    approverId?: SortOrder
    stepApproverId?: SortOrder
    status?: SortOrder
    comments?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    remindersSent?: SortOrder
    lastReminderAt?: SortOrderInput | SortOrder
    instance?: WorkflowInstanceOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
    stepApprover?: WorkflowStepApproverOrderByWithRelationInput
  }

  export type WorkflowApprovalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowApprovalWhereInput | WorkflowApprovalWhereInput[]
    OR?: WorkflowApprovalWhereInput[]
    NOT?: WorkflowApprovalWhereInput | WorkflowApprovalWhereInput[]
    instanceId?: StringFilter<"WorkflowApproval"> | string
    approverId?: StringFilter<"WorkflowApproval"> | string
    stepApproverId?: StringFilter<"WorkflowApproval"> | string
    status?: EnumApprovalStatusFilter<"WorkflowApproval"> | $Enums.ApprovalStatus
    comments?: StringNullableFilter<"WorkflowApproval"> | string | null
    approvedAt?: DateTimeNullableFilter<"WorkflowApproval"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"WorkflowApproval"> | Date | string | null
    requestedAt?: DateTimeFilter<"WorkflowApproval"> | Date | string
    remindersSent?: IntFilter<"WorkflowApproval"> | number
    lastReminderAt?: DateTimeNullableFilter<"WorkflowApproval"> | Date | string | null
    instance?: XOR<WorkflowInstanceRelationFilter, WorkflowInstanceWhereInput>
    approver?: XOR<UserRelationFilter, UserWhereInput>
    stepApprover?: XOR<WorkflowStepApproverRelationFilter, WorkflowStepApproverWhereInput>
  }, "id">

  export type WorkflowApprovalOrderByWithAggregationInput = {
    id?: SortOrder
    instanceId?: SortOrder
    approverId?: SortOrder
    stepApproverId?: SortOrder
    status?: SortOrder
    comments?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    remindersSent?: SortOrder
    lastReminderAt?: SortOrderInput | SortOrder
    _count?: WorkflowApprovalCountOrderByAggregateInput
    _avg?: WorkflowApprovalAvgOrderByAggregateInput
    _max?: WorkflowApprovalMaxOrderByAggregateInput
    _min?: WorkflowApprovalMinOrderByAggregateInput
    _sum?: WorkflowApprovalSumOrderByAggregateInput
  }

  export type WorkflowApprovalScalarWhereWithAggregatesInput = {
    AND?: WorkflowApprovalScalarWhereWithAggregatesInput | WorkflowApprovalScalarWhereWithAggregatesInput[]
    OR?: WorkflowApprovalScalarWhereWithAggregatesInput[]
    NOT?: WorkflowApprovalScalarWhereWithAggregatesInput | WorkflowApprovalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkflowApproval"> | string
    instanceId?: StringWithAggregatesFilter<"WorkflowApproval"> | string
    approverId?: StringWithAggregatesFilter<"WorkflowApproval"> | string
    stepApproverId?: StringWithAggregatesFilter<"WorkflowApproval"> | string
    status?: EnumApprovalStatusWithAggregatesFilter<"WorkflowApproval"> | $Enums.ApprovalStatus
    comments?: StringNullableWithAggregatesFilter<"WorkflowApproval"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"WorkflowApproval"> | Date | string | null
    rejectedAt?: DateTimeNullableWithAggregatesFilter<"WorkflowApproval"> | Date | string | null
    requestedAt?: DateTimeWithAggregatesFilter<"WorkflowApproval"> | Date | string
    remindersSent?: IntWithAggregatesFilter<"WorkflowApproval"> | number
    lastReminderAt?: DateTimeNullableWithAggregatesFilter<"WorkflowApproval"> | Date | string | null
  }

  export type WorkflowTemplateWhereInput = {
    AND?: WorkflowTemplateWhereInput | WorkflowTemplateWhereInput[]
    OR?: WorkflowTemplateWhereInput[]
    NOT?: WorkflowTemplateWhereInput | WorkflowTemplateWhereInput[]
    id?: StringFilter<"WorkflowTemplate"> | string
    name?: StringFilter<"WorkflowTemplate"> | string
    description?: StringNullableFilter<"WorkflowTemplate"> | string | null
    category?: StringFilter<"WorkflowTemplate"> | string
    industry?: StringFilter<"WorkflowTemplate"> | string
    templateData?: JsonFilter<"WorkflowTemplate">
    isPublic?: BoolFilter<"WorkflowTemplate"> | boolean
    usageCount?: IntFilter<"WorkflowTemplate"> | number
    rating?: FloatNullableFilter<"WorkflowTemplate"> | number | null
    accountId?: StringNullableFilter<"WorkflowTemplate"> | string | null
    createdById?: StringFilter<"WorkflowTemplate"> | string
    createdAt?: DateTimeFilter<"WorkflowTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowTemplate"> | Date | string
    workflowId?: StringNullableFilter<"WorkflowTemplate"> | string | null
    account?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    workflow?: XOR<WorkflowDefinitionNullableRelationFilter, WorkflowDefinitionWhereInput> | null
  }

  export type WorkflowTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    industry?: SortOrder
    templateData?: SortOrder
    isPublic?: SortOrder
    usageCount?: SortOrder
    rating?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workflowId?: SortOrderInput | SortOrder
    account?: AccountOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    workflow?: WorkflowDefinitionOrderByWithRelationInput
  }

  export type WorkflowTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowTemplateWhereInput | WorkflowTemplateWhereInput[]
    OR?: WorkflowTemplateWhereInput[]
    NOT?: WorkflowTemplateWhereInput | WorkflowTemplateWhereInput[]
    name?: StringFilter<"WorkflowTemplate"> | string
    description?: StringNullableFilter<"WorkflowTemplate"> | string | null
    category?: StringFilter<"WorkflowTemplate"> | string
    industry?: StringFilter<"WorkflowTemplate"> | string
    templateData?: JsonFilter<"WorkflowTemplate">
    isPublic?: BoolFilter<"WorkflowTemplate"> | boolean
    usageCount?: IntFilter<"WorkflowTemplate"> | number
    rating?: FloatNullableFilter<"WorkflowTemplate"> | number | null
    accountId?: StringNullableFilter<"WorkflowTemplate"> | string | null
    createdById?: StringFilter<"WorkflowTemplate"> | string
    createdAt?: DateTimeFilter<"WorkflowTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowTemplate"> | Date | string
    workflowId?: StringNullableFilter<"WorkflowTemplate"> | string | null
    account?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    workflow?: XOR<WorkflowDefinitionNullableRelationFilter, WorkflowDefinitionWhereInput> | null
  }, "id">

  export type WorkflowTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    industry?: SortOrder
    templateData?: SortOrder
    isPublic?: SortOrder
    usageCount?: SortOrder
    rating?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workflowId?: SortOrderInput | SortOrder
    _count?: WorkflowTemplateCountOrderByAggregateInput
    _avg?: WorkflowTemplateAvgOrderByAggregateInput
    _max?: WorkflowTemplateMaxOrderByAggregateInput
    _min?: WorkflowTemplateMinOrderByAggregateInput
    _sum?: WorkflowTemplateSumOrderByAggregateInput
  }

  export type WorkflowTemplateScalarWhereWithAggregatesInput = {
    AND?: WorkflowTemplateScalarWhereWithAggregatesInput | WorkflowTemplateScalarWhereWithAggregatesInput[]
    OR?: WorkflowTemplateScalarWhereWithAggregatesInput[]
    NOT?: WorkflowTemplateScalarWhereWithAggregatesInput | WorkflowTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkflowTemplate"> | string
    name?: StringWithAggregatesFilter<"WorkflowTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"WorkflowTemplate"> | string | null
    category?: StringWithAggregatesFilter<"WorkflowTemplate"> | string
    industry?: StringWithAggregatesFilter<"WorkflowTemplate"> | string
    templateData?: JsonWithAggregatesFilter<"WorkflowTemplate">
    isPublic?: BoolWithAggregatesFilter<"WorkflowTemplate"> | boolean
    usageCount?: IntWithAggregatesFilter<"WorkflowTemplate"> | number
    rating?: FloatNullableWithAggregatesFilter<"WorkflowTemplate"> | number | null
    accountId?: StringNullableWithAggregatesFilter<"WorkflowTemplate"> | string | null
    createdById?: StringWithAggregatesFilter<"WorkflowTemplate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WorkflowTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkflowTemplate"> | Date | string
    workflowId?: StringNullableWithAggregatesFilter<"WorkflowTemplate"> | string | null
  }

  export type AutomationRuleWhereInput = {
    AND?: AutomationRuleWhereInput | AutomationRuleWhereInput[]
    OR?: AutomationRuleWhereInput[]
    NOT?: AutomationRuleWhereInput | AutomationRuleWhereInput[]
    id?: StringFilter<"AutomationRule"> | string
    name?: StringFilter<"AutomationRule"> | string
    description?: StringNullableFilter<"AutomationRule"> | string | null
    triggerEvent?: StringFilter<"AutomationRule"> | string
    conditions?: JsonFilter<"AutomationRule">
    actions?: JsonFilter<"AutomationRule">
    isActive?: BoolFilter<"AutomationRule"> | boolean
    priority?: IntFilter<"AutomationRule"> | number
    executionCount?: IntFilter<"AutomationRule"> | number
    lastExecutedAt?: DateTimeNullableFilter<"AutomationRule"> | Date | string | null
    accountId?: StringFilter<"AutomationRule"> | string
    createdById?: StringFilter<"AutomationRule"> | string
    createdAt?: DateTimeFilter<"AutomationRule"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationRule"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    executions?: AutomationExecutionListRelationFilter
  }

  export type AutomationRuleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    triggerEvent?: SortOrder
    conditions?: SortOrder
    actions?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    executionCount?: SortOrder
    lastExecutedAt?: SortOrderInput | SortOrder
    accountId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    executions?: AutomationExecutionOrderByRelationAggregateInput
  }

  export type AutomationRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutomationRuleWhereInput | AutomationRuleWhereInput[]
    OR?: AutomationRuleWhereInput[]
    NOT?: AutomationRuleWhereInput | AutomationRuleWhereInput[]
    name?: StringFilter<"AutomationRule"> | string
    description?: StringNullableFilter<"AutomationRule"> | string | null
    triggerEvent?: StringFilter<"AutomationRule"> | string
    conditions?: JsonFilter<"AutomationRule">
    actions?: JsonFilter<"AutomationRule">
    isActive?: BoolFilter<"AutomationRule"> | boolean
    priority?: IntFilter<"AutomationRule"> | number
    executionCount?: IntFilter<"AutomationRule"> | number
    lastExecutedAt?: DateTimeNullableFilter<"AutomationRule"> | Date | string | null
    accountId?: StringFilter<"AutomationRule"> | string
    createdById?: StringFilter<"AutomationRule"> | string
    createdAt?: DateTimeFilter<"AutomationRule"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationRule"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    executions?: AutomationExecutionListRelationFilter
  }, "id">

  export type AutomationRuleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    triggerEvent?: SortOrder
    conditions?: SortOrder
    actions?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    executionCount?: SortOrder
    lastExecutedAt?: SortOrderInput | SortOrder
    accountId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AutomationRuleCountOrderByAggregateInput
    _avg?: AutomationRuleAvgOrderByAggregateInput
    _max?: AutomationRuleMaxOrderByAggregateInput
    _min?: AutomationRuleMinOrderByAggregateInput
    _sum?: AutomationRuleSumOrderByAggregateInput
  }

  export type AutomationRuleScalarWhereWithAggregatesInput = {
    AND?: AutomationRuleScalarWhereWithAggregatesInput | AutomationRuleScalarWhereWithAggregatesInput[]
    OR?: AutomationRuleScalarWhereWithAggregatesInput[]
    NOT?: AutomationRuleScalarWhereWithAggregatesInput | AutomationRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutomationRule"> | string
    name?: StringWithAggregatesFilter<"AutomationRule"> | string
    description?: StringNullableWithAggregatesFilter<"AutomationRule"> | string | null
    triggerEvent?: StringWithAggregatesFilter<"AutomationRule"> | string
    conditions?: JsonWithAggregatesFilter<"AutomationRule">
    actions?: JsonWithAggregatesFilter<"AutomationRule">
    isActive?: BoolWithAggregatesFilter<"AutomationRule"> | boolean
    priority?: IntWithAggregatesFilter<"AutomationRule"> | number
    executionCount?: IntWithAggregatesFilter<"AutomationRule"> | number
    lastExecutedAt?: DateTimeNullableWithAggregatesFilter<"AutomationRule"> | Date | string | null
    accountId?: StringWithAggregatesFilter<"AutomationRule"> | string
    createdById?: StringWithAggregatesFilter<"AutomationRule"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AutomationRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AutomationRule"> | Date | string
  }

  export type AutomationExecutionWhereInput = {
    AND?: AutomationExecutionWhereInput | AutomationExecutionWhereInput[]
    OR?: AutomationExecutionWhereInput[]
    NOT?: AutomationExecutionWhereInput | AutomationExecutionWhereInput[]
    id?: StringFilter<"AutomationExecution"> | string
    ruleId?: StringFilter<"AutomationExecution"> | string
    triggerData?: JsonFilter<"AutomationExecution">
    result?: JsonNullableFilter<"AutomationExecution">
    status?: EnumAutomationStatusFilter<"AutomationExecution"> | $Enums.AutomationStatus
    errorMessage?: StringNullableFilter<"AutomationExecution"> | string | null
    executedAt?: DateTimeFilter<"AutomationExecution"> | Date | string
    durationMs?: IntNullableFilter<"AutomationExecution"> | number | null
    rule?: XOR<AutomationRuleRelationFilter, AutomationRuleWhereInput>
  }

  export type AutomationExecutionOrderByWithRelationInput = {
    id?: SortOrder
    ruleId?: SortOrder
    triggerData?: SortOrder
    result?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    executedAt?: SortOrder
    durationMs?: SortOrderInput | SortOrder
    rule?: AutomationRuleOrderByWithRelationInput
  }

  export type AutomationExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutomationExecutionWhereInput | AutomationExecutionWhereInput[]
    OR?: AutomationExecutionWhereInput[]
    NOT?: AutomationExecutionWhereInput | AutomationExecutionWhereInput[]
    ruleId?: StringFilter<"AutomationExecution"> | string
    triggerData?: JsonFilter<"AutomationExecution">
    result?: JsonNullableFilter<"AutomationExecution">
    status?: EnumAutomationStatusFilter<"AutomationExecution"> | $Enums.AutomationStatus
    errorMessage?: StringNullableFilter<"AutomationExecution"> | string | null
    executedAt?: DateTimeFilter<"AutomationExecution"> | Date | string
    durationMs?: IntNullableFilter<"AutomationExecution"> | number | null
    rule?: XOR<AutomationRuleRelationFilter, AutomationRuleWhereInput>
  }, "id">

  export type AutomationExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    ruleId?: SortOrder
    triggerData?: SortOrder
    result?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    executedAt?: SortOrder
    durationMs?: SortOrderInput | SortOrder
    _count?: AutomationExecutionCountOrderByAggregateInput
    _avg?: AutomationExecutionAvgOrderByAggregateInput
    _max?: AutomationExecutionMaxOrderByAggregateInput
    _min?: AutomationExecutionMinOrderByAggregateInput
    _sum?: AutomationExecutionSumOrderByAggregateInput
  }

  export type AutomationExecutionScalarWhereWithAggregatesInput = {
    AND?: AutomationExecutionScalarWhereWithAggregatesInput | AutomationExecutionScalarWhereWithAggregatesInput[]
    OR?: AutomationExecutionScalarWhereWithAggregatesInput[]
    NOT?: AutomationExecutionScalarWhereWithAggregatesInput | AutomationExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutomationExecution"> | string
    ruleId?: StringWithAggregatesFilter<"AutomationExecution"> | string
    triggerData?: JsonWithAggregatesFilter<"AutomationExecution">
    result?: JsonNullableWithAggregatesFilter<"AutomationExecution">
    status?: EnumAutomationStatusWithAggregatesFilter<"AutomationExecution"> | $Enums.AutomationStatus
    errorMessage?: StringNullableWithAggregatesFilter<"AutomationExecution"> | string | null
    executedAt?: DateTimeWithAggregatesFilter<"AutomationExecution"> | Date | string
    durationMs?: IntNullableWithAggregatesFilter<"AutomationExecution"> | number | null
  }

  export type TestPlanWhereInput = {
    AND?: TestPlanWhereInput | TestPlanWhereInput[]
    OR?: TestPlanWhereInput[]
    NOT?: TestPlanWhereInput | TestPlanWhereInput[]
    id?: StringFilter<"TestPlan"> | string
    name?: StringFilter<"TestPlan"> | string
    description?: StringNullableFilter<"TestPlan"> | string | null
    version?: StringFilter<"TestPlan"> | string
    status?: EnumTestPlanStatusFilter<"TestPlan"> | $Enums.TestPlanStatus
    projectId?: StringNullableFilter<"TestPlan"> | string | null
    feature?: StringNullableFilter<"TestPlan"> | string | null
    environment?: StringNullableFilter<"TestPlan"> | string | null
    startDate?: DateTimeNullableFilter<"TestPlan"> | Date | string | null
    endDate?: DateTimeNullableFilter<"TestPlan"> | Date | string | null
    createdById?: StringFilter<"TestPlan"> | string
    assignedToId?: StringNullableFilter<"TestPlan"> | string | null
    createdAt?: DateTimeFilter<"TestPlan"> | Date | string
    updatedAt?: DateTimeFilter<"TestPlan"> | Date | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    testCases?: TestCaseListRelationFilter
    executions?: TestExecutionListRelationFilter
    reviews?: QAReviewListRelationFilter
  }

  export type TestPlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrder
    status?: SortOrder
    projectId?: SortOrderInput | SortOrder
    feature?: SortOrderInput | SortOrder
    environment?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdById?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
    testCases?: TestCaseOrderByRelationAggregateInput
    executions?: TestExecutionOrderByRelationAggregateInput
    reviews?: QAReviewOrderByRelationAggregateInput
  }

  export type TestPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestPlanWhereInput | TestPlanWhereInput[]
    OR?: TestPlanWhereInput[]
    NOT?: TestPlanWhereInput | TestPlanWhereInput[]
    name?: StringFilter<"TestPlan"> | string
    description?: StringNullableFilter<"TestPlan"> | string | null
    version?: StringFilter<"TestPlan"> | string
    status?: EnumTestPlanStatusFilter<"TestPlan"> | $Enums.TestPlanStatus
    projectId?: StringNullableFilter<"TestPlan"> | string | null
    feature?: StringNullableFilter<"TestPlan"> | string | null
    environment?: StringNullableFilter<"TestPlan"> | string | null
    startDate?: DateTimeNullableFilter<"TestPlan"> | Date | string | null
    endDate?: DateTimeNullableFilter<"TestPlan"> | Date | string | null
    createdById?: StringFilter<"TestPlan"> | string
    assignedToId?: StringNullableFilter<"TestPlan"> | string | null
    createdAt?: DateTimeFilter<"TestPlan"> | Date | string
    updatedAt?: DateTimeFilter<"TestPlan"> | Date | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    testCases?: TestCaseListRelationFilter
    executions?: TestExecutionListRelationFilter
    reviews?: QAReviewListRelationFilter
  }, "id">

  export type TestPlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrder
    status?: SortOrder
    projectId?: SortOrderInput | SortOrder
    feature?: SortOrderInput | SortOrder
    environment?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdById?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TestPlanCountOrderByAggregateInput
    _max?: TestPlanMaxOrderByAggregateInput
    _min?: TestPlanMinOrderByAggregateInput
  }

  export type TestPlanScalarWhereWithAggregatesInput = {
    AND?: TestPlanScalarWhereWithAggregatesInput | TestPlanScalarWhereWithAggregatesInput[]
    OR?: TestPlanScalarWhereWithAggregatesInput[]
    NOT?: TestPlanScalarWhereWithAggregatesInput | TestPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TestPlan"> | string
    name?: StringWithAggregatesFilter<"TestPlan"> | string
    description?: StringNullableWithAggregatesFilter<"TestPlan"> | string | null
    version?: StringWithAggregatesFilter<"TestPlan"> | string
    status?: EnumTestPlanStatusWithAggregatesFilter<"TestPlan"> | $Enums.TestPlanStatus
    projectId?: StringNullableWithAggregatesFilter<"TestPlan"> | string | null
    feature?: StringNullableWithAggregatesFilter<"TestPlan"> | string | null
    environment?: StringNullableWithAggregatesFilter<"TestPlan"> | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"TestPlan"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"TestPlan"> | Date | string | null
    createdById?: StringWithAggregatesFilter<"TestPlan"> | string
    assignedToId?: StringNullableWithAggregatesFilter<"TestPlan"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TestPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TestPlan"> | Date | string
  }

  export type TestCaseWhereInput = {
    AND?: TestCaseWhereInput | TestCaseWhereInput[]
    OR?: TestCaseWhereInput[]
    NOT?: TestCaseWhereInput | TestCaseWhereInput[]
    id?: StringFilter<"TestCase"> | string
    title?: StringFilter<"TestCase"> | string
    description?: StringNullableFilter<"TestCase"> | string | null
    preconditions?: StringNullableFilter<"TestCase"> | string | null
    steps?: JsonFilter<"TestCase">
    expectedResult?: StringNullableFilter<"TestCase"> | string | null
    priority?: EnumTestCasePriorityFilter<"TestCase"> | $Enums.TestCasePriority
    status?: EnumTestCaseStatusFilter<"TestCase"> | $Enums.TestCaseStatus
    tags?: StringNullableListFilter<"TestCase">
    automatable?: BoolFilter<"TestCase"> | boolean
    estimatedTime?: IntNullableFilter<"TestCase"> | number | null
    testPlanId?: StringFilter<"TestCase"> | string
    createdById?: StringFilter<"TestCase"> | string
    createdAt?: DateTimeFilter<"TestCase"> | Date | string
    updatedAt?: DateTimeFilter<"TestCase"> | Date | string
    testPlan?: XOR<TestPlanRelationFilter, TestPlanWhereInput>
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    executions?: TestExecutionListRelationFilter
    defects?: DefectTestCaseListRelationFilter
  }

  export type TestCaseOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    preconditions?: SortOrderInput | SortOrder
    steps?: SortOrder
    expectedResult?: SortOrderInput | SortOrder
    priority?: SortOrder
    status?: SortOrder
    tags?: SortOrder
    automatable?: SortOrder
    estimatedTime?: SortOrderInput | SortOrder
    testPlanId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    testPlan?: TestPlanOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    executions?: TestExecutionOrderByRelationAggregateInput
    defects?: DefectTestCaseOrderByRelationAggregateInput
  }

  export type TestCaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestCaseWhereInput | TestCaseWhereInput[]
    OR?: TestCaseWhereInput[]
    NOT?: TestCaseWhereInput | TestCaseWhereInput[]
    title?: StringFilter<"TestCase"> | string
    description?: StringNullableFilter<"TestCase"> | string | null
    preconditions?: StringNullableFilter<"TestCase"> | string | null
    steps?: JsonFilter<"TestCase">
    expectedResult?: StringNullableFilter<"TestCase"> | string | null
    priority?: EnumTestCasePriorityFilter<"TestCase"> | $Enums.TestCasePriority
    status?: EnumTestCaseStatusFilter<"TestCase"> | $Enums.TestCaseStatus
    tags?: StringNullableListFilter<"TestCase">
    automatable?: BoolFilter<"TestCase"> | boolean
    estimatedTime?: IntNullableFilter<"TestCase"> | number | null
    testPlanId?: StringFilter<"TestCase"> | string
    createdById?: StringFilter<"TestCase"> | string
    createdAt?: DateTimeFilter<"TestCase"> | Date | string
    updatedAt?: DateTimeFilter<"TestCase"> | Date | string
    testPlan?: XOR<TestPlanRelationFilter, TestPlanWhereInput>
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    executions?: TestExecutionListRelationFilter
    defects?: DefectTestCaseListRelationFilter
  }, "id">

  export type TestCaseOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    preconditions?: SortOrderInput | SortOrder
    steps?: SortOrder
    expectedResult?: SortOrderInput | SortOrder
    priority?: SortOrder
    status?: SortOrder
    tags?: SortOrder
    automatable?: SortOrder
    estimatedTime?: SortOrderInput | SortOrder
    testPlanId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TestCaseCountOrderByAggregateInput
    _avg?: TestCaseAvgOrderByAggregateInput
    _max?: TestCaseMaxOrderByAggregateInput
    _min?: TestCaseMinOrderByAggregateInput
    _sum?: TestCaseSumOrderByAggregateInput
  }

  export type TestCaseScalarWhereWithAggregatesInput = {
    AND?: TestCaseScalarWhereWithAggregatesInput | TestCaseScalarWhereWithAggregatesInput[]
    OR?: TestCaseScalarWhereWithAggregatesInput[]
    NOT?: TestCaseScalarWhereWithAggregatesInput | TestCaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TestCase"> | string
    title?: StringWithAggregatesFilter<"TestCase"> | string
    description?: StringNullableWithAggregatesFilter<"TestCase"> | string | null
    preconditions?: StringNullableWithAggregatesFilter<"TestCase"> | string | null
    steps?: JsonWithAggregatesFilter<"TestCase">
    expectedResult?: StringNullableWithAggregatesFilter<"TestCase"> | string | null
    priority?: EnumTestCasePriorityWithAggregatesFilter<"TestCase"> | $Enums.TestCasePriority
    status?: EnumTestCaseStatusWithAggregatesFilter<"TestCase"> | $Enums.TestCaseStatus
    tags?: StringNullableListFilter<"TestCase">
    automatable?: BoolWithAggregatesFilter<"TestCase"> | boolean
    estimatedTime?: IntNullableWithAggregatesFilter<"TestCase"> | number | null
    testPlanId?: StringWithAggregatesFilter<"TestCase"> | string
    createdById?: StringWithAggregatesFilter<"TestCase"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TestCase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TestCase"> | Date | string
  }

  export type TestExecutionWhereInput = {
    AND?: TestExecutionWhereInput | TestExecutionWhereInput[]
    OR?: TestExecutionWhereInput[]
    NOT?: TestExecutionWhereInput | TestExecutionWhereInput[]
    id?: StringFilter<"TestExecution"> | string
    testPlanId?: StringFilter<"TestExecution"> | string
    testCaseId?: StringFilter<"TestExecution"> | string
    status?: EnumTestExecutionStatusFilter<"TestExecution"> | $Enums.TestExecutionStatus
    result?: StringNullableFilter<"TestExecution"> | string | null
    actualResult?: StringNullableFilter<"TestExecution"> | string | null
    evidence?: JsonNullableFilter<"TestExecution">
    executionTime?: IntNullableFilter<"TestExecution"> | number | null
    environment?: StringNullableFilter<"TestExecution"> | string | null
    browserVersion?: StringNullableFilter<"TestExecution"> | string | null
    osVersion?: StringNullableFilter<"TestExecution"> | string | null
    notes?: StringNullableFilter<"TestExecution"> | string | null
    executedById?: StringFilter<"TestExecution"> | string
    startedAt?: DateTimeNullableFilter<"TestExecution"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"TestExecution"> | Date | string | null
    createdAt?: DateTimeFilter<"TestExecution"> | Date | string
    updatedAt?: DateTimeFilter<"TestExecution"> | Date | string
    testPlan?: XOR<TestPlanRelationFilter, TestPlanWhereInput>
    testCase?: XOR<TestCaseRelationFilter, TestCaseWhereInput>
    executedBy?: XOR<UserRelationFilter, UserWhereInput>
    defects?: DefectListRelationFilter
  }

  export type TestExecutionOrderByWithRelationInput = {
    id?: SortOrder
    testPlanId?: SortOrder
    testCaseId?: SortOrder
    status?: SortOrder
    result?: SortOrderInput | SortOrder
    actualResult?: SortOrderInput | SortOrder
    evidence?: SortOrderInput | SortOrder
    executionTime?: SortOrderInput | SortOrder
    environment?: SortOrderInput | SortOrder
    browserVersion?: SortOrderInput | SortOrder
    osVersion?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    executedById?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    testPlan?: TestPlanOrderByWithRelationInput
    testCase?: TestCaseOrderByWithRelationInput
    executedBy?: UserOrderByWithRelationInput
    defects?: DefectOrderByRelationAggregateInput
  }

  export type TestExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestExecutionWhereInput | TestExecutionWhereInput[]
    OR?: TestExecutionWhereInput[]
    NOT?: TestExecutionWhereInput | TestExecutionWhereInput[]
    testPlanId?: StringFilter<"TestExecution"> | string
    testCaseId?: StringFilter<"TestExecution"> | string
    status?: EnumTestExecutionStatusFilter<"TestExecution"> | $Enums.TestExecutionStatus
    result?: StringNullableFilter<"TestExecution"> | string | null
    actualResult?: StringNullableFilter<"TestExecution"> | string | null
    evidence?: JsonNullableFilter<"TestExecution">
    executionTime?: IntNullableFilter<"TestExecution"> | number | null
    environment?: StringNullableFilter<"TestExecution"> | string | null
    browserVersion?: StringNullableFilter<"TestExecution"> | string | null
    osVersion?: StringNullableFilter<"TestExecution"> | string | null
    notes?: StringNullableFilter<"TestExecution"> | string | null
    executedById?: StringFilter<"TestExecution"> | string
    startedAt?: DateTimeNullableFilter<"TestExecution"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"TestExecution"> | Date | string | null
    createdAt?: DateTimeFilter<"TestExecution"> | Date | string
    updatedAt?: DateTimeFilter<"TestExecution"> | Date | string
    testPlan?: XOR<TestPlanRelationFilter, TestPlanWhereInput>
    testCase?: XOR<TestCaseRelationFilter, TestCaseWhereInput>
    executedBy?: XOR<UserRelationFilter, UserWhereInput>
    defects?: DefectListRelationFilter
  }, "id">

  export type TestExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    testPlanId?: SortOrder
    testCaseId?: SortOrder
    status?: SortOrder
    result?: SortOrderInput | SortOrder
    actualResult?: SortOrderInput | SortOrder
    evidence?: SortOrderInput | SortOrder
    executionTime?: SortOrderInput | SortOrder
    environment?: SortOrderInput | SortOrder
    browserVersion?: SortOrderInput | SortOrder
    osVersion?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    executedById?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TestExecutionCountOrderByAggregateInput
    _avg?: TestExecutionAvgOrderByAggregateInput
    _max?: TestExecutionMaxOrderByAggregateInput
    _min?: TestExecutionMinOrderByAggregateInput
    _sum?: TestExecutionSumOrderByAggregateInput
  }

  export type TestExecutionScalarWhereWithAggregatesInput = {
    AND?: TestExecutionScalarWhereWithAggregatesInput | TestExecutionScalarWhereWithAggregatesInput[]
    OR?: TestExecutionScalarWhereWithAggregatesInput[]
    NOT?: TestExecutionScalarWhereWithAggregatesInput | TestExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TestExecution"> | string
    testPlanId?: StringWithAggregatesFilter<"TestExecution"> | string
    testCaseId?: StringWithAggregatesFilter<"TestExecution"> | string
    status?: EnumTestExecutionStatusWithAggregatesFilter<"TestExecution"> | $Enums.TestExecutionStatus
    result?: StringNullableWithAggregatesFilter<"TestExecution"> | string | null
    actualResult?: StringNullableWithAggregatesFilter<"TestExecution"> | string | null
    evidence?: JsonNullableWithAggregatesFilter<"TestExecution">
    executionTime?: IntNullableWithAggregatesFilter<"TestExecution"> | number | null
    environment?: StringNullableWithAggregatesFilter<"TestExecution"> | string | null
    browserVersion?: StringNullableWithAggregatesFilter<"TestExecution"> | string | null
    osVersion?: StringNullableWithAggregatesFilter<"TestExecution"> | string | null
    notes?: StringNullableWithAggregatesFilter<"TestExecution"> | string | null
    executedById?: StringWithAggregatesFilter<"TestExecution"> | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"TestExecution"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"TestExecution"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TestExecution"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TestExecution"> | Date | string
  }

  export type DefectWhereInput = {
    AND?: DefectWhereInput | DefectWhereInput[]
    OR?: DefectWhereInput[]
    NOT?: DefectWhereInput | DefectWhereInput[]
    id?: StringFilter<"Defect"> | string
    title?: StringFilter<"Defect"> | string
    description?: StringFilter<"Defect"> | string
    steps?: StringNullableFilter<"Defect"> | string | null
    expectedBehavior?: StringNullableFilter<"Defect"> | string | null
    actualBehavior?: StringNullableFilter<"Defect"> | string | null
    severity?: EnumDefectSeverityFilter<"Defect"> | $Enums.DefectSeverity
    priority?: EnumDefectPriorityFilter<"Defect"> | $Enums.DefectPriority
    status?: EnumDefectStatusFilter<"Defect"> | $Enums.DefectStatus
    environment?: StringNullableFilter<"Defect"> | string | null
    browserVersion?: StringNullableFilter<"Defect"> | string | null
    osVersion?: StringNullableFilter<"Defect"> | string | null
    attachments?: JsonNullableFilter<"Defect">
    reproducible?: BoolFilter<"Defect"> | boolean
    regression?: BoolFilter<"Defect"> | boolean
    testExecutionId?: StringNullableFilter<"Defect"> | string | null
    reportedById?: StringFilter<"Defect"> | string
    assignedToId?: StringNullableFilter<"Defect"> | string | null
    reportedAt?: DateTimeFilter<"Defect"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Defect"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"Defect"> | Date | string | null
    createdAt?: DateTimeFilter<"Defect"> | Date | string
    updatedAt?: DateTimeFilter<"Defect"> | Date | string
    testExecution?: XOR<TestExecutionNullableRelationFilter, TestExecutionWhereInput> | null
    reportedBy?: XOR<UserRelationFilter, UserWhereInput>
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    testCases?: DefectTestCaseListRelationFilter
    comments?: DefectCommentListRelationFilter
  }

  export type DefectOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    steps?: SortOrderInput | SortOrder
    expectedBehavior?: SortOrderInput | SortOrder
    actualBehavior?: SortOrderInput | SortOrder
    severity?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    environment?: SortOrderInput | SortOrder
    browserVersion?: SortOrderInput | SortOrder
    osVersion?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    reproducible?: SortOrder
    regression?: SortOrder
    testExecutionId?: SortOrderInput | SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    reportedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    testExecution?: TestExecutionOrderByWithRelationInput
    reportedBy?: UserOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
    testCases?: DefectTestCaseOrderByRelationAggregateInput
    comments?: DefectCommentOrderByRelationAggregateInput
  }

  export type DefectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DefectWhereInput | DefectWhereInput[]
    OR?: DefectWhereInput[]
    NOT?: DefectWhereInput | DefectWhereInput[]
    title?: StringFilter<"Defect"> | string
    description?: StringFilter<"Defect"> | string
    steps?: StringNullableFilter<"Defect"> | string | null
    expectedBehavior?: StringNullableFilter<"Defect"> | string | null
    actualBehavior?: StringNullableFilter<"Defect"> | string | null
    severity?: EnumDefectSeverityFilter<"Defect"> | $Enums.DefectSeverity
    priority?: EnumDefectPriorityFilter<"Defect"> | $Enums.DefectPriority
    status?: EnumDefectStatusFilter<"Defect"> | $Enums.DefectStatus
    environment?: StringNullableFilter<"Defect"> | string | null
    browserVersion?: StringNullableFilter<"Defect"> | string | null
    osVersion?: StringNullableFilter<"Defect"> | string | null
    attachments?: JsonNullableFilter<"Defect">
    reproducible?: BoolFilter<"Defect"> | boolean
    regression?: BoolFilter<"Defect"> | boolean
    testExecutionId?: StringNullableFilter<"Defect"> | string | null
    reportedById?: StringFilter<"Defect"> | string
    assignedToId?: StringNullableFilter<"Defect"> | string | null
    reportedAt?: DateTimeFilter<"Defect"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Defect"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"Defect"> | Date | string | null
    createdAt?: DateTimeFilter<"Defect"> | Date | string
    updatedAt?: DateTimeFilter<"Defect"> | Date | string
    testExecution?: XOR<TestExecutionNullableRelationFilter, TestExecutionWhereInput> | null
    reportedBy?: XOR<UserRelationFilter, UserWhereInput>
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    testCases?: DefectTestCaseListRelationFilter
    comments?: DefectCommentListRelationFilter
  }, "id">

  export type DefectOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    steps?: SortOrderInput | SortOrder
    expectedBehavior?: SortOrderInput | SortOrder
    actualBehavior?: SortOrderInput | SortOrder
    severity?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    environment?: SortOrderInput | SortOrder
    browserVersion?: SortOrderInput | SortOrder
    osVersion?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    reproducible?: SortOrder
    regression?: SortOrder
    testExecutionId?: SortOrderInput | SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    reportedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DefectCountOrderByAggregateInput
    _max?: DefectMaxOrderByAggregateInput
    _min?: DefectMinOrderByAggregateInput
  }

  export type DefectScalarWhereWithAggregatesInput = {
    AND?: DefectScalarWhereWithAggregatesInput | DefectScalarWhereWithAggregatesInput[]
    OR?: DefectScalarWhereWithAggregatesInput[]
    NOT?: DefectScalarWhereWithAggregatesInput | DefectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Defect"> | string
    title?: StringWithAggregatesFilter<"Defect"> | string
    description?: StringWithAggregatesFilter<"Defect"> | string
    steps?: StringNullableWithAggregatesFilter<"Defect"> | string | null
    expectedBehavior?: StringNullableWithAggregatesFilter<"Defect"> | string | null
    actualBehavior?: StringNullableWithAggregatesFilter<"Defect"> | string | null
    severity?: EnumDefectSeverityWithAggregatesFilter<"Defect"> | $Enums.DefectSeverity
    priority?: EnumDefectPriorityWithAggregatesFilter<"Defect"> | $Enums.DefectPriority
    status?: EnumDefectStatusWithAggregatesFilter<"Defect"> | $Enums.DefectStatus
    environment?: StringNullableWithAggregatesFilter<"Defect"> | string | null
    browserVersion?: StringNullableWithAggregatesFilter<"Defect"> | string | null
    osVersion?: StringNullableWithAggregatesFilter<"Defect"> | string | null
    attachments?: JsonNullableWithAggregatesFilter<"Defect">
    reproducible?: BoolWithAggregatesFilter<"Defect"> | boolean
    regression?: BoolWithAggregatesFilter<"Defect"> | boolean
    testExecutionId?: StringNullableWithAggregatesFilter<"Defect"> | string | null
    reportedById?: StringWithAggregatesFilter<"Defect"> | string
    assignedToId?: StringNullableWithAggregatesFilter<"Defect"> | string | null
    reportedAt?: DateTimeWithAggregatesFilter<"Defect"> | Date | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Defect"> | Date | string | null
    closedAt?: DateTimeNullableWithAggregatesFilter<"Defect"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Defect"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Defect"> | Date | string
  }

  export type DefectTestCaseWhereInput = {
    AND?: DefectTestCaseWhereInput | DefectTestCaseWhereInput[]
    OR?: DefectTestCaseWhereInput[]
    NOT?: DefectTestCaseWhereInput | DefectTestCaseWhereInput[]
    id?: StringFilter<"DefectTestCase"> | string
    defectId?: StringFilter<"DefectTestCase"> | string
    testCaseId?: StringFilter<"DefectTestCase"> | string
    createdAt?: DateTimeFilter<"DefectTestCase"> | Date | string
    defect?: XOR<DefectRelationFilter, DefectWhereInput>
    testCase?: XOR<TestCaseRelationFilter, TestCaseWhereInput>
  }

  export type DefectTestCaseOrderByWithRelationInput = {
    id?: SortOrder
    defectId?: SortOrder
    testCaseId?: SortOrder
    createdAt?: SortOrder
    defect?: DefectOrderByWithRelationInput
    testCase?: TestCaseOrderByWithRelationInput
  }

  export type DefectTestCaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    defectId_testCaseId?: DefectTestCaseDefectIdTestCaseIdCompoundUniqueInput
    AND?: DefectTestCaseWhereInput | DefectTestCaseWhereInput[]
    OR?: DefectTestCaseWhereInput[]
    NOT?: DefectTestCaseWhereInput | DefectTestCaseWhereInput[]
    defectId?: StringFilter<"DefectTestCase"> | string
    testCaseId?: StringFilter<"DefectTestCase"> | string
    createdAt?: DateTimeFilter<"DefectTestCase"> | Date | string
    defect?: XOR<DefectRelationFilter, DefectWhereInput>
    testCase?: XOR<TestCaseRelationFilter, TestCaseWhereInput>
  }, "id" | "defectId_testCaseId">

  export type DefectTestCaseOrderByWithAggregationInput = {
    id?: SortOrder
    defectId?: SortOrder
    testCaseId?: SortOrder
    createdAt?: SortOrder
    _count?: DefectTestCaseCountOrderByAggregateInput
    _max?: DefectTestCaseMaxOrderByAggregateInput
    _min?: DefectTestCaseMinOrderByAggregateInput
  }

  export type DefectTestCaseScalarWhereWithAggregatesInput = {
    AND?: DefectTestCaseScalarWhereWithAggregatesInput | DefectTestCaseScalarWhereWithAggregatesInput[]
    OR?: DefectTestCaseScalarWhereWithAggregatesInput[]
    NOT?: DefectTestCaseScalarWhereWithAggregatesInput | DefectTestCaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DefectTestCase"> | string
    defectId?: StringWithAggregatesFilter<"DefectTestCase"> | string
    testCaseId?: StringWithAggregatesFilter<"DefectTestCase"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DefectTestCase"> | Date | string
  }

  export type DefectCommentWhereInput = {
    AND?: DefectCommentWhereInput | DefectCommentWhereInput[]
    OR?: DefectCommentWhereInput[]
    NOT?: DefectCommentWhereInput | DefectCommentWhereInput[]
    id?: StringFilter<"DefectComment"> | string
    content?: StringFilter<"DefectComment"> | string
    defectId?: StringFilter<"DefectComment"> | string
    authorId?: StringFilter<"DefectComment"> | string
    isInternal?: BoolFilter<"DefectComment"> | boolean
    createdAt?: DateTimeFilter<"DefectComment"> | Date | string
    updatedAt?: DateTimeFilter<"DefectComment"> | Date | string
    defect?: XOR<DefectRelationFilter, DefectWhereInput>
  }

  export type DefectCommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    defectId?: SortOrder
    authorId?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    defect?: DefectOrderByWithRelationInput
  }

  export type DefectCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DefectCommentWhereInput | DefectCommentWhereInput[]
    OR?: DefectCommentWhereInput[]
    NOT?: DefectCommentWhereInput | DefectCommentWhereInput[]
    content?: StringFilter<"DefectComment"> | string
    defectId?: StringFilter<"DefectComment"> | string
    authorId?: StringFilter<"DefectComment"> | string
    isInternal?: BoolFilter<"DefectComment"> | boolean
    createdAt?: DateTimeFilter<"DefectComment"> | Date | string
    updatedAt?: DateTimeFilter<"DefectComment"> | Date | string
    defect?: XOR<DefectRelationFilter, DefectWhereInput>
  }, "id">

  export type DefectCommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    defectId?: SortOrder
    authorId?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DefectCommentCountOrderByAggregateInput
    _max?: DefectCommentMaxOrderByAggregateInput
    _min?: DefectCommentMinOrderByAggregateInput
  }

  export type DefectCommentScalarWhereWithAggregatesInput = {
    AND?: DefectCommentScalarWhereWithAggregatesInput | DefectCommentScalarWhereWithAggregatesInput[]
    OR?: DefectCommentScalarWhereWithAggregatesInput[]
    NOT?: DefectCommentScalarWhereWithAggregatesInput | DefectCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DefectComment"> | string
    content?: StringWithAggregatesFilter<"DefectComment"> | string
    defectId?: StringWithAggregatesFilter<"DefectComment"> | string
    authorId?: StringWithAggregatesFilter<"DefectComment"> | string
    isInternal?: BoolWithAggregatesFilter<"DefectComment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DefectComment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DefectComment"> | Date | string
  }

  export type QAReviewWhereInput = {
    AND?: QAReviewWhereInput | QAReviewWhereInput[]
    OR?: QAReviewWhereInput[]
    NOT?: QAReviewWhereInput | QAReviewWhereInput[]
    id?: StringFilter<"QAReview"> | string
    title?: StringFilter<"QAReview"> | string
    description?: StringNullableFilter<"QAReview"> | string | null
    type?: StringFilter<"QAReview"> | string
    entityId?: StringFilter<"QAReview"> | string
    status?: EnumQAReviewStatusFilter<"QAReview"> | $Enums.QAReviewStatus
    criteria?: JsonNullableFilter<"QAReview">
    findings?: StringNullableFilter<"QAReview"> | string | null
    recommendations?: StringNullableFilter<"QAReview"> | string | null
    approved?: BoolNullableFilter<"QAReview"> | boolean | null
    testPlanId?: StringNullableFilter<"QAReview"> | string | null
    reviewerId?: StringFilter<"QAReview"> | string
    reviewedAt?: DateTimeNullableFilter<"QAReview"> | Date | string | null
    createdAt?: DateTimeFilter<"QAReview"> | Date | string
    updatedAt?: DateTimeFilter<"QAReview"> | Date | string
    testPlan?: XOR<TestPlanNullableRelationFilter, TestPlanWhereInput> | null
    reviewer?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type QAReviewOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    entityId?: SortOrder
    status?: SortOrder
    criteria?: SortOrderInput | SortOrder
    findings?: SortOrderInput | SortOrder
    recommendations?: SortOrderInput | SortOrder
    approved?: SortOrderInput | SortOrder
    testPlanId?: SortOrderInput | SortOrder
    reviewerId?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    testPlan?: TestPlanOrderByWithRelationInput
    reviewer?: UserOrderByWithRelationInput
  }

  export type QAReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QAReviewWhereInput | QAReviewWhereInput[]
    OR?: QAReviewWhereInput[]
    NOT?: QAReviewWhereInput | QAReviewWhereInput[]
    title?: StringFilter<"QAReview"> | string
    description?: StringNullableFilter<"QAReview"> | string | null
    type?: StringFilter<"QAReview"> | string
    entityId?: StringFilter<"QAReview"> | string
    status?: EnumQAReviewStatusFilter<"QAReview"> | $Enums.QAReviewStatus
    criteria?: JsonNullableFilter<"QAReview">
    findings?: StringNullableFilter<"QAReview"> | string | null
    recommendations?: StringNullableFilter<"QAReview"> | string | null
    approved?: BoolNullableFilter<"QAReview"> | boolean | null
    testPlanId?: StringNullableFilter<"QAReview"> | string | null
    reviewerId?: StringFilter<"QAReview"> | string
    reviewedAt?: DateTimeNullableFilter<"QAReview"> | Date | string | null
    createdAt?: DateTimeFilter<"QAReview"> | Date | string
    updatedAt?: DateTimeFilter<"QAReview"> | Date | string
    testPlan?: XOR<TestPlanNullableRelationFilter, TestPlanWhereInput> | null
    reviewer?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type QAReviewOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    entityId?: SortOrder
    status?: SortOrder
    criteria?: SortOrderInput | SortOrder
    findings?: SortOrderInput | SortOrder
    recommendations?: SortOrderInput | SortOrder
    approved?: SortOrderInput | SortOrder
    testPlanId?: SortOrderInput | SortOrder
    reviewerId?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QAReviewCountOrderByAggregateInput
    _max?: QAReviewMaxOrderByAggregateInput
    _min?: QAReviewMinOrderByAggregateInput
  }

  export type QAReviewScalarWhereWithAggregatesInput = {
    AND?: QAReviewScalarWhereWithAggregatesInput | QAReviewScalarWhereWithAggregatesInput[]
    OR?: QAReviewScalarWhereWithAggregatesInput[]
    NOT?: QAReviewScalarWhereWithAggregatesInput | QAReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QAReview"> | string
    title?: StringWithAggregatesFilter<"QAReview"> | string
    description?: StringNullableWithAggregatesFilter<"QAReview"> | string | null
    type?: StringWithAggregatesFilter<"QAReview"> | string
    entityId?: StringWithAggregatesFilter<"QAReview"> | string
    status?: EnumQAReviewStatusWithAggregatesFilter<"QAReview"> | $Enums.QAReviewStatus
    criteria?: JsonNullableWithAggregatesFilter<"QAReview">
    findings?: StringNullableWithAggregatesFilter<"QAReview"> | string | null
    recommendations?: StringNullableWithAggregatesFilter<"QAReview"> | string | null
    approved?: BoolNullableWithAggregatesFilter<"QAReview"> | boolean | null
    testPlanId?: StringNullableWithAggregatesFilter<"QAReview"> | string | null
    reviewerId?: StringWithAggregatesFilter<"QAReview"> | string
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"QAReview"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"QAReview"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QAReview"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedAccounts?: AccountCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownedAccounts?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceUncheckedCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverUncheckedCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanUncheckedCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanUncheckedCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionUncheckedCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectUncheckedCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectUncheckedCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedAccounts?: AccountUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedAccounts?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUncheckedUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUncheckedUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUncheckedUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUncheckedUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUncheckedUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    owner: UserCreateNestedOneWithoutOwnedAccountsInput
    activities?: ActivityCreateNestedManyWithoutAccountInput
    appointments?: AppointmentCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectCreateNestedManyWithoutAccountInput
    contacts?: ContactCreateNestedManyWithoutAccountInput
    documents?: DocumentCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryCreateNestedManyWithoutAccountInput
    events?: EventLogCreateNestedManyWithoutAccountInput
    leads?: LeadCreateNestedManyWithoutAccountInput
    projects?: ProjectCreateNestedManyWithoutAccountInput
    snags?: SnagCreateNestedManyWithoutAccountInput
    tasks?: TaskCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutAccountInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAccountInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutAccountInput
    events?: EventLogUncheckedCreateNestedManyWithoutAccountInput
    leads?: LeadUncheckedCreateNestedManyWithoutAccountInput
    projects?: ProjectUncheckedCreateNestedManyWithoutAccountInput
    snags?: SnagUncheckedCreateNestedManyWithoutAccountInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: UserUpdateOneRequiredWithoutOwnedAccountsNestedInput
    activities?: ActivityUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUpdateManyWithoutAccountNestedInput
    contacts?: ContactUpdateManyWithoutAccountNestedInput
    documents?: DocumentUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUpdateManyWithoutAccountNestedInput
    events?: EventLogUpdateManyWithoutAccountNestedInput
    leads?: LeadUpdateManyWithoutAccountNestedInput
    projects?: ProjectUpdateManyWithoutAccountNestedInput
    snags?: SnagUpdateManyWithoutAccountNestedInput
    tasks?: TaskUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUncheckedUpdateManyWithoutAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAccountNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutAccountNestedInput
    events?: EventLogUncheckedUpdateManyWithoutAccountNestedInput
    leads?: LeadUncheckedUpdateManyWithoutAccountNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutAccountNestedInput
    snags?: SnagUncheckedUpdateManyWithoutAccountNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUncheckedUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountCreateManyInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EnquiryCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.EnquiryStatus
    priority?: $Enums.Priority
    source?: string | null
    campaign?: string | null
    medium?: string | null
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    contactMethod?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    company?: string | null
    message?: string | null
    leadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityCreateNestedManyWithoutEnquiryInput
    account?: AccountCreateNestedOneWithoutEnquiriesInput
    owner: UserCreateNestedOneWithoutOwnedEnquiriesInput
    lead?: LeadCreateNestedOneWithoutEnquiryInput
    tasks?: TaskCreateNestedManyWithoutEnquiryInput
  }

  export type EnquiryUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.EnquiryStatus
    priority?: $Enums.Priority
    source?: string | null
    campaign?: string | null
    medium?: string | null
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    contactMethod?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    company?: string | null
    message?: string | null
    accountId?: string | null
    ownerId: string
    leadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutEnquiryInput
    lead?: LeadUncheckedCreateNestedOneWithoutEnquiryInput
    tasks?: TaskUncheckedCreateNestedManyWithoutEnquiryInput
  }

  export type EnquiryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnquiryStatusFieldUpdateOperationsInput | $Enums.EnquiryStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutEnquiryNestedInput
    account?: AccountUpdateOneWithoutEnquiriesNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedEnquiriesNestedInput
    lead?: LeadUpdateOneWithoutEnquiryNestedInput
    tasks?: TaskUpdateManyWithoutEnquiryNestedInput
  }

  export type EnquiryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnquiryStatusFieldUpdateOperationsInput | $Enums.EnquiryStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutEnquiryNestedInput
    lead?: LeadUncheckedUpdateOneWithoutEnquiryNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutEnquiryNestedInput
  }

  export type EnquiryCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.EnquiryStatus
    priority?: $Enums.Priority
    source?: string | null
    campaign?: string | null
    medium?: string | null
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    contactMethod?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    company?: string | null
    message?: string | null
    accountId?: string | null
    ownerId: string
    leadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
  }

  export type EnquiryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnquiryStatusFieldUpdateOperationsInput | $Enums.EnquiryStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EnquiryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnquiryStatusFieldUpdateOperationsInput | $Enums.EnquiryStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactCreateInput = {
    id?: string
    name: string
    role?: string | null
    email?: string | null
    phone?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutContactsInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    accountId: string
    name: string
    role?: string | null
    email?: string | null
    phone?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateManyInput = {
    id?: string
    accountId: string
    name: string
    role?: string | null
    email?: string | null
    phone?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityCreateNestedManyWithoutLeadInput
    account: AccountCreateNestedOneWithoutLeadsInput
    enquiry?: EnquiryCreateNestedOneWithoutLeadInput
    owner: UserCreateNestedOneWithoutOwnedLeadsInput
    project?: ProjectCreateNestedOneWithoutLeadInput
    tasks?: TaskCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    accountId: string
    ownerId: string
    enquiryId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutLeadInput
    project?: ProjectUncheckedCreateNestedOneWithoutLeadInput
    tasks?: TaskUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutLeadNestedInput
    account?: AccountUpdateOneRequiredWithoutLeadsNestedInput
    enquiry?: EnquiryUpdateOneWithoutLeadNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedLeadsNestedInput
    project?: ProjectUpdateOneWithoutLeadNestedInput
    tasks?: TaskUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutLeadNestedInput
    project?: ProjectUncheckedUpdateOneWithoutLeadNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    accountId: string
    ownerId: string
    enquiryId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
  }

  export type LeadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectCreateInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    amountGrossIncVat: number
    vatRate?: number
    probability?: number
    source?: string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    completedProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutProjectInput
    appointments?: AppointmentCreateNestedManyWithoutProjectInput
    completedProject?: CompletedProjectCreateNestedOneWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    account: AccountCreateNestedOneWithoutProjectsInput
    lead?: LeadCreateNestedOneWithoutProjectInput
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    snags?: SnagCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    accountId: string
    ownerId: string
    amountGrossIncVat: number
    vatRate?: number
    probability?: number
    source?: string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    leadId?: string | null
    completedProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProjectInput
    completedProject?: CompletedProjectUncheckedCreateNestedOneWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    snags?: SnagUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    amountGrossIncVat?: IntFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    completedProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    appointments?: AppointmentUpdateManyWithoutProjectNestedInput
    completedProject?: CompletedProjectUpdateOneWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    account?: AccountUpdateOneRequiredWithoutProjectsNestedInput
    lead?: LeadUpdateOneWithoutProjectNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    snags?: SnagUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    accountId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    amountGrossIncVat?: IntFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    completedProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutProjectNestedInput
    completedProject?: CompletedProjectUncheckedUpdateOneWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    snags?: SnagUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    accountId: string
    ownerId: string
    amountGrossIncVat: number
    vatRate?: number
    probability?: number
    source?: string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    leadId?: string | null
    completedProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    amountGrossIncVat?: IntFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    completedProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    accountId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    amountGrossIncVat?: IntFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    completedProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompletedProjectCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.CompletedProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutCompletedProjectsInput
    owner: UserCreateNestedOneWithoutOwnedCompletedProjectsInput
    project?: ProjectCreateNestedOneWithoutCompletedProjectInput
  }

  export type CompletedProjectUncheckedCreateInput = {
    id?: string
    accountId: string
    projectId?: string | null
    ownerId: string
    title: string
    description?: string | null
    status?: $Enums.CompletedProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompletedProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompletedProjectStatusFieldUpdateOperationsInput | $Enums.CompletedProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutCompletedProjectsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedCompletedProjectsNestedInput
    project?: ProjectUpdateOneWithoutCompletedProjectNestedInput
  }

  export type CompletedProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompletedProjectStatusFieldUpdateOperationsInput | $Enums.CompletedProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompletedProjectCreateManyInput = {
    id?: string
    accountId: string
    projectId?: string | null
    ownerId: string
    title: string
    description?: string | null
    status?: $Enums.CompletedProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompletedProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompletedProjectStatusFieldUpdateOperationsInput | $Enums.CompletedProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompletedProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompletedProjectStatusFieldUpdateOperationsInput | $Enums.CompletedProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateInput = {
    id?: string
    type: $Enums.ActivityType
    threadKey?: string | null
    summary?: string | null
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: Date | string
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutActivitiesInput
    enquiry?: EnquiryCreateNestedOneWithoutActivitiesInput
    lead?: LeadCreateNestedOneWithoutActivitiesInput
    project?: ProjectCreateNestedOneWithoutActivitiesInput
    user?: UserCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    accountId: string
    enquiryId?: string | null
    leadId?: string | null
    projectId?: string | null
    userId?: string | null
    type: $Enums.ActivityType
    threadKey?: string | null
    summary?: string | null
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: Date | string
    createdAt?: Date | string
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    threadKey?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutActivitiesNestedInput
    enquiry?: EnquiryUpdateOneWithoutActivitiesNestedInput
    lead?: LeadUpdateOneWithoutActivitiesNestedInput
    project?: ProjectUpdateOneWithoutActivitiesNestedInput
    user?: UserUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    threadKey?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyInput = {
    id?: string
    accountId: string
    enquiryId?: string | null
    leadId?: string | null
    projectId?: string | null
    userId?: string | null
    type: $Enums.ActivityType
    threadKey?: string | null
    summary?: string | null
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: Date | string
    createdAt?: Date | string
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    threadKey?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    threadKey?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutTasksInput
    assignee: UserCreateNestedOneWithoutAssignedTasksInput
    enquiry?: EnquiryCreateNestedOneWithoutTasksInput
    lead?: LeadCreateNestedOneWithoutTasksInput
    project?: ProjectCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    assigneeId: string
    accountId: string
    enquiryId?: string | null
    leadId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutTasksNestedInput
    assignee?: UserUpdateOneRequiredWithoutAssignedTasksNestedInput
    enquiry?: EnquiryUpdateOneWithoutTasksNestedInput
    lead?: LeadUpdateOneWithoutTasksNestedInput
    project?: ProjectUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    assigneeId: string
    accountId: string
    enquiryId?: string | null
    leadId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.AppointmentType
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    status?: $Enums.AppointmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutAppointmentsInput
    project?: ProjectCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: string
    accountId: string
    projectId?: string | null
    title: string
    description?: string | null
    type: $Enums.AppointmentType
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    status?: $Enums.AppointmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutAppointmentsNestedInput
    project?: ProjectUpdateOneWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyInput = {
    id?: string
    accountId: string
    projectId?: string | null
    title: string
    description?: string | null
    type: $Enums.AppointmentType
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    status?: $Enums.AppointmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    filename: string
    fileUrl: string
    fileSize?: number | null
    mimeType?: string | null
    type?: $Enums.DocumentType
    uploadedBy?: string | null
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutDocumentsInput
    project?: ProjectCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    accountId: string
    projectId?: string | null
    filename: string
    fileUrl: string
    fileSize?: number | null
    mimeType?: string | null
    type?: $Enums.DocumentType
    uploadedBy?: string | null
    createdAt?: Date | string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutDocumentsNestedInput
    project?: ProjectUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    accountId: string
    projectId?: string | null
    filename: string
    fileUrl: string
    fileSize?: number | null
    mimeType?: string | null
    type?: $Enums.DocumentType
    uploadedBy?: string | null
    createdAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnagCreateInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SnagStatus
    priority?: $Enums.Priority
    assigneeId?: string | null
    dueAt?: Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutSnagsInput
    project: ProjectCreateNestedOneWithoutSnagsInput
  }

  export type SnagUncheckedCreateInput = {
    id?: string
    accountId: string
    projectId: string
    title: string
    description: string
    status?: $Enums.SnagStatus
    priority?: $Enums.Priority
    assigneeId?: string | null
    dueAt?: Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SnagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSnagStatusFieldUpdateOperationsInput | $Enums.SnagStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutSnagsNestedInput
    project?: ProjectUpdateOneRequiredWithoutSnagsNestedInput
  }

  export type SnagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSnagStatusFieldUpdateOperationsInput | $Enums.SnagStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnagCreateManyInput = {
    id?: string
    accountId: string
    projectId: string
    title: string
    description: string
    status?: $Enums.SnagStatus
    priority?: $Enums.Priority
    assigneeId?: string | null
    dueAt?: Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SnagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSnagStatusFieldUpdateOperationsInput | $Enums.SnagStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSnagStatusFieldUpdateOperationsInput | $Enums.SnagStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventLogCreateInput = {
    id?: string
    actorId?: string | null
    entity: string
    entityId: string
    action: string
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    account?: AccountCreateNestedOneWithoutEventsInput
  }

  export type EventLogUncheckedCreateInput = {
    id?: string
    accountId?: string | null
    actorId?: string | null
    entity: string
    entityId: string
    action: string
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EventLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutEventsNestedInput
  }

  export type EventLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventLogCreateManyInput = {
    id?: string
    accountId?: string | null
    actorId?: string | null
    entity: string
    entityId: string
    action: string
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EventLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowDefinitionCreateInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    triggerType: $Enums.WorkflowTriggerType
    triggerConditions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutWorkflowsInput
    createdBy: UserCreateNestedOneWithoutCreatedWorkflowsInput
    steps?: WorkflowStepCreateNestedManyWithoutWorkflowInput
    instances?: WorkflowInstanceCreateNestedManyWithoutWorkflowInput
    templates?: WorkflowTemplateCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowDefinitionUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    triggerType: $Enums.WorkflowTriggerType
    triggerConditions: JsonNullValueInput | InputJsonValue
    accountId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: WorkflowStepUncheckedCreateNestedManyWithoutWorkflowInput
    instances?: WorkflowInstanceUncheckedCreateNestedManyWithoutWorkflowInput
    templates?: WorkflowTemplateUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowDefinitionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    triggerType?: EnumWorkflowTriggerTypeFieldUpdateOperationsInput | $Enums.WorkflowTriggerType
    triggerConditions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutWorkflowsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedWorkflowsNestedInput
    steps?: WorkflowStepUpdateManyWithoutWorkflowNestedInput
    instances?: WorkflowInstanceUpdateManyWithoutWorkflowNestedInput
    templates?: WorkflowTemplateUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowDefinitionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    triggerType?: EnumWorkflowTriggerTypeFieldUpdateOperationsInput | $Enums.WorkflowTriggerType
    triggerConditions?: JsonNullValueInput | InputJsonValue
    accountId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: WorkflowStepUncheckedUpdateManyWithoutWorkflowNestedInput
    instances?: WorkflowInstanceUncheckedUpdateManyWithoutWorkflowNestedInput
    templates?: WorkflowTemplateUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowDefinitionCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    triggerType: $Enums.WorkflowTriggerType
    triggerConditions: JsonNullValueInput | InputJsonValue
    accountId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowDefinitionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    triggerType?: EnumWorkflowTriggerTypeFieldUpdateOperationsInput | $Enums.WorkflowTriggerType
    triggerConditions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowDefinitionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    triggerType?: EnumWorkflowTriggerTypeFieldUpdateOperationsInput | $Enums.WorkflowTriggerType
    triggerConditions?: JsonNullValueInput | InputJsonValue
    accountId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowStepCreateInput = {
    id?: string
    name: string
    description?: string | null
    stepType: $Enums.WorkflowStepType
    position: number
    configuration: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    timeoutMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workflow: WorkflowDefinitionCreateNestedOneWithoutStepsInput
    executions?: WorkflowStepExecutionCreateNestedManyWithoutStepInput
    approvers?: WorkflowStepApproverCreateNestedManyWithoutStepInput
  }

  export type WorkflowStepUncheckedCreateInput = {
    id?: string
    workflowId: string
    name: string
    description?: string | null
    stepType: $Enums.WorkflowStepType
    position: number
    configuration: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    timeoutMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutStepInput
    approvers?: WorkflowStepApproverUncheckedCreateNestedManyWithoutStepInput
  }

  export type WorkflowStepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    position?: IntFieldUpdateOperationsInput | number
    configuration?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    timeoutMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflow?: WorkflowDefinitionUpdateOneRequiredWithoutStepsNestedInput
    executions?: WorkflowStepExecutionUpdateManyWithoutStepNestedInput
    approvers?: WorkflowStepApproverUpdateManyWithoutStepNestedInput
  }

  export type WorkflowStepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    position?: IntFieldUpdateOperationsInput | number
    configuration?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    timeoutMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: WorkflowStepExecutionUncheckedUpdateManyWithoutStepNestedInput
    approvers?: WorkflowStepApproverUncheckedUpdateManyWithoutStepNestedInput
  }

  export type WorkflowStepCreateManyInput = {
    id?: string
    workflowId: string
    name: string
    description?: string | null
    stepType: $Enums.WorkflowStepType
    position: number
    configuration: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    timeoutMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowStepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    position?: IntFieldUpdateOperationsInput | number
    configuration?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    timeoutMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowStepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    position?: IntFieldUpdateOperationsInput | number
    configuration?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    timeoutMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowStepApproverCreateInput = {
    id?: string
    approverType: $Enums.ApproverType
    isRequired?: boolean
    order?: number
    createdAt?: Date | string
    step: WorkflowStepCreateNestedOneWithoutApproversInput
    user: UserCreateNestedOneWithoutApproverStepsInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutStepApproverInput
  }

  export type WorkflowStepApproverUncheckedCreateInput = {
    id?: string
    stepId: string
    userId: string
    approverType: $Enums.ApproverType
    isRequired?: boolean
    order?: number
    createdAt?: Date | string
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutStepApproverInput
  }

  export type WorkflowStepApproverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    approverType?: EnumApproverTypeFieldUpdateOperationsInput | $Enums.ApproverType
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    step?: WorkflowStepUpdateOneRequiredWithoutApproversNestedInput
    user?: UserUpdateOneRequiredWithoutApproverStepsNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutStepApproverNestedInput
  }

  export type WorkflowStepApproverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    approverType?: EnumApproverTypeFieldUpdateOperationsInput | $Enums.ApproverType
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutStepApproverNestedInput
  }

  export type WorkflowStepApproverCreateManyInput = {
    id?: string
    stepId: string
    userId: string
    approverType: $Enums.ApproverType
    isRequired?: boolean
    order?: number
    createdAt?: Date | string
  }

  export type WorkflowStepApproverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    approverType?: EnumApproverTypeFieldUpdateOperationsInput | $Enums.ApproverType
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowStepApproverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    approverType?: EnumApproverTypeFieldUpdateOperationsInput | $Enums.ApproverType
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowInstanceCreateInput = {
    id?: string
    entityType: string
    entityId: string
    status: $Enums.WorkflowStatus
    currentStepId?: string | null
    priority?: $Enums.Priority
    startedAt?: Date | string
    completedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    workflow: WorkflowDefinitionCreateNestedOneWithoutInstancesInput
    account: AccountCreateNestedOneWithoutWorkflowInstancesInput
    initiatedBy: UserCreateNestedOneWithoutInitiatedWorkflowsInput
    executions?: WorkflowStepExecutionCreateNestedManyWithoutInstanceInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutInstanceInput
  }

  export type WorkflowInstanceUncheckedCreateInput = {
    id?: string
    workflowId: string
    entityType: string
    entityId: string
    status: $Enums.WorkflowStatus
    currentStepId?: string | null
    priority?: $Enums.Priority
    startedAt?: Date | string
    completedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId: string
    initiatedById: string
    executions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutInstanceInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type WorkflowInstanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    workflow?: WorkflowDefinitionUpdateOneRequiredWithoutInstancesNestedInput
    account?: AccountUpdateOneRequiredWithoutWorkflowInstancesNestedInput
    initiatedBy?: UserUpdateOneRequiredWithoutInitiatedWorkflowsNestedInput
    executions?: WorkflowStepExecutionUpdateManyWithoutInstanceNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutInstanceNestedInput
  }

  export type WorkflowInstanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId?: StringFieldUpdateOperationsInput | string
    initiatedById?: StringFieldUpdateOperationsInput | string
    executions?: WorkflowStepExecutionUncheckedUpdateManyWithoutInstanceNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type WorkflowInstanceCreateManyInput = {
    id?: string
    workflowId: string
    entityType: string
    entityId: string
    status: $Enums.WorkflowStatus
    currentStepId?: string | null
    priority?: $Enums.Priority
    startedAt?: Date | string
    completedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId: string
    initiatedById: string
  }

  export type WorkflowInstanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WorkflowInstanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId?: StringFieldUpdateOperationsInput | string
    initiatedById?: StringFieldUpdateOperationsInput | string
  }

  export type WorkflowStepExecutionCreateInput = {
    id?: string
    status: $Enums.WorkflowStepStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    retryCount?: number
    isManual?: boolean
    instance: WorkflowInstanceCreateNestedOneWithoutExecutionsInput
    step: WorkflowStepCreateNestedOneWithoutExecutionsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedStepsInput
  }

  export type WorkflowStepExecutionUncheckedCreateInput = {
    id?: string
    instanceId: string
    stepId: string
    status: $Enums.WorkflowStepStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    assignedToId?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    retryCount?: number
    isManual?: boolean
  }

  export type WorkflowStepExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStepStatusFieldUpdateOperationsInput | $Enums.WorkflowStepStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    isManual?: BoolFieldUpdateOperationsInput | boolean
    instance?: WorkflowInstanceUpdateOneRequiredWithoutExecutionsNestedInput
    step?: WorkflowStepUpdateOneRequiredWithoutExecutionsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedStepsNestedInput
  }

  export type WorkflowStepExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStepStatusFieldUpdateOperationsInput | $Enums.WorkflowStepStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    isManual?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkflowStepExecutionCreateManyInput = {
    id?: string
    instanceId: string
    stepId: string
    status: $Enums.WorkflowStepStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    assignedToId?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    retryCount?: number
    isManual?: boolean
  }

  export type WorkflowStepExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStepStatusFieldUpdateOperationsInput | $Enums.WorkflowStepStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    isManual?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkflowStepExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStepStatusFieldUpdateOperationsInput | $Enums.WorkflowStepStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    isManual?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkflowApprovalCreateInput = {
    id?: string
    status: $Enums.ApprovalStatus
    comments?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestedAt?: Date | string
    remindersSent?: number
    lastReminderAt?: Date | string | null
    instance: WorkflowInstanceCreateNestedOneWithoutApprovalsInput
    approver: UserCreateNestedOneWithoutApprovalsInput
    stepApprover: WorkflowStepApproverCreateNestedOneWithoutApprovalsInput
  }

  export type WorkflowApprovalUncheckedCreateInput = {
    id?: string
    instanceId: string
    approverId: string
    stepApproverId: string
    status: $Enums.ApprovalStatus
    comments?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestedAt?: Date | string
    remindersSent?: number
    lastReminderAt?: Date | string | null
  }

  export type WorkflowApprovalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remindersSent?: IntFieldUpdateOperationsInput | number
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: WorkflowInstanceUpdateOneRequiredWithoutApprovalsNestedInput
    approver?: UserUpdateOneRequiredWithoutApprovalsNestedInput
    stepApprover?: WorkflowStepApproverUpdateOneRequiredWithoutApprovalsNestedInput
  }

  export type WorkflowApprovalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    stepApproverId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remindersSent?: IntFieldUpdateOperationsInput | number
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkflowApprovalCreateManyInput = {
    id?: string
    instanceId: string
    approverId: string
    stepApproverId: string
    status: $Enums.ApprovalStatus
    comments?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestedAt?: Date | string
    remindersSent?: number
    lastReminderAt?: Date | string | null
  }

  export type WorkflowApprovalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remindersSent?: IntFieldUpdateOperationsInput | number
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkflowApprovalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    stepApproverId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remindersSent?: IntFieldUpdateOperationsInput | number
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkflowTemplateCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    industry?: string
    templateData: JsonNullValueInput | InputJsonValue
    isPublic?: boolean
    usageCount?: number
    rating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account?: AccountCreateNestedOneWithoutWorkflowTemplatesInput
    createdBy: UserCreateNestedOneWithoutCreatedTemplatesInput
    workflow?: WorkflowDefinitionCreateNestedOneWithoutTemplatesInput
  }

  export type WorkflowTemplateUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    industry?: string
    templateData: JsonNullValueInput | InputJsonValue
    isPublic?: boolean
    usageCount?: number
    rating?: number | null
    accountId?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workflowId?: string | null
  }

  export type WorkflowTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    templateData?: JsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutWorkflowTemplatesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTemplatesNestedInput
    workflow?: WorkflowDefinitionUpdateOneWithoutTemplatesNestedInput
  }

  export type WorkflowTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    templateData?: JsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkflowTemplateCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    industry?: string
    templateData: JsonNullValueInput | InputJsonValue
    isPublic?: boolean
    usageCount?: number
    rating?: number | null
    accountId?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workflowId?: string | null
  }

  export type WorkflowTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    templateData?: JsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    templateData?: JsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AutomationRuleCreateInput = {
    id?: string
    name: string
    description?: string | null
    triggerEvent: string
    conditions: JsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    priority?: number
    executionCount?: number
    lastExecutedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutAutomationRulesInput
    createdBy: UserCreateNestedOneWithoutCreatedRulesInput
    executions?: AutomationExecutionCreateNestedManyWithoutRuleInput
  }

  export type AutomationRuleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    triggerEvent: string
    conditions: JsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    priority?: number
    executionCount?: number
    lastExecutedAt?: Date | string | null
    accountId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: AutomationExecutionUncheckedCreateNestedManyWithoutRuleInput
  }

  export type AutomationRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerEvent?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    executionCount?: IntFieldUpdateOperationsInput | number
    lastExecutedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutAutomationRulesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedRulesNestedInput
    executions?: AutomationExecutionUpdateManyWithoutRuleNestedInput
  }

  export type AutomationRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerEvent?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    executionCount?: IntFieldUpdateOperationsInput | number
    lastExecutedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: AutomationExecutionUncheckedUpdateManyWithoutRuleNestedInput
  }

  export type AutomationRuleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    triggerEvent: string
    conditions: JsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    priority?: number
    executionCount?: number
    lastExecutedAt?: Date | string | null
    accountId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerEvent?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    executionCount?: IntFieldUpdateOperationsInput | number
    lastExecutedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerEvent?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    executionCount?: IntFieldUpdateOperationsInput | number
    lastExecutedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationExecutionCreateInput = {
    id?: string
    triggerData: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.AutomationStatus
    errorMessage?: string | null
    executedAt?: Date | string
    durationMs?: number | null
    rule: AutomationRuleCreateNestedOneWithoutExecutionsInput
  }

  export type AutomationExecutionUncheckedCreateInput = {
    id?: string
    ruleId: string
    triggerData: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.AutomationStatus
    errorMessage?: string | null
    executedAt?: Date | string
    durationMs?: number | null
  }

  export type AutomationExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    triggerData?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    rule?: AutomationRuleUpdateOneRequiredWithoutExecutionsNestedInput
  }

  export type AutomationExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    triggerData?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AutomationExecutionCreateManyInput = {
    id?: string
    ruleId: string
    triggerData: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.AutomationStatus
    errorMessage?: string | null
    executedAt?: Date | string
    durationMs?: number | null
  }

  export type AutomationExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    triggerData?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AutomationExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    triggerData?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TestPlanCreateInput = {
    id?: string
    name: string
    description?: string | null
    version?: string
    status?: $Enums.TestPlanStatus
    projectId?: string | null
    feature?: string | null
    environment?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTestPlansInput
    assignedTo?: UserCreateNestedOneWithoutAssignedTestPlansInput
    testCases?: TestCaseCreateNestedManyWithoutTestPlanInput
    executions?: TestExecutionCreateNestedManyWithoutTestPlanInput
    reviews?: QAReviewCreateNestedManyWithoutTestPlanInput
  }

  export type TestPlanUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    version?: string
    status?: $Enums.TestPlanStatus
    projectId?: string | null
    feature?: string | null
    environment?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testCases?: TestCaseUncheckedCreateNestedManyWithoutTestPlanInput
    executions?: TestExecutionUncheckedCreateNestedManyWithoutTestPlanInput
    reviews?: QAReviewUncheckedCreateNestedManyWithoutTestPlanInput
  }

  export type TestPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumTestPlanStatusFieldUpdateOperationsInput | $Enums.TestPlanStatus
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTestPlansNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedTestPlansNestedInput
    testCases?: TestCaseUpdateManyWithoutTestPlanNestedInput
    executions?: TestExecutionUpdateManyWithoutTestPlanNestedInput
    reviews?: QAReviewUpdateManyWithoutTestPlanNestedInput
  }

  export type TestPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumTestPlanStatusFieldUpdateOperationsInput | $Enums.TestPlanStatus
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testCases?: TestCaseUncheckedUpdateManyWithoutTestPlanNestedInput
    executions?: TestExecutionUncheckedUpdateManyWithoutTestPlanNestedInput
    reviews?: QAReviewUncheckedUpdateManyWithoutTestPlanNestedInput
  }

  export type TestPlanCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    version?: string
    status?: $Enums.TestPlanStatus
    projectId?: string | null
    feature?: string | null
    environment?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumTestPlanStatusFieldUpdateOperationsInput | $Enums.TestPlanStatus
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumTestPlanStatusFieldUpdateOperationsInput | $Enums.TestPlanStatus
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestCaseCreateInput = {
    id?: string
    title: string
    description?: string | null
    preconditions?: string | null
    steps: JsonNullValueInput | InputJsonValue
    expectedResult?: string | null
    priority?: $Enums.TestCasePriority
    status?: $Enums.TestCaseStatus
    tags?: TestCaseCreatetagsInput | string[]
    automatable?: boolean
    estimatedTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testPlan: TestPlanCreateNestedOneWithoutTestCasesInput
    createdBy: UserCreateNestedOneWithoutCreatedTestCasesInput
    executions?: TestExecutionCreateNestedManyWithoutTestCaseInput
    defects?: DefectTestCaseCreateNestedManyWithoutTestCaseInput
  }

  export type TestCaseUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    preconditions?: string | null
    steps: JsonNullValueInput | InputJsonValue
    expectedResult?: string | null
    priority?: $Enums.TestCasePriority
    status?: $Enums.TestCaseStatus
    tags?: TestCaseCreatetagsInput | string[]
    automatable?: boolean
    estimatedTime?: number | null
    testPlanId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: TestExecutionUncheckedCreateNestedManyWithoutTestCaseInput
    defects?: DefectTestCaseUncheckedCreateNestedManyWithoutTestCaseInput
  }

  export type TestCaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    steps?: JsonNullValueInput | InputJsonValue
    expectedResult?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTestCasePriorityFieldUpdateOperationsInput | $Enums.TestCasePriority
    status?: EnumTestCaseStatusFieldUpdateOperationsInput | $Enums.TestCaseStatus
    tags?: TestCaseUpdatetagsInput | string[]
    automatable?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testPlan?: TestPlanUpdateOneRequiredWithoutTestCasesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTestCasesNestedInput
    executions?: TestExecutionUpdateManyWithoutTestCaseNestedInput
    defects?: DefectTestCaseUpdateManyWithoutTestCaseNestedInput
  }

  export type TestCaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    steps?: JsonNullValueInput | InputJsonValue
    expectedResult?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTestCasePriorityFieldUpdateOperationsInput | $Enums.TestCasePriority
    status?: EnumTestCaseStatusFieldUpdateOperationsInput | $Enums.TestCaseStatus
    tags?: TestCaseUpdatetagsInput | string[]
    automatable?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: NullableIntFieldUpdateOperationsInput | number | null
    testPlanId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: TestExecutionUncheckedUpdateManyWithoutTestCaseNestedInput
    defects?: DefectTestCaseUncheckedUpdateManyWithoutTestCaseNestedInput
  }

  export type TestCaseCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    preconditions?: string | null
    steps: JsonNullValueInput | InputJsonValue
    expectedResult?: string | null
    priority?: $Enums.TestCasePriority
    status?: $Enums.TestCaseStatus
    tags?: TestCaseCreatetagsInput | string[]
    automatable?: boolean
    estimatedTime?: number | null
    testPlanId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestCaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    steps?: JsonNullValueInput | InputJsonValue
    expectedResult?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTestCasePriorityFieldUpdateOperationsInput | $Enums.TestCasePriority
    status?: EnumTestCaseStatusFieldUpdateOperationsInput | $Enums.TestCaseStatus
    tags?: TestCaseUpdatetagsInput | string[]
    automatable?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestCaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    steps?: JsonNullValueInput | InputJsonValue
    expectedResult?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTestCasePriorityFieldUpdateOperationsInput | $Enums.TestCasePriority
    status?: EnumTestCaseStatusFieldUpdateOperationsInput | $Enums.TestCaseStatus
    tags?: TestCaseUpdatetagsInput | string[]
    automatable?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: NullableIntFieldUpdateOperationsInput | number | null
    testPlanId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestExecutionCreateInput = {
    id?: string
    status?: $Enums.TestExecutionStatus
    result?: string | null
    actualResult?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: number | null
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    notes?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testPlan: TestPlanCreateNestedOneWithoutExecutionsInput
    testCase: TestCaseCreateNestedOneWithoutExecutionsInput
    executedBy: UserCreateNestedOneWithoutTestExecutionsInput
    defects?: DefectCreateNestedManyWithoutTestExecutionInput
  }

  export type TestExecutionUncheckedCreateInput = {
    id?: string
    testPlanId: string
    testCaseId: string
    status?: $Enums.TestExecutionStatus
    result?: string | null
    actualResult?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: number | null
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    notes?: string | null
    executedById: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defects?: DefectUncheckedCreateNestedManyWithoutTestExecutionInput
  }

  export type TestExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTestExecutionStatusFieldUpdateOperationsInput | $Enums.TestExecutionStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    actualResult?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testPlan?: TestPlanUpdateOneRequiredWithoutExecutionsNestedInput
    testCase?: TestCaseUpdateOneRequiredWithoutExecutionsNestedInput
    executedBy?: UserUpdateOneRequiredWithoutTestExecutionsNestedInput
    defects?: DefectUpdateManyWithoutTestExecutionNestedInput
  }

  export type TestExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    testPlanId?: StringFieldUpdateOperationsInput | string
    testCaseId?: StringFieldUpdateOperationsInput | string
    status?: EnumTestExecutionStatusFieldUpdateOperationsInput | $Enums.TestExecutionStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    actualResult?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    executedById?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defects?: DefectUncheckedUpdateManyWithoutTestExecutionNestedInput
  }

  export type TestExecutionCreateManyInput = {
    id?: string
    testPlanId: string
    testCaseId: string
    status?: $Enums.TestExecutionStatus
    result?: string | null
    actualResult?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: number | null
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    notes?: string | null
    executedById: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTestExecutionStatusFieldUpdateOperationsInput | $Enums.TestExecutionStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    actualResult?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    testPlanId?: StringFieldUpdateOperationsInput | string
    testCaseId?: StringFieldUpdateOperationsInput | string
    status?: EnumTestExecutionStatusFieldUpdateOperationsInput | $Enums.TestExecutionStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    actualResult?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    executedById?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectCreateInput = {
    id?: string
    title: string
    description: string
    steps?: string | null
    expectedBehavior?: string | null
    actualBehavior?: string | null
    severity?: $Enums.DefectSeverity
    priority?: $Enums.DefectPriority
    status?: $Enums.DefectStatus
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: boolean
    regression?: boolean
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testExecution?: TestExecutionCreateNestedOneWithoutDefectsInput
    reportedBy: UserCreateNestedOneWithoutReportedDefectsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedDefectsInput
    testCases?: DefectTestCaseCreateNestedManyWithoutDefectInput
    comments?: DefectCommentCreateNestedManyWithoutDefectInput
  }

  export type DefectUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    steps?: string | null
    expectedBehavior?: string | null
    actualBehavior?: string | null
    severity?: $Enums.DefectSeverity
    priority?: $Enums.DefectPriority
    status?: $Enums.DefectStatus
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: boolean
    regression?: boolean
    testExecutionId?: string | null
    reportedById: string
    assignedToId?: string | null
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testCases?: DefectTestCaseUncheckedCreateNestedManyWithoutDefectInput
    comments?: DefectCommentUncheckedCreateNestedManyWithoutDefectInput
  }

  export type DefectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    expectedBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    actualBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    priority?: EnumDefectPriorityFieldUpdateOperationsInput | $Enums.DefectPriority
    status?: EnumDefectStatusFieldUpdateOperationsInput | $Enums.DefectStatus
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: BoolFieldUpdateOperationsInput | boolean
    regression?: BoolFieldUpdateOperationsInput | boolean
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testExecution?: TestExecutionUpdateOneWithoutDefectsNestedInput
    reportedBy?: UserUpdateOneRequiredWithoutReportedDefectsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedDefectsNestedInput
    testCases?: DefectTestCaseUpdateManyWithoutDefectNestedInput
    comments?: DefectCommentUpdateManyWithoutDefectNestedInput
  }

  export type DefectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    expectedBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    actualBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    priority?: EnumDefectPriorityFieldUpdateOperationsInput | $Enums.DefectPriority
    status?: EnumDefectStatusFieldUpdateOperationsInput | $Enums.DefectStatus
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: BoolFieldUpdateOperationsInput | boolean
    regression?: BoolFieldUpdateOperationsInput | boolean
    testExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedById?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testCases?: DefectTestCaseUncheckedUpdateManyWithoutDefectNestedInput
    comments?: DefectCommentUncheckedUpdateManyWithoutDefectNestedInput
  }

  export type DefectCreateManyInput = {
    id?: string
    title: string
    description: string
    steps?: string | null
    expectedBehavior?: string | null
    actualBehavior?: string | null
    severity?: $Enums.DefectSeverity
    priority?: $Enums.DefectPriority
    status?: $Enums.DefectStatus
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: boolean
    regression?: boolean
    testExecutionId?: string | null
    reportedById: string
    assignedToId?: string | null
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DefectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    expectedBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    actualBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    priority?: EnumDefectPriorityFieldUpdateOperationsInput | $Enums.DefectPriority
    status?: EnumDefectStatusFieldUpdateOperationsInput | $Enums.DefectStatus
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: BoolFieldUpdateOperationsInput | boolean
    regression?: BoolFieldUpdateOperationsInput | boolean
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    expectedBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    actualBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    priority?: EnumDefectPriorityFieldUpdateOperationsInput | $Enums.DefectPriority
    status?: EnumDefectStatusFieldUpdateOperationsInput | $Enums.DefectStatus
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: BoolFieldUpdateOperationsInput | boolean
    regression?: BoolFieldUpdateOperationsInput | boolean
    testExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedById?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectTestCaseCreateInput = {
    id?: string
    createdAt?: Date | string
    defect: DefectCreateNestedOneWithoutTestCasesInput
    testCase: TestCaseCreateNestedOneWithoutDefectsInput
  }

  export type DefectTestCaseUncheckedCreateInput = {
    id?: string
    defectId: string
    testCaseId: string
    createdAt?: Date | string
  }

  export type DefectTestCaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defect?: DefectUpdateOneRequiredWithoutTestCasesNestedInput
    testCase?: TestCaseUpdateOneRequiredWithoutDefectsNestedInput
  }

  export type DefectTestCaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    defectId?: StringFieldUpdateOperationsInput | string
    testCaseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectTestCaseCreateManyInput = {
    id?: string
    defectId: string
    testCaseId: string
    createdAt?: Date | string
  }

  export type DefectTestCaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectTestCaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    defectId?: StringFieldUpdateOperationsInput | string
    testCaseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectCommentCreateInput = {
    id?: string
    content: string
    authorId: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    defect: DefectCreateNestedOneWithoutCommentsInput
  }

  export type DefectCommentUncheckedCreateInput = {
    id?: string
    content: string
    defectId: string
    authorId: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DefectCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defect?: DefectUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type DefectCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    defectId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectCommentCreateManyInput = {
    id?: string
    content: string
    defectId: string
    authorId: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DefectCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    defectId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QAReviewCreateInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    entityId: string
    status?: $Enums.QAReviewStatus
    criteria?: NullableJsonNullValueInput | InputJsonValue
    findings?: string | null
    recommendations?: string | null
    approved?: boolean | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testPlan?: TestPlanCreateNestedOneWithoutReviewsInput
    reviewer: UserCreateNestedOneWithoutQaReviewsInput
  }

  export type QAReviewUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    entityId: string
    status?: $Enums.QAReviewStatus
    criteria?: NullableJsonNullValueInput | InputJsonValue
    findings?: string | null
    recommendations?: string | null
    approved?: boolean | null
    testPlanId?: string | null
    reviewerId: string
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QAReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumQAReviewStatusFieldUpdateOperationsInput | $Enums.QAReviewStatus
    criteria?: NullableJsonNullValueInput | InputJsonValue
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testPlan?: TestPlanUpdateOneWithoutReviewsNestedInput
    reviewer?: UserUpdateOneRequiredWithoutQaReviewsNestedInput
  }

  export type QAReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumQAReviewStatusFieldUpdateOperationsInput | $Enums.QAReviewStatus
    criteria?: NullableJsonNullValueInput | InputJsonValue
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    testPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerId?: StringFieldUpdateOperationsInput | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QAReviewCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    entityId: string
    status?: $Enums.QAReviewStatus
    criteria?: NullableJsonNullValueInput | InputJsonValue
    findings?: string | null
    recommendations?: string | null
    approved?: boolean | null
    testPlanId?: string | null
    reviewerId: string
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QAReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumQAReviewStatusFieldUpdateOperationsInput | $Enums.QAReviewStatus
    criteria?: NullableJsonNullValueInput | InputJsonValue
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QAReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumQAReviewStatusFieldUpdateOperationsInput | $Enums.QAReviewStatus
    criteria?: NullableJsonNullValueInput | InputJsonValue
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    testPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerId?: StringFieldUpdateOperationsInput | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type CompletedProjectListRelationFilter = {
    every?: CompletedProjectWhereInput
    some?: CompletedProjectWhereInput
    none?: CompletedProjectWhereInput
  }

  export type EnquiryListRelationFilter = {
    every?: EnquiryWhereInput
    some?: EnquiryWhereInput
    none?: EnquiryWhereInput
  }

  export type LeadListRelationFilter = {
    every?: LeadWhereInput
    some?: LeadWhereInput
    none?: LeadWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type WorkflowDefinitionListRelationFilter = {
    every?: WorkflowDefinitionWhereInput
    some?: WorkflowDefinitionWhereInput
    none?: WorkflowDefinitionWhereInput
  }

  export type WorkflowInstanceListRelationFilter = {
    every?: WorkflowInstanceWhereInput
    some?: WorkflowInstanceWhereInput
    none?: WorkflowInstanceWhereInput
  }

  export type WorkflowStepExecutionListRelationFilter = {
    every?: WorkflowStepExecutionWhereInput
    some?: WorkflowStepExecutionWhereInput
    none?: WorkflowStepExecutionWhereInput
  }

  export type WorkflowStepApproverListRelationFilter = {
    every?: WorkflowStepApproverWhereInput
    some?: WorkflowStepApproverWhereInput
    none?: WorkflowStepApproverWhereInput
  }

  export type WorkflowApprovalListRelationFilter = {
    every?: WorkflowApprovalWhereInput
    some?: WorkflowApprovalWhereInput
    none?: WorkflowApprovalWhereInput
  }

  export type WorkflowTemplateListRelationFilter = {
    every?: WorkflowTemplateWhereInput
    some?: WorkflowTemplateWhereInput
    none?: WorkflowTemplateWhereInput
  }

  export type AutomationRuleListRelationFilter = {
    every?: AutomationRuleWhereInput
    some?: AutomationRuleWhereInput
    none?: AutomationRuleWhereInput
  }

  export type TestPlanListRelationFilter = {
    every?: TestPlanWhereInput
    some?: TestPlanWhereInput
    none?: TestPlanWhereInput
  }

  export type TestCaseListRelationFilter = {
    every?: TestCaseWhereInput
    some?: TestCaseWhereInput
    none?: TestCaseWhereInput
  }

  export type TestExecutionListRelationFilter = {
    every?: TestExecutionWhereInput
    some?: TestExecutionWhereInput
    none?: TestExecutionWhereInput
  }

  export type DefectListRelationFilter = {
    every?: DefectWhereInput
    some?: DefectWhereInput
    none?: DefectWhereInput
  }

  export type QAReviewListRelationFilter = {
    every?: QAReviewWhereInput
    some?: QAReviewWhereInput
    none?: QAReviewWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompletedProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnquiryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowDefinitionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowInstanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowStepExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowStepApproverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowApprovalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutomationRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestCaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DefectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QAReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    emailVerifiedAt?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorEnabled?: SortOrder
    avatarUrl?: SortOrder
    timezone?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    emailVerifiedAt?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorEnabled?: SortOrder
    avatarUrl?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    emailVerifiedAt?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorEnabled?: SortOrder
    avatarUrl?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusFilter<$PrismaModel> | $Enums.AccountStatus
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type EventLogListRelationFilter = {
    every?: EventLogWhereInput
    some?: EventLogWhereInput
    none?: EventLogWhereInput
  }

  export type SnagListRelationFilter = {
    every?: SnagWhereInput
    some?: SnagWhereInput
    none?: SnagWhereInput
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SnagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    emails?: SortOrder
    phones?: SortOrder
    billingAddress?: SortOrder
    siteAddresses?: SortOrder
    ownerId?: SortOrder
    tags?: SortOrder
    status?: SortOrder
    portalToken?: SortOrder
    designFeePaid?: SortOrder
    consentMarketing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    ownerId?: SortOrder
    status?: SortOrder
    portalToken?: SortOrder
    designFeePaid?: SortOrder
    consentMarketing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    ownerId?: SortOrder
    status?: SortOrder
    portalToken?: SortOrder
    designFeePaid?: SortOrder
    consentMarketing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountStatusFilter<$PrismaModel>
  }

  export type EnumEnquiryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EnquiryStatus | EnumEnquiryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnquiryStatus[] | ListEnumEnquiryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnquiryStatus[] | ListEnumEnquiryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnquiryStatusFilter<$PrismaModel> | $Enums.EnquiryStatus
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type AccountNullableRelationFilter = {
    is?: AccountWhereInput | null
    isNot?: AccountWhereInput | null
  }

  export type LeadNullableRelationFilter = {
    is?: LeadWhereInput | null
    isNot?: LeadWhereInput | null
  }

  export type EnquiryCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    source?: SortOrder
    campaign?: SortOrder
    medium?: SortOrder
    estimatedValue?: SortOrder
    contactMethod?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    mobile?: SortOrder
    company?: SortOrder
    message?: SortOrder
    accountId?: SortOrder
    ownerId?: SortOrder
    leadId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type EnquiryAvgOrderByAggregateInput = {
    estimatedValue?: SortOrder
  }

  export type EnquiryMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    source?: SortOrder
    campaign?: SortOrder
    medium?: SortOrder
    estimatedValue?: SortOrder
    contactMethod?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    mobile?: SortOrder
    company?: SortOrder
    message?: SortOrder
    accountId?: SortOrder
    ownerId?: SortOrder
    leadId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type EnquiryMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    source?: SortOrder
    campaign?: SortOrder
    medium?: SortOrder
    estimatedValue?: SortOrder
    contactMethod?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    mobile?: SortOrder
    company?: SortOrder
    message?: SortOrder
    accountId?: SortOrder
    ownerId?: SortOrder
    leadId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type EnquirySumOrderByAggregateInput = {
    estimatedValue?: SortOrder
  }

  export type EnumEnquiryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnquiryStatus | EnumEnquiryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnquiryStatus[] | ListEnumEnquiryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnquiryStatus[] | ListEnumEnquiryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnquiryStatusWithAggregatesFilter<$PrismaModel> | $Enums.EnquiryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnquiryStatusFilter<$PrismaModel>
    _max?: NestedEnumEnquiryStatusFilter<$PrismaModel>
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type AccountRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnquiryNullableRelationFilter = {
    is?: EnquiryWhereInput | null
    isNot?: EnquiryWhereInput | null
  }

  export type ProjectNullableRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type LeadCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    estimatedValue?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrder
    source?: SortOrder
    campaign?: SortOrder
    medium?: SortOrder
    firstResponseAt?: SortOrder
    responseTime?: SortOrder
    accountId?: SortOrder
    ownerId?: SortOrder
    enquiryId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type LeadAvgOrderByAggregateInput = {
    estimatedValue?: SortOrder
    probability?: SortOrder
    responseTime?: SortOrder
  }

  export type LeadMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    estimatedValue?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrder
    source?: SortOrder
    campaign?: SortOrder
    medium?: SortOrder
    firstResponseAt?: SortOrder
    responseTime?: SortOrder
    accountId?: SortOrder
    ownerId?: SortOrder
    enquiryId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type LeadMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    estimatedValue?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrder
    source?: SortOrder
    campaign?: SortOrder
    medium?: SortOrder
    firstResponseAt?: SortOrder
    responseTime?: SortOrder
    accountId?: SortOrder
    ownerId?: SortOrder
    enquiryId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type LeadSumOrderByAggregateInput = {
    estimatedValue?: SortOrder
    probability?: SortOrder
    responseTime?: SortOrder
  }

  export type EnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumProjectTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectType | EnumProjectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectType[] | ListEnumProjectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectType[] | ListEnumProjectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectTypeFilter<$PrismaModel> | $Enums.ProjectType
  }

  export type EnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type CompletedProjectNullableRelationFilter = {
    is?: CompletedProjectWhereInput | null
    isNot?: CompletedProjectWhereInput | null
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    accountId?: SortOrder
    ownerId?: SortOrder
    amountGrossIncVat?: SortOrder
    vatRate?: SortOrder
    probability?: SortOrder
    source?: SortOrder
    utm?: SortOrder
    leadId?: SortOrder
    completedProjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    amountGrossIncVat?: SortOrder
    vatRate?: SortOrder
    probability?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    accountId?: SortOrder
    ownerId?: SortOrder
    amountGrossIncVat?: SortOrder
    vatRate?: SortOrder
    probability?: SortOrder
    source?: SortOrder
    leadId?: SortOrder
    completedProjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    accountId?: SortOrder
    ownerId?: SortOrder
    amountGrossIncVat?: SortOrder
    vatRate?: SortOrder
    probability?: SortOrder
    source?: SortOrder
    leadId?: SortOrder
    completedProjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    amountGrossIncVat?: SortOrder
    vatRate?: SortOrder
    probability?: SortOrder
  }

  export type EnumProjectTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectType | EnumProjectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectType[] | ListEnumProjectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectType[] | ListEnumProjectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProjectType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectTypeFilter<$PrismaModel>
    _max?: NestedEnumProjectTypeFilter<$PrismaModel>
  }

  export type EnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumCompletedProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CompletedProjectStatus | EnumCompletedProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CompletedProjectStatus[] | ListEnumCompletedProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompletedProjectStatus[] | ListEnumCompletedProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCompletedProjectStatusFilter<$PrismaModel> | $Enums.CompletedProjectStatus
  }

  export type CompletedProjectCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    projectId?: SortOrder
    ownerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompletedProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    projectId?: SortOrder
    ownerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompletedProjectMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    projectId?: SortOrder
    ownerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCompletedProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompletedProjectStatus | EnumCompletedProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CompletedProjectStatus[] | ListEnumCompletedProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompletedProjectStatus[] | ListEnumCompletedProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCompletedProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.CompletedProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompletedProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumCompletedProjectStatusFilter<$PrismaModel>
  }

  export type EnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    enquiryId?: SortOrder
    leadId?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    threadKey?: SortOrder
    summary?: SortOrder
    body?: SortOrder
    attachments?: SortOrder
    durations?: SortOrder
    metadata?: SortOrder
    occurredAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    enquiryId?: SortOrder
    leadId?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    threadKey?: SortOrder
    summary?: SortOrder
    body?: SortOrder
    occurredAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    enquiryId?: SortOrder
    leadId?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    threadKey?: SortOrder
    summary?: SortOrder
    body?: SortOrder
    occurredAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    assigneeId?: SortOrder
    accountId?: SortOrder
    enquiryId?: SortOrder
    leadId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    assigneeId?: SortOrder
    accountId?: SortOrder
    enquiryId?: SortOrder
    leadId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    assigneeId?: SortOrder
    accountId?: SortOrder
    enquiryId?: SortOrder
    leadId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type EnumAppointmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentType | EnumAppointmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentTypeFilter<$PrismaModel> | $Enums.AppointmentType
  }

  export type EnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAppointmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentType | EnumAppointmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentTypeFilter<$PrismaModel>
    _max?: NestedEnumAppointmentTypeFilter<$PrismaModel>
  }

  export type EnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    projectId?: SortOrder
    filename?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    type?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    projectId?: SortOrder
    filename?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    type?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    projectId?: SortOrder
    filename?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    type?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type EnumSnagStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SnagStatus | EnumSnagStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SnagStatus[] | ListEnumSnagStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SnagStatus[] | ListEnumSnagStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSnagStatusFilter<$PrismaModel> | $Enums.SnagStatus
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type SnagCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assigneeId?: SortOrder
    dueAt?: SortOrder
    photos?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SnagMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assigneeId?: SortOrder
    dueAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SnagMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assigneeId?: SortOrder
    dueAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSnagStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SnagStatus | EnumSnagStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SnagStatus[] | ListEnumSnagStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SnagStatus[] | ListEnumSnagStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSnagStatusWithAggregatesFilter<$PrismaModel> | $Enums.SnagStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSnagStatusFilter<$PrismaModel>
    _max?: NestedEnumSnagStatusFilter<$PrismaModel>
  }

  export type EventLogCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    actorId?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    before?: SortOrder
    after?: SortOrder
    createdAt?: SortOrder
  }

  export type EventLogMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    actorId?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type EventLogMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    actorId?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumWorkflowTriggerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowTriggerType | EnumWorkflowTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowTriggerType[] | ListEnumWorkflowTriggerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowTriggerType[] | ListEnumWorkflowTriggerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowTriggerTypeFilter<$PrismaModel> | $Enums.WorkflowTriggerType
  }

  export type WorkflowStepListRelationFilter = {
    every?: WorkflowStepWhereInput
    some?: WorkflowStepWhereInput
    none?: WorkflowStepWhereInput
  }

  export type WorkflowStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowDefinitionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    triggerType?: SortOrder
    triggerConditions?: SortOrder
    accountId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowDefinitionAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type WorkflowDefinitionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    triggerType?: SortOrder
    accountId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowDefinitionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    triggerType?: SortOrder
    accountId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowDefinitionSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumWorkflowTriggerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowTriggerType | EnumWorkflowTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowTriggerType[] | ListEnumWorkflowTriggerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowTriggerType[] | ListEnumWorkflowTriggerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowTriggerTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowTriggerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowTriggerTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkflowTriggerTypeFilter<$PrismaModel>
  }

  export type EnumWorkflowStepTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStepType | EnumWorkflowStepTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStepType[] | ListEnumWorkflowStepTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStepType[] | ListEnumWorkflowStepTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStepTypeFilter<$PrismaModel> | $Enums.WorkflowStepType
  }

  export type WorkflowDefinitionRelationFilter = {
    is?: WorkflowDefinitionWhereInput
    isNot?: WorkflowDefinitionWhereInput
  }

  export type WorkflowStepCountOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    stepType?: SortOrder
    position?: SortOrder
    configuration?: SortOrder
    conditions?: SortOrder
    isRequired?: SortOrder
    timeoutMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowStepAvgOrderByAggregateInput = {
    position?: SortOrder
    timeoutMinutes?: SortOrder
  }

  export type WorkflowStepMaxOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    stepType?: SortOrder
    position?: SortOrder
    isRequired?: SortOrder
    timeoutMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowStepMinOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    stepType?: SortOrder
    position?: SortOrder
    isRequired?: SortOrder
    timeoutMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowStepSumOrderByAggregateInput = {
    position?: SortOrder
    timeoutMinutes?: SortOrder
  }

  export type EnumWorkflowStepTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStepType | EnumWorkflowStepTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStepType[] | ListEnumWorkflowStepTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStepType[] | ListEnumWorkflowStepTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStepTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowStepType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowStepTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkflowStepTypeFilter<$PrismaModel>
  }

  export type EnumApproverTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ApproverType | EnumApproverTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApproverType[] | ListEnumApproverTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApproverType[] | ListEnumApproverTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApproverTypeFilter<$PrismaModel> | $Enums.ApproverType
  }

  export type WorkflowStepRelationFilter = {
    is?: WorkflowStepWhereInput
    isNot?: WorkflowStepWhereInput
  }

  export type WorkflowStepApproverStepIdUserIdCompoundUniqueInput = {
    stepId: string
    userId: string
  }

  export type WorkflowStepApproverCountOrderByAggregateInput = {
    id?: SortOrder
    stepId?: SortOrder
    userId?: SortOrder
    approverType?: SortOrder
    isRequired?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkflowStepApproverAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type WorkflowStepApproverMaxOrderByAggregateInput = {
    id?: SortOrder
    stepId?: SortOrder
    userId?: SortOrder
    approverType?: SortOrder
    isRequired?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkflowStepApproverMinOrderByAggregateInput = {
    id?: SortOrder
    stepId?: SortOrder
    userId?: SortOrder
    approverType?: SortOrder
    isRequired?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkflowStepApproverSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumApproverTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApproverType | EnumApproverTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApproverType[] | ListEnumApproverTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApproverType[] | ListEnumApproverTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApproverTypeWithAggregatesFilter<$PrismaModel> | $Enums.ApproverType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApproverTypeFilter<$PrismaModel>
    _max?: NestedEnumApproverTypeFilter<$PrismaModel>
  }

  export type EnumWorkflowStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusFilter<$PrismaModel> | $Enums.WorkflowStatus
  }

  export type WorkflowInstanceCountOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    status?: SortOrder
    currentStepId?: SortOrder
    priority?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    metadata?: SortOrder
    accountId?: SortOrder
    initiatedById?: SortOrder
  }

  export type WorkflowInstanceMaxOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    status?: SortOrder
    currentStepId?: SortOrder
    priority?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    accountId?: SortOrder
    initiatedById?: SortOrder
  }

  export type WorkflowInstanceMinOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    status?: SortOrder
    currentStepId?: SortOrder
    priority?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    accountId?: SortOrder
    initiatedById?: SortOrder
  }

  export type EnumWorkflowStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkflowStatusFilter<$PrismaModel>
  }

  export type EnumWorkflowStepStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStepStatus | EnumWorkflowStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStepStatus[] | ListEnumWorkflowStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStepStatus[] | ListEnumWorkflowStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStepStatusFilter<$PrismaModel> | $Enums.WorkflowStepStatus
  }

  export type WorkflowInstanceRelationFilter = {
    is?: WorkflowInstanceWhereInput
    isNot?: WorkflowInstanceWhereInput
  }

  export type WorkflowStepExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    instanceId?: SortOrder
    stepId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    assignedToId?: SortOrder
    result?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    isManual?: SortOrder
  }

  export type WorkflowStepExecutionAvgOrderByAggregateInput = {
    retryCount?: SortOrder
  }

  export type WorkflowStepExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    instanceId?: SortOrder
    stepId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    assignedToId?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    isManual?: SortOrder
  }

  export type WorkflowStepExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    instanceId?: SortOrder
    stepId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    assignedToId?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    isManual?: SortOrder
  }

  export type WorkflowStepExecutionSumOrderByAggregateInput = {
    retryCount?: SortOrder
  }

  export type EnumWorkflowStepStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStepStatus | EnumWorkflowStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStepStatus[] | ListEnumWorkflowStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStepStatus[] | ListEnumWorkflowStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStepStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowStepStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowStepStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkflowStepStatusFilter<$PrismaModel>
  }

  export type EnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type WorkflowStepApproverRelationFilter = {
    is?: WorkflowStepApproverWhereInput
    isNot?: WorkflowStepApproverWhereInput
  }

  export type WorkflowApprovalCountOrderByAggregateInput = {
    id?: SortOrder
    instanceId?: SortOrder
    approverId?: SortOrder
    stepApproverId?: SortOrder
    status?: SortOrder
    comments?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    requestedAt?: SortOrder
    remindersSent?: SortOrder
    lastReminderAt?: SortOrder
  }

  export type WorkflowApprovalAvgOrderByAggregateInput = {
    remindersSent?: SortOrder
  }

  export type WorkflowApprovalMaxOrderByAggregateInput = {
    id?: SortOrder
    instanceId?: SortOrder
    approverId?: SortOrder
    stepApproverId?: SortOrder
    status?: SortOrder
    comments?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    requestedAt?: SortOrder
    remindersSent?: SortOrder
    lastReminderAt?: SortOrder
  }

  export type WorkflowApprovalMinOrderByAggregateInput = {
    id?: SortOrder
    instanceId?: SortOrder
    approverId?: SortOrder
    stepApproverId?: SortOrder
    status?: SortOrder
    comments?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    requestedAt?: SortOrder
    remindersSent?: SortOrder
    lastReminderAt?: SortOrder
  }

  export type WorkflowApprovalSumOrderByAggregateInput = {
    remindersSent?: SortOrder
  }

  export type EnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type WorkflowDefinitionNullableRelationFilter = {
    is?: WorkflowDefinitionWhereInput | null
    isNot?: WorkflowDefinitionWhereInput | null
  }

  export type WorkflowTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    industry?: SortOrder
    templateData?: SortOrder
    isPublic?: SortOrder
    usageCount?: SortOrder
    rating?: SortOrder
    accountId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workflowId?: SortOrder
  }

  export type WorkflowTemplateAvgOrderByAggregateInput = {
    usageCount?: SortOrder
    rating?: SortOrder
  }

  export type WorkflowTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    industry?: SortOrder
    isPublic?: SortOrder
    usageCount?: SortOrder
    rating?: SortOrder
    accountId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workflowId?: SortOrder
  }

  export type WorkflowTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    industry?: SortOrder
    isPublic?: SortOrder
    usageCount?: SortOrder
    rating?: SortOrder
    accountId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workflowId?: SortOrder
  }

  export type WorkflowTemplateSumOrderByAggregateInput = {
    usageCount?: SortOrder
    rating?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type AutomationExecutionListRelationFilter = {
    every?: AutomationExecutionWhereInput
    some?: AutomationExecutionWhereInput
    none?: AutomationExecutionWhereInput
  }

  export type AutomationExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutomationRuleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    triggerEvent?: SortOrder
    conditions?: SortOrder
    actions?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    executionCount?: SortOrder
    lastExecutedAt?: SortOrder
    accountId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutomationRuleAvgOrderByAggregateInput = {
    priority?: SortOrder
    executionCount?: SortOrder
  }

  export type AutomationRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    triggerEvent?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    executionCount?: SortOrder
    lastExecutedAt?: SortOrder
    accountId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutomationRuleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    triggerEvent?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    executionCount?: SortOrder
    lastExecutedAt?: SortOrder
    accountId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutomationRuleSumOrderByAggregateInput = {
    priority?: SortOrder
    executionCount?: SortOrder
  }

  export type EnumAutomationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationStatus | EnumAutomationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationStatusFilter<$PrismaModel> | $Enums.AutomationStatus
  }

  export type AutomationRuleRelationFilter = {
    is?: AutomationRuleWhereInput
    isNot?: AutomationRuleWhereInput
  }

  export type AutomationExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    ruleId?: SortOrder
    triggerData?: SortOrder
    result?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    executedAt?: SortOrder
    durationMs?: SortOrder
  }

  export type AutomationExecutionAvgOrderByAggregateInput = {
    durationMs?: SortOrder
  }

  export type AutomationExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    ruleId?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    executedAt?: SortOrder
    durationMs?: SortOrder
  }

  export type AutomationExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    ruleId?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    executedAt?: SortOrder
    durationMs?: SortOrder
  }

  export type AutomationExecutionSumOrderByAggregateInput = {
    durationMs?: SortOrder
  }

  export type EnumAutomationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationStatus | EnumAutomationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationStatusWithAggregatesFilter<$PrismaModel> | $Enums.AutomationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutomationStatusFilter<$PrismaModel>
    _max?: NestedEnumAutomationStatusFilter<$PrismaModel>
  }

  export type EnumTestPlanStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TestPlanStatus | EnumTestPlanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TestPlanStatus[] | ListEnumTestPlanStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestPlanStatus[] | ListEnumTestPlanStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTestPlanStatusFilter<$PrismaModel> | $Enums.TestPlanStatus
  }

  export type TestPlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    feature?: SortOrder
    environment?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdById?: SortOrder
    assignedToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    feature?: SortOrder
    environment?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdById?: SortOrder
    assignedToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestPlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    feature?: SortOrder
    environment?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdById?: SortOrder
    assignedToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTestPlanStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TestPlanStatus | EnumTestPlanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TestPlanStatus[] | ListEnumTestPlanStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestPlanStatus[] | ListEnumTestPlanStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTestPlanStatusWithAggregatesFilter<$PrismaModel> | $Enums.TestPlanStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTestPlanStatusFilter<$PrismaModel>
    _max?: NestedEnumTestPlanStatusFilter<$PrismaModel>
  }

  export type EnumTestCasePriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TestCasePriority | EnumTestCasePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TestCasePriority[] | ListEnumTestCasePriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestCasePriority[] | ListEnumTestCasePriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTestCasePriorityFilter<$PrismaModel> | $Enums.TestCasePriority
  }

  export type EnumTestCaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TestCaseStatus | EnumTestCaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TestCaseStatus[] | ListEnumTestCaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestCaseStatus[] | ListEnumTestCaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTestCaseStatusFilter<$PrismaModel> | $Enums.TestCaseStatus
  }

  export type TestPlanRelationFilter = {
    is?: TestPlanWhereInput
    isNot?: TestPlanWhereInput
  }

  export type DefectTestCaseListRelationFilter = {
    every?: DefectTestCaseWhereInput
    some?: DefectTestCaseWhereInput
    none?: DefectTestCaseWhereInput
  }

  export type DefectTestCaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestCaseCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    preconditions?: SortOrder
    steps?: SortOrder
    expectedResult?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    tags?: SortOrder
    automatable?: SortOrder
    estimatedTime?: SortOrder
    testPlanId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestCaseAvgOrderByAggregateInput = {
    estimatedTime?: SortOrder
  }

  export type TestCaseMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    preconditions?: SortOrder
    expectedResult?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    automatable?: SortOrder
    estimatedTime?: SortOrder
    testPlanId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestCaseMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    preconditions?: SortOrder
    expectedResult?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    automatable?: SortOrder
    estimatedTime?: SortOrder
    testPlanId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestCaseSumOrderByAggregateInput = {
    estimatedTime?: SortOrder
  }

  export type EnumTestCasePriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TestCasePriority | EnumTestCasePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TestCasePriority[] | ListEnumTestCasePriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestCasePriority[] | ListEnumTestCasePriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTestCasePriorityWithAggregatesFilter<$PrismaModel> | $Enums.TestCasePriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTestCasePriorityFilter<$PrismaModel>
    _max?: NestedEnumTestCasePriorityFilter<$PrismaModel>
  }

  export type EnumTestCaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TestCaseStatus | EnumTestCaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TestCaseStatus[] | ListEnumTestCaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestCaseStatus[] | ListEnumTestCaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTestCaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.TestCaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTestCaseStatusFilter<$PrismaModel>
    _max?: NestedEnumTestCaseStatusFilter<$PrismaModel>
  }

  export type EnumTestExecutionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TestExecutionStatus | EnumTestExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TestExecutionStatus[] | ListEnumTestExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestExecutionStatus[] | ListEnumTestExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTestExecutionStatusFilter<$PrismaModel> | $Enums.TestExecutionStatus
  }

  export type TestCaseRelationFilter = {
    is?: TestCaseWhereInput
    isNot?: TestCaseWhereInput
  }

  export type TestExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    testPlanId?: SortOrder
    testCaseId?: SortOrder
    status?: SortOrder
    result?: SortOrder
    actualResult?: SortOrder
    evidence?: SortOrder
    executionTime?: SortOrder
    environment?: SortOrder
    browserVersion?: SortOrder
    osVersion?: SortOrder
    notes?: SortOrder
    executedById?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestExecutionAvgOrderByAggregateInput = {
    executionTime?: SortOrder
  }

  export type TestExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    testPlanId?: SortOrder
    testCaseId?: SortOrder
    status?: SortOrder
    result?: SortOrder
    actualResult?: SortOrder
    executionTime?: SortOrder
    environment?: SortOrder
    browserVersion?: SortOrder
    osVersion?: SortOrder
    notes?: SortOrder
    executedById?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    testPlanId?: SortOrder
    testCaseId?: SortOrder
    status?: SortOrder
    result?: SortOrder
    actualResult?: SortOrder
    executionTime?: SortOrder
    environment?: SortOrder
    browserVersion?: SortOrder
    osVersion?: SortOrder
    notes?: SortOrder
    executedById?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestExecutionSumOrderByAggregateInput = {
    executionTime?: SortOrder
  }

  export type EnumTestExecutionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TestExecutionStatus | EnumTestExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TestExecutionStatus[] | ListEnumTestExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestExecutionStatus[] | ListEnumTestExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTestExecutionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TestExecutionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTestExecutionStatusFilter<$PrismaModel>
    _max?: NestedEnumTestExecutionStatusFilter<$PrismaModel>
  }

  export type EnumDefectSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.DefectSeverity | EnumDefectSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.DefectSeverity[] | ListEnumDefectSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefectSeverity[] | ListEnumDefectSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumDefectSeverityFilter<$PrismaModel> | $Enums.DefectSeverity
  }

  export type EnumDefectPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.DefectPriority | EnumDefectPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.DefectPriority[] | ListEnumDefectPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefectPriority[] | ListEnumDefectPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumDefectPriorityFilter<$PrismaModel> | $Enums.DefectPriority
  }

  export type EnumDefectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DefectStatus | EnumDefectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DefectStatus[] | ListEnumDefectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefectStatus[] | ListEnumDefectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDefectStatusFilter<$PrismaModel> | $Enums.DefectStatus
  }

  export type TestExecutionNullableRelationFilter = {
    is?: TestExecutionWhereInput | null
    isNot?: TestExecutionWhereInput | null
  }

  export type DefectCommentListRelationFilter = {
    every?: DefectCommentWhereInput
    some?: DefectCommentWhereInput
    none?: DefectCommentWhereInput
  }

  export type DefectCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DefectCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    steps?: SortOrder
    expectedBehavior?: SortOrder
    actualBehavior?: SortOrder
    severity?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    environment?: SortOrder
    browserVersion?: SortOrder
    osVersion?: SortOrder
    attachments?: SortOrder
    reproducible?: SortOrder
    regression?: SortOrder
    testExecutionId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrder
    reportedAt?: SortOrder
    resolvedAt?: SortOrder
    closedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DefectMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    steps?: SortOrder
    expectedBehavior?: SortOrder
    actualBehavior?: SortOrder
    severity?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    environment?: SortOrder
    browserVersion?: SortOrder
    osVersion?: SortOrder
    reproducible?: SortOrder
    regression?: SortOrder
    testExecutionId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrder
    reportedAt?: SortOrder
    resolvedAt?: SortOrder
    closedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DefectMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    steps?: SortOrder
    expectedBehavior?: SortOrder
    actualBehavior?: SortOrder
    severity?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    environment?: SortOrder
    browserVersion?: SortOrder
    osVersion?: SortOrder
    reproducible?: SortOrder
    regression?: SortOrder
    testExecutionId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrder
    reportedAt?: SortOrder
    resolvedAt?: SortOrder
    closedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDefectSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DefectSeverity | EnumDefectSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.DefectSeverity[] | ListEnumDefectSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefectSeverity[] | ListEnumDefectSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumDefectSeverityWithAggregatesFilter<$PrismaModel> | $Enums.DefectSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDefectSeverityFilter<$PrismaModel>
    _max?: NestedEnumDefectSeverityFilter<$PrismaModel>
  }

  export type EnumDefectPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DefectPriority | EnumDefectPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.DefectPriority[] | ListEnumDefectPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefectPriority[] | ListEnumDefectPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumDefectPriorityWithAggregatesFilter<$PrismaModel> | $Enums.DefectPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDefectPriorityFilter<$PrismaModel>
    _max?: NestedEnumDefectPriorityFilter<$PrismaModel>
  }

  export type EnumDefectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DefectStatus | EnumDefectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DefectStatus[] | ListEnumDefectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefectStatus[] | ListEnumDefectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDefectStatusWithAggregatesFilter<$PrismaModel> | $Enums.DefectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDefectStatusFilter<$PrismaModel>
    _max?: NestedEnumDefectStatusFilter<$PrismaModel>
  }

  export type DefectRelationFilter = {
    is?: DefectWhereInput
    isNot?: DefectWhereInput
  }

  export type DefectTestCaseDefectIdTestCaseIdCompoundUniqueInput = {
    defectId: string
    testCaseId: string
  }

  export type DefectTestCaseCountOrderByAggregateInput = {
    id?: SortOrder
    defectId?: SortOrder
    testCaseId?: SortOrder
    createdAt?: SortOrder
  }

  export type DefectTestCaseMaxOrderByAggregateInput = {
    id?: SortOrder
    defectId?: SortOrder
    testCaseId?: SortOrder
    createdAt?: SortOrder
  }

  export type DefectTestCaseMinOrderByAggregateInput = {
    id?: SortOrder
    defectId?: SortOrder
    testCaseId?: SortOrder
    createdAt?: SortOrder
  }

  export type DefectCommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    defectId?: SortOrder
    authorId?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DefectCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    defectId?: SortOrder
    authorId?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DefectCommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    defectId?: SortOrder
    authorId?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumQAReviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QAReviewStatus | EnumQAReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QAReviewStatus[] | ListEnumQAReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QAReviewStatus[] | ListEnumQAReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQAReviewStatusFilter<$PrismaModel> | $Enums.QAReviewStatus
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type TestPlanNullableRelationFilter = {
    is?: TestPlanWhereInput | null
    isNot?: TestPlanWhereInput | null
  }

  export type QAReviewCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    entityId?: SortOrder
    status?: SortOrder
    criteria?: SortOrder
    findings?: SortOrder
    recommendations?: SortOrder
    approved?: SortOrder
    testPlanId?: SortOrder
    reviewerId?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QAReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    entityId?: SortOrder
    status?: SortOrder
    findings?: SortOrder
    recommendations?: SortOrder
    approved?: SortOrder
    testPlanId?: SortOrder
    reviewerId?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QAReviewMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    entityId?: SortOrder
    status?: SortOrder
    findings?: SortOrder
    recommendations?: SortOrder
    approved?: SortOrder
    testPlanId?: SortOrder
    reviewerId?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumQAReviewStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QAReviewStatus | EnumQAReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QAReviewStatus[] | ListEnumQAReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QAReviewStatus[] | ListEnumQAReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQAReviewStatusWithAggregatesFilter<$PrismaModel> | $Enums.QAReviewStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQAReviewStatusFilter<$PrismaModel>
    _max?: NestedEnumQAReviewStatusFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type AccountCreateNestedManyWithoutOwnerInput = {
    create?: XOR<AccountCreateWithoutOwnerInput, AccountUncheckedCreateWithoutOwnerInput> | AccountCreateWithoutOwnerInput[] | AccountUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutOwnerInput | AccountCreateOrConnectWithoutOwnerInput[]
    createMany?: AccountCreateManyOwnerInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type CompletedProjectCreateNestedManyWithoutOwnerInput = {
    create?: XOR<CompletedProjectCreateWithoutOwnerInput, CompletedProjectUncheckedCreateWithoutOwnerInput> | CompletedProjectCreateWithoutOwnerInput[] | CompletedProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CompletedProjectCreateOrConnectWithoutOwnerInput | CompletedProjectCreateOrConnectWithoutOwnerInput[]
    createMany?: CompletedProjectCreateManyOwnerInputEnvelope
    connect?: CompletedProjectWhereUniqueInput | CompletedProjectWhereUniqueInput[]
  }

  export type EnquiryCreateNestedManyWithoutOwnerInput = {
    create?: XOR<EnquiryCreateWithoutOwnerInput, EnquiryUncheckedCreateWithoutOwnerInput> | EnquiryCreateWithoutOwnerInput[] | EnquiryUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: EnquiryCreateOrConnectWithoutOwnerInput | EnquiryCreateOrConnectWithoutOwnerInput[]
    createMany?: EnquiryCreateManyOwnerInputEnvelope
    connect?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
  }

  export type LeadCreateNestedManyWithoutOwnerInput = {
    create?: XOR<LeadCreateWithoutOwnerInput, LeadUncheckedCreateWithoutOwnerInput> | LeadCreateWithoutOwnerInput[] | LeadUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutOwnerInput | LeadCreateOrConnectWithoutOwnerInput[]
    createMany?: LeadCreateManyOwnerInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput> | ProjectCreateWithoutOwnerInput[] | ProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOwnerInput | ProjectCreateOrConnectWithoutOwnerInput[]
    createMany?: ProjectCreateManyOwnerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCreatedUsersInput = {
    create?: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedUsersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutUpdatedUsersInput = {
    create?: XOR<UserCreateWithoutUpdatedUsersInput, UserUncheckedCreateWithoutUpdatedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedUsersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<UserCreateWithoutUpdatedByInput, UserUncheckedCreateWithoutUpdatedByInput> | UserCreateWithoutUpdatedByInput[] | UserUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedByInput | UserCreateOrConnectWithoutUpdatedByInput[]
    createMany?: UserCreateManyUpdatedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type WorkflowDefinitionCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<WorkflowDefinitionCreateWithoutCreatedByInput, WorkflowDefinitionUncheckedCreateWithoutCreatedByInput> | WorkflowDefinitionCreateWithoutCreatedByInput[] | WorkflowDefinitionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WorkflowDefinitionCreateOrConnectWithoutCreatedByInput | WorkflowDefinitionCreateOrConnectWithoutCreatedByInput[]
    createMany?: WorkflowDefinitionCreateManyCreatedByInputEnvelope
    connect?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
  }

  export type WorkflowInstanceCreateNestedManyWithoutInitiatedByInput = {
    create?: XOR<WorkflowInstanceCreateWithoutInitiatedByInput, WorkflowInstanceUncheckedCreateWithoutInitiatedByInput> | WorkflowInstanceCreateWithoutInitiatedByInput[] | WorkflowInstanceUncheckedCreateWithoutInitiatedByInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutInitiatedByInput | WorkflowInstanceCreateOrConnectWithoutInitiatedByInput[]
    createMany?: WorkflowInstanceCreateManyInitiatedByInputEnvelope
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
  }

  export type WorkflowStepExecutionCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<WorkflowStepExecutionCreateWithoutAssignedToInput, WorkflowStepExecutionUncheckedCreateWithoutAssignedToInput> | WorkflowStepExecutionCreateWithoutAssignedToInput[] | WorkflowStepExecutionUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: WorkflowStepExecutionCreateOrConnectWithoutAssignedToInput | WorkflowStepExecutionCreateOrConnectWithoutAssignedToInput[]
    createMany?: WorkflowStepExecutionCreateManyAssignedToInputEnvelope
    connect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
  }

  export type WorkflowStepApproverCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkflowStepApproverCreateWithoutUserInput, WorkflowStepApproverUncheckedCreateWithoutUserInput> | WorkflowStepApproverCreateWithoutUserInput[] | WorkflowStepApproverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkflowStepApproverCreateOrConnectWithoutUserInput | WorkflowStepApproverCreateOrConnectWithoutUserInput[]
    createMany?: WorkflowStepApproverCreateManyUserInputEnvelope
    connect?: WorkflowStepApproverWhereUniqueInput | WorkflowStepApproverWhereUniqueInput[]
  }

  export type WorkflowApprovalCreateNestedManyWithoutApproverInput = {
    create?: XOR<WorkflowApprovalCreateWithoutApproverInput, WorkflowApprovalUncheckedCreateWithoutApproverInput> | WorkflowApprovalCreateWithoutApproverInput[] | WorkflowApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: WorkflowApprovalCreateOrConnectWithoutApproverInput | WorkflowApprovalCreateOrConnectWithoutApproverInput[]
    createMany?: WorkflowApprovalCreateManyApproverInputEnvelope
    connect?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
  }

  export type WorkflowTemplateCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<WorkflowTemplateCreateWithoutCreatedByInput, WorkflowTemplateUncheckedCreateWithoutCreatedByInput> | WorkflowTemplateCreateWithoutCreatedByInput[] | WorkflowTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WorkflowTemplateCreateOrConnectWithoutCreatedByInput | WorkflowTemplateCreateOrConnectWithoutCreatedByInput[]
    createMany?: WorkflowTemplateCreateManyCreatedByInputEnvelope
    connect?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
  }

  export type AutomationRuleCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AutomationRuleCreateWithoutCreatedByInput, AutomationRuleUncheckedCreateWithoutCreatedByInput> | AutomationRuleCreateWithoutCreatedByInput[] | AutomationRuleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AutomationRuleCreateOrConnectWithoutCreatedByInput | AutomationRuleCreateOrConnectWithoutCreatedByInput[]
    createMany?: AutomationRuleCreateManyCreatedByInputEnvelope
    connect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
  }

  export type TestPlanCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TestPlanCreateWithoutCreatedByInput, TestPlanUncheckedCreateWithoutCreatedByInput> | TestPlanCreateWithoutCreatedByInput[] | TestPlanUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TestPlanCreateOrConnectWithoutCreatedByInput | TestPlanCreateOrConnectWithoutCreatedByInput[]
    createMany?: TestPlanCreateManyCreatedByInputEnvelope
    connect?: TestPlanWhereUniqueInput | TestPlanWhereUniqueInput[]
  }

  export type TestPlanCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<TestPlanCreateWithoutAssignedToInput, TestPlanUncheckedCreateWithoutAssignedToInput> | TestPlanCreateWithoutAssignedToInput[] | TestPlanUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TestPlanCreateOrConnectWithoutAssignedToInput | TestPlanCreateOrConnectWithoutAssignedToInput[]
    createMany?: TestPlanCreateManyAssignedToInputEnvelope
    connect?: TestPlanWhereUniqueInput | TestPlanWhereUniqueInput[]
  }

  export type TestCaseCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TestCaseCreateWithoutCreatedByInput, TestCaseUncheckedCreateWithoutCreatedByInput> | TestCaseCreateWithoutCreatedByInput[] | TestCaseUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TestCaseCreateOrConnectWithoutCreatedByInput | TestCaseCreateOrConnectWithoutCreatedByInput[]
    createMany?: TestCaseCreateManyCreatedByInputEnvelope
    connect?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
  }

  export type TestExecutionCreateNestedManyWithoutExecutedByInput = {
    create?: XOR<TestExecutionCreateWithoutExecutedByInput, TestExecutionUncheckedCreateWithoutExecutedByInput> | TestExecutionCreateWithoutExecutedByInput[] | TestExecutionUncheckedCreateWithoutExecutedByInput[]
    connectOrCreate?: TestExecutionCreateOrConnectWithoutExecutedByInput | TestExecutionCreateOrConnectWithoutExecutedByInput[]
    createMany?: TestExecutionCreateManyExecutedByInputEnvelope
    connect?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
  }

  export type DefectCreateNestedManyWithoutReportedByInput = {
    create?: XOR<DefectCreateWithoutReportedByInput, DefectUncheckedCreateWithoutReportedByInput> | DefectCreateWithoutReportedByInput[] | DefectUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: DefectCreateOrConnectWithoutReportedByInput | DefectCreateOrConnectWithoutReportedByInput[]
    createMany?: DefectCreateManyReportedByInputEnvelope
    connect?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
  }

  export type DefectCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<DefectCreateWithoutAssignedToInput, DefectUncheckedCreateWithoutAssignedToInput> | DefectCreateWithoutAssignedToInput[] | DefectUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: DefectCreateOrConnectWithoutAssignedToInput | DefectCreateOrConnectWithoutAssignedToInput[]
    createMany?: DefectCreateManyAssignedToInputEnvelope
    connect?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
  }

  export type QAReviewCreateNestedManyWithoutReviewerInput = {
    create?: XOR<QAReviewCreateWithoutReviewerInput, QAReviewUncheckedCreateWithoutReviewerInput> | QAReviewCreateWithoutReviewerInput[] | QAReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: QAReviewCreateOrConnectWithoutReviewerInput | QAReviewCreateOrConnectWithoutReviewerInput[]
    createMany?: QAReviewCreateManyReviewerInputEnvelope
    connect?: QAReviewWhereUniqueInput | QAReviewWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<AccountCreateWithoutOwnerInput, AccountUncheckedCreateWithoutOwnerInput> | AccountCreateWithoutOwnerInput[] | AccountUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutOwnerInput | AccountCreateOrConnectWithoutOwnerInput[]
    createMany?: AccountCreateManyOwnerInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type CompletedProjectUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<CompletedProjectCreateWithoutOwnerInput, CompletedProjectUncheckedCreateWithoutOwnerInput> | CompletedProjectCreateWithoutOwnerInput[] | CompletedProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CompletedProjectCreateOrConnectWithoutOwnerInput | CompletedProjectCreateOrConnectWithoutOwnerInput[]
    createMany?: CompletedProjectCreateManyOwnerInputEnvelope
    connect?: CompletedProjectWhereUniqueInput | CompletedProjectWhereUniqueInput[]
  }

  export type EnquiryUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<EnquiryCreateWithoutOwnerInput, EnquiryUncheckedCreateWithoutOwnerInput> | EnquiryCreateWithoutOwnerInput[] | EnquiryUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: EnquiryCreateOrConnectWithoutOwnerInput | EnquiryCreateOrConnectWithoutOwnerInput[]
    createMany?: EnquiryCreateManyOwnerInputEnvelope
    connect?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<LeadCreateWithoutOwnerInput, LeadUncheckedCreateWithoutOwnerInput> | LeadCreateWithoutOwnerInput[] | LeadUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutOwnerInput | LeadCreateOrConnectWithoutOwnerInput[]
    createMany?: LeadCreateManyOwnerInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput> | ProjectCreateWithoutOwnerInput[] | ProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOwnerInput | ProjectCreateOrConnectWithoutOwnerInput[]
    createMany?: ProjectCreateManyOwnerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<UserCreateWithoutUpdatedByInput, UserUncheckedCreateWithoutUpdatedByInput> | UserCreateWithoutUpdatedByInput[] | UserUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedByInput | UserCreateOrConnectWithoutUpdatedByInput[]
    createMany?: UserCreateManyUpdatedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type WorkflowDefinitionUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<WorkflowDefinitionCreateWithoutCreatedByInput, WorkflowDefinitionUncheckedCreateWithoutCreatedByInput> | WorkflowDefinitionCreateWithoutCreatedByInput[] | WorkflowDefinitionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WorkflowDefinitionCreateOrConnectWithoutCreatedByInput | WorkflowDefinitionCreateOrConnectWithoutCreatedByInput[]
    createMany?: WorkflowDefinitionCreateManyCreatedByInputEnvelope
    connect?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
  }

  export type WorkflowInstanceUncheckedCreateNestedManyWithoutInitiatedByInput = {
    create?: XOR<WorkflowInstanceCreateWithoutInitiatedByInput, WorkflowInstanceUncheckedCreateWithoutInitiatedByInput> | WorkflowInstanceCreateWithoutInitiatedByInput[] | WorkflowInstanceUncheckedCreateWithoutInitiatedByInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutInitiatedByInput | WorkflowInstanceCreateOrConnectWithoutInitiatedByInput[]
    createMany?: WorkflowInstanceCreateManyInitiatedByInputEnvelope
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
  }

  export type WorkflowStepExecutionUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<WorkflowStepExecutionCreateWithoutAssignedToInput, WorkflowStepExecutionUncheckedCreateWithoutAssignedToInput> | WorkflowStepExecutionCreateWithoutAssignedToInput[] | WorkflowStepExecutionUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: WorkflowStepExecutionCreateOrConnectWithoutAssignedToInput | WorkflowStepExecutionCreateOrConnectWithoutAssignedToInput[]
    createMany?: WorkflowStepExecutionCreateManyAssignedToInputEnvelope
    connect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
  }

  export type WorkflowStepApproverUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkflowStepApproverCreateWithoutUserInput, WorkflowStepApproverUncheckedCreateWithoutUserInput> | WorkflowStepApproverCreateWithoutUserInput[] | WorkflowStepApproverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkflowStepApproverCreateOrConnectWithoutUserInput | WorkflowStepApproverCreateOrConnectWithoutUserInput[]
    createMany?: WorkflowStepApproverCreateManyUserInputEnvelope
    connect?: WorkflowStepApproverWhereUniqueInput | WorkflowStepApproverWhereUniqueInput[]
  }

  export type WorkflowApprovalUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<WorkflowApprovalCreateWithoutApproverInput, WorkflowApprovalUncheckedCreateWithoutApproverInput> | WorkflowApprovalCreateWithoutApproverInput[] | WorkflowApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: WorkflowApprovalCreateOrConnectWithoutApproverInput | WorkflowApprovalCreateOrConnectWithoutApproverInput[]
    createMany?: WorkflowApprovalCreateManyApproverInputEnvelope
    connect?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
  }

  export type WorkflowTemplateUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<WorkflowTemplateCreateWithoutCreatedByInput, WorkflowTemplateUncheckedCreateWithoutCreatedByInput> | WorkflowTemplateCreateWithoutCreatedByInput[] | WorkflowTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WorkflowTemplateCreateOrConnectWithoutCreatedByInput | WorkflowTemplateCreateOrConnectWithoutCreatedByInput[]
    createMany?: WorkflowTemplateCreateManyCreatedByInputEnvelope
    connect?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
  }

  export type AutomationRuleUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AutomationRuleCreateWithoutCreatedByInput, AutomationRuleUncheckedCreateWithoutCreatedByInput> | AutomationRuleCreateWithoutCreatedByInput[] | AutomationRuleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AutomationRuleCreateOrConnectWithoutCreatedByInput | AutomationRuleCreateOrConnectWithoutCreatedByInput[]
    createMany?: AutomationRuleCreateManyCreatedByInputEnvelope
    connect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
  }

  export type TestPlanUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TestPlanCreateWithoutCreatedByInput, TestPlanUncheckedCreateWithoutCreatedByInput> | TestPlanCreateWithoutCreatedByInput[] | TestPlanUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TestPlanCreateOrConnectWithoutCreatedByInput | TestPlanCreateOrConnectWithoutCreatedByInput[]
    createMany?: TestPlanCreateManyCreatedByInputEnvelope
    connect?: TestPlanWhereUniqueInput | TestPlanWhereUniqueInput[]
  }

  export type TestPlanUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<TestPlanCreateWithoutAssignedToInput, TestPlanUncheckedCreateWithoutAssignedToInput> | TestPlanCreateWithoutAssignedToInput[] | TestPlanUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TestPlanCreateOrConnectWithoutAssignedToInput | TestPlanCreateOrConnectWithoutAssignedToInput[]
    createMany?: TestPlanCreateManyAssignedToInputEnvelope
    connect?: TestPlanWhereUniqueInput | TestPlanWhereUniqueInput[]
  }

  export type TestCaseUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TestCaseCreateWithoutCreatedByInput, TestCaseUncheckedCreateWithoutCreatedByInput> | TestCaseCreateWithoutCreatedByInput[] | TestCaseUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TestCaseCreateOrConnectWithoutCreatedByInput | TestCaseCreateOrConnectWithoutCreatedByInput[]
    createMany?: TestCaseCreateManyCreatedByInputEnvelope
    connect?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
  }

  export type TestExecutionUncheckedCreateNestedManyWithoutExecutedByInput = {
    create?: XOR<TestExecutionCreateWithoutExecutedByInput, TestExecutionUncheckedCreateWithoutExecutedByInput> | TestExecutionCreateWithoutExecutedByInput[] | TestExecutionUncheckedCreateWithoutExecutedByInput[]
    connectOrCreate?: TestExecutionCreateOrConnectWithoutExecutedByInput | TestExecutionCreateOrConnectWithoutExecutedByInput[]
    createMany?: TestExecutionCreateManyExecutedByInputEnvelope
    connect?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
  }

  export type DefectUncheckedCreateNestedManyWithoutReportedByInput = {
    create?: XOR<DefectCreateWithoutReportedByInput, DefectUncheckedCreateWithoutReportedByInput> | DefectCreateWithoutReportedByInput[] | DefectUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: DefectCreateOrConnectWithoutReportedByInput | DefectCreateOrConnectWithoutReportedByInput[]
    createMany?: DefectCreateManyReportedByInputEnvelope
    connect?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
  }

  export type DefectUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<DefectCreateWithoutAssignedToInput, DefectUncheckedCreateWithoutAssignedToInput> | DefectCreateWithoutAssignedToInput[] | DefectUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: DefectCreateOrConnectWithoutAssignedToInput | DefectCreateOrConnectWithoutAssignedToInput[]
    createMany?: DefectCreateManyAssignedToInputEnvelope
    connect?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
  }

  export type QAReviewUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<QAReviewCreateWithoutReviewerInput, QAReviewUncheckedCreateWithoutReviewerInput> | QAReviewCreateWithoutReviewerInput[] | QAReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: QAReviewCreateOrConnectWithoutReviewerInput | QAReviewCreateOrConnectWithoutReviewerInput[]
    createMany?: QAReviewCreateManyReviewerInputEnvelope
    connect?: QAReviewWhereUniqueInput | QAReviewWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AccountUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<AccountCreateWithoutOwnerInput, AccountUncheckedCreateWithoutOwnerInput> | AccountCreateWithoutOwnerInput[] | AccountUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutOwnerInput | AccountCreateOrConnectWithoutOwnerInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutOwnerInput | AccountUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: AccountCreateManyOwnerInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutOwnerInput | AccountUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutOwnerInput | AccountUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutUserInput | ActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutUserInput | ActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutUserInput | ActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type CompletedProjectUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<CompletedProjectCreateWithoutOwnerInput, CompletedProjectUncheckedCreateWithoutOwnerInput> | CompletedProjectCreateWithoutOwnerInput[] | CompletedProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CompletedProjectCreateOrConnectWithoutOwnerInput | CompletedProjectCreateOrConnectWithoutOwnerInput[]
    upsert?: CompletedProjectUpsertWithWhereUniqueWithoutOwnerInput | CompletedProjectUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: CompletedProjectCreateManyOwnerInputEnvelope
    set?: CompletedProjectWhereUniqueInput | CompletedProjectWhereUniqueInput[]
    disconnect?: CompletedProjectWhereUniqueInput | CompletedProjectWhereUniqueInput[]
    delete?: CompletedProjectWhereUniqueInput | CompletedProjectWhereUniqueInput[]
    connect?: CompletedProjectWhereUniqueInput | CompletedProjectWhereUniqueInput[]
    update?: CompletedProjectUpdateWithWhereUniqueWithoutOwnerInput | CompletedProjectUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: CompletedProjectUpdateManyWithWhereWithoutOwnerInput | CompletedProjectUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: CompletedProjectScalarWhereInput | CompletedProjectScalarWhereInput[]
  }

  export type EnquiryUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<EnquiryCreateWithoutOwnerInput, EnquiryUncheckedCreateWithoutOwnerInput> | EnquiryCreateWithoutOwnerInput[] | EnquiryUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: EnquiryCreateOrConnectWithoutOwnerInput | EnquiryCreateOrConnectWithoutOwnerInput[]
    upsert?: EnquiryUpsertWithWhereUniqueWithoutOwnerInput | EnquiryUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: EnquiryCreateManyOwnerInputEnvelope
    set?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    disconnect?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    delete?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    connect?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    update?: EnquiryUpdateWithWhereUniqueWithoutOwnerInput | EnquiryUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: EnquiryUpdateManyWithWhereWithoutOwnerInput | EnquiryUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: EnquiryScalarWhereInput | EnquiryScalarWhereInput[]
  }

  export type LeadUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<LeadCreateWithoutOwnerInput, LeadUncheckedCreateWithoutOwnerInput> | LeadCreateWithoutOwnerInput[] | LeadUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutOwnerInput | LeadCreateOrConnectWithoutOwnerInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutOwnerInput | LeadUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: LeadCreateManyOwnerInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutOwnerInput | LeadUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutOwnerInput | LeadUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput> | ProjectCreateWithoutOwnerInput[] | ProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOwnerInput | ProjectCreateOrConnectWithoutOwnerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutOwnerInput | ProjectUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ProjectCreateManyOwnerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutOwnerInput | ProjectUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutOwnerInput | ProjectUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAssigneeInput | TaskUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAssigneeInput | TaskUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAssigneeInput | TaskUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type UserUpdateOneWithoutCreatedUsersNestedInput = {
    create?: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedUsersInput
    upsert?: UserUpsertWithoutCreatedUsersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedUsersInput, UserUpdateWithoutCreatedUsersInput>, UserUncheckedUpdateWithoutCreatedUsersInput>
  }

  export type UserUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCreatedByInput | UserUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCreatedByInput | UserUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCreatedByInput | UserUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUpdateOneWithoutUpdatedUsersNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedUsersInput, UserUncheckedCreateWithoutUpdatedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedUsersInput
    upsert?: UserUpsertWithoutUpdatedUsersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedUsersInput, UserUpdateWithoutUpdatedUsersInput>, UserUncheckedUpdateWithoutUpdatedUsersInput>
  }

  export type UserUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedByInput, UserUncheckedCreateWithoutUpdatedByInput> | UserCreateWithoutUpdatedByInput[] | UserUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedByInput | UserCreateOrConnectWithoutUpdatedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutUpdatedByInput | UserUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: UserCreateManyUpdatedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutUpdatedByInput | UserUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutUpdatedByInput | UserUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type WorkflowDefinitionUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<WorkflowDefinitionCreateWithoutCreatedByInput, WorkflowDefinitionUncheckedCreateWithoutCreatedByInput> | WorkflowDefinitionCreateWithoutCreatedByInput[] | WorkflowDefinitionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WorkflowDefinitionCreateOrConnectWithoutCreatedByInput | WorkflowDefinitionCreateOrConnectWithoutCreatedByInput[]
    upsert?: WorkflowDefinitionUpsertWithWhereUniqueWithoutCreatedByInput | WorkflowDefinitionUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: WorkflowDefinitionCreateManyCreatedByInputEnvelope
    set?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
    disconnect?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
    delete?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
    connect?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
    update?: WorkflowDefinitionUpdateWithWhereUniqueWithoutCreatedByInput | WorkflowDefinitionUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: WorkflowDefinitionUpdateManyWithWhereWithoutCreatedByInput | WorkflowDefinitionUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: WorkflowDefinitionScalarWhereInput | WorkflowDefinitionScalarWhereInput[]
  }

  export type WorkflowInstanceUpdateManyWithoutInitiatedByNestedInput = {
    create?: XOR<WorkflowInstanceCreateWithoutInitiatedByInput, WorkflowInstanceUncheckedCreateWithoutInitiatedByInput> | WorkflowInstanceCreateWithoutInitiatedByInput[] | WorkflowInstanceUncheckedCreateWithoutInitiatedByInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutInitiatedByInput | WorkflowInstanceCreateOrConnectWithoutInitiatedByInput[]
    upsert?: WorkflowInstanceUpsertWithWhereUniqueWithoutInitiatedByInput | WorkflowInstanceUpsertWithWhereUniqueWithoutInitiatedByInput[]
    createMany?: WorkflowInstanceCreateManyInitiatedByInputEnvelope
    set?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    disconnect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    delete?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    update?: WorkflowInstanceUpdateWithWhereUniqueWithoutInitiatedByInput | WorkflowInstanceUpdateWithWhereUniqueWithoutInitiatedByInput[]
    updateMany?: WorkflowInstanceUpdateManyWithWhereWithoutInitiatedByInput | WorkflowInstanceUpdateManyWithWhereWithoutInitiatedByInput[]
    deleteMany?: WorkflowInstanceScalarWhereInput | WorkflowInstanceScalarWhereInput[]
  }

  export type WorkflowStepExecutionUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<WorkflowStepExecutionCreateWithoutAssignedToInput, WorkflowStepExecutionUncheckedCreateWithoutAssignedToInput> | WorkflowStepExecutionCreateWithoutAssignedToInput[] | WorkflowStepExecutionUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: WorkflowStepExecutionCreateOrConnectWithoutAssignedToInput | WorkflowStepExecutionCreateOrConnectWithoutAssignedToInput[]
    upsert?: WorkflowStepExecutionUpsertWithWhereUniqueWithoutAssignedToInput | WorkflowStepExecutionUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: WorkflowStepExecutionCreateManyAssignedToInputEnvelope
    set?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    disconnect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    delete?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    connect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    update?: WorkflowStepExecutionUpdateWithWhereUniqueWithoutAssignedToInput | WorkflowStepExecutionUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: WorkflowStepExecutionUpdateManyWithWhereWithoutAssignedToInput | WorkflowStepExecutionUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: WorkflowStepExecutionScalarWhereInput | WorkflowStepExecutionScalarWhereInput[]
  }

  export type WorkflowStepApproverUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkflowStepApproverCreateWithoutUserInput, WorkflowStepApproverUncheckedCreateWithoutUserInput> | WorkflowStepApproverCreateWithoutUserInput[] | WorkflowStepApproverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkflowStepApproverCreateOrConnectWithoutUserInput | WorkflowStepApproverCreateOrConnectWithoutUserInput[]
    upsert?: WorkflowStepApproverUpsertWithWhereUniqueWithoutUserInput | WorkflowStepApproverUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkflowStepApproverCreateManyUserInputEnvelope
    set?: WorkflowStepApproverWhereUniqueInput | WorkflowStepApproverWhereUniqueInput[]
    disconnect?: WorkflowStepApproverWhereUniqueInput | WorkflowStepApproverWhereUniqueInput[]
    delete?: WorkflowStepApproverWhereUniqueInput | WorkflowStepApproverWhereUniqueInput[]
    connect?: WorkflowStepApproverWhereUniqueInput | WorkflowStepApproverWhereUniqueInput[]
    update?: WorkflowStepApproverUpdateWithWhereUniqueWithoutUserInput | WorkflowStepApproverUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkflowStepApproverUpdateManyWithWhereWithoutUserInput | WorkflowStepApproverUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkflowStepApproverScalarWhereInput | WorkflowStepApproverScalarWhereInput[]
  }

  export type WorkflowApprovalUpdateManyWithoutApproverNestedInput = {
    create?: XOR<WorkflowApprovalCreateWithoutApproverInput, WorkflowApprovalUncheckedCreateWithoutApproverInput> | WorkflowApprovalCreateWithoutApproverInput[] | WorkflowApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: WorkflowApprovalCreateOrConnectWithoutApproverInput | WorkflowApprovalCreateOrConnectWithoutApproverInput[]
    upsert?: WorkflowApprovalUpsertWithWhereUniqueWithoutApproverInput | WorkflowApprovalUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: WorkflowApprovalCreateManyApproverInputEnvelope
    set?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
    disconnect?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
    delete?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
    connect?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
    update?: WorkflowApprovalUpdateWithWhereUniqueWithoutApproverInput | WorkflowApprovalUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: WorkflowApprovalUpdateManyWithWhereWithoutApproverInput | WorkflowApprovalUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: WorkflowApprovalScalarWhereInput | WorkflowApprovalScalarWhereInput[]
  }

  export type WorkflowTemplateUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<WorkflowTemplateCreateWithoutCreatedByInput, WorkflowTemplateUncheckedCreateWithoutCreatedByInput> | WorkflowTemplateCreateWithoutCreatedByInput[] | WorkflowTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WorkflowTemplateCreateOrConnectWithoutCreatedByInput | WorkflowTemplateCreateOrConnectWithoutCreatedByInput[]
    upsert?: WorkflowTemplateUpsertWithWhereUniqueWithoutCreatedByInput | WorkflowTemplateUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: WorkflowTemplateCreateManyCreatedByInputEnvelope
    set?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
    disconnect?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
    delete?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
    connect?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
    update?: WorkflowTemplateUpdateWithWhereUniqueWithoutCreatedByInput | WorkflowTemplateUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: WorkflowTemplateUpdateManyWithWhereWithoutCreatedByInput | WorkflowTemplateUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: WorkflowTemplateScalarWhereInput | WorkflowTemplateScalarWhereInput[]
  }

  export type AutomationRuleUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AutomationRuleCreateWithoutCreatedByInput, AutomationRuleUncheckedCreateWithoutCreatedByInput> | AutomationRuleCreateWithoutCreatedByInput[] | AutomationRuleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AutomationRuleCreateOrConnectWithoutCreatedByInput | AutomationRuleCreateOrConnectWithoutCreatedByInput[]
    upsert?: AutomationRuleUpsertWithWhereUniqueWithoutCreatedByInput | AutomationRuleUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AutomationRuleCreateManyCreatedByInputEnvelope
    set?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    disconnect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    delete?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    connect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    update?: AutomationRuleUpdateWithWhereUniqueWithoutCreatedByInput | AutomationRuleUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AutomationRuleUpdateManyWithWhereWithoutCreatedByInput | AutomationRuleUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AutomationRuleScalarWhereInput | AutomationRuleScalarWhereInput[]
  }

  export type TestPlanUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TestPlanCreateWithoutCreatedByInput, TestPlanUncheckedCreateWithoutCreatedByInput> | TestPlanCreateWithoutCreatedByInput[] | TestPlanUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TestPlanCreateOrConnectWithoutCreatedByInput | TestPlanCreateOrConnectWithoutCreatedByInput[]
    upsert?: TestPlanUpsertWithWhereUniqueWithoutCreatedByInput | TestPlanUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TestPlanCreateManyCreatedByInputEnvelope
    set?: TestPlanWhereUniqueInput | TestPlanWhereUniqueInput[]
    disconnect?: TestPlanWhereUniqueInput | TestPlanWhereUniqueInput[]
    delete?: TestPlanWhereUniqueInput | TestPlanWhereUniqueInput[]
    connect?: TestPlanWhereUniqueInput | TestPlanWhereUniqueInput[]
    update?: TestPlanUpdateWithWhereUniqueWithoutCreatedByInput | TestPlanUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TestPlanUpdateManyWithWhereWithoutCreatedByInput | TestPlanUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TestPlanScalarWhereInput | TestPlanScalarWhereInput[]
  }

  export type TestPlanUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<TestPlanCreateWithoutAssignedToInput, TestPlanUncheckedCreateWithoutAssignedToInput> | TestPlanCreateWithoutAssignedToInput[] | TestPlanUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TestPlanCreateOrConnectWithoutAssignedToInput | TestPlanCreateOrConnectWithoutAssignedToInput[]
    upsert?: TestPlanUpsertWithWhereUniqueWithoutAssignedToInput | TestPlanUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: TestPlanCreateManyAssignedToInputEnvelope
    set?: TestPlanWhereUniqueInput | TestPlanWhereUniqueInput[]
    disconnect?: TestPlanWhereUniqueInput | TestPlanWhereUniqueInput[]
    delete?: TestPlanWhereUniqueInput | TestPlanWhereUniqueInput[]
    connect?: TestPlanWhereUniqueInput | TestPlanWhereUniqueInput[]
    update?: TestPlanUpdateWithWhereUniqueWithoutAssignedToInput | TestPlanUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: TestPlanUpdateManyWithWhereWithoutAssignedToInput | TestPlanUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: TestPlanScalarWhereInput | TestPlanScalarWhereInput[]
  }

  export type TestCaseUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TestCaseCreateWithoutCreatedByInput, TestCaseUncheckedCreateWithoutCreatedByInput> | TestCaseCreateWithoutCreatedByInput[] | TestCaseUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TestCaseCreateOrConnectWithoutCreatedByInput | TestCaseCreateOrConnectWithoutCreatedByInput[]
    upsert?: TestCaseUpsertWithWhereUniqueWithoutCreatedByInput | TestCaseUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TestCaseCreateManyCreatedByInputEnvelope
    set?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    disconnect?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    delete?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    connect?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    update?: TestCaseUpdateWithWhereUniqueWithoutCreatedByInput | TestCaseUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TestCaseUpdateManyWithWhereWithoutCreatedByInput | TestCaseUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TestCaseScalarWhereInput | TestCaseScalarWhereInput[]
  }

  export type TestExecutionUpdateManyWithoutExecutedByNestedInput = {
    create?: XOR<TestExecutionCreateWithoutExecutedByInput, TestExecutionUncheckedCreateWithoutExecutedByInput> | TestExecutionCreateWithoutExecutedByInput[] | TestExecutionUncheckedCreateWithoutExecutedByInput[]
    connectOrCreate?: TestExecutionCreateOrConnectWithoutExecutedByInput | TestExecutionCreateOrConnectWithoutExecutedByInput[]
    upsert?: TestExecutionUpsertWithWhereUniqueWithoutExecutedByInput | TestExecutionUpsertWithWhereUniqueWithoutExecutedByInput[]
    createMany?: TestExecutionCreateManyExecutedByInputEnvelope
    set?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
    disconnect?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
    delete?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
    connect?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
    update?: TestExecutionUpdateWithWhereUniqueWithoutExecutedByInput | TestExecutionUpdateWithWhereUniqueWithoutExecutedByInput[]
    updateMany?: TestExecutionUpdateManyWithWhereWithoutExecutedByInput | TestExecutionUpdateManyWithWhereWithoutExecutedByInput[]
    deleteMany?: TestExecutionScalarWhereInput | TestExecutionScalarWhereInput[]
  }

  export type DefectUpdateManyWithoutReportedByNestedInput = {
    create?: XOR<DefectCreateWithoutReportedByInput, DefectUncheckedCreateWithoutReportedByInput> | DefectCreateWithoutReportedByInput[] | DefectUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: DefectCreateOrConnectWithoutReportedByInput | DefectCreateOrConnectWithoutReportedByInput[]
    upsert?: DefectUpsertWithWhereUniqueWithoutReportedByInput | DefectUpsertWithWhereUniqueWithoutReportedByInput[]
    createMany?: DefectCreateManyReportedByInputEnvelope
    set?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
    disconnect?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
    delete?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
    connect?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
    update?: DefectUpdateWithWhereUniqueWithoutReportedByInput | DefectUpdateWithWhereUniqueWithoutReportedByInput[]
    updateMany?: DefectUpdateManyWithWhereWithoutReportedByInput | DefectUpdateManyWithWhereWithoutReportedByInput[]
    deleteMany?: DefectScalarWhereInput | DefectScalarWhereInput[]
  }

  export type DefectUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<DefectCreateWithoutAssignedToInput, DefectUncheckedCreateWithoutAssignedToInput> | DefectCreateWithoutAssignedToInput[] | DefectUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: DefectCreateOrConnectWithoutAssignedToInput | DefectCreateOrConnectWithoutAssignedToInput[]
    upsert?: DefectUpsertWithWhereUniqueWithoutAssignedToInput | DefectUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: DefectCreateManyAssignedToInputEnvelope
    set?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
    disconnect?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
    delete?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
    connect?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
    update?: DefectUpdateWithWhereUniqueWithoutAssignedToInput | DefectUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: DefectUpdateManyWithWhereWithoutAssignedToInput | DefectUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: DefectScalarWhereInput | DefectScalarWhereInput[]
  }

  export type QAReviewUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<QAReviewCreateWithoutReviewerInput, QAReviewUncheckedCreateWithoutReviewerInput> | QAReviewCreateWithoutReviewerInput[] | QAReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: QAReviewCreateOrConnectWithoutReviewerInput | QAReviewCreateOrConnectWithoutReviewerInput[]
    upsert?: QAReviewUpsertWithWhereUniqueWithoutReviewerInput | QAReviewUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: QAReviewCreateManyReviewerInputEnvelope
    set?: QAReviewWhereUniqueInput | QAReviewWhereUniqueInput[]
    disconnect?: QAReviewWhereUniqueInput | QAReviewWhereUniqueInput[]
    delete?: QAReviewWhereUniqueInput | QAReviewWhereUniqueInput[]
    connect?: QAReviewWhereUniqueInput | QAReviewWhereUniqueInput[]
    update?: QAReviewUpdateWithWhereUniqueWithoutReviewerInput | QAReviewUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: QAReviewUpdateManyWithWhereWithoutReviewerInput | QAReviewUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: QAReviewScalarWhereInput | QAReviewScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<AccountCreateWithoutOwnerInput, AccountUncheckedCreateWithoutOwnerInput> | AccountCreateWithoutOwnerInput[] | AccountUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutOwnerInput | AccountCreateOrConnectWithoutOwnerInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutOwnerInput | AccountUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: AccountCreateManyOwnerInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutOwnerInput | AccountUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutOwnerInput | AccountUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutUserInput | ActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutUserInput | ActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutUserInput | ActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type CompletedProjectUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<CompletedProjectCreateWithoutOwnerInput, CompletedProjectUncheckedCreateWithoutOwnerInput> | CompletedProjectCreateWithoutOwnerInput[] | CompletedProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CompletedProjectCreateOrConnectWithoutOwnerInput | CompletedProjectCreateOrConnectWithoutOwnerInput[]
    upsert?: CompletedProjectUpsertWithWhereUniqueWithoutOwnerInput | CompletedProjectUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: CompletedProjectCreateManyOwnerInputEnvelope
    set?: CompletedProjectWhereUniqueInput | CompletedProjectWhereUniqueInput[]
    disconnect?: CompletedProjectWhereUniqueInput | CompletedProjectWhereUniqueInput[]
    delete?: CompletedProjectWhereUniqueInput | CompletedProjectWhereUniqueInput[]
    connect?: CompletedProjectWhereUniqueInput | CompletedProjectWhereUniqueInput[]
    update?: CompletedProjectUpdateWithWhereUniqueWithoutOwnerInput | CompletedProjectUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: CompletedProjectUpdateManyWithWhereWithoutOwnerInput | CompletedProjectUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: CompletedProjectScalarWhereInput | CompletedProjectScalarWhereInput[]
  }

  export type EnquiryUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<EnquiryCreateWithoutOwnerInput, EnquiryUncheckedCreateWithoutOwnerInput> | EnquiryCreateWithoutOwnerInput[] | EnquiryUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: EnquiryCreateOrConnectWithoutOwnerInput | EnquiryCreateOrConnectWithoutOwnerInput[]
    upsert?: EnquiryUpsertWithWhereUniqueWithoutOwnerInput | EnquiryUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: EnquiryCreateManyOwnerInputEnvelope
    set?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    disconnect?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    delete?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    connect?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    update?: EnquiryUpdateWithWhereUniqueWithoutOwnerInput | EnquiryUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: EnquiryUpdateManyWithWhereWithoutOwnerInput | EnquiryUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: EnquiryScalarWhereInput | EnquiryScalarWhereInput[]
  }

  export type LeadUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<LeadCreateWithoutOwnerInput, LeadUncheckedCreateWithoutOwnerInput> | LeadCreateWithoutOwnerInput[] | LeadUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutOwnerInput | LeadCreateOrConnectWithoutOwnerInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutOwnerInput | LeadUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: LeadCreateManyOwnerInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutOwnerInput | LeadUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutOwnerInput | LeadUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput> | ProjectCreateWithoutOwnerInput[] | ProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOwnerInput | ProjectCreateOrConnectWithoutOwnerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutOwnerInput | ProjectUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ProjectCreateManyOwnerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutOwnerInput | ProjectUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutOwnerInput | ProjectUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAssigneeInput | TaskUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAssigneeInput | TaskUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAssigneeInput | TaskUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCreatedByInput | UserUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCreatedByInput | UserUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCreatedByInput | UserUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedByInput, UserUncheckedCreateWithoutUpdatedByInput> | UserCreateWithoutUpdatedByInput[] | UserUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedByInput | UserCreateOrConnectWithoutUpdatedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutUpdatedByInput | UserUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: UserCreateManyUpdatedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutUpdatedByInput | UserUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutUpdatedByInput | UserUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<WorkflowDefinitionCreateWithoutCreatedByInput, WorkflowDefinitionUncheckedCreateWithoutCreatedByInput> | WorkflowDefinitionCreateWithoutCreatedByInput[] | WorkflowDefinitionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WorkflowDefinitionCreateOrConnectWithoutCreatedByInput | WorkflowDefinitionCreateOrConnectWithoutCreatedByInput[]
    upsert?: WorkflowDefinitionUpsertWithWhereUniqueWithoutCreatedByInput | WorkflowDefinitionUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: WorkflowDefinitionCreateManyCreatedByInputEnvelope
    set?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
    disconnect?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
    delete?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
    connect?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
    update?: WorkflowDefinitionUpdateWithWhereUniqueWithoutCreatedByInput | WorkflowDefinitionUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: WorkflowDefinitionUpdateManyWithWhereWithoutCreatedByInput | WorkflowDefinitionUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: WorkflowDefinitionScalarWhereInput | WorkflowDefinitionScalarWhereInput[]
  }

  export type WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByNestedInput = {
    create?: XOR<WorkflowInstanceCreateWithoutInitiatedByInput, WorkflowInstanceUncheckedCreateWithoutInitiatedByInput> | WorkflowInstanceCreateWithoutInitiatedByInput[] | WorkflowInstanceUncheckedCreateWithoutInitiatedByInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutInitiatedByInput | WorkflowInstanceCreateOrConnectWithoutInitiatedByInput[]
    upsert?: WorkflowInstanceUpsertWithWhereUniqueWithoutInitiatedByInput | WorkflowInstanceUpsertWithWhereUniqueWithoutInitiatedByInput[]
    createMany?: WorkflowInstanceCreateManyInitiatedByInputEnvelope
    set?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    disconnect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    delete?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    update?: WorkflowInstanceUpdateWithWhereUniqueWithoutInitiatedByInput | WorkflowInstanceUpdateWithWhereUniqueWithoutInitiatedByInput[]
    updateMany?: WorkflowInstanceUpdateManyWithWhereWithoutInitiatedByInput | WorkflowInstanceUpdateManyWithWhereWithoutInitiatedByInput[]
    deleteMany?: WorkflowInstanceScalarWhereInput | WorkflowInstanceScalarWhereInput[]
  }

  export type WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<WorkflowStepExecutionCreateWithoutAssignedToInput, WorkflowStepExecutionUncheckedCreateWithoutAssignedToInput> | WorkflowStepExecutionCreateWithoutAssignedToInput[] | WorkflowStepExecutionUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: WorkflowStepExecutionCreateOrConnectWithoutAssignedToInput | WorkflowStepExecutionCreateOrConnectWithoutAssignedToInput[]
    upsert?: WorkflowStepExecutionUpsertWithWhereUniqueWithoutAssignedToInput | WorkflowStepExecutionUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: WorkflowStepExecutionCreateManyAssignedToInputEnvelope
    set?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    disconnect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    delete?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    connect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    update?: WorkflowStepExecutionUpdateWithWhereUniqueWithoutAssignedToInput | WorkflowStepExecutionUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: WorkflowStepExecutionUpdateManyWithWhereWithoutAssignedToInput | WorkflowStepExecutionUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: WorkflowStepExecutionScalarWhereInput | WorkflowStepExecutionScalarWhereInput[]
  }

  export type WorkflowStepApproverUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkflowStepApproverCreateWithoutUserInput, WorkflowStepApproverUncheckedCreateWithoutUserInput> | WorkflowStepApproverCreateWithoutUserInput[] | WorkflowStepApproverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkflowStepApproverCreateOrConnectWithoutUserInput | WorkflowStepApproverCreateOrConnectWithoutUserInput[]
    upsert?: WorkflowStepApproverUpsertWithWhereUniqueWithoutUserInput | WorkflowStepApproverUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkflowStepApproverCreateManyUserInputEnvelope
    set?: WorkflowStepApproverWhereUniqueInput | WorkflowStepApproverWhereUniqueInput[]
    disconnect?: WorkflowStepApproverWhereUniqueInput | WorkflowStepApproverWhereUniqueInput[]
    delete?: WorkflowStepApproverWhereUniqueInput | WorkflowStepApproverWhereUniqueInput[]
    connect?: WorkflowStepApproverWhereUniqueInput | WorkflowStepApproverWhereUniqueInput[]
    update?: WorkflowStepApproverUpdateWithWhereUniqueWithoutUserInput | WorkflowStepApproverUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkflowStepApproverUpdateManyWithWhereWithoutUserInput | WorkflowStepApproverUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkflowStepApproverScalarWhereInput | WorkflowStepApproverScalarWhereInput[]
  }

  export type WorkflowApprovalUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<WorkflowApprovalCreateWithoutApproverInput, WorkflowApprovalUncheckedCreateWithoutApproverInput> | WorkflowApprovalCreateWithoutApproverInput[] | WorkflowApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: WorkflowApprovalCreateOrConnectWithoutApproverInput | WorkflowApprovalCreateOrConnectWithoutApproverInput[]
    upsert?: WorkflowApprovalUpsertWithWhereUniqueWithoutApproverInput | WorkflowApprovalUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: WorkflowApprovalCreateManyApproverInputEnvelope
    set?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
    disconnect?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
    delete?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
    connect?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
    update?: WorkflowApprovalUpdateWithWhereUniqueWithoutApproverInput | WorkflowApprovalUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: WorkflowApprovalUpdateManyWithWhereWithoutApproverInput | WorkflowApprovalUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: WorkflowApprovalScalarWhereInput | WorkflowApprovalScalarWhereInput[]
  }

  export type WorkflowTemplateUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<WorkflowTemplateCreateWithoutCreatedByInput, WorkflowTemplateUncheckedCreateWithoutCreatedByInput> | WorkflowTemplateCreateWithoutCreatedByInput[] | WorkflowTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WorkflowTemplateCreateOrConnectWithoutCreatedByInput | WorkflowTemplateCreateOrConnectWithoutCreatedByInput[]
    upsert?: WorkflowTemplateUpsertWithWhereUniqueWithoutCreatedByInput | WorkflowTemplateUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: WorkflowTemplateCreateManyCreatedByInputEnvelope
    set?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
    disconnect?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
    delete?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
    connect?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
    update?: WorkflowTemplateUpdateWithWhereUniqueWithoutCreatedByInput | WorkflowTemplateUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: WorkflowTemplateUpdateManyWithWhereWithoutCreatedByInput | WorkflowTemplateUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: WorkflowTemplateScalarWhereInput | WorkflowTemplateScalarWhereInput[]
  }

  export type AutomationRuleUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AutomationRuleCreateWithoutCreatedByInput, AutomationRuleUncheckedCreateWithoutCreatedByInput> | AutomationRuleCreateWithoutCreatedByInput[] | AutomationRuleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AutomationRuleCreateOrConnectWithoutCreatedByInput | AutomationRuleCreateOrConnectWithoutCreatedByInput[]
    upsert?: AutomationRuleUpsertWithWhereUniqueWithoutCreatedByInput | AutomationRuleUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AutomationRuleCreateManyCreatedByInputEnvelope
    set?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    disconnect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    delete?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    connect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    update?: AutomationRuleUpdateWithWhereUniqueWithoutCreatedByInput | AutomationRuleUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AutomationRuleUpdateManyWithWhereWithoutCreatedByInput | AutomationRuleUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AutomationRuleScalarWhereInput | AutomationRuleScalarWhereInput[]
  }

  export type TestPlanUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TestPlanCreateWithoutCreatedByInput, TestPlanUncheckedCreateWithoutCreatedByInput> | TestPlanCreateWithoutCreatedByInput[] | TestPlanUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TestPlanCreateOrConnectWithoutCreatedByInput | TestPlanCreateOrConnectWithoutCreatedByInput[]
    upsert?: TestPlanUpsertWithWhereUniqueWithoutCreatedByInput | TestPlanUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TestPlanCreateManyCreatedByInputEnvelope
    set?: TestPlanWhereUniqueInput | TestPlanWhereUniqueInput[]
    disconnect?: TestPlanWhereUniqueInput | TestPlanWhereUniqueInput[]
    delete?: TestPlanWhereUniqueInput | TestPlanWhereUniqueInput[]
    connect?: TestPlanWhereUniqueInput | TestPlanWhereUniqueInput[]
    update?: TestPlanUpdateWithWhereUniqueWithoutCreatedByInput | TestPlanUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TestPlanUpdateManyWithWhereWithoutCreatedByInput | TestPlanUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TestPlanScalarWhereInput | TestPlanScalarWhereInput[]
  }

  export type TestPlanUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<TestPlanCreateWithoutAssignedToInput, TestPlanUncheckedCreateWithoutAssignedToInput> | TestPlanCreateWithoutAssignedToInput[] | TestPlanUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TestPlanCreateOrConnectWithoutAssignedToInput | TestPlanCreateOrConnectWithoutAssignedToInput[]
    upsert?: TestPlanUpsertWithWhereUniqueWithoutAssignedToInput | TestPlanUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: TestPlanCreateManyAssignedToInputEnvelope
    set?: TestPlanWhereUniqueInput | TestPlanWhereUniqueInput[]
    disconnect?: TestPlanWhereUniqueInput | TestPlanWhereUniqueInput[]
    delete?: TestPlanWhereUniqueInput | TestPlanWhereUniqueInput[]
    connect?: TestPlanWhereUniqueInput | TestPlanWhereUniqueInput[]
    update?: TestPlanUpdateWithWhereUniqueWithoutAssignedToInput | TestPlanUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: TestPlanUpdateManyWithWhereWithoutAssignedToInput | TestPlanUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: TestPlanScalarWhereInput | TestPlanScalarWhereInput[]
  }

  export type TestCaseUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TestCaseCreateWithoutCreatedByInput, TestCaseUncheckedCreateWithoutCreatedByInput> | TestCaseCreateWithoutCreatedByInput[] | TestCaseUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TestCaseCreateOrConnectWithoutCreatedByInput | TestCaseCreateOrConnectWithoutCreatedByInput[]
    upsert?: TestCaseUpsertWithWhereUniqueWithoutCreatedByInput | TestCaseUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TestCaseCreateManyCreatedByInputEnvelope
    set?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    disconnect?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    delete?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    connect?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    update?: TestCaseUpdateWithWhereUniqueWithoutCreatedByInput | TestCaseUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TestCaseUpdateManyWithWhereWithoutCreatedByInput | TestCaseUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TestCaseScalarWhereInput | TestCaseScalarWhereInput[]
  }

  export type TestExecutionUncheckedUpdateManyWithoutExecutedByNestedInput = {
    create?: XOR<TestExecutionCreateWithoutExecutedByInput, TestExecutionUncheckedCreateWithoutExecutedByInput> | TestExecutionCreateWithoutExecutedByInput[] | TestExecutionUncheckedCreateWithoutExecutedByInput[]
    connectOrCreate?: TestExecutionCreateOrConnectWithoutExecutedByInput | TestExecutionCreateOrConnectWithoutExecutedByInput[]
    upsert?: TestExecutionUpsertWithWhereUniqueWithoutExecutedByInput | TestExecutionUpsertWithWhereUniqueWithoutExecutedByInput[]
    createMany?: TestExecutionCreateManyExecutedByInputEnvelope
    set?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
    disconnect?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
    delete?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
    connect?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
    update?: TestExecutionUpdateWithWhereUniqueWithoutExecutedByInput | TestExecutionUpdateWithWhereUniqueWithoutExecutedByInput[]
    updateMany?: TestExecutionUpdateManyWithWhereWithoutExecutedByInput | TestExecutionUpdateManyWithWhereWithoutExecutedByInput[]
    deleteMany?: TestExecutionScalarWhereInput | TestExecutionScalarWhereInput[]
  }

  export type DefectUncheckedUpdateManyWithoutReportedByNestedInput = {
    create?: XOR<DefectCreateWithoutReportedByInput, DefectUncheckedCreateWithoutReportedByInput> | DefectCreateWithoutReportedByInput[] | DefectUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: DefectCreateOrConnectWithoutReportedByInput | DefectCreateOrConnectWithoutReportedByInput[]
    upsert?: DefectUpsertWithWhereUniqueWithoutReportedByInput | DefectUpsertWithWhereUniqueWithoutReportedByInput[]
    createMany?: DefectCreateManyReportedByInputEnvelope
    set?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
    disconnect?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
    delete?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
    connect?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
    update?: DefectUpdateWithWhereUniqueWithoutReportedByInput | DefectUpdateWithWhereUniqueWithoutReportedByInput[]
    updateMany?: DefectUpdateManyWithWhereWithoutReportedByInput | DefectUpdateManyWithWhereWithoutReportedByInput[]
    deleteMany?: DefectScalarWhereInput | DefectScalarWhereInput[]
  }

  export type DefectUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<DefectCreateWithoutAssignedToInput, DefectUncheckedCreateWithoutAssignedToInput> | DefectCreateWithoutAssignedToInput[] | DefectUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: DefectCreateOrConnectWithoutAssignedToInput | DefectCreateOrConnectWithoutAssignedToInput[]
    upsert?: DefectUpsertWithWhereUniqueWithoutAssignedToInput | DefectUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: DefectCreateManyAssignedToInputEnvelope
    set?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
    disconnect?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
    delete?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
    connect?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
    update?: DefectUpdateWithWhereUniqueWithoutAssignedToInput | DefectUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: DefectUpdateManyWithWhereWithoutAssignedToInput | DefectUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: DefectScalarWhereInput | DefectScalarWhereInput[]
  }

  export type QAReviewUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<QAReviewCreateWithoutReviewerInput, QAReviewUncheckedCreateWithoutReviewerInput> | QAReviewCreateWithoutReviewerInput[] | QAReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: QAReviewCreateOrConnectWithoutReviewerInput | QAReviewCreateOrConnectWithoutReviewerInput[]
    upsert?: QAReviewUpsertWithWhereUniqueWithoutReviewerInput | QAReviewUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: QAReviewCreateManyReviewerInputEnvelope
    set?: QAReviewWhereUniqueInput | QAReviewWhereUniqueInput[]
    disconnect?: QAReviewWhereUniqueInput | QAReviewWhereUniqueInput[]
    delete?: QAReviewWhereUniqueInput | QAReviewWhereUniqueInput[]
    connect?: QAReviewWhereUniqueInput | QAReviewWhereUniqueInput[]
    update?: QAReviewUpdateWithWhereUniqueWithoutReviewerInput | QAReviewUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: QAReviewUpdateManyWithWhereWithoutReviewerInput | QAReviewUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: QAReviewScalarWhereInput | QAReviewScalarWhereInput[]
  }

  export type AccountCreateemailsInput = {
    set: string[]
  }

  export type AccountCreatephonesInput = {
    set: string[]
  }

  export type AccountCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutOwnedAccountsInput = {
    create?: XOR<UserCreateWithoutOwnedAccountsInput, UserUncheckedCreateWithoutOwnedAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type ActivityCreateNestedManyWithoutAccountInput = {
    create?: XOR<ActivityCreateWithoutAccountInput, ActivityUncheckedCreateWithoutAccountInput> | ActivityCreateWithoutAccountInput[] | ActivityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutAccountInput | ActivityCreateOrConnectWithoutAccountInput[]
    createMany?: ActivityCreateManyAccountInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutAccountInput = {
    create?: XOR<AppointmentCreateWithoutAccountInput, AppointmentUncheckedCreateWithoutAccountInput> | AppointmentCreateWithoutAccountInput[] | AppointmentUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutAccountInput | AppointmentCreateOrConnectWithoutAccountInput[]
    createMany?: AppointmentCreateManyAccountInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type CompletedProjectCreateNestedManyWithoutAccountInput = {
    create?: XOR<CompletedProjectCreateWithoutAccountInput, CompletedProjectUncheckedCreateWithoutAccountInput> | CompletedProjectCreateWithoutAccountInput[] | CompletedProjectUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CompletedProjectCreateOrConnectWithoutAccountInput | CompletedProjectCreateOrConnectWithoutAccountInput[]
    createMany?: CompletedProjectCreateManyAccountInputEnvelope
    connect?: CompletedProjectWhereUniqueInput | CompletedProjectWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutAccountInput = {
    create?: XOR<ContactCreateWithoutAccountInput, ContactUncheckedCreateWithoutAccountInput> | ContactCreateWithoutAccountInput[] | ContactUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutAccountInput | ContactCreateOrConnectWithoutAccountInput[]
    createMany?: ContactCreateManyAccountInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutAccountInput = {
    create?: XOR<DocumentCreateWithoutAccountInput, DocumentUncheckedCreateWithoutAccountInput> | DocumentCreateWithoutAccountInput[] | DocumentUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutAccountInput | DocumentCreateOrConnectWithoutAccountInput[]
    createMany?: DocumentCreateManyAccountInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type EnquiryCreateNestedManyWithoutAccountInput = {
    create?: XOR<EnquiryCreateWithoutAccountInput, EnquiryUncheckedCreateWithoutAccountInput> | EnquiryCreateWithoutAccountInput[] | EnquiryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: EnquiryCreateOrConnectWithoutAccountInput | EnquiryCreateOrConnectWithoutAccountInput[]
    createMany?: EnquiryCreateManyAccountInputEnvelope
    connect?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
  }

  export type EventLogCreateNestedManyWithoutAccountInput = {
    create?: XOR<EventLogCreateWithoutAccountInput, EventLogUncheckedCreateWithoutAccountInput> | EventLogCreateWithoutAccountInput[] | EventLogUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: EventLogCreateOrConnectWithoutAccountInput | EventLogCreateOrConnectWithoutAccountInput[]
    createMany?: EventLogCreateManyAccountInputEnvelope
    connect?: EventLogWhereUniqueInput | EventLogWhereUniqueInput[]
  }

  export type LeadCreateNestedManyWithoutAccountInput = {
    create?: XOR<LeadCreateWithoutAccountInput, LeadUncheckedCreateWithoutAccountInput> | LeadCreateWithoutAccountInput[] | LeadUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutAccountInput | LeadCreateOrConnectWithoutAccountInput[]
    createMany?: LeadCreateManyAccountInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutAccountInput = {
    create?: XOR<ProjectCreateWithoutAccountInput, ProjectUncheckedCreateWithoutAccountInput> | ProjectCreateWithoutAccountInput[] | ProjectUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutAccountInput | ProjectCreateOrConnectWithoutAccountInput[]
    createMany?: ProjectCreateManyAccountInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type SnagCreateNestedManyWithoutAccountInput = {
    create?: XOR<SnagCreateWithoutAccountInput, SnagUncheckedCreateWithoutAccountInput> | SnagCreateWithoutAccountInput[] | SnagUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SnagCreateOrConnectWithoutAccountInput | SnagCreateOrConnectWithoutAccountInput[]
    createMany?: SnagCreateManyAccountInputEnvelope
    connect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutAccountInput = {
    create?: XOR<TaskCreateWithoutAccountInput, TaskUncheckedCreateWithoutAccountInput> | TaskCreateWithoutAccountInput[] | TaskUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAccountInput | TaskCreateOrConnectWithoutAccountInput[]
    createMany?: TaskCreateManyAccountInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type WorkflowDefinitionCreateNestedManyWithoutAccountInput = {
    create?: XOR<WorkflowDefinitionCreateWithoutAccountInput, WorkflowDefinitionUncheckedCreateWithoutAccountInput> | WorkflowDefinitionCreateWithoutAccountInput[] | WorkflowDefinitionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: WorkflowDefinitionCreateOrConnectWithoutAccountInput | WorkflowDefinitionCreateOrConnectWithoutAccountInput[]
    createMany?: WorkflowDefinitionCreateManyAccountInputEnvelope
    connect?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
  }

  export type WorkflowInstanceCreateNestedManyWithoutAccountInput = {
    create?: XOR<WorkflowInstanceCreateWithoutAccountInput, WorkflowInstanceUncheckedCreateWithoutAccountInput> | WorkflowInstanceCreateWithoutAccountInput[] | WorkflowInstanceUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutAccountInput | WorkflowInstanceCreateOrConnectWithoutAccountInput[]
    createMany?: WorkflowInstanceCreateManyAccountInputEnvelope
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
  }

  export type WorkflowTemplateCreateNestedManyWithoutAccountInput = {
    create?: XOR<WorkflowTemplateCreateWithoutAccountInput, WorkflowTemplateUncheckedCreateWithoutAccountInput> | WorkflowTemplateCreateWithoutAccountInput[] | WorkflowTemplateUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: WorkflowTemplateCreateOrConnectWithoutAccountInput | WorkflowTemplateCreateOrConnectWithoutAccountInput[]
    createMany?: WorkflowTemplateCreateManyAccountInputEnvelope
    connect?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
  }

  export type AutomationRuleCreateNestedManyWithoutAccountInput = {
    create?: XOR<AutomationRuleCreateWithoutAccountInput, AutomationRuleUncheckedCreateWithoutAccountInput> | AutomationRuleCreateWithoutAccountInput[] | AutomationRuleUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AutomationRuleCreateOrConnectWithoutAccountInput | AutomationRuleCreateOrConnectWithoutAccountInput[]
    createMany?: AutomationRuleCreateManyAccountInputEnvelope
    connect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<ActivityCreateWithoutAccountInput, ActivityUncheckedCreateWithoutAccountInput> | ActivityCreateWithoutAccountInput[] | ActivityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutAccountInput | ActivityCreateOrConnectWithoutAccountInput[]
    createMany?: ActivityCreateManyAccountInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<AppointmentCreateWithoutAccountInput, AppointmentUncheckedCreateWithoutAccountInput> | AppointmentCreateWithoutAccountInput[] | AppointmentUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutAccountInput | AppointmentCreateOrConnectWithoutAccountInput[]
    createMany?: AppointmentCreateManyAccountInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type CompletedProjectUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<CompletedProjectCreateWithoutAccountInput, CompletedProjectUncheckedCreateWithoutAccountInput> | CompletedProjectCreateWithoutAccountInput[] | CompletedProjectUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CompletedProjectCreateOrConnectWithoutAccountInput | CompletedProjectCreateOrConnectWithoutAccountInput[]
    createMany?: CompletedProjectCreateManyAccountInputEnvelope
    connect?: CompletedProjectWhereUniqueInput | CompletedProjectWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<ContactCreateWithoutAccountInput, ContactUncheckedCreateWithoutAccountInput> | ContactCreateWithoutAccountInput[] | ContactUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutAccountInput | ContactCreateOrConnectWithoutAccountInput[]
    createMany?: ContactCreateManyAccountInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<DocumentCreateWithoutAccountInput, DocumentUncheckedCreateWithoutAccountInput> | DocumentCreateWithoutAccountInput[] | DocumentUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutAccountInput | DocumentCreateOrConnectWithoutAccountInput[]
    createMany?: DocumentCreateManyAccountInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type EnquiryUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<EnquiryCreateWithoutAccountInput, EnquiryUncheckedCreateWithoutAccountInput> | EnquiryCreateWithoutAccountInput[] | EnquiryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: EnquiryCreateOrConnectWithoutAccountInput | EnquiryCreateOrConnectWithoutAccountInput[]
    createMany?: EnquiryCreateManyAccountInputEnvelope
    connect?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
  }

  export type EventLogUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<EventLogCreateWithoutAccountInput, EventLogUncheckedCreateWithoutAccountInput> | EventLogCreateWithoutAccountInput[] | EventLogUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: EventLogCreateOrConnectWithoutAccountInput | EventLogCreateOrConnectWithoutAccountInput[]
    createMany?: EventLogCreateManyAccountInputEnvelope
    connect?: EventLogWhereUniqueInput | EventLogWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<LeadCreateWithoutAccountInput, LeadUncheckedCreateWithoutAccountInput> | LeadCreateWithoutAccountInput[] | LeadUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutAccountInput | LeadCreateOrConnectWithoutAccountInput[]
    createMany?: LeadCreateManyAccountInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<ProjectCreateWithoutAccountInput, ProjectUncheckedCreateWithoutAccountInput> | ProjectCreateWithoutAccountInput[] | ProjectUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutAccountInput | ProjectCreateOrConnectWithoutAccountInput[]
    createMany?: ProjectCreateManyAccountInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type SnagUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<SnagCreateWithoutAccountInput, SnagUncheckedCreateWithoutAccountInput> | SnagCreateWithoutAccountInput[] | SnagUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SnagCreateOrConnectWithoutAccountInput | SnagCreateOrConnectWithoutAccountInput[]
    createMany?: SnagCreateManyAccountInputEnvelope
    connect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<TaskCreateWithoutAccountInput, TaskUncheckedCreateWithoutAccountInput> | TaskCreateWithoutAccountInput[] | TaskUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAccountInput | TaskCreateOrConnectWithoutAccountInput[]
    createMany?: TaskCreateManyAccountInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type WorkflowDefinitionUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<WorkflowDefinitionCreateWithoutAccountInput, WorkflowDefinitionUncheckedCreateWithoutAccountInput> | WorkflowDefinitionCreateWithoutAccountInput[] | WorkflowDefinitionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: WorkflowDefinitionCreateOrConnectWithoutAccountInput | WorkflowDefinitionCreateOrConnectWithoutAccountInput[]
    createMany?: WorkflowDefinitionCreateManyAccountInputEnvelope
    connect?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
  }

  export type WorkflowInstanceUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<WorkflowInstanceCreateWithoutAccountInput, WorkflowInstanceUncheckedCreateWithoutAccountInput> | WorkflowInstanceCreateWithoutAccountInput[] | WorkflowInstanceUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutAccountInput | WorkflowInstanceCreateOrConnectWithoutAccountInput[]
    createMany?: WorkflowInstanceCreateManyAccountInputEnvelope
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
  }

  export type WorkflowTemplateUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<WorkflowTemplateCreateWithoutAccountInput, WorkflowTemplateUncheckedCreateWithoutAccountInput> | WorkflowTemplateCreateWithoutAccountInput[] | WorkflowTemplateUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: WorkflowTemplateCreateOrConnectWithoutAccountInput | WorkflowTemplateCreateOrConnectWithoutAccountInput[]
    createMany?: WorkflowTemplateCreateManyAccountInputEnvelope
    connect?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
  }

  export type AutomationRuleUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<AutomationRuleCreateWithoutAccountInput, AutomationRuleUncheckedCreateWithoutAccountInput> | AutomationRuleCreateWithoutAccountInput[] | AutomationRuleUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AutomationRuleCreateOrConnectWithoutAccountInput | AutomationRuleCreateOrConnectWithoutAccountInput[]
    createMany?: AutomationRuleCreateManyAccountInputEnvelope
    connect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
  }

  export type AccountUpdateemailsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AccountUpdatephonesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AccountUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumAccountStatusFieldUpdateOperationsInput = {
    set?: $Enums.AccountStatus
  }

  export type UserUpdateOneRequiredWithoutOwnedAccountsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedAccountsInput, UserUncheckedCreateWithoutOwnedAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedAccountsInput
    upsert?: UserUpsertWithoutOwnedAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedAccountsInput, UserUpdateWithoutOwnedAccountsInput>, UserUncheckedUpdateWithoutOwnedAccountsInput>
  }

  export type ActivityUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ActivityCreateWithoutAccountInput, ActivityUncheckedCreateWithoutAccountInput> | ActivityCreateWithoutAccountInput[] | ActivityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutAccountInput | ActivityCreateOrConnectWithoutAccountInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutAccountInput | ActivityUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ActivityCreateManyAccountInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutAccountInput | ActivityUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutAccountInput | ActivityUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutAccountNestedInput = {
    create?: XOR<AppointmentCreateWithoutAccountInput, AppointmentUncheckedCreateWithoutAccountInput> | AppointmentCreateWithoutAccountInput[] | AppointmentUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutAccountInput | AppointmentCreateOrConnectWithoutAccountInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutAccountInput | AppointmentUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: AppointmentCreateManyAccountInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutAccountInput | AppointmentUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutAccountInput | AppointmentUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type CompletedProjectUpdateManyWithoutAccountNestedInput = {
    create?: XOR<CompletedProjectCreateWithoutAccountInput, CompletedProjectUncheckedCreateWithoutAccountInput> | CompletedProjectCreateWithoutAccountInput[] | CompletedProjectUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CompletedProjectCreateOrConnectWithoutAccountInput | CompletedProjectCreateOrConnectWithoutAccountInput[]
    upsert?: CompletedProjectUpsertWithWhereUniqueWithoutAccountInput | CompletedProjectUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: CompletedProjectCreateManyAccountInputEnvelope
    set?: CompletedProjectWhereUniqueInput | CompletedProjectWhereUniqueInput[]
    disconnect?: CompletedProjectWhereUniqueInput | CompletedProjectWhereUniqueInput[]
    delete?: CompletedProjectWhereUniqueInput | CompletedProjectWhereUniqueInput[]
    connect?: CompletedProjectWhereUniqueInput | CompletedProjectWhereUniqueInput[]
    update?: CompletedProjectUpdateWithWhereUniqueWithoutAccountInput | CompletedProjectUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: CompletedProjectUpdateManyWithWhereWithoutAccountInput | CompletedProjectUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: CompletedProjectScalarWhereInput | CompletedProjectScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ContactCreateWithoutAccountInput, ContactUncheckedCreateWithoutAccountInput> | ContactCreateWithoutAccountInput[] | ContactUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutAccountInput | ContactCreateOrConnectWithoutAccountInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutAccountInput | ContactUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ContactCreateManyAccountInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutAccountInput | ContactUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutAccountInput | ContactUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutAccountNestedInput = {
    create?: XOR<DocumentCreateWithoutAccountInput, DocumentUncheckedCreateWithoutAccountInput> | DocumentCreateWithoutAccountInput[] | DocumentUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutAccountInput | DocumentCreateOrConnectWithoutAccountInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutAccountInput | DocumentUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: DocumentCreateManyAccountInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutAccountInput | DocumentUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutAccountInput | DocumentUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type EnquiryUpdateManyWithoutAccountNestedInput = {
    create?: XOR<EnquiryCreateWithoutAccountInput, EnquiryUncheckedCreateWithoutAccountInput> | EnquiryCreateWithoutAccountInput[] | EnquiryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: EnquiryCreateOrConnectWithoutAccountInput | EnquiryCreateOrConnectWithoutAccountInput[]
    upsert?: EnquiryUpsertWithWhereUniqueWithoutAccountInput | EnquiryUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: EnquiryCreateManyAccountInputEnvelope
    set?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    disconnect?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    delete?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    connect?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    update?: EnquiryUpdateWithWhereUniqueWithoutAccountInput | EnquiryUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: EnquiryUpdateManyWithWhereWithoutAccountInput | EnquiryUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: EnquiryScalarWhereInput | EnquiryScalarWhereInput[]
  }

  export type EventLogUpdateManyWithoutAccountNestedInput = {
    create?: XOR<EventLogCreateWithoutAccountInput, EventLogUncheckedCreateWithoutAccountInput> | EventLogCreateWithoutAccountInput[] | EventLogUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: EventLogCreateOrConnectWithoutAccountInput | EventLogCreateOrConnectWithoutAccountInput[]
    upsert?: EventLogUpsertWithWhereUniqueWithoutAccountInput | EventLogUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: EventLogCreateManyAccountInputEnvelope
    set?: EventLogWhereUniqueInput | EventLogWhereUniqueInput[]
    disconnect?: EventLogWhereUniqueInput | EventLogWhereUniqueInput[]
    delete?: EventLogWhereUniqueInput | EventLogWhereUniqueInput[]
    connect?: EventLogWhereUniqueInput | EventLogWhereUniqueInput[]
    update?: EventLogUpdateWithWhereUniqueWithoutAccountInput | EventLogUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: EventLogUpdateManyWithWhereWithoutAccountInput | EventLogUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: EventLogScalarWhereInput | EventLogScalarWhereInput[]
  }

  export type LeadUpdateManyWithoutAccountNestedInput = {
    create?: XOR<LeadCreateWithoutAccountInput, LeadUncheckedCreateWithoutAccountInput> | LeadCreateWithoutAccountInput[] | LeadUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutAccountInput | LeadCreateOrConnectWithoutAccountInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutAccountInput | LeadUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: LeadCreateManyAccountInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutAccountInput | LeadUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutAccountInput | LeadUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ProjectCreateWithoutAccountInput, ProjectUncheckedCreateWithoutAccountInput> | ProjectCreateWithoutAccountInput[] | ProjectUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutAccountInput | ProjectCreateOrConnectWithoutAccountInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutAccountInput | ProjectUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ProjectCreateManyAccountInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutAccountInput | ProjectUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutAccountInput | ProjectUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type SnagUpdateManyWithoutAccountNestedInput = {
    create?: XOR<SnagCreateWithoutAccountInput, SnagUncheckedCreateWithoutAccountInput> | SnagCreateWithoutAccountInput[] | SnagUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SnagCreateOrConnectWithoutAccountInput | SnagCreateOrConnectWithoutAccountInput[]
    upsert?: SnagUpsertWithWhereUniqueWithoutAccountInput | SnagUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: SnagCreateManyAccountInputEnvelope
    set?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    disconnect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    delete?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    connect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    update?: SnagUpdateWithWhereUniqueWithoutAccountInput | SnagUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: SnagUpdateManyWithWhereWithoutAccountInput | SnagUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: SnagScalarWhereInput | SnagScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutAccountNestedInput = {
    create?: XOR<TaskCreateWithoutAccountInput, TaskUncheckedCreateWithoutAccountInput> | TaskCreateWithoutAccountInput[] | TaskUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAccountInput | TaskCreateOrConnectWithoutAccountInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAccountInput | TaskUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: TaskCreateManyAccountInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAccountInput | TaskUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAccountInput | TaskUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type WorkflowDefinitionUpdateManyWithoutAccountNestedInput = {
    create?: XOR<WorkflowDefinitionCreateWithoutAccountInput, WorkflowDefinitionUncheckedCreateWithoutAccountInput> | WorkflowDefinitionCreateWithoutAccountInput[] | WorkflowDefinitionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: WorkflowDefinitionCreateOrConnectWithoutAccountInput | WorkflowDefinitionCreateOrConnectWithoutAccountInput[]
    upsert?: WorkflowDefinitionUpsertWithWhereUniqueWithoutAccountInput | WorkflowDefinitionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: WorkflowDefinitionCreateManyAccountInputEnvelope
    set?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
    disconnect?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
    delete?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
    connect?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
    update?: WorkflowDefinitionUpdateWithWhereUniqueWithoutAccountInput | WorkflowDefinitionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: WorkflowDefinitionUpdateManyWithWhereWithoutAccountInput | WorkflowDefinitionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: WorkflowDefinitionScalarWhereInput | WorkflowDefinitionScalarWhereInput[]
  }

  export type WorkflowInstanceUpdateManyWithoutAccountNestedInput = {
    create?: XOR<WorkflowInstanceCreateWithoutAccountInput, WorkflowInstanceUncheckedCreateWithoutAccountInput> | WorkflowInstanceCreateWithoutAccountInput[] | WorkflowInstanceUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutAccountInput | WorkflowInstanceCreateOrConnectWithoutAccountInput[]
    upsert?: WorkflowInstanceUpsertWithWhereUniqueWithoutAccountInput | WorkflowInstanceUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: WorkflowInstanceCreateManyAccountInputEnvelope
    set?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    disconnect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    delete?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    update?: WorkflowInstanceUpdateWithWhereUniqueWithoutAccountInput | WorkflowInstanceUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: WorkflowInstanceUpdateManyWithWhereWithoutAccountInput | WorkflowInstanceUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: WorkflowInstanceScalarWhereInput | WorkflowInstanceScalarWhereInput[]
  }

  export type WorkflowTemplateUpdateManyWithoutAccountNestedInput = {
    create?: XOR<WorkflowTemplateCreateWithoutAccountInput, WorkflowTemplateUncheckedCreateWithoutAccountInput> | WorkflowTemplateCreateWithoutAccountInput[] | WorkflowTemplateUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: WorkflowTemplateCreateOrConnectWithoutAccountInput | WorkflowTemplateCreateOrConnectWithoutAccountInput[]
    upsert?: WorkflowTemplateUpsertWithWhereUniqueWithoutAccountInput | WorkflowTemplateUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: WorkflowTemplateCreateManyAccountInputEnvelope
    set?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
    disconnect?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
    delete?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
    connect?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
    update?: WorkflowTemplateUpdateWithWhereUniqueWithoutAccountInput | WorkflowTemplateUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: WorkflowTemplateUpdateManyWithWhereWithoutAccountInput | WorkflowTemplateUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: WorkflowTemplateScalarWhereInput | WorkflowTemplateScalarWhereInput[]
  }

  export type AutomationRuleUpdateManyWithoutAccountNestedInput = {
    create?: XOR<AutomationRuleCreateWithoutAccountInput, AutomationRuleUncheckedCreateWithoutAccountInput> | AutomationRuleCreateWithoutAccountInput[] | AutomationRuleUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AutomationRuleCreateOrConnectWithoutAccountInput | AutomationRuleCreateOrConnectWithoutAccountInput[]
    upsert?: AutomationRuleUpsertWithWhereUniqueWithoutAccountInput | AutomationRuleUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: AutomationRuleCreateManyAccountInputEnvelope
    set?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    disconnect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    delete?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    connect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    update?: AutomationRuleUpdateWithWhereUniqueWithoutAccountInput | AutomationRuleUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: AutomationRuleUpdateManyWithWhereWithoutAccountInput | AutomationRuleUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: AutomationRuleScalarWhereInput | AutomationRuleScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ActivityCreateWithoutAccountInput, ActivityUncheckedCreateWithoutAccountInput> | ActivityCreateWithoutAccountInput[] | ActivityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutAccountInput | ActivityCreateOrConnectWithoutAccountInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutAccountInput | ActivityUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ActivityCreateManyAccountInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutAccountInput | ActivityUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutAccountInput | ActivityUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<AppointmentCreateWithoutAccountInput, AppointmentUncheckedCreateWithoutAccountInput> | AppointmentCreateWithoutAccountInput[] | AppointmentUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutAccountInput | AppointmentCreateOrConnectWithoutAccountInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutAccountInput | AppointmentUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: AppointmentCreateManyAccountInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutAccountInput | AppointmentUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutAccountInput | AppointmentUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type CompletedProjectUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<CompletedProjectCreateWithoutAccountInput, CompletedProjectUncheckedCreateWithoutAccountInput> | CompletedProjectCreateWithoutAccountInput[] | CompletedProjectUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CompletedProjectCreateOrConnectWithoutAccountInput | CompletedProjectCreateOrConnectWithoutAccountInput[]
    upsert?: CompletedProjectUpsertWithWhereUniqueWithoutAccountInput | CompletedProjectUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: CompletedProjectCreateManyAccountInputEnvelope
    set?: CompletedProjectWhereUniqueInput | CompletedProjectWhereUniqueInput[]
    disconnect?: CompletedProjectWhereUniqueInput | CompletedProjectWhereUniqueInput[]
    delete?: CompletedProjectWhereUniqueInput | CompletedProjectWhereUniqueInput[]
    connect?: CompletedProjectWhereUniqueInput | CompletedProjectWhereUniqueInput[]
    update?: CompletedProjectUpdateWithWhereUniqueWithoutAccountInput | CompletedProjectUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: CompletedProjectUpdateManyWithWhereWithoutAccountInput | CompletedProjectUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: CompletedProjectScalarWhereInput | CompletedProjectScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ContactCreateWithoutAccountInput, ContactUncheckedCreateWithoutAccountInput> | ContactCreateWithoutAccountInput[] | ContactUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutAccountInput | ContactCreateOrConnectWithoutAccountInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutAccountInput | ContactUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ContactCreateManyAccountInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutAccountInput | ContactUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutAccountInput | ContactUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<DocumentCreateWithoutAccountInput, DocumentUncheckedCreateWithoutAccountInput> | DocumentCreateWithoutAccountInput[] | DocumentUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutAccountInput | DocumentCreateOrConnectWithoutAccountInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutAccountInput | DocumentUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: DocumentCreateManyAccountInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutAccountInput | DocumentUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutAccountInput | DocumentUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type EnquiryUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<EnquiryCreateWithoutAccountInput, EnquiryUncheckedCreateWithoutAccountInput> | EnquiryCreateWithoutAccountInput[] | EnquiryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: EnquiryCreateOrConnectWithoutAccountInput | EnquiryCreateOrConnectWithoutAccountInput[]
    upsert?: EnquiryUpsertWithWhereUniqueWithoutAccountInput | EnquiryUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: EnquiryCreateManyAccountInputEnvelope
    set?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    disconnect?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    delete?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    connect?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    update?: EnquiryUpdateWithWhereUniqueWithoutAccountInput | EnquiryUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: EnquiryUpdateManyWithWhereWithoutAccountInput | EnquiryUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: EnquiryScalarWhereInput | EnquiryScalarWhereInput[]
  }

  export type EventLogUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<EventLogCreateWithoutAccountInput, EventLogUncheckedCreateWithoutAccountInput> | EventLogCreateWithoutAccountInput[] | EventLogUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: EventLogCreateOrConnectWithoutAccountInput | EventLogCreateOrConnectWithoutAccountInput[]
    upsert?: EventLogUpsertWithWhereUniqueWithoutAccountInput | EventLogUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: EventLogCreateManyAccountInputEnvelope
    set?: EventLogWhereUniqueInput | EventLogWhereUniqueInput[]
    disconnect?: EventLogWhereUniqueInput | EventLogWhereUniqueInput[]
    delete?: EventLogWhereUniqueInput | EventLogWhereUniqueInput[]
    connect?: EventLogWhereUniqueInput | EventLogWhereUniqueInput[]
    update?: EventLogUpdateWithWhereUniqueWithoutAccountInput | EventLogUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: EventLogUpdateManyWithWhereWithoutAccountInput | EventLogUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: EventLogScalarWhereInput | EventLogScalarWhereInput[]
  }

  export type LeadUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<LeadCreateWithoutAccountInput, LeadUncheckedCreateWithoutAccountInput> | LeadCreateWithoutAccountInput[] | LeadUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutAccountInput | LeadCreateOrConnectWithoutAccountInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutAccountInput | LeadUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: LeadCreateManyAccountInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutAccountInput | LeadUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutAccountInput | LeadUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ProjectCreateWithoutAccountInput, ProjectUncheckedCreateWithoutAccountInput> | ProjectCreateWithoutAccountInput[] | ProjectUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutAccountInput | ProjectCreateOrConnectWithoutAccountInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutAccountInput | ProjectUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ProjectCreateManyAccountInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutAccountInput | ProjectUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutAccountInput | ProjectUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type SnagUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<SnagCreateWithoutAccountInput, SnagUncheckedCreateWithoutAccountInput> | SnagCreateWithoutAccountInput[] | SnagUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SnagCreateOrConnectWithoutAccountInput | SnagCreateOrConnectWithoutAccountInput[]
    upsert?: SnagUpsertWithWhereUniqueWithoutAccountInput | SnagUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: SnagCreateManyAccountInputEnvelope
    set?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    disconnect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    delete?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    connect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    update?: SnagUpdateWithWhereUniqueWithoutAccountInput | SnagUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: SnagUpdateManyWithWhereWithoutAccountInput | SnagUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: SnagScalarWhereInput | SnagScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<TaskCreateWithoutAccountInput, TaskUncheckedCreateWithoutAccountInput> | TaskCreateWithoutAccountInput[] | TaskUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAccountInput | TaskCreateOrConnectWithoutAccountInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAccountInput | TaskUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: TaskCreateManyAccountInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAccountInput | TaskUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAccountInput | TaskUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type WorkflowDefinitionUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<WorkflowDefinitionCreateWithoutAccountInput, WorkflowDefinitionUncheckedCreateWithoutAccountInput> | WorkflowDefinitionCreateWithoutAccountInput[] | WorkflowDefinitionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: WorkflowDefinitionCreateOrConnectWithoutAccountInput | WorkflowDefinitionCreateOrConnectWithoutAccountInput[]
    upsert?: WorkflowDefinitionUpsertWithWhereUniqueWithoutAccountInput | WorkflowDefinitionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: WorkflowDefinitionCreateManyAccountInputEnvelope
    set?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
    disconnect?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
    delete?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
    connect?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
    update?: WorkflowDefinitionUpdateWithWhereUniqueWithoutAccountInput | WorkflowDefinitionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: WorkflowDefinitionUpdateManyWithWhereWithoutAccountInput | WorkflowDefinitionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: WorkflowDefinitionScalarWhereInput | WorkflowDefinitionScalarWhereInput[]
  }

  export type WorkflowInstanceUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<WorkflowInstanceCreateWithoutAccountInput, WorkflowInstanceUncheckedCreateWithoutAccountInput> | WorkflowInstanceCreateWithoutAccountInput[] | WorkflowInstanceUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutAccountInput | WorkflowInstanceCreateOrConnectWithoutAccountInput[]
    upsert?: WorkflowInstanceUpsertWithWhereUniqueWithoutAccountInput | WorkflowInstanceUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: WorkflowInstanceCreateManyAccountInputEnvelope
    set?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    disconnect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    delete?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    update?: WorkflowInstanceUpdateWithWhereUniqueWithoutAccountInput | WorkflowInstanceUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: WorkflowInstanceUpdateManyWithWhereWithoutAccountInput | WorkflowInstanceUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: WorkflowInstanceScalarWhereInput | WorkflowInstanceScalarWhereInput[]
  }

  export type WorkflowTemplateUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<WorkflowTemplateCreateWithoutAccountInput, WorkflowTemplateUncheckedCreateWithoutAccountInput> | WorkflowTemplateCreateWithoutAccountInput[] | WorkflowTemplateUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: WorkflowTemplateCreateOrConnectWithoutAccountInput | WorkflowTemplateCreateOrConnectWithoutAccountInput[]
    upsert?: WorkflowTemplateUpsertWithWhereUniqueWithoutAccountInput | WorkflowTemplateUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: WorkflowTemplateCreateManyAccountInputEnvelope
    set?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
    disconnect?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
    delete?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
    connect?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
    update?: WorkflowTemplateUpdateWithWhereUniqueWithoutAccountInput | WorkflowTemplateUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: WorkflowTemplateUpdateManyWithWhereWithoutAccountInput | WorkflowTemplateUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: WorkflowTemplateScalarWhereInput | WorkflowTemplateScalarWhereInput[]
  }

  export type AutomationRuleUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<AutomationRuleCreateWithoutAccountInput, AutomationRuleUncheckedCreateWithoutAccountInput> | AutomationRuleCreateWithoutAccountInput[] | AutomationRuleUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AutomationRuleCreateOrConnectWithoutAccountInput | AutomationRuleCreateOrConnectWithoutAccountInput[]
    upsert?: AutomationRuleUpsertWithWhereUniqueWithoutAccountInput | AutomationRuleUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: AutomationRuleCreateManyAccountInputEnvelope
    set?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    disconnect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    delete?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    connect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    update?: AutomationRuleUpdateWithWhereUniqueWithoutAccountInput | AutomationRuleUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: AutomationRuleUpdateManyWithWhereWithoutAccountInput | AutomationRuleUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: AutomationRuleScalarWhereInput | AutomationRuleScalarWhereInput[]
  }

  export type ActivityCreateNestedManyWithoutEnquiryInput = {
    create?: XOR<ActivityCreateWithoutEnquiryInput, ActivityUncheckedCreateWithoutEnquiryInput> | ActivityCreateWithoutEnquiryInput[] | ActivityUncheckedCreateWithoutEnquiryInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutEnquiryInput | ActivityCreateOrConnectWithoutEnquiryInput[]
    createMany?: ActivityCreateManyEnquiryInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type AccountCreateNestedOneWithoutEnquiriesInput = {
    create?: XOR<AccountCreateWithoutEnquiriesInput, AccountUncheckedCreateWithoutEnquiriesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutEnquiriesInput
    connect?: AccountWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOwnedEnquiriesInput = {
    create?: XOR<UserCreateWithoutOwnedEnquiriesInput, UserUncheckedCreateWithoutOwnedEnquiriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedEnquiriesInput
    connect?: UserWhereUniqueInput
  }

  export type LeadCreateNestedOneWithoutEnquiryInput = {
    create?: XOR<LeadCreateWithoutEnquiryInput, LeadUncheckedCreateWithoutEnquiryInput>
    connectOrCreate?: LeadCreateOrConnectWithoutEnquiryInput
    connect?: LeadWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutEnquiryInput = {
    create?: XOR<TaskCreateWithoutEnquiryInput, TaskUncheckedCreateWithoutEnquiryInput> | TaskCreateWithoutEnquiryInput[] | TaskUncheckedCreateWithoutEnquiryInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutEnquiryInput | TaskCreateOrConnectWithoutEnquiryInput[]
    createMany?: TaskCreateManyEnquiryInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutEnquiryInput = {
    create?: XOR<ActivityCreateWithoutEnquiryInput, ActivityUncheckedCreateWithoutEnquiryInput> | ActivityCreateWithoutEnquiryInput[] | ActivityUncheckedCreateWithoutEnquiryInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutEnquiryInput | ActivityCreateOrConnectWithoutEnquiryInput[]
    createMany?: ActivityCreateManyEnquiryInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedOneWithoutEnquiryInput = {
    create?: XOR<LeadCreateWithoutEnquiryInput, LeadUncheckedCreateWithoutEnquiryInput>
    connectOrCreate?: LeadCreateOrConnectWithoutEnquiryInput
    connect?: LeadWhereUniqueInput
  }

  export type TaskUncheckedCreateNestedManyWithoutEnquiryInput = {
    create?: XOR<TaskCreateWithoutEnquiryInput, TaskUncheckedCreateWithoutEnquiryInput> | TaskCreateWithoutEnquiryInput[] | TaskUncheckedCreateWithoutEnquiryInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutEnquiryInput | TaskCreateOrConnectWithoutEnquiryInput[]
    createMany?: TaskCreateManyEnquiryInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type EnumEnquiryStatusFieldUpdateOperationsInput = {
    set?: $Enums.EnquiryStatus
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ActivityUpdateManyWithoutEnquiryNestedInput = {
    create?: XOR<ActivityCreateWithoutEnquiryInput, ActivityUncheckedCreateWithoutEnquiryInput> | ActivityCreateWithoutEnquiryInput[] | ActivityUncheckedCreateWithoutEnquiryInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutEnquiryInput | ActivityCreateOrConnectWithoutEnquiryInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutEnquiryInput | ActivityUpsertWithWhereUniqueWithoutEnquiryInput[]
    createMany?: ActivityCreateManyEnquiryInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutEnquiryInput | ActivityUpdateWithWhereUniqueWithoutEnquiryInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutEnquiryInput | ActivityUpdateManyWithWhereWithoutEnquiryInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type AccountUpdateOneWithoutEnquiriesNestedInput = {
    create?: XOR<AccountCreateWithoutEnquiriesInput, AccountUncheckedCreateWithoutEnquiriesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutEnquiriesInput
    upsert?: AccountUpsertWithoutEnquiriesInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutEnquiriesInput, AccountUpdateWithoutEnquiriesInput>, AccountUncheckedUpdateWithoutEnquiriesInput>
  }

  export type UserUpdateOneRequiredWithoutOwnedEnquiriesNestedInput = {
    create?: XOR<UserCreateWithoutOwnedEnquiriesInput, UserUncheckedCreateWithoutOwnedEnquiriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedEnquiriesInput
    upsert?: UserUpsertWithoutOwnedEnquiriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedEnquiriesInput, UserUpdateWithoutOwnedEnquiriesInput>, UserUncheckedUpdateWithoutOwnedEnquiriesInput>
  }

  export type LeadUpdateOneWithoutEnquiryNestedInput = {
    create?: XOR<LeadCreateWithoutEnquiryInput, LeadUncheckedCreateWithoutEnquiryInput>
    connectOrCreate?: LeadCreateOrConnectWithoutEnquiryInput
    upsert?: LeadUpsertWithoutEnquiryInput
    disconnect?: LeadWhereInput | boolean
    delete?: LeadWhereInput | boolean
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutEnquiryInput, LeadUpdateWithoutEnquiryInput>, LeadUncheckedUpdateWithoutEnquiryInput>
  }

  export type TaskUpdateManyWithoutEnquiryNestedInput = {
    create?: XOR<TaskCreateWithoutEnquiryInput, TaskUncheckedCreateWithoutEnquiryInput> | TaskCreateWithoutEnquiryInput[] | TaskUncheckedCreateWithoutEnquiryInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutEnquiryInput | TaskCreateOrConnectWithoutEnquiryInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutEnquiryInput | TaskUpsertWithWhereUniqueWithoutEnquiryInput[]
    createMany?: TaskCreateManyEnquiryInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutEnquiryInput | TaskUpdateWithWhereUniqueWithoutEnquiryInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutEnquiryInput | TaskUpdateManyWithWhereWithoutEnquiryInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutEnquiryNestedInput = {
    create?: XOR<ActivityCreateWithoutEnquiryInput, ActivityUncheckedCreateWithoutEnquiryInput> | ActivityCreateWithoutEnquiryInput[] | ActivityUncheckedCreateWithoutEnquiryInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutEnquiryInput | ActivityCreateOrConnectWithoutEnquiryInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutEnquiryInput | ActivityUpsertWithWhereUniqueWithoutEnquiryInput[]
    createMany?: ActivityCreateManyEnquiryInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutEnquiryInput | ActivityUpdateWithWhereUniqueWithoutEnquiryInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutEnquiryInput | ActivityUpdateManyWithWhereWithoutEnquiryInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type LeadUncheckedUpdateOneWithoutEnquiryNestedInput = {
    create?: XOR<LeadCreateWithoutEnquiryInput, LeadUncheckedCreateWithoutEnquiryInput>
    connectOrCreate?: LeadCreateOrConnectWithoutEnquiryInput
    upsert?: LeadUpsertWithoutEnquiryInput
    disconnect?: LeadWhereInput | boolean
    delete?: LeadWhereInput | boolean
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutEnquiryInput, LeadUpdateWithoutEnquiryInput>, LeadUncheckedUpdateWithoutEnquiryInput>
  }

  export type TaskUncheckedUpdateManyWithoutEnquiryNestedInput = {
    create?: XOR<TaskCreateWithoutEnquiryInput, TaskUncheckedCreateWithoutEnquiryInput> | TaskCreateWithoutEnquiryInput[] | TaskUncheckedCreateWithoutEnquiryInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutEnquiryInput | TaskCreateOrConnectWithoutEnquiryInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutEnquiryInput | TaskUpsertWithWhereUniqueWithoutEnquiryInput[]
    createMany?: TaskCreateManyEnquiryInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutEnquiryInput | TaskUpdateWithWhereUniqueWithoutEnquiryInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutEnquiryInput | TaskUpdateManyWithWhereWithoutEnquiryInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutContactsInput = {
    create?: XOR<AccountCreateWithoutContactsInput, AccountUncheckedCreateWithoutContactsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutContactsInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<AccountCreateWithoutContactsInput, AccountUncheckedCreateWithoutContactsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutContactsInput
    upsert?: AccountUpsertWithoutContactsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutContactsInput, AccountUpdateWithoutContactsInput>, AccountUncheckedUpdateWithoutContactsInput>
  }

  export type ActivityCreateNestedManyWithoutLeadInput = {
    create?: XOR<ActivityCreateWithoutLeadInput, ActivityUncheckedCreateWithoutLeadInput> | ActivityCreateWithoutLeadInput[] | ActivityUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutLeadInput | ActivityCreateOrConnectWithoutLeadInput[]
    createMany?: ActivityCreateManyLeadInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type AccountCreateNestedOneWithoutLeadsInput = {
    create?: XOR<AccountCreateWithoutLeadsInput, AccountUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutLeadsInput
    connect?: AccountWhereUniqueInput
  }

  export type EnquiryCreateNestedOneWithoutLeadInput = {
    create?: XOR<EnquiryCreateWithoutLeadInput, EnquiryUncheckedCreateWithoutLeadInput>
    connectOrCreate?: EnquiryCreateOrConnectWithoutLeadInput
    connect?: EnquiryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOwnedLeadsInput = {
    create?: XOR<UserCreateWithoutOwnedLeadsInput, UserUncheckedCreateWithoutOwnedLeadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedLeadsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutLeadInput = {
    create?: XOR<ProjectCreateWithoutLeadInput, ProjectUncheckedCreateWithoutLeadInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLeadInput
    connect?: ProjectWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutLeadInput = {
    create?: XOR<TaskCreateWithoutLeadInput, TaskUncheckedCreateWithoutLeadInput> | TaskCreateWithoutLeadInput[] | TaskUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutLeadInput | TaskCreateOrConnectWithoutLeadInput[]
    createMany?: TaskCreateManyLeadInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<ActivityCreateWithoutLeadInput, ActivityUncheckedCreateWithoutLeadInput> | ActivityCreateWithoutLeadInput[] | ActivityUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutLeadInput | ActivityCreateOrConnectWithoutLeadInput[]
    createMany?: ActivityCreateManyLeadInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedOneWithoutLeadInput = {
    create?: XOR<ProjectCreateWithoutLeadInput, ProjectUncheckedCreateWithoutLeadInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLeadInput
    connect?: ProjectWhereUniqueInput
  }

  export type TaskUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<TaskCreateWithoutLeadInput, TaskUncheckedCreateWithoutLeadInput> | TaskCreateWithoutLeadInput[] | TaskUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutLeadInput | TaskCreateOrConnectWithoutLeadInput[]
    createMany?: TaskCreateManyLeadInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type EnumLeadStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeadStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ActivityUpdateManyWithoutLeadNestedInput = {
    create?: XOR<ActivityCreateWithoutLeadInput, ActivityUncheckedCreateWithoutLeadInput> | ActivityCreateWithoutLeadInput[] | ActivityUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutLeadInput | ActivityCreateOrConnectWithoutLeadInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutLeadInput | ActivityUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: ActivityCreateManyLeadInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutLeadInput | ActivityUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutLeadInput | ActivityUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type AccountUpdateOneRequiredWithoutLeadsNestedInput = {
    create?: XOR<AccountCreateWithoutLeadsInput, AccountUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutLeadsInput
    upsert?: AccountUpsertWithoutLeadsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutLeadsInput, AccountUpdateWithoutLeadsInput>, AccountUncheckedUpdateWithoutLeadsInput>
  }

  export type EnquiryUpdateOneWithoutLeadNestedInput = {
    create?: XOR<EnquiryCreateWithoutLeadInput, EnquiryUncheckedCreateWithoutLeadInput>
    connectOrCreate?: EnquiryCreateOrConnectWithoutLeadInput
    upsert?: EnquiryUpsertWithoutLeadInput
    disconnect?: EnquiryWhereInput | boolean
    delete?: EnquiryWhereInput | boolean
    connect?: EnquiryWhereUniqueInput
    update?: XOR<XOR<EnquiryUpdateToOneWithWhereWithoutLeadInput, EnquiryUpdateWithoutLeadInput>, EnquiryUncheckedUpdateWithoutLeadInput>
  }

  export type UserUpdateOneRequiredWithoutOwnedLeadsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedLeadsInput, UserUncheckedCreateWithoutOwnedLeadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedLeadsInput
    upsert?: UserUpsertWithoutOwnedLeadsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedLeadsInput, UserUpdateWithoutOwnedLeadsInput>, UserUncheckedUpdateWithoutOwnedLeadsInput>
  }

  export type ProjectUpdateOneWithoutLeadNestedInput = {
    create?: XOR<ProjectCreateWithoutLeadInput, ProjectUncheckedCreateWithoutLeadInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLeadInput
    upsert?: ProjectUpsertWithoutLeadInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutLeadInput, ProjectUpdateWithoutLeadInput>, ProjectUncheckedUpdateWithoutLeadInput>
  }

  export type TaskUpdateManyWithoutLeadNestedInput = {
    create?: XOR<TaskCreateWithoutLeadInput, TaskUncheckedCreateWithoutLeadInput> | TaskCreateWithoutLeadInput[] | TaskUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutLeadInput | TaskCreateOrConnectWithoutLeadInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutLeadInput | TaskUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: TaskCreateManyLeadInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutLeadInput | TaskUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutLeadInput | TaskUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<ActivityCreateWithoutLeadInput, ActivityUncheckedCreateWithoutLeadInput> | ActivityCreateWithoutLeadInput[] | ActivityUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutLeadInput | ActivityCreateOrConnectWithoutLeadInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutLeadInput | ActivityUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: ActivityCreateManyLeadInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutLeadInput | ActivityUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutLeadInput | ActivityUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateOneWithoutLeadNestedInput = {
    create?: XOR<ProjectCreateWithoutLeadInput, ProjectUncheckedCreateWithoutLeadInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLeadInput
    upsert?: ProjectUpsertWithoutLeadInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutLeadInput, ProjectUpdateWithoutLeadInput>, ProjectUncheckedUpdateWithoutLeadInput>
  }

  export type TaskUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<TaskCreateWithoutLeadInput, TaskUncheckedCreateWithoutLeadInput> | TaskCreateWithoutLeadInput[] | TaskUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutLeadInput | TaskCreateOrConnectWithoutLeadInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutLeadInput | TaskUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: TaskCreateManyLeadInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutLeadInput | TaskUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutLeadInput | TaskUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ActivityCreateNestedManyWithoutProjectInput = {
    create?: XOR<ActivityCreateWithoutProjectInput, ActivityUncheckedCreateWithoutProjectInput> | ActivityCreateWithoutProjectInput[] | ActivityUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutProjectInput | ActivityCreateOrConnectWithoutProjectInput[]
    createMany?: ActivityCreateManyProjectInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutProjectInput = {
    create?: XOR<AppointmentCreateWithoutProjectInput, AppointmentUncheckedCreateWithoutProjectInput> | AppointmentCreateWithoutProjectInput[] | AppointmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutProjectInput | AppointmentCreateOrConnectWithoutProjectInput[]
    createMany?: AppointmentCreateManyProjectInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type CompletedProjectCreateNestedOneWithoutProjectInput = {
    create?: XOR<CompletedProjectCreateWithoutProjectInput, CompletedProjectUncheckedCreateWithoutProjectInput>
    connectOrCreate?: CompletedProjectCreateOrConnectWithoutProjectInput
    connect?: CompletedProjectWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutProjectInput = {
    create?: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput> | DocumentCreateWithoutProjectInput[] | DocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutProjectInput | DocumentCreateOrConnectWithoutProjectInput[]
    createMany?: DocumentCreateManyProjectInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type AccountCreateNestedOneWithoutProjectsInput = {
    create?: XOR<AccountCreateWithoutProjectsInput, AccountUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutProjectsInput
    connect?: AccountWhereUniqueInput
  }

  export type LeadCreateNestedOneWithoutProjectInput = {
    create?: XOR<LeadCreateWithoutProjectInput, LeadUncheckedCreateWithoutProjectInput>
    connectOrCreate?: LeadCreateOrConnectWithoutProjectInput
    connect?: LeadWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOwnedProjectsInput = {
    create?: XOR<UserCreateWithoutOwnedProjectsInput, UserUncheckedCreateWithoutOwnedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type SnagCreateNestedManyWithoutProjectInput = {
    create?: XOR<SnagCreateWithoutProjectInput, SnagUncheckedCreateWithoutProjectInput> | SnagCreateWithoutProjectInput[] | SnagUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SnagCreateOrConnectWithoutProjectInput | SnagCreateOrConnectWithoutProjectInput[]
    createMany?: SnagCreateManyProjectInputEnvelope
    connect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ActivityCreateWithoutProjectInput, ActivityUncheckedCreateWithoutProjectInput> | ActivityCreateWithoutProjectInput[] | ActivityUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutProjectInput | ActivityCreateOrConnectWithoutProjectInput[]
    createMany?: ActivityCreateManyProjectInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<AppointmentCreateWithoutProjectInput, AppointmentUncheckedCreateWithoutProjectInput> | AppointmentCreateWithoutProjectInput[] | AppointmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutProjectInput | AppointmentCreateOrConnectWithoutProjectInput[]
    createMany?: AppointmentCreateManyProjectInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type CompletedProjectUncheckedCreateNestedOneWithoutProjectInput = {
    create?: XOR<CompletedProjectCreateWithoutProjectInput, CompletedProjectUncheckedCreateWithoutProjectInput>
    connectOrCreate?: CompletedProjectCreateOrConnectWithoutProjectInput
    connect?: CompletedProjectWhereUniqueInput
  }

  export type DocumentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput> | DocumentCreateWithoutProjectInput[] | DocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutProjectInput | DocumentCreateOrConnectWithoutProjectInput[]
    createMany?: DocumentCreateManyProjectInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type SnagUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<SnagCreateWithoutProjectInput, SnagUncheckedCreateWithoutProjectInput> | SnagCreateWithoutProjectInput[] | SnagUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SnagCreateOrConnectWithoutProjectInput | SnagCreateOrConnectWithoutProjectInput[]
    createMany?: SnagCreateManyProjectInputEnvelope
    connect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type EnumProjectTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProjectType
  }

  export type EnumProjectStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProjectStatus
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ActivityUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ActivityCreateWithoutProjectInput, ActivityUncheckedCreateWithoutProjectInput> | ActivityCreateWithoutProjectInput[] | ActivityUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutProjectInput | ActivityCreateOrConnectWithoutProjectInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutProjectInput | ActivityUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ActivityCreateManyProjectInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutProjectInput | ActivityUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutProjectInput | ActivityUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AppointmentCreateWithoutProjectInput, AppointmentUncheckedCreateWithoutProjectInput> | AppointmentCreateWithoutProjectInput[] | AppointmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutProjectInput | AppointmentCreateOrConnectWithoutProjectInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutProjectInput | AppointmentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AppointmentCreateManyProjectInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutProjectInput | AppointmentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutProjectInput | AppointmentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type CompletedProjectUpdateOneWithoutProjectNestedInput = {
    create?: XOR<CompletedProjectCreateWithoutProjectInput, CompletedProjectUncheckedCreateWithoutProjectInput>
    connectOrCreate?: CompletedProjectCreateOrConnectWithoutProjectInput
    upsert?: CompletedProjectUpsertWithoutProjectInput
    disconnect?: CompletedProjectWhereInput | boolean
    delete?: CompletedProjectWhereInput | boolean
    connect?: CompletedProjectWhereUniqueInput
    update?: XOR<XOR<CompletedProjectUpdateToOneWithWhereWithoutProjectInput, CompletedProjectUpdateWithoutProjectInput>, CompletedProjectUncheckedUpdateWithoutProjectInput>
  }

  export type DocumentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput> | DocumentCreateWithoutProjectInput[] | DocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutProjectInput | DocumentCreateOrConnectWithoutProjectInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutProjectInput | DocumentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DocumentCreateManyProjectInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutProjectInput | DocumentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutProjectInput | DocumentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type AccountUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<AccountCreateWithoutProjectsInput, AccountUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutProjectsInput
    upsert?: AccountUpsertWithoutProjectsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutProjectsInput, AccountUpdateWithoutProjectsInput>, AccountUncheckedUpdateWithoutProjectsInput>
  }

  export type LeadUpdateOneWithoutProjectNestedInput = {
    create?: XOR<LeadCreateWithoutProjectInput, LeadUncheckedCreateWithoutProjectInput>
    connectOrCreate?: LeadCreateOrConnectWithoutProjectInput
    upsert?: LeadUpsertWithoutProjectInput
    disconnect?: LeadWhereInput | boolean
    delete?: LeadWhereInput | boolean
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutProjectInput, LeadUpdateWithoutProjectInput>, LeadUncheckedUpdateWithoutProjectInput>
  }

  export type UserUpdateOneRequiredWithoutOwnedProjectsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedProjectsInput, UserUncheckedCreateWithoutOwnedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedProjectsInput
    upsert?: UserUpsertWithoutOwnedProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedProjectsInput, UserUpdateWithoutOwnedProjectsInput>, UserUncheckedUpdateWithoutOwnedProjectsInput>
  }

  export type SnagUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SnagCreateWithoutProjectInput, SnagUncheckedCreateWithoutProjectInput> | SnagCreateWithoutProjectInput[] | SnagUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SnagCreateOrConnectWithoutProjectInput | SnagCreateOrConnectWithoutProjectInput[]
    upsert?: SnagUpsertWithWhereUniqueWithoutProjectInput | SnagUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SnagCreateManyProjectInputEnvelope
    set?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    disconnect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    delete?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    connect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    update?: SnagUpdateWithWhereUniqueWithoutProjectInput | SnagUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SnagUpdateManyWithWhereWithoutProjectInput | SnagUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SnagScalarWhereInput | SnagScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutProjectInput | TaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutProjectInput | TaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutProjectInput | TaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ActivityCreateWithoutProjectInput, ActivityUncheckedCreateWithoutProjectInput> | ActivityCreateWithoutProjectInput[] | ActivityUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutProjectInput | ActivityCreateOrConnectWithoutProjectInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutProjectInput | ActivityUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ActivityCreateManyProjectInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutProjectInput | ActivityUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutProjectInput | ActivityUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AppointmentCreateWithoutProjectInput, AppointmentUncheckedCreateWithoutProjectInput> | AppointmentCreateWithoutProjectInput[] | AppointmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutProjectInput | AppointmentCreateOrConnectWithoutProjectInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutProjectInput | AppointmentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AppointmentCreateManyProjectInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutProjectInput | AppointmentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutProjectInput | AppointmentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type CompletedProjectUncheckedUpdateOneWithoutProjectNestedInput = {
    create?: XOR<CompletedProjectCreateWithoutProjectInput, CompletedProjectUncheckedCreateWithoutProjectInput>
    connectOrCreate?: CompletedProjectCreateOrConnectWithoutProjectInput
    upsert?: CompletedProjectUpsertWithoutProjectInput
    disconnect?: CompletedProjectWhereInput | boolean
    delete?: CompletedProjectWhereInput | boolean
    connect?: CompletedProjectWhereUniqueInput
    update?: XOR<XOR<CompletedProjectUpdateToOneWithWhereWithoutProjectInput, CompletedProjectUpdateWithoutProjectInput>, CompletedProjectUncheckedUpdateWithoutProjectInput>
  }

  export type DocumentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput> | DocumentCreateWithoutProjectInput[] | DocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutProjectInput | DocumentCreateOrConnectWithoutProjectInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutProjectInput | DocumentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DocumentCreateManyProjectInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutProjectInput | DocumentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutProjectInput | DocumentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type SnagUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SnagCreateWithoutProjectInput, SnagUncheckedCreateWithoutProjectInput> | SnagCreateWithoutProjectInput[] | SnagUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SnagCreateOrConnectWithoutProjectInput | SnagCreateOrConnectWithoutProjectInput[]
    upsert?: SnagUpsertWithWhereUniqueWithoutProjectInput | SnagUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SnagCreateManyProjectInputEnvelope
    set?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    disconnect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    delete?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    connect?: SnagWhereUniqueInput | SnagWhereUniqueInput[]
    update?: SnagUpdateWithWhereUniqueWithoutProjectInput | SnagUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SnagUpdateManyWithWhereWithoutProjectInput | SnagUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SnagScalarWhereInput | SnagScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutProjectInput | TaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutProjectInput | TaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutProjectInput | TaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutCompletedProjectsInput = {
    create?: XOR<AccountCreateWithoutCompletedProjectsInput, AccountUncheckedCreateWithoutCompletedProjectsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCompletedProjectsInput
    connect?: AccountWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOwnedCompletedProjectsInput = {
    create?: XOR<UserCreateWithoutOwnedCompletedProjectsInput, UserUncheckedCreateWithoutOwnedCompletedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedCompletedProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutCompletedProjectInput = {
    create?: XOR<ProjectCreateWithoutCompletedProjectInput, ProjectUncheckedCreateWithoutCompletedProjectInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCompletedProjectInput
    connect?: ProjectWhereUniqueInput
  }

  export type EnumCompletedProjectStatusFieldUpdateOperationsInput = {
    set?: $Enums.CompletedProjectStatus
  }

  export type AccountUpdateOneRequiredWithoutCompletedProjectsNestedInput = {
    create?: XOR<AccountCreateWithoutCompletedProjectsInput, AccountUncheckedCreateWithoutCompletedProjectsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCompletedProjectsInput
    upsert?: AccountUpsertWithoutCompletedProjectsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutCompletedProjectsInput, AccountUpdateWithoutCompletedProjectsInput>, AccountUncheckedUpdateWithoutCompletedProjectsInput>
  }

  export type UserUpdateOneRequiredWithoutOwnedCompletedProjectsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedCompletedProjectsInput, UserUncheckedCreateWithoutOwnedCompletedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedCompletedProjectsInput
    upsert?: UserUpsertWithoutOwnedCompletedProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedCompletedProjectsInput, UserUpdateWithoutOwnedCompletedProjectsInput>, UserUncheckedUpdateWithoutOwnedCompletedProjectsInput>
  }

  export type ProjectUpdateOneWithoutCompletedProjectNestedInput = {
    create?: XOR<ProjectCreateWithoutCompletedProjectInput, ProjectUncheckedCreateWithoutCompletedProjectInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCompletedProjectInput
    upsert?: ProjectUpsertWithoutCompletedProjectInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutCompletedProjectInput, ProjectUpdateWithoutCompletedProjectInput>, ProjectUncheckedUpdateWithoutCompletedProjectInput>
  }

  export type AccountCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<AccountCreateWithoutActivitiesInput, AccountUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutActivitiesInput
    connect?: AccountWhereUniqueInput
  }

  export type EnquiryCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<EnquiryCreateWithoutActivitiesInput, EnquiryUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: EnquiryCreateOrConnectWithoutActivitiesInput
    connect?: EnquiryWhereUniqueInput
  }

  export type LeadCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<LeadCreateWithoutActivitiesInput, LeadUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: LeadCreateOrConnectWithoutActivitiesInput
    connect?: LeadWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<ProjectCreateWithoutActivitiesInput, ProjectUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutActivitiesInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumActivityTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActivityType
  }

  export type AccountUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<AccountCreateWithoutActivitiesInput, AccountUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutActivitiesInput
    upsert?: AccountUpsertWithoutActivitiesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutActivitiesInput, AccountUpdateWithoutActivitiesInput>, AccountUncheckedUpdateWithoutActivitiesInput>
  }

  export type EnquiryUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<EnquiryCreateWithoutActivitiesInput, EnquiryUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: EnquiryCreateOrConnectWithoutActivitiesInput
    upsert?: EnquiryUpsertWithoutActivitiesInput
    disconnect?: EnquiryWhereInput | boolean
    delete?: EnquiryWhereInput | boolean
    connect?: EnquiryWhereUniqueInput
    update?: XOR<XOR<EnquiryUpdateToOneWithWhereWithoutActivitiesInput, EnquiryUpdateWithoutActivitiesInput>, EnquiryUncheckedUpdateWithoutActivitiesInput>
  }

  export type LeadUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<LeadCreateWithoutActivitiesInput, LeadUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: LeadCreateOrConnectWithoutActivitiesInput
    upsert?: LeadUpsertWithoutActivitiesInput
    disconnect?: LeadWhereInput | boolean
    delete?: LeadWhereInput | boolean
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutActivitiesInput, LeadUpdateWithoutActivitiesInput>, LeadUncheckedUpdateWithoutActivitiesInput>
  }

  export type ProjectUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<ProjectCreateWithoutActivitiesInput, ProjectUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutActivitiesInput
    upsert?: ProjectUpsertWithoutActivitiesInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutActivitiesInput, ProjectUpdateWithoutActivitiesInput>, ProjectUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    upsert?: UserUpsertWithoutActivitiesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivitiesInput, UserUpdateWithoutActivitiesInput>, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type AccountCreateNestedOneWithoutTasksInput = {
    create?: XOR<AccountCreateWithoutTasksInput, AccountUncheckedCreateWithoutTasksInput>
    connectOrCreate?: AccountCreateOrConnectWithoutTasksInput
    connect?: AccountWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedTasksInput = {
    create?: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTasksInput
    connect?: UserWhereUniqueInput
  }

  export type EnquiryCreateNestedOneWithoutTasksInput = {
    create?: XOR<EnquiryCreateWithoutTasksInput, EnquiryUncheckedCreateWithoutTasksInput>
    connectOrCreate?: EnquiryCreateOrConnectWithoutTasksInput
    connect?: EnquiryWhereUniqueInput
  }

  export type LeadCreateNestedOneWithoutTasksInput = {
    create?: XOR<LeadCreateWithoutTasksInput, LeadUncheckedCreateWithoutTasksInput>
    connectOrCreate?: LeadCreateOrConnectWithoutTasksInput
    connect?: LeadWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutTasksInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    connect?: ProjectWhereUniqueInput
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus
  }

  export type AccountUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<AccountCreateWithoutTasksInput, AccountUncheckedCreateWithoutTasksInput>
    connectOrCreate?: AccountCreateOrConnectWithoutTasksInput
    upsert?: AccountUpsertWithoutTasksInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutTasksInput, AccountUpdateWithoutTasksInput>, AccountUncheckedUpdateWithoutTasksInput>
  }

  export type UserUpdateOneRequiredWithoutAssignedTasksNestedInput = {
    create?: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTasksInput
    upsert?: UserUpsertWithoutAssignedTasksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedTasksInput, UserUpdateWithoutAssignedTasksInput>, UserUncheckedUpdateWithoutAssignedTasksInput>
  }

  export type EnquiryUpdateOneWithoutTasksNestedInput = {
    create?: XOR<EnquiryCreateWithoutTasksInput, EnquiryUncheckedCreateWithoutTasksInput>
    connectOrCreate?: EnquiryCreateOrConnectWithoutTasksInput
    upsert?: EnquiryUpsertWithoutTasksInput
    disconnect?: EnquiryWhereInput | boolean
    delete?: EnquiryWhereInput | boolean
    connect?: EnquiryWhereUniqueInput
    update?: XOR<XOR<EnquiryUpdateToOneWithWhereWithoutTasksInput, EnquiryUpdateWithoutTasksInput>, EnquiryUncheckedUpdateWithoutTasksInput>
  }

  export type LeadUpdateOneWithoutTasksNestedInput = {
    create?: XOR<LeadCreateWithoutTasksInput, LeadUncheckedCreateWithoutTasksInput>
    connectOrCreate?: LeadCreateOrConnectWithoutTasksInput
    upsert?: LeadUpsertWithoutTasksInput
    disconnect?: LeadWhereInput | boolean
    delete?: LeadWhereInput | boolean
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutTasksInput, LeadUpdateWithoutTasksInput>, LeadUncheckedUpdateWithoutTasksInput>
  }

  export type ProjectUpdateOneWithoutTasksNestedInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    upsert?: ProjectUpsertWithoutTasksInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTasksInput, ProjectUpdateWithoutTasksInput>, ProjectUncheckedUpdateWithoutTasksInput>
  }

  export type AccountCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<AccountCreateWithoutAppointmentsInput, AccountUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAppointmentsInput
    connect?: AccountWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<ProjectCreateWithoutAppointmentsInput, ProjectUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAppointmentsInput
    connect?: ProjectWhereUniqueInput
  }

  export type EnumAppointmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.AppointmentType
  }

  export type EnumAppointmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AppointmentStatus
  }

  export type AccountUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<AccountCreateWithoutAppointmentsInput, AccountUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAppointmentsInput
    upsert?: AccountUpsertWithoutAppointmentsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutAppointmentsInput, AccountUpdateWithoutAppointmentsInput>, AccountUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ProjectUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<ProjectCreateWithoutAppointmentsInput, ProjectUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAppointmentsInput
    upsert?: ProjectUpsertWithoutAppointmentsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutAppointmentsInput, ProjectUpdateWithoutAppointmentsInput>, ProjectUncheckedUpdateWithoutAppointmentsInput>
  }

  export type AccountCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<AccountCreateWithoutDocumentsInput, AccountUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutDocumentsInput
    connect?: AccountWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDocumentsInput
    connect?: ProjectWhereUniqueInput
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type AccountUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<AccountCreateWithoutDocumentsInput, AccountUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutDocumentsInput
    upsert?: AccountUpsertWithoutDocumentsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutDocumentsInput, AccountUpdateWithoutDocumentsInput>, AccountUncheckedUpdateWithoutDocumentsInput>
  }

  export type ProjectUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDocumentsInput
    upsert?: ProjectUpsertWithoutDocumentsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutDocumentsInput, ProjectUpdateWithoutDocumentsInput>, ProjectUncheckedUpdateWithoutDocumentsInput>
  }

  export type AccountCreateNestedOneWithoutSnagsInput = {
    create?: XOR<AccountCreateWithoutSnagsInput, AccountUncheckedCreateWithoutSnagsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutSnagsInput
    connect?: AccountWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutSnagsInput = {
    create?: XOR<ProjectCreateWithoutSnagsInput, ProjectUncheckedCreateWithoutSnagsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSnagsInput
    connect?: ProjectWhereUniqueInput
  }

  export type EnumSnagStatusFieldUpdateOperationsInput = {
    set?: $Enums.SnagStatus
  }

  export type AccountUpdateOneRequiredWithoutSnagsNestedInput = {
    create?: XOR<AccountCreateWithoutSnagsInput, AccountUncheckedCreateWithoutSnagsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutSnagsInput
    upsert?: AccountUpsertWithoutSnagsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutSnagsInput, AccountUpdateWithoutSnagsInput>, AccountUncheckedUpdateWithoutSnagsInput>
  }

  export type ProjectUpdateOneRequiredWithoutSnagsNestedInput = {
    create?: XOR<ProjectCreateWithoutSnagsInput, ProjectUncheckedCreateWithoutSnagsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSnagsInput
    upsert?: ProjectUpsertWithoutSnagsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSnagsInput, ProjectUpdateWithoutSnagsInput>, ProjectUncheckedUpdateWithoutSnagsInput>
  }

  export type AccountCreateNestedOneWithoutEventsInput = {
    create?: XOR<AccountCreateWithoutEventsInput, AccountUncheckedCreateWithoutEventsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutEventsInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountUpdateOneWithoutEventsNestedInput = {
    create?: XOR<AccountCreateWithoutEventsInput, AccountUncheckedCreateWithoutEventsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutEventsInput
    upsert?: AccountUpsertWithoutEventsInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutEventsInput, AccountUpdateWithoutEventsInput>, AccountUncheckedUpdateWithoutEventsInput>
  }

  export type AccountCreateNestedOneWithoutWorkflowsInput = {
    create?: XOR<AccountCreateWithoutWorkflowsInput, AccountUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutWorkflowsInput
    connect?: AccountWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedWorkflowsInput = {
    create?: XOR<UserCreateWithoutCreatedWorkflowsInput, UserUncheckedCreateWithoutCreatedWorkflowsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedWorkflowsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkflowStepCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<WorkflowStepCreateWithoutWorkflowInput, WorkflowStepUncheckedCreateWithoutWorkflowInput> | WorkflowStepCreateWithoutWorkflowInput[] | WorkflowStepUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutWorkflowInput | WorkflowStepCreateOrConnectWithoutWorkflowInput[]
    createMany?: WorkflowStepCreateManyWorkflowInputEnvelope
    connect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
  }

  export type WorkflowInstanceCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<WorkflowInstanceCreateWithoutWorkflowInput, WorkflowInstanceUncheckedCreateWithoutWorkflowInput> | WorkflowInstanceCreateWithoutWorkflowInput[] | WorkflowInstanceUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutWorkflowInput | WorkflowInstanceCreateOrConnectWithoutWorkflowInput[]
    createMany?: WorkflowInstanceCreateManyWorkflowInputEnvelope
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
  }

  export type WorkflowTemplateCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<WorkflowTemplateCreateWithoutWorkflowInput, WorkflowTemplateUncheckedCreateWithoutWorkflowInput> | WorkflowTemplateCreateWithoutWorkflowInput[] | WorkflowTemplateUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowTemplateCreateOrConnectWithoutWorkflowInput | WorkflowTemplateCreateOrConnectWithoutWorkflowInput[]
    createMany?: WorkflowTemplateCreateManyWorkflowInputEnvelope
    connect?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
  }

  export type WorkflowStepUncheckedCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<WorkflowStepCreateWithoutWorkflowInput, WorkflowStepUncheckedCreateWithoutWorkflowInput> | WorkflowStepCreateWithoutWorkflowInput[] | WorkflowStepUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutWorkflowInput | WorkflowStepCreateOrConnectWithoutWorkflowInput[]
    createMany?: WorkflowStepCreateManyWorkflowInputEnvelope
    connect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
  }

  export type WorkflowInstanceUncheckedCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<WorkflowInstanceCreateWithoutWorkflowInput, WorkflowInstanceUncheckedCreateWithoutWorkflowInput> | WorkflowInstanceCreateWithoutWorkflowInput[] | WorkflowInstanceUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutWorkflowInput | WorkflowInstanceCreateOrConnectWithoutWorkflowInput[]
    createMany?: WorkflowInstanceCreateManyWorkflowInputEnvelope
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
  }

  export type WorkflowTemplateUncheckedCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<WorkflowTemplateCreateWithoutWorkflowInput, WorkflowTemplateUncheckedCreateWithoutWorkflowInput> | WorkflowTemplateCreateWithoutWorkflowInput[] | WorkflowTemplateUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowTemplateCreateOrConnectWithoutWorkflowInput | WorkflowTemplateCreateOrConnectWithoutWorkflowInput[]
    createMany?: WorkflowTemplateCreateManyWorkflowInputEnvelope
    connect?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
  }

  export type EnumWorkflowTriggerTypeFieldUpdateOperationsInput = {
    set?: $Enums.WorkflowTriggerType
  }

  export type AccountUpdateOneRequiredWithoutWorkflowsNestedInput = {
    create?: XOR<AccountCreateWithoutWorkflowsInput, AccountUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutWorkflowsInput
    upsert?: AccountUpsertWithoutWorkflowsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutWorkflowsInput, AccountUpdateWithoutWorkflowsInput>, AccountUncheckedUpdateWithoutWorkflowsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedWorkflowsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedWorkflowsInput, UserUncheckedCreateWithoutCreatedWorkflowsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedWorkflowsInput
    upsert?: UserUpsertWithoutCreatedWorkflowsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedWorkflowsInput, UserUpdateWithoutCreatedWorkflowsInput>, UserUncheckedUpdateWithoutCreatedWorkflowsInput>
  }

  export type WorkflowStepUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<WorkflowStepCreateWithoutWorkflowInput, WorkflowStepUncheckedCreateWithoutWorkflowInput> | WorkflowStepCreateWithoutWorkflowInput[] | WorkflowStepUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutWorkflowInput | WorkflowStepCreateOrConnectWithoutWorkflowInput[]
    upsert?: WorkflowStepUpsertWithWhereUniqueWithoutWorkflowInput | WorkflowStepUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: WorkflowStepCreateManyWorkflowInputEnvelope
    set?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    disconnect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    delete?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    connect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    update?: WorkflowStepUpdateWithWhereUniqueWithoutWorkflowInput | WorkflowStepUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: WorkflowStepUpdateManyWithWhereWithoutWorkflowInput | WorkflowStepUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: WorkflowStepScalarWhereInput | WorkflowStepScalarWhereInput[]
  }

  export type WorkflowInstanceUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<WorkflowInstanceCreateWithoutWorkflowInput, WorkflowInstanceUncheckedCreateWithoutWorkflowInput> | WorkflowInstanceCreateWithoutWorkflowInput[] | WorkflowInstanceUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutWorkflowInput | WorkflowInstanceCreateOrConnectWithoutWorkflowInput[]
    upsert?: WorkflowInstanceUpsertWithWhereUniqueWithoutWorkflowInput | WorkflowInstanceUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: WorkflowInstanceCreateManyWorkflowInputEnvelope
    set?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    disconnect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    delete?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    update?: WorkflowInstanceUpdateWithWhereUniqueWithoutWorkflowInput | WorkflowInstanceUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: WorkflowInstanceUpdateManyWithWhereWithoutWorkflowInput | WorkflowInstanceUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: WorkflowInstanceScalarWhereInput | WorkflowInstanceScalarWhereInput[]
  }

  export type WorkflowTemplateUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<WorkflowTemplateCreateWithoutWorkflowInput, WorkflowTemplateUncheckedCreateWithoutWorkflowInput> | WorkflowTemplateCreateWithoutWorkflowInput[] | WorkflowTemplateUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowTemplateCreateOrConnectWithoutWorkflowInput | WorkflowTemplateCreateOrConnectWithoutWorkflowInput[]
    upsert?: WorkflowTemplateUpsertWithWhereUniqueWithoutWorkflowInput | WorkflowTemplateUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: WorkflowTemplateCreateManyWorkflowInputEnvelope
    set?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
    disconnect?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
    delete?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
    connect?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
    update?: WorkflowTemplateUpdateWithWhereUniqueWithoutWorkflowInput | WorkflowTemplateUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: WorkflowTemplateUpdateManyWithWhereWithoutWorkflowInput | WorkflowTemplateUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: WorkflowTemplateScalarWhereInput | WorkflowTemplateScalarWhereInput[]
  }

  export type WorkflowStepUncheckedUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<WorkflowStepCreateWithoutWorkflowInput, WorkflowStepUncheckedCreateWithoutWorkflowInput> | WorkflowStepCreateWithoutWorkflowInput[] | WorkflowStepUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutWorkflowInput | WorkflowStepCreateOrConnectWithoutWorkflowInput[]
    upsert?: WorkflowStepUpsertWithWhereUniqueWithoutWorkflowInput | WorkflowStepUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: WorkflowStepCreateManyWorkflowInputEnvelope
    set?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    disconnect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    delete?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    connect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    update?: WorkflowStepUpdateWithWhereUniqueWithoutWorkflowInput | WorkflowStepUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: WorkflowStepUpdateManyWithWhereWithoutWorkflowInput | WorkflowStepUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: WorkflowStepScalarWhereInput | WorkflowStepScalarWhereInput[]
  }

  export type WorkflowInstanceUncheckedUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<WorkflowInstanceCreateWithoutWorkflowInput, WorkflowInstanceUncheckedCreateWithoutWorkflowInput> | WorkflowInstanceCreateWithoutWorkflowInput[] | WorkflowInstanceUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutWorkflowInput | WorkflowInstanceCreateOrConnectWithoutWorkflowInput[]
    upsert?: WorkflowInstanceUpsertWithWhereUniqueWithoutWorkflowInput | WorkflowInstanceUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: WorkflowInstanceCreateManyWorkflowInputEnvelope
    set?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    disconnect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    delete?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    update?: WorkflowInstanceUpdateWithWhereUniqueWithoutWorkflowInput | WorkflowInstanceUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: WorkflowInstanceUpdateManyWithWhereWithoutWorkflowInput | WorkflowInstanceUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: WorkflowInstanceScalarWhereInput | WorkflowInstanceScalarWhereInput[]
  }

  export type WorkflowTemplateUncheckedUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<WorkflowTemplateCreateWithoutWorkflowInput, WorkflowTemplateUncheckedCreateWithoutWorkflowInput> | WorkflowTemplateCreateWithoutWorkflowInput[] | WorkflowTemplateUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowTemplateCreateOrConnectWithoutWorkflowInput | WorkflowTemplateCreateOrConnectWithoutWorkflowInput[]
    upsert?: WorkflowTemplateUpsertWithWhereUniqueWithoutWorkflowInput | WorkflowTemplateUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: WorkflowTemplateCreateManyWorkflowInputEnvelope
    set?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
    disconnect?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
    delete?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
    connect?: WorkflowTemplateWhereUniqueInput | WorkflowTemplateWhereUniqueInput[]
    update?: WorkflowTemplateUpdateWithWhereUniqueWithoutWorkflowInput | WorkflowTemplateUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: WorkflowTemplateUpdateManyWithWhereWithoutWorkflowInput | WorkflowTemplateUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: WorkflowTemplateScalarWhereInput | WorkflowTemplateScalarWhereInput[]
  }

  export type WorkflowDefinitionCreateNestedOneWithoutStepsInput = {
    create?: XOR<WorkflowDefinitionCreateWithoutStepsInput, WorkflowDefinitionUncheckedCreateWithoutStepsInput>
    connectOrCreate?: WorkflowDefinitionCreateOrConnectWithoutStepsInput
    connect?: WorkflowDefinitionWhereUniqueInput
  }

  export type WorkflowStepExecutionCreateNestedManyWithoutStepInput = {
    create?: XOR<WorkflowStepExecutionCreateWithoutStepInput, WorkflowStepExecutionUncheckedCreateWithoutStepInput> | WorkflowStepExecutionCreateWithoutStepInput[] | WorkflowStepExecutionUncheckedCreateWithoutStepInput[]
    connectOrCreate?: WorkflowStepExecutionCreateOrConnectWithoutStepInput | WorkflowStepExecutionCreateOrConnectWithoutStepInput[]
    createMany?: WorkflowStepExecutionCreateManyStepInputEnvelope
    connect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
  }

  export type WorkflowStepApproverCreateNestedManyWithoutStepInput = {
    create?: XOR<WorkflowStepApproverCreateWithoutStepInput, WorkflowStepApproverUncheckedCreateWithoutStepInput> | WorkflowStepApproverCreateWithoutStepInput[] | WorkflowStepApproverUncheckedCreateWithoutStepInput[]
    connectOrCreate?: WorkflowStepApproverCreateOrConnectWithoutStepInput | WorkflowStepApproverCreateOrConnectWithoutStepInput[]
    createMany?: WorkflowStepApproverCreateManyStepInputEnvelope
    connect?: WorkflowStepApproverWhereUniqueInput | WorkflowStepApproverWhereUniqueInput[]
  }

  export type WorkflowStepExecutionUncheckedCreateNestedManyWithoutStepInput = {
    create?: XOR<WorkflowStepExecutionCreateWithoutStepInput, WorkflowStepExecutionUncheckedCreateWithoutStepInput> | WorkflowStepExecutionCreateWithoutStepInput[] | WorkflowStepExecutionUncheckedCreateWithoutStepInput[]
    connectOrCreate?: WorkflowStepExecutionCreateOrConnectWithoutStepInput | WorkflowStepExecutionCreateOrConnectWithoutStepInput[]
    createMany?: WorkflowStepExecutionCreateManyStepInputEnvelope
    connect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
  }

  export type WorkflowStepApproverUncheckedCreateNestedManyWithoutStepInput = {
    create?: XOR<WorkflowStepApproverCreateWithoutStepInput, WorkflowStepApproverUncheckedCreateWithoutStepInput> | WorkflowStepApproverCreateWithoutStepInput[] | WorkflowStepApproverUncheckedCreateWithoutStepInput[]
    connectOrCreate?: WorkflowStepApproverCreateOrConnectWithoutStepInput | WorkflowStepApproverCreateOrConnectWithoutStepInput[]
    createMany?: WorkflowStepApproverCreateManyStepInputEnvelope
    connect?: WorkflowStepApproverWhereUniqueInput | WorkflowStepApproverWhereUniqueInput[]
  }

  export type EnumWorkflowStepTypeFieldUpdateOperationsInput = {
    set?: $Enums.WorkflowStepType
  }

  export type WorkflowDefinitionUpdateOneRequiredWithoutStepsNestedInput = {
    create?: XOR<WorkflowDefinitionCreateWithoutStepsInput, WorkflowDefinitionUncheckedCreateWithoutStepsInput>
    connectOrCreate?: WorkflowDefinitionCreateOrConnectWithoutStepsInput
    upsert?: WorkflowDefinitionUpsertWithoutStepsInput
    connect?: WorkflowDefinitionWhereUniqueInput
    update?: XOR<XOR<WorkflowDefinitionUpdateToOneWithWhereWithoutStepsInput, WorkflowDefinitionUpdateWithoutStepsInput>, WorkflowDefinitionUncheckedUpdateWithoutStepsInput>
  }

  export type WorkflowStepExecutionUpdateManyWithoutStepNestedInput = {
    create?: XOR<WorkflowStepExecutionCreateWithoutStepInput, WorkflowStepExecutionUncheckedCreateWithoutStepInput> | WorkflowStepExecutionCreateWithoutStepInput[] | WorkflowStepExecutionUncheckedCreateWithoutStepInput[]
    connectOrCreate?: WorkflowStepExecutionCreateOrConnectWithoutStepInput | WorkflowStepExecutionCreateOrConnectWithoutStepInput[]
    upsert?: WorkflowStepExecutionUpsertWithWhereUniqueWithoutStepInput | WorkflowStepExecutionUpsertWithWhereUniqueWithoutStepInput[]
    createMany?: WorkflowStepExecutionCreateManyStepInputEnvelope
    set?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    disconnect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    delete?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    connect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    update?: WorkflowStepExecutionUpdateWithWhereUniqueWithoutStepInput | WorkflowStepExecutionUpdateWithWhereUniqueWithoutStepInput[]
    updateMany?: WorkflowStepExecutionUpdateManyWithWhereWithoutStepInput | WorkflowStepExecutionUpdateManyWithWhereWithoutStepInput[]
    deleteMany?: WorkflowStepExecutionScalarWhereInput | WorkflowStepExecutionScalarWhereInput[]
  }

  export type WorkflowStepApproverUpdateManyWithoutStepNestedInput = {
    create?: XOR<WorkflowStepApproverCreateWithoutStepInput, WorkflowStepApproverUncheckedCreateWithoutStepInput> | WorkflowStepApproverCreateWithoutStepInput[] | WorkflowStepApproverUncheckedCreateWithoutStepInput[]
    connectOrCreate?: WorkflowStepApproverCreateOrConnectWithoutStepInput | WorkflowStepApproverCreateOrConnectWithoutStepInput[]
    upsert?: WorkflowStepApproverUpsertWithWhereUniqueWithoutStepInput | WorkflowStepApproverUpsertWithWhereUniqueWithoutStepInput[]
    createMany?: WorkflowStepApproverCreateManyStepInputEnvelope
    set?: WorkflowStepApproverWhereUniqueInput | WorkflowStepApproverWhereUniqueInput[]
    disconnect?: WorkflowStepApproverWhereUniqueInput | WorkflowStepApproverWhereUniqueInput[]
    delete?: WorkflowStepApproverWhereUniqueInput | WorkflowStepApproverWhereUniqueInput[]
    connect?: WorkflowStepApproverWhereUniqueInput | WorkflowStepApproverWhereUniqueInput[]
    update?: WorkflowStepApproverUpdateWithWhereUniqueWithoutStepInput | WorkflowStepApproverUpdateWithWhereUniqueWithoutStepInput[]
    updateMany?: WorkflowStepApproverUpdateManyWithWhereWithoutStepInput | WorkflowStepApproverUpdateManyWithWhereWithoutStepInput[]
    deleteMany?: WorkflowStepApproverScalarWhereInput | WorkflowStepApproverScalarWhereInput[]
  }

  export type WorkflowStepExecutionUncheckedUpdateManyWithoutStepNestedInput = {
    create?: XOR<WorkflowStepExecutionCreateWithoutStepInput, WorkflowStepExecutionUncheckedCreateWithoutStepInput> | WorkflowStepExecutionCreateWithoutStepInput[] | WorkflowStepExecutionUncheckedCreateWithoutStepInput[]
    connectOrCreate?: WorkflowStepExecutionCreateOrConnectWithoutStepInput | WorkflowStepExecutionCreateOrConnectWithoutStepInput[]
    upsert?: WorkflowStepExecutionUpsertWithWhereUniqueWithoutStepInput | WorkflowStepExecutionUpsertWithWhereUniqueWithoutStepInput[]
    createMany?: WorkflowStepExecutionCreateManyStepInputEnvelope
    set?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    disconnect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    delete?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    connect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    update?: WorkflowStepExecutionUpdateWithWhereUniqueWithoutStepInput | WorkflowStepExecutionUpdateWithWhereUniqueWithoutStepInput[]
    updateMany?: WorkflowStepExecutionUpdateManyWithWhereWithoutStepInput | WorkflowStepExecutionUpdateManyWithWhereWithoutStepInput[]
    deleteMany?: WorkflowStepExecutionScalarWhereInput | WorkflowStepExecutionScalarWhereInput[]
  }

  export type WorkflowStepApproverUncheckedUpdateManyWithoutStepNestedInput = {
    create?: XOR<WorkflowStepApproverCreateWithoutStepInput, WorkflowStepApproverUncheckedCreateWithoutStepInput> | WorkflowStepApproverCreateWithoutStepInput[] | WorkflowStepApproverUncheckedCreateWithoutStepInput[]
    connectOrCreate?: WorkflowStepApproverCreateOrConnectWithoutStepInput | WorkflowStepApproverCreateOrConnectWithoutStepInput[]
    upsert?: WorkflowStepApproverUpsertWithWhereUniqueWithoutStepInput | WorkflowStepApproverUpsertWithWhereUniqueWithoutStepInput[]
    createMany?: WorkflowStepApproverCreateManyStepInputEnvelope
    set?: WorkflowStepApproverWhereUniqueInput | WorkflowStepApproverWhereUniqueInput[]
    disconnect?: WorkflowStepApproverWhereUniqueInput | WorkflowStepApproverWhereUniqueInput[]
    delete?: WorkflowStepApproverWhereUniqueInput | WorkflowStepApproverWhereUniqueInput[]
    connect?: WorkflowStepApproverWhereUniqueInput | WorkflowStepApproverWhereUniqueInput[]
    update?: WorkflowStepApproverUpdateWithWhereUniqueWithoutStepInput | WorkflowStepApproverUpdateWithWhereUniqueWithoutStepInput[]
    updateMany?: WorkflowStepApproverUpdateManyWithWhereWithoutStepInput | WorkflowStepApproverUpdateManyWithWhereWithoutStepInput[]
    deleteMany?: WorkflowStepApproverScalarWhereInput | WorkflowStepApproverScalarWhereInput[]
  }

  export type WorkflowStepCreateNestedOneWithoutApproversInput = {
    create?: XOR<WorkflowStepCreateWithoutApproversInput, WorkflowStepUncheckedCreateWithoutApproversInput>
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutApproversInput
    connect?: WorkflowStepWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApproverStepsInput = {
    create?: XOR<UserCreateWithoutApproverStepsInput, UserUncheckedCreateWithoutApproverStepsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApproverStepsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkflowApprovalCreateNestedManyWithoutStepApproverInput = {
    create?: XOR<WorkflowApprovalCreateWithoutStepApproverInput, WorkflowApprovalUncheckedCreateWithoutStepApproverInput> | WorkflowApprovalCreateWithoutStepApproverInput[] | WorkflowApprovalUncheckedCreateWithoutStepApproverInput[]
    connectOrCreate?: WorkflowApprovalCreateOrConnectWithoutStepApproverInput | WorkflowApprovalCreateOrConnectWithoutStepApproverInput[]
    createMany?: WorkflowApprovalCreateManyStepApproverInputEnvelope
    connect?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
  }

  export type WorkflowApprovalUncheckedCreateNestedManyWithoutStepApproverInput = {
    create?: XOR<WorkflowApprovalCreateWithoutStepApproverInput, WorkflowApprovalUncheckedCreateWithoutStepApproverInput> | WorkflowApprovalCreateWithoutStepApproverInput[] | WorkflowApprovalUncheckedCreateWithoutStepApproverInput[]
    connectOrCreate?: WorkflowApprovalCreateOrConnectWithoutStepApproverInput | WorkflowApprovalCreateOrConnectWithoutStepApproverInput[]
    createMany?: WorkflowApprovalCreateManyStepApproverInputEnvelope
    connect?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
  }

  export type EnumApproverTypeFieldUpdateOperationsInput = {
    set?: $Enums.ApproverType
  }

  export type WorkflowStepUpdateOneRequiredWithoutApproversNestedInput = {
    create?: XOR<WorkflowStepCreateWithoutApproversInput, WorkflowStepUncheckedCreateWithoutApproversInput>
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutApproversInput
    upsert?: WorkflowStepUpsertWithoutApproversInput
    connect?: WorkflowStepWhereUniqueInput
    update?: XOR<XOR<WorkflowStepUpdateToOneWithWhereWithoutApproversInput, WorkflowStepUpdateWithoutApproversInput>, WorkflowStepUncheckedUpdateWithoutApproversInput>
  }

  export type UserUpdateOneRequiredWithoutApproverStepsNestedInput = {
    create?: XOR<UserCreateWithoutApproverStepsInput, UserUncheckedCreateWithoutApproverStepsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApproverStepsInput
    upsert?: UserUpsertWithoutApproverStepsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApproverStepsInput, UserUpdateWithoutApproverStepsInput>, UserUncheckedUpdateWithoutApproverStepsInput>
  }

  export type WorkflowApprovalUpdateManyWithoutStepApproverNestedInput = {
    create?: XOR<WorkflowApprovalCreateWithoutStepApproverInput, WorkflowApprovalUncheckedCreateWithoutStepApproverInput> | WorkflowApprovalCreateWithoutStepApproverInput[] | WorkflowApprovalUncheckedCreateWithoutStepApproverInput[]
    connectOrCreate?: WorkflowApprovalCreateOrConnectWithoutStepApproverInput | WorkflowApprovalCreateOrConnectWithoutStepApproverInput[]
    upsert?: WorkflowApprovalUpsertWithWhereUniqueWithoutStepApproverInput | WorkflowApprovalUpsertWithWhereUniqueWithoutStepApproverInput[]
    createMany?: WorkflowApprovalCreateManyStepApproverInputEnvelope
    set?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
    disconnect?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
    delete?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
    connect?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
    update?: WorkflowApprovalUpdateWithWhereUniqueWithoutStepApproverInput | WorkflowApprovalUpdateWithWhereUniqueWithoutStepApproverInput[]
    updateMany?: WorkflowApprovalUpdateManyWithWhereWithoutStepApproverInput | WorkflowApprovalUpdateManyWithWhereWithoutStepApproverInput[]
    deleteMany?: WorkflowApprovalScalarWhereInput | WorkflowApprovalScalarWhereInput[]
  }

  export type WorkflowApprovalUncheckedUpdateManyWithoutStepApproverNestedInput = {
    create?: XOR<WorkflowApprovalCreateWithoutStepApproverInput, WorkflowApprovalUncheckedCreateWithoutStepApproverInput> | WorkflowApprovalCreateWithoutStepApproverInput[] | WorkflowApprovalUncheckedCreateWithoutStepApproverInput[]
    connectOrCreate?: WorkflowApprovalCreateOrConnectWithoutStepApproverInput | WorkflowApprovalCreateOrConnectWithoutStepApproverInput[]
    upsert?: WorkflowApprovalUpsertWithWhereUniqueWithoutStepApproverInput | WorkflowApprovalUpsertWithWhereUniqueWithoutStepApproverInput[]
    createMany?: WorkflowApprovalCreateManyStepApproverInputEnvelope
    set?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
    disconnect?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
    delete?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
    connect?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
    update?: WorkflowApprovalUpdateWithWhereUniqueWithoutStepApproverInput | WorkflowApprovalUpdateWithWhereUniqueWithoutStepApproverInput[]
    updateMany?: WorkflowApprovalUpdateManyWithWhereWithoutStepApproverInput | WorkflowApprovalUpdateManyWithWhereWithoutStepApproverInput[]
    deleteMany?: WorkflowApprovalScalarWhereInput | WorkflowApprovalScalarWhereInput[]
  }

  export type WorkflowDefinitionCreateNestedOneWithoutInstancesInput = {
    create?: XOR<WorkflowDefinitionCreateWithoutInstancesInput, WorkflowDefinitionUncheckedCreateWithoutInstancesInput>
    connectOrCreate?: WorkflowDefinitionCreateOrConnectWithoutInstancesInput
    connect?: WorkflowDefinitionWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutWorkflowInstancesInput = {
    create?: XOR<AccountCreateWithoutWorkflowInstancesInput, AccountUncheckedCreateWithoutWorkflowInstancesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutWorkflowInstancesInput
    connect?: AccountWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInitiatedWorkflowsInput = {
    create?: XOR<UserCreateWithoutInitiatedWorkflowsInput, UserUncheckedCreateWithoutInitiatedWorkflowsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInitiatedWorkflowsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkflowStepExecutionCreateNestedManyWithoutInstanceInput = {
    create?: XOR<WorkflowStepExecutionCreateWithoutInstanceInput, WorkflowStepExecutionUncheckedCreateWithoutInstanceInput> | WorkflowStepExecutionCreateWithoutInstanceInput[] | WorkflowStepExecutionUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WorkflowStepExecutionCreateOrConnectWithoutInstanceInput | WorkflowStepExecutionCreateOrConnectWithoutInstanceInput[]
    createMany?: WorkflowStepExecutionCreateManyInstanceInputEnvelope
    connect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
  }

  export type WorkflowApprovalCreateNestedManyWithoutInstanceInput = {
    create?: XOR<WorkflowApprovalCreateWithoutInstanceInput, WorkflowApprovalUncheckedCreateWithoutInstanceInput> | WorkflowApprovalCreateWithoutInstanceInput[] | WorkflowApprovalUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WorkflowApprovalCreateOrConnectWithoutInstanceInput | WorkflowApprovalCreateOrConnectWithoutInstanceInput[]
    createMany?: WorkflowApprovalCreateManyInstanceInputEnvelope
    connect?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
  }

  export type WorkflowStepExecutionUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<WorkflowStepExecutionCreateWithoutInstanceInput, WorkflowStepExecutionUncheckedCreateWithoutInstanceInput> | WorkflowStepExecutionCreateWithoutInstanceInput[] | WorkflowStepExecutionUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WorkflowStepExecutionCreateOrConnectWithoutInstanceInput | WorkflowStepExecutionCreateOrConnectWithoutInstanceInput[]
    createMany?: WorkflowStepExecutionCreateManyInstanceInputEnvelope
    connect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
  }

  export type WorkflowApprovalUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<WorkflowApprovalCreateWithoutInstanceInput, WorkflowApprovalUncheckedCreateWithoutInstanceInput> | WorkflowApprovalCreateWithoutInstanceInput[] | WorkflowApprovalUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WorkflowApprovalCreateOrConnectWithoutInstanceInput | WorkflowApprovalCreateOrConnectWithoutInstanceInput[]
    createMany?: WorkflowApprovalCreateManyInstanceInputEnvelope
    connect?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
  }

  export type EnumWorkflowStatusFieldUpdateOperationsInput = {
    set?: $Enums.WorkflowStatus
  }

  export type WorkflowDefinitionUpdateOneRequiredWithoutInstancesNestedInput = {
    create?: XOR<WorkflowDefinitionCreateWithoutInstancesInput, WorkflowDefinitionUncheckedCreateWithoutInstancesInput>
    connectOrCreate?: WorkflowDefinitionCreateOrConnectWithoutInstancesInput
    upsert?: WorkflowDefinitionUpsertWithoutInstancesInput
    connect?: WorkflowDefinitionWhereUniqueInput
    update?: XOR<XOR<WorkflowDefinitionUpdateToOneWithWhereWithoutInstancesInput, WorkflowDefinitionUpdateWithoutInstancesInput>, WorkflowDefinitionUncheckedUpdateWithoutInstancesInput>
  }

  export type AccountUpdateOneRequiredWithoutWorkflowInstancesNestedInput = {
    create?: XOR<AccountCreateWithoutWorkflowInstancesInput, AccountUncheckedCreateWithoutWorkflowInstancesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutWorkflowInstancesInput
    upsert?: AccountUpsertWithoutWorkflowInstancesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutWorkflowInstancesInput, AccountUpdateWithoutWorkflowInstancesInput>, AccountUncheckedUpdateWithoutWorkflowInstancesInput>
  }

  export type UserUpdateOneRequiredWithoutInitiatedWorkflowsNestedInput = {
    create?: XOR<UserCreateWithoutInitiatedWorkflowsInput, UserUncheckedCreateWithoutInitiatedWorkflowsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInitiatedWorkflowsInput
    upsert?: UserUpsertWithoutInitiatedWorkflowsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInitiatedWorkflowsInput, UserUpdateWithoutInitiatedWorkflowsInput>, UserUncheckedUpdateWithoutInitiatedWorkflowsInput>
  }

  export type WorkflowStepExecutionUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<WorkflowStepExecutionCreateWithoutInstanceInput, WorkflowStepExecutionUncheckedCreateWithoutInstanceInput> | WorkflowStepExecutionCreateWithoutInstanceInput[] | WorkflowStepExecutionUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WorkflowStepExecutionCreateOrConnectWithoutInstanceInput | WorkflowStepExecutionCreateOrConnectWithoutInstanceInput[]
    upsert?: WorkflowStepExecutionUpsertWithWhereUniqueWithoutInstanceInput | WorkflowStepExecutionUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: WorkflowStepExecutionCreateManyInstanceInputEnvelope
    set?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    disconnect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    delete?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    connect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    update?: WorkflowStepExecutionUpdateWithWhereUniqueWithoutInstanceInput | WorkflowStepExecutionUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: WorkflowStepExecutionUpdateManyWithWhereWithoutInstanceInput | WorkflowStepExecutionUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: WorkflowStepExecutionScalarWhereInput | WorkflowStepExecutionScalarWhereInput[]
  }

  export type WorkflowApprovalUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<WorkflowApprovalCreateWithoutInstanceInput, WorkflowApprovalUncheckedCreateWithoutInstanceInput> | WorkflowApprovalCreateWithoutInstanceInput[] | WorkflowApprovalUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WorkflowApprovalCreateOrConnectWithoutInstanceInput | WorkflowApprovalCreateOrConnectWithoutInstanceInput[]
    upsert?: WorkflowApprovalUpsertWithWhereUniqueWithoutInstanceInput | WorkflowApprovalUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: WorkflowApprovalCreateManyInstanceInputEnvelope
    set?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
    disconnect?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
    delete?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
    connect?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
    update?: WorkflowApprovalUpdateWithWhereUniqueWithoutInstanceInput | WorkflowApprovalUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: WorkflowApprovalUpdateManyWithWhereWithoutInstanceInput | WorkflowApprovalUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: WorkflowApprovalScalarWhereInput | WorkflowApprovalScalarWhereInput[]
  }

  export type WorkflowStepExecutionUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<WorkflowStepExecutionCreateWithoutInstanceInput, WorkflowStepExecutionUncheckedCreateWithoutInstanceInput> | WorkflowStepExecutionCreateWithoutInstanceInput[] | WorkflowStepExecutionUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WorkflowStepExecutionCreateOrConnectWithoutInstanceInput | WorkflowStepExecutionCreateOrConnectWithoutInstanceInput[]
    upsert?: WorkflowStepExecutionUpsertWithWhereUniqueWithoutInstanceInput | WorkflowStepExecutionUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: WorkflowStepExecutionCreateManyInstanceInputEnvelope
    set?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    disconnect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    delete?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    connect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    update?: WorkflowStepExecutionUpdateWithWhereUniqueWithoutInstanceInput | WorkflowStepExecutionUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: WorkflowStepExecutionUpdateManyWithWhereWithoutInstanceInput | WorkflowStepExecutionUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: WorkflowStepExecutionScalarWhereInput | WorkflowStepExecutionScalarWhereInput[]
  }

  export type WorkflowApprovalUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<WorkflowApprovalCreateWithoutInstanceInput, WorkflowApprovalUncheckedCreateWithoutInstanceInput> | WorkflowApprovalCreateWithoutInstanceInput[] | WorkflowApprovalUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WorkflowApprovalCreateOrConnectWithoutInstanceInput | WorkflowApprovalCreateOrConnectWithoutInstanceInput[]
    upsert?: WorkflowApprovalUpsertWithWhereUniqueWithoutInstanceInput | WorkflowApprovalUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: WorkflowApprovalCreateManyInstanceInputEnvelope
    set?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
    disconnect?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
    delete?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
    connect?: WorkflowApprovalWhereUniqueInput | WorkflowApprovalWhereUniqueInput[]
    update?: WorkflowApprovalUpdateWithWhereUniqueWithoutInstanceInput | WorkflowApprovalUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: WorkflowApprovalUpdateManyWithWhereWithoutInstanceInput | WorkflowApprovalUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: WorkflowApprovalScalarWhereInput | WorkflowApprovalScalarWhereInput[]
  }

  export type WorkflowInstanceCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<WorkflowInstanceCreateWithoutExecutionsInput, WorkflowInstanceUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutExecutionsInput
    connect?: WorkflowInstanceWhereUniqueInput
  }

  export type WorkflowStepCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<WorkflowStepCreateWithoutExecutionsInput, WorkflowStepUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutExecutionsInput
    connect?: WorkflowStepWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedStepsInput = {
    create?: XOR<UserCreateWithoutAssignedStepsInput, UserUncheckedCreateWithoutAssignedStepsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedStepsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumWorkflowStepStatusFieldUpdateOperationsInput = {
    set?: $Enums.WorkflowStepStatus
  }

  export type WorkflowInstanceUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<WorkflowInstanceCreateWithoutExecutionsInput, WorkflowInstanceUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutExecutionsInput
    upsert?: WorkflowInstanceUpsertWithoutExecutionsInput
    connect?: WorkflowInstanceWhereUniqueInput
    update?: XOR<XOR<WorkflowInstanceUpdateToOneWithWhereWithoutExecutionsInput, WorkflowInstanceUpdateWithoutExecutionsInput>, WorkflowInstanceUncheckedUpdateWithoutExecutionsInput>
  }

  export type WorkflowStepUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<WorkflowStepCreateWithoutExecutionsInput, WorkflowStepUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutExecutionsInput
    upsert?: WorkflowStepUpsertWithoutExecutionsInput
    connect?: WorkflowStepWhereUniqueInput
    update?: XOR<XOR<WorkflowStepUpdateToOneWithWhereWithoutExecutionsInput, WorkflowStepUpdateWithoutExecutionsInput>, WorkflowStepUncheckedUpdateWithoutExecutionsInput>
  }

  export type UserUpdateOneWithoutAssignedStepsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedStepsInput, UserUncheckedCreateWithoutAssignedStepsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedStepsInput
    upsert?: UserUpsertWithoutAssignedStepsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedStepsInput, UserUpdateWithoutAssignedStepsInput>, UserUncheckedUpdateWithoutAssignedStepsInput>
  }

  export type WorkflowInstanceCreateNestedOneWithoutApprovalsInput = {
    create?: XOR<WorkflowInstanceCreateWithoutApprovalsInput, WorkflowInstanceUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutApprovalsInput
    connect?: WorkflowInstanceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovalsInput = {
    create?: XOR<UserCreateWithoutApprovalsInput, UserUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovalsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkflowStepApproverCreateNestedOneWithoutApprovalsInput = {
    create?: XOR<WorkflowStepApproverCreateWithoutApprovalsInput, WorkflowStepApproverUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: WorkflowStepApproverCreateOrConnectWithoutApprovalsInput
    connect?: WorkflowStepApproverWhereUniqueInput
  }

  export type EnumApprovalStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApprovalStatus
  }

  export type WorkflowInstanceUpdateOneRequiredWithoutApprovalsNestedInput = {
    create?: XOR<WorkflowInstanceCreateWithoutApprovalsInput, WorkflowInstanceUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutApprovalsInput
    upsert?: WorkflowInstanceUpsertWithoutApprovalsInput
    connect?: WorkflowInstanceWhereUniqueInput
    update?: XOR<XOR<WorkflowInstanceUpdateToOneWithWhereWithoutApprovalsInput, WorkflowInstanceUpdateWithoutApprovalsInput>, WorkflowInstanceUncheckedUpdateWithoutApprovalsInput>
  }

  export type UserUpdateOneRequiredWithoutApprovalsNestedInput = {
    create?: XOR<UserCreateWithoutApprovalsInput, UserUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovalsInput
    upsert?: UserUpsertWithoutApprovalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovalsInput, UserUpdateWithoutApprovalsInput>, UserUncheckedUpdateWithoutApprovalsInput>
  }

  export type WorkflowStepApproverUpdateOneRequiredWithoutApprovalsNestedInput = {
    create?: XOR<WorkflowStepApproverCreateWithoutApprovalsInput, WorkflowStepApproverUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: WorkflowStepApproverCreateOrConnectWithoutApprovalsInput
    upsert?: WorkflowStepApproverUpsertWithoutApprovalsInput
    connect?: WorkflowStepApproverWhereUniqueInput
    update?: XOR<XOR<WorkflowStepApproverUpdateToOneWithWhereWithoutApprovalsInput, WorkflowStepApproverUpdateWithoutApprovalsInput>, WorkflowStepApproverUncheckedUpdateWithoutApprovalsInput>
  }

  export type AccountCreateNestedOneWithoutWorkflowTemplatesInput = {
    create?: XOR<AccountCreateWithoutWorkflowTemplatesInput, AccountUncheckedCreateWithoutWorkflowTemplatesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutWorkflowTemplatesInput
    connect?: AccountWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedTemplatesInput = {
    create?: XOR<UserCreateWithoutCreatedTemplatesInput, UserUncheckedCreateWithoutCreatedTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTemplatesInput
    connect?: UserWhereUniqueInput
  }

  export type WorkflowDefinitionCreateNestedOneWithoutTemplatesInput = {
    create?: XOR<WorkflowDefinitionCreateWithoutTemplatesInput, WorkflowDefinitionUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: WorkflowDefinitionCreateOrConnectWithoutTemplatesInput
    connect?: WorkflowDefinitionWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AccountUpdateOneWithoutWorkflowTemplatesNestedInput = {
    create?: XOR<AccountCreateWithoutWorkflowTemplatesInput, AccountUncheckedCreateWithoutWorkflowTemplatesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutWorkflowTemplatesInput
    upsert?: AccountUpsertWithoutWorkflowTemplatesInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutWorkflowTemplatesInput, AccountUpdateWithoutWorkflowTemplatesInput>, AccountUncheckedUpdateWithoutWorkflowTemplatesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedTemplatesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTemplatesInput, UserUncheckedCreateWithoutCreatedTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTemplatesInput
    upsert?: UserUpsertWithoutCreatedTemplatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedTemplatesInput, UserUpdateWithoutCreatedTemplatesInput>, UserUncheckedUpdateWithoutCreatedTemplatesInput>
  }

  export type WorkflowDefinitionUpdateOneWithoutTemplatesNestedInput = {
    create?: XOR<WorkflowDefinitionCreateWithoutTemplatesInput, WorkflowDefinitionUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: WorkflowDefinitionCreateOrConnectWithoutTemplatesInput
    upsert?: WorkflowDefinitionUpsertWithoutTemplatesInput
    disconnect?: WorkflowDefinitionWhereInput | boolean
    delete?: WorkflowDefinitionWhereInput | boolean
    connect?: WorkflowDefinitionWhereUniqueInput
    update?: XOR<XOR<WorkflowDefinitionUpdateToOneWithWhereWithoutTemplatesInput, WorkflowDefinitionUpdateWithoutTemplatesInput>, WorkflowDefinitionUncheckedUpdateWithoutTemplatesInput>
  }

  export type AccountCreateNestedOneWithoutAutomationRulesInput = {
    create?: XOR<AccountCreateWithoutAutomationRulesInput, AccountUncheckedCreateWithoutAutomationRulesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAutomationRulesInput
    connect?: AccountWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedRulesInput = {
    create?: XOR<UserCreateWithoutCreatedRulesInput, UserUncheckedCreateWithoutCreatedRulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedRulesInput
    connect?: UserWhereUniqueInput
  }

  export type AutomationExecutionCreateNestedManyWithoutRuleInput = {
    create?: XOR<AutomationExecutionCreateWithoutRuleInput, AutomationExecutionUncheckedCreateWithoutRuleInput> | AutomationExecutionCreateWithoutRuleInput[] | AutomationExecutionUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: AutomationExecutionCreateOrConnectWithoutRuleInput | AutomationExecutionCreateOrConnectWithoutRuleInput[]
    createMany?: AutomationExecutionCreateManyRuleInputEnvelope
    connect?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
  }

  export type AutomationExecutionUncheckedCreateNestedManyWithoutRuleInput = {
    create?: XOR<AutomationExecutionCreateWithoutRuleInput, AutomationExecutionUncheckedCreateWithoutRuleInput> | AutomationExecutionCreateWithoutRuleInput[] | AutomationExecutionUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: AutomationExecutionCreateOrConnectWithoutRuleInput | AutomationExecutionCreateOrConnectWithoutRuleInput[]
    createMany?: AutomationExecutionCreateManyRuleInputEnvelope
    connect?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
  }

  export type AccountUpdateOneRequiredWithoutAutomationRulesNestedInput = {
    create?: XOR<AccountCreateWithoutAutomationRulesInput, AccountUncheckedCreateWithoutAutomationRulesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAutomationRulesInput
    upsert?: AccountUpsertWithoutAutomationRulesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutAutomationRulesInput, AccountUpdateWithoutAutomationRulesInput>, AccountUncheckedUpdateWithoutAutomationRulesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedRulesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedRulesInput, UserUncheckedCreateWithoutCreatedRulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedRulesInput
    upsert?: UserUpsertWithoutCreatedRulesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedRulesInput, UserUpdateWithoutCreatedRulesInput>, UserUncheckedUpdateWithoutCreatedRulesInput>
  }

  export type AutomationExecutionUpdateManyWithoutRuleNestedInput = {
    create?: XOR<AutomationExecutionCreateWithoutRuleInput, AutomationExecutionUncheckedCreateWithoutRuleInput> | AutomationExecutionCreateWithoutRuleInput[] | AutomationExecutionUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: AutomationExecutionCreateOrConnectWithoutRuleInput | AutomationExecutionCreateOrConnectWithoutRuleInput[]
    upsert?: AutomationExecutionUpsertWithWhereUniqueWithoutRuleInput | AutomationExecutionUpsertWithWhereUniqueWithoutRuleInput[]
    createMany?: AutomationExecutionCreateManyRuleInputEnvelope
    set?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    disconnect?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    delete?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    connect?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    update?: AutomationExecutionUpdateWithWhereUniqueWithoutRuleInput | AutomationExecutionUpdateWithWhereUniqueWithoutRuleInput[]
    updateMany?: AutomationExecutionUpdateManyWithWhereWithoutRuleInput | AutomationExecutionUpdateManyWithWhereWithoutRuleInput[]
    deleteMany?: AutomationExecutionScalarWhereInput | AutomationExecutionScalarWhereInput[]
  }

  export type AutomationExecutionUncheckedUpdateManyWithoutRuleNestedInput = {
    create?: XOR<AutomationExecutionCreateWithoutRuleInput, AutomationExecutionUncheckedCreateWithoutRuleInput> | AutomationExecutionCreateWithoutRuleInput[] | AutomationExecutionUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: AutomationExecutionCreateOrConnectWithoutRuleInput | AutomationExecutionCreateOrConnectWithoutRuleInput[]
    upsert?: AutomationExecutionUpsertWithWhereUniqueWithoutRuleInput | AutomationExecutionUpsertWithWhereUniqueWithoutRuleInput[]
    createMany?: AutomationExecutionCreateManyRuleInputEnvelope
    set?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    disconnect?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    delete?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    connect?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    update?: AutomationExecutionUpdateWithWhereUniqueWithoutRuleInput | AutomationExecutionUpdateWithWhereUniqueWithoutRuleInput[]
    updateMany?: AutomationExecutionUpdateManyWithWhereWithoutRuleInput | AutomationExecutionUpdateManyWithWhereWithoutRuleInput[]
    deleteMany?: AutomationExecutionScalarWhereInput | AutomationExecutionScalarWhereInput[]
  }

  export type AutomationRuleCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<AutomationRuleCreateWithoutExecutionsInput, AutomationRuleUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: AutomationRuleCreateOrConnectWithoutExecutionsInput
    connect?: AutomationRuleWhereUniqueInput
  }

  export type EnumAutomationStatusFieldUpdateOperationsInput = {
    set?: $Enums.AutomationStatus
  }

  export type AutomationRuleUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<AutomationRuleCreateWithoutExecutionsInput, AutomationRuleUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: AutomationRuleCreateOrConnectWithoutExecutionsInput
    upsert?: AutomationRuleUpsertWithoutExecutionsInput
    connect?: AutomationRuleWhereUniqueInput
    update?: XOR<XOR<AutomationRuleUpdateToOneWithWhereWithoutExecutionsInput, AutomationRuleUpdateWithoutExecutionsInput>, AutomationRuleUncheckedUpdateWithoutExecutionsInput>
  }

  export type UserCreateNestedOneWithoutCreatedTestPlansInput = {
    create?: XOR<UserCreateWithoutCreatedTestPlansInput, UserUncheckedCreateWithoutCreatedTestPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTestPlansInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedTestPlansInput = {
    create?: XOR<UserCreateWithoutAssignedTestPlansInput, UserUncheckedCreateWithoutAssignedTestPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTestPlansInput
    connect?: UserWhereUniqueInput
  }

  export type TestCaseCreateNestedManyWithoutTestPlanInput = {
    create?: XOR<TestCaseCreateWithoutTestPlanInput, TestCaseUncheckedCreateWithoutTestPlanInput> | TestCaseCreateWithoutTestPlanInput[] | TestCaseUncheckedCreateWithoutTestPlanInput[]
    connectOrCreate?: TestCaseCreateOrConnectWithoutTestPlanInput | TestCaseCreateOrConnectWithoutTestPlanInput[]
    createMany?: TestCaseCreateManyTestPlanInputEnvelope
    connect?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
  }

  export type TestExecutionCreateNestedManyWithoutTestPlanInput = {
    create?: XOR<TestExecutionCreateWithoutTestPlanInput, TestExecutionUncheckedCreateWithoutTestPlanInput> | TestExecutionCreateWithoutTestPlanInput[] | TestExecutionUncheckedCreateWithoutTestPlanInput[]
    connectOrCreate?: TestExecutionCreateOrConnectWithoutTestPlanInput | TestExecutionCreateOrConnectWithoutTestPlanInput[]
    createMany?: TestExecutionCreateManyTestPlanInputEnvelope
    connect?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
  }

  export type QAReviewCreateNestedManyWithoutTestPlanInput = {
    create?: XOR<QAReviewCreateWithoutTestPlanInput, QAReviewUncheckedCreateWithoutTestPlanInput> | QAReviewCreateWithoutTestPlanInput[] | QAReviewUncheckedCreateWithoutTestPlanInput[]
    connectOrCreate?: QAReviewCreateOrConnectWithoutTestPlanInput | QAReviewCreateOrConnectWithoutTestPlanInput[]
    createMany?: QAReviewCreateManyTestPlanInputEnvelope
    connect?: QAReviewWhereUniqueInput | QAReviewWhereUniqueInput[]
  }

  export type TestCaseUncheckedCreateNestedManyWithoutTestPlanInput = {
    create?: XOR<TestCaseCreateWithoutTestPlanInput, TestCaseUncheckedCreateWithoutTestPlanInput> | TestCaseCreateWithoutTestPlanInput[] | TestCaseUncheckedCreateWithoutTestPlanInput[]
    connectOrCreate?: TestCaseCreateOrConnectWithoutTestPlanInput | TestCaseCreateOrConnectWithoutTestPlanInput[]
    createMany?: TestCaseCreateManyTestPlanInputEnvelope
    connect?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
  }

  export type TestExecutionUncheckedCreateNestedManyWithoutTestPlanInput = {
    create?: XOR<TestExecutionCreateWithoutTestPlanInput, TestExecutionUncheckedCreateWithoutTestPlanInput> | TestExecutionCreateWithoutTestPlanInput[] | TestExecutionUncheckedCreateWithoutTestPlanInput[]
    connectOrCreate?: TestExecutionCreateOrConnectWithoutTestPlanInput | TestExecutionCreateOrConnectWithoutTestPlanInput[]
    createMany?: TestExecutionCreateManyTestPlanInputEnvelope
    connect?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
  }

  export type QAReviewUncheckedCreateNestedManyWithoutTestPlanInput = {
    create?: XOR<QAReviewCreateWithoutTestPlanInput, QAReviewUncheckedCreateWithoutTestPlanInput> | QAReviewCreateWithoutTestPlanInput[] | QAReviewUncheckedCreateWithoutTestPlanInput[]
    connectOrCreate?: QAReviewCreateOrConnectWithoutTestPlanInput | QAReviewCreateOrConnectWithoutTestPlanInput[]
    createMany?: QAReviewCreateManyTestPlanInputEnvelope
    connect?: QAReviewWhereUniqueInput | QAReviewWhereUniqueInput[]
  }

  export type EnumTestPlanStatusFieldUpdateOperationsInput = {
    set?: $Enums.TestPlanStatus
  }

  export type UserUpdateOneRequiredWithoutCreatedTestPlansNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTestPlansInput, UserUncheckedCreateWithoutCreatedTestPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTestPlansInput
    upsert?: UserUpsertWithoutCreatedTestPlansInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedTestPlansInput, UserUpdateWithoutCreatedTestPlansInput>, UserUncheckedUpdateWithoutCreatedTestPlansInput>
  }

  export type UserUpdateOneWithoutAssignedTestPlansNestedInput = {
    create?: XOR<UserCreateWithoutAssignedTestPlansInput, UserUncheckedCreateWithoutAssignedTestPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTestPlansInput
    upsert?: UserUpsertWithoutAssignedTestPlansInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedTestPlansInput, UserUpdateWithoutAssignedTestPlansInput>, UserUncheckedUpdateWithoutAssignedTestPlansInput>
  }

  export type TestCaseUpdateManyWithoutTestPlanNestedInput = {
    create?: XOR<TestCaseCreateWithoutTestPlanInput, TestCaseUncheckedCreateWithoutTestPlanInput> | TestCaseCreateWithoutTestPlanInput[] | TestCaseUncheckedCreateWithoutTestPlanInput[]
    connectOrCreate?: TestCaseCreateOrConnectWithoutTestPlanInput | TestCaseCreateOrConnectWithoutTestPlanInput[]
    upsert?: TestCaseUpsertWithWhereUniqueWithoutTestPlanInput | TestCaseUpsertWithWhereUniqueWithoutTestPlanInput[]
    createMany?: TestCaseCreateManyTestPlanInputEnvelope
    set?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    disconnect?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    delete?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    connect?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    update?: TestCaseUpdateWithWhereUniqueWithoutTestPlanInput | TestCaseUpdateWithWhereUniqueWithoutTestPlanInput[]
    updateMany?: TestCaseUpdateManyWithWhereWithoutTestPlanInput | TestCaseUpdateManyWithWhereWithoutTestPlanInput[]
    deleteMany?: TestCaseScalarWhereInput | TestCaseScalarWhereInput[]
  }

  export type TestExecutionUpdateManyWithoutTestPlanNestedInput = {
    create?: XOR<TestExecutionCreateWithoutTestPlanInput, TestExecutionUncheckedCreateWithoutTestPlanInput> | TestExecutionCreateWithoutTestPlanInput[] | TestExecutionUncheckedCreateWithoutTestPlanInput[]
    connectOrCreate?: TestExecutionCreateOrConnectWithoutTestPlanInput | TestExecutionCreateOrConnectWithoutTestPlanInput[]
    upsert?: TestExecutionUpsertWithWhereUniqueWithoutTestPlanInput | TestExecutionUpsertWithWhereUniqueWithoutTestPlanInput[]
    createMany?: TestExecutionCreateManyTestPlanInputEnvelope
    set?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
    disconnect?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
    delete?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
    connect?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
    update?: TestExecutionUpdateWithWhereUniqueWithoutTestPlanInput | TestExecutionUpdateWithWhereUniqueWithoutTestPlanInput[]
    updateMany?: TestExecutionUpdateManyWithWhereWithoutTestPlanInput | TestExecutionUpdateManyWithWhereWithoutTestPlanInput[]
    deleteMany?: TestExecutionScalarWhereInput | TestExecutionScalarWhereInput[]
  }

  export type QAReviewUpdateManyWithoutTestPlanNestedInput = {
    create?: XOR<QAReviewCreateWithoutTestPlanInput, QAReviewUncheckedCreateWithoutTestPlanInput> | QAReviewCreateWithoutTestPlanInput[] | QAReviewUncheckedCreateWithoutTestPlanInput[]
    connectOrCreate?: QAReviewCreateOrConnectWithoutTestPlanInput | QAReviewCreateOrConnectWithoutTestPlanInput[]
    upsert?: QAReviewUpsertWithWhereUniqueWithoutTestPlanInput | QAReviewUpsertWithWhereUniqueWithoutTestPlanInput[]
    createMany?: QAReviewCreateManyTestPlanInputEnvelope
    set?: QAReviewWhereUniqueInput | QAReviewWhereUniqueInput[]
    disconnect?: QAReviewWhereUniqueInput | QAReviewWhereUniqueInput[]
    delete?: QAReviewWhereUniqueInput | QAReviewWhereUniqueInput[]
    connect?: QAReviewWhereUniqueInput | QAReviewWhereUniqueInput[]
    update?: QAReviewUpdateWithWhereUniqueWithoutTestPlanInput | QAReviewUpdateWithWhereUniqueWithoutTestPlanInput[]
    updateMany?: QAReviewUpdateManyWithWhereWithoutTestPlanInput | QAReviewUpdateManyWithWhereWithoutTestPlanInput[]
    deleteMany?: QAReviewScalarWhereInput | QAReviewScalarWhereInput[]
  }

  export type TestCaseUncheckedUpdateManyWithoutTestPlanNestedInput = {
    create?: XOR<TestCaseCreateWithoutTestPlanInput, TestCaseUncheckedCreateWithoutTestPlanInput> | TestCaseCreateWithoutTestPlanInput[] | TestCaseUncheckedCreateWithoutTestPlanInput[]
    connectOrCreate?: TestCaseCreateOrConnectWithoutTestPlanInput | TestCaseCreateOrConnectWithoutTestPlanInput[]
    upsert?: TestCaseUpsertWithWhereUniqueWithoutTestPlanInput | TestCaseUpsertWithWhereUniqueWithoutTestPlanInput[]
    createMany?: TestCaseCreateManyTestPlanInputEnvelope
    set?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    disconnect?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    delete?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    connect?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    update?: TestCaseUpdateWithWhereUniqueWithoutTestPlanInput | TestCaseUpdateWithWhereUniqueWithoutTestPlanInput[]
    updateMany?: TestCaseUpdateManyWithWhereWithoutTestPlanInput | TestCaseUpdateManyWithWhereWithoutTestPlanInput[]
    deleteMany?: TestCaseScalarWhereInput | TestCaseScalarWhereInput[]
  }

  export type TestExecutionUncheckedUpdateManyWithoutTestPlanNestedInput = {
    create?: XOR<TestExecutionCreateWithoutTestPlanInput, TestExecutionUncheckedCreateWithoutTestPlanInput> | TestExecutionCreateWithoutTestPlanInput[] | TestExecutionUncheckedCreateWithoutTestPlanInput[]
    connectOrCreate?: TestExecutionCreateOrConnectWithoutTestPlanInput | TestExecutionCreateOrConnectWithoutTestPlanInput[]
    upsert?: TestExecutionUpsertWithWhereUniqueWithoutTestPlanInput | TestExecutionUpsertWithWhereUniqueWithoutTestPlanInput[]
    createMany?: TestExecutionCreateManyTestPlanInputEnvelope
    set?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
    disconnect?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
    delete?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
    connect?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
    update?: TestExecutionUpdateWithWhereUniqueWithoutTestPlanInput | TestExecutionUpdateWithWhereUniqueWithoutTestPlanInput[]
    updateMany?: TestExecutionUpdateManyWithWhereWithoutTestPlanInput | TestExecutionUpdateManyWithWhereWithoutTestPlanInput[]
    deleteMany?: TestExecutionScalarWhereInput | TestExecutionScalarWhereInput[]
  }

  export type QAReviewUncheckedUpdateManyWithoutTestPlanNestedInput = {
    create?: XOR<QAReviewCreateWithoutTestPlanInput, QAReviewUncheckedCreateWithoutTestPlanInput> | QAReviewCreateWithoutTestPlanInput[] | QAReviewUncheckedCreateWithoutTestPlanInput[]
    connectOrCreate?: QAReviewCreateOrConnectWithoutTestPlanInput | QAReviewCreateOrConnectWithoutTestPlanInput[]
    upsert?: QAReviewUpsertWithWhereUniqueWithoutTestPlanInput | QAReviewUpsertWithWhereUniqueWithoutTestPlanInput[]
    createMany?: QAReviewCreateManyTestPlanInputEnvelope
    set?: QAReviewWhereUniqueInput | QAReviewWhereUniqueInput[]
    disconnect?: QAReviewWhereUniqueInput | QAReviewWhereUniqueInput[]
    delete?: QAReviewWhereUniqueInput | QAReviewWhereUniqueInput[]
    connect?: QAReviewWhereUniqueInput | QAReviewWhereUniqueInput[]
    update?: QAReviewUpdateWithWhereUniqueWithoutTestPlanInput | QAReviewUpdateWithWhereUniqueWithoutTestPlanInput[]
    updateMany?: QAReviewUpdateManyWithWhereWithoutTestPlanInput | QAReviewUpdateManyWithWhereWithoutTestPlanInput[]
    deleteMany?: QAReviewScalarWhereInput | QAReviewScalarWhereInput[]
  }

  export type TestCaseCreatetagsInput = {
    set: string[]
  }

  export type TestPlanCreateNestedOneWithoutTestCasesInput = {
    create?: XOR<TestPlanCreateWithoutTestCasesInput, TestPlanUncheckedCreateWithoutTestCasesInput>
    connectOrCreate?: TestPlanCreateOrConnectWithoutTestCasesInput
    connect?: TestPlanWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedTestCasesInput = {
    create?: XOR<UserCreateWithoutCreatedTestCasesInput, UserUncheckedCreateWithoutCreatedTestCasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTestCasesInput
    connect?: UserWhereUniqueInput
  }

  export type TestExecutionCreateNestedManyWithoutTestCaseInput = {
    create?: XOR<TestExecutionCreateWithoutTestCaseInput, TestExecutionUncheckedCreateWithoutTestCaseInput> | TestExecutionCreateWithoutTestCaseInput[] | TestExecutionUncheckedCreateWithoutTestCaseInput[]
    connectOrCreate?: TestExecutionCreateOrConnectWithoutTestCaseInput | TestExecutionCreateOrConnectWithoutTestCaseInput[]
    createMany?: TestExecutionCreateManyTestCaseInputEnvelope
    connect?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
  }

  export type DefectTestCaseCreateNestedManyWithoutTestCaseInput = {
    create?: XOR<DefectTestCaseCreateWithoutTestCaseInput, DefectTestCaseUncheckedCreateWithoutTestCaseInput> | DefectTestCaseCreateWithoutTestCaseInput[] | DefectTestCaseUncheckedCreateWithoutTestCaseInput[]
    connectOrCreate?: DefectTestCaseCreateOrConnectWithoutTestCaseInput | DefectTestCaseCreateOrConnectWithoutTestCaseInput[]
    createMany?: DefectTestCaseCreateManyTestCaseInputEnvelope
    connect?: DefectTestCaseWhereUniqueInput | DefectTestCaseWhereUniqueInput[]
  }

  export type TestExecutionUncheckedCreateNestedManyWithoutTestCaseInput = {
    create?: XOR<TestExecutionCreateWithoutTestCaseInput, TestExecutionUncheckedCreateWithoutTestCaseInput> | TestExecutionCreateWithoutTestCaseInput[] | TestExecutionUncheckedCreateWithoutTestCaseInput[]
    connectOrCreate?: TestExecutionCreateOrConnectWithoutTestCaseInput | TestExecutionCreateOrConnectWithoutTestCaseInput[]
    createMany?: TestExecutionCreateManyTestCaseInputEnvelope
    connect?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
  }

  export type DefectTestCaseUncheckedCreateNestedManyWithoutTestCaseInput = {
    create?: XOR<DefectTestCaseCreateWithoutTestCaseInput, DefectTestCaseUncheckedCreateWithoutTestCaseInput> | DefectTestCaseCreateWithoutTestCaseInput[] | DefectTestCaseUncheckedCreateWithoutTestCaseInput[]
    connectOrCreate?: DefectTestCaseCreateOrConnectWithoutTestCaseInput | DefectTestCaseCreateOrConnectWithoutTestCaseInput[]
    createMany?: DefectTestCaseCreateManyTestCaseInputEnvelope
    connect?: DefectTestCaseWhereUniqueInput | DefectTestCaseWhereUniqueInput[]
  }

  export type EnumTestCasePriorityFieldUpdateOperationsInput = {
    set?: $Enums.TestCasePriority
  }

  export type EnumTestCaseStatusFieldUpdateOperationsInput = {
    set?: $Enums.TestCaseStatus
  }

  export type TestCaseUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TestPlanUpdateOneRequiredWithoutTestCasesNestedInput = {
    create?: XOR<TestPlanCreateWithoutTestCasesInput, TestPlanUncheckedCreateWithoutTestCasesInput>
    connectOrCreate?: TestPlanCreateOrConnectWithoutTestCasesInput
    upsert?: TestPlanUpsertWithoutTestCasesInput
    connect?: TestPlanWhereUniqueInput
    update?: XOR<XOR<TestPlanUpdateToOneWithWhereWithoutTestCasesInput, TestPlanUpdateWithoutTestCasesInput>, TestPlanUncheckedUpdateWithoutTestCasesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedTestCasesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTestCasesInput, UserUncheckedCreateWithoutCreatedTestCasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTestCasesInput
    upsert?: UserUpsertWithoutCreatedTestCasesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedTestCasesInput, UserUpdateWithoutCreatedTestCasesInput>, UserUncheckedUpdateWithoutCreatedTestCasesInput>
  }

  export type TestExecutionUpdateManyWithoutTestCaseNestedInput = {
    create?: XOR<TestExecutionCreateWithoutTestCaseInput, TestExecutionUncheckedCreateWithoutTestCaseInput> | TestExecutionCreateWithoutTestCaseInput[] | TestExecutionUncheckedCreateWithoutTestCaseInput[]
    connectOrCreate?: TestExecutionCreateOrConnectWithoutTestCaseInput | TestExecutionCreateOrConnectWithoutTestCaseInput[]
    upsert?: TestExecutionUpsertWithWhereUniqueWithoutTestCaseInput | TestExecutionUpsertWithWhereUniqueWithoutTestCaseInput[]
    createMany?: TestExecutionCreateManyTestCaseInputEnvelope
    set?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
    disconnect?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
    delete?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
    connect?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
    update?: TestExecutionUpdateWithWhereUniqueWithoutTestCaseInput | TestExecutionUpdateWithWhereUniqueWithoutTestCaseInput[]
    updateMany?: TestExecutionUpdateManyWithWhereWithoutTestCaseInput | TestExecutionUpdateManyWithWhereWithoutTestCaseInput[]
    deleteMany?: TestExecutionScalarWhereInput | TestExecutionScalarWhereInput[]
  }

  export type DefectTestCaseUpdateManyWithoutTestCaseNestedInput = {
    create?: XOR<DefectTestCaseCreateWithoutTestCaseInput, DefectTestCaseUncheckedCreateWithoutTestCaseInput> | DefectTestCaseCreateWithoutTestCaseInput[] | DefectTestCaseUncheckedCreateWithoutTestCaseInput[]
    connectOrCreate?: DefectTestCaseCreateOrConnectWithoutTestCaseInput | DefectTestCaseCreateOrConnectWithoutTestCaseInput[]
    upsert?: DefectTestCaseUpsertWithWhereUniqueWithoutTestCaseInput | DefectTestCaseUpsertWithWhereUniqueWithoutTestCaseInput[]
    createMany?: DefectTestCaseCreateManyTestCaseInputEnvelope
    set?: DefectTestCaseWhereUniqueInput | DefectTestCaseWhereUniqueInput[]
    disconnect?: DefectTestCaseWhereUniqueInput | DefectTestCaseWhereUniqueInput[]
    delete?: DefectTestCaseWhereUniqueInput | DefectTestCaseWhereUniqueInput[]
    connect?: DefectTestCaseWhereUniqueInput | DefectTestCaseWhereUniqueInput[]
    update?: DefectTestCaseUpdateWithWhereUniqueWithoutTestCaseInput | DefectTestCaseUpdateWithWhereUniqueWithoutTestCaseInput[]
    updateMany?: DefectTestCaseUpdateManyWithWhereWithoutTestCaseInput | DefectTestCaseUpdateManyWithWhereWithoutTestCaseInput[]
    deleteMany?: DefectTestCaseScalarWhereInput | DefectTestCaseScalarWhereInput[]
  }

  export type TestExecutionUncheckedUpdateManyWithoutTestCaseNestedInput = {
    create?: XOR<TestExecutionCreateWithoutTestCaseInput, TestExecutionUncheckedCreateWithoutTestCaseInput> | TestExecutionCreateWithoutTestCaseInput[] | TestExecutionUncheckedCreateWithoutTestCaseInput[]
    connectOrCreate?: TestExecutionCreateOrConnectWithoutTestCaseInput | TestExecutionCreateOrConnectWithoutTestCaseInput[]
    upsert?: TestExecutionUpsertWithWhereUniqueWithoutTestCaseInput | TestExecutionUpsertWithWhereUniqueWithoutTestCaseInput[]
    createMany?: TestExecutionCreateManyTestCaseInputEnvelope
    set?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
    disconnect?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
    delete?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
    connect?: TestExecutionWhereUniqueInput | TestExecutionWhereUniqueInput[]
    update?: TestExecutionUpdateWithWhereUniqueWithoutTestCaseInput | TestExecutionUpdateWithWhereUniqueWithoutTestCaseInput[]
    updateMany?: TestExecutionUpdateManyWithWhereWithoutTestCaseInput | TestExecutionUpdateManyWithWhereWithoutTestCaseInput[]
    deleteMany?: TestExecutionScalarWhereInput | TestExecutionScalarWhereInput[]
  }

  export type DefectTestCaseUncheckedUpdateManyWithoutTestCaseNestedInput = {
    create?: XOR<DefectTestCaseCreateWithoutTestCaseInput, DefectTestCaseUncheckedCreateWithoutTestCaseInput> | DefectTestCaseCreateWithoutTestCaseInput[] | DefectTestCaseUncheckedCreateWithoutTestCaseInput[]
    connectOrCreate?: DefectTestCaseCreateOrConnectWithoutTestCaseInput | DefectTestCaseCreateOrConnectWithoutTestCaseInput[]
    upsert?: DefectTestCaseUpsertWithWhereUniqueWithoutTestCaseInput | DefectTestCaseUpsertWithWhereUniqueWithoutTestCaseInput[]
    createMany?: DefectTestCaseCreateManyTestCaseInputEnvelope
    set?: DefectTestCaseWhereUniqueInput | DefectTestCaseWhereUniqueInput[]
    disconnect?: DefectTestCaseWhereUniqueInput | DefectTestCaseWhereUniqueInput[]
    delete?: DefectTestCaseWhereUniqueInput | DefectTestCaseWhereUniqueInput[]
    connect?: DefectTestCaseWhereUniqueInput | DefectTestCaseWhereUniqueInput[]
    update?: DefectTestCaseUpdateWithWhereUniqueWithoutTestCaseInput | DefectTestCaseUpdateWithWhereUniqueWithoutTestCaseInput[]
    updateMany?: DefectTestCaseUpdateManyWithWhereWithoutTestCaseInput | DefectTestCaseUpdateManyWithWhereWithoutTestCaseInput[]
    deleteMany?: DefectTestCaseScalarWhereInput | DefectTestCaseScalarWhereInput[]
  }

  export type TestPlanCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<TestPlanCreateWithoutExecutionsInput, TestPlanUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: TestPlanCreateOrConnectWithoutExecutionsInput
    connect?: TestPlanWhereUniqueInput
  }

  export type TestCaseCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<TestCaseCreateWithoutExecutionsInput, TestCaseUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: TestCaseCreateOrConnectWithoutExecutionsInput
    connect?: TestCaseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTestExecutionsInput = {
    create?: XOR<UserCreateWithoutTestExecutionsInput, UserUncheckedCreateWithoutTestExecutionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestExecutionsInput
    connect?: UserWhereUniqueInput
  }

  export type DefectCreateNestedManyWithoutTestExecutionInput = {
    create?: XOR<DefectCreateWithoutTestExecutionInput, DefectUncheckedCreateWithoutTestExecutionInput> | DefectCreateWithoutTestExecutionInput[] | DefectUncheckedCreateWithoutTestExecutionInput[]
    connectOrCreate?: DefectCreateOrConnectWithoutTestExecutionInput | DefectCreateOrConnectWithoutTestExecutionInput[]
    createMany?: DefectCreateManyTestExecutionInputEnvelope
    connect?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
  }

  export type DefectUncheckedCreateNestedManyWithoutTestExecutionInput = {
    create?: XOR<DefectCreateWithoutTestExecutionInput, DefectUncheckedCreateWithoutTestExecutionInput> | DefectCreateWithoutTestExecutionInput[] | DefectUncheckedCreateWithoutTestExecutionInput[]
    connectOrCreate?: DefectCreateOrConnectWithoutTestExecutionInput | DefectCreateOrConnectWithoutTestExecutionInput[]
    createMany?: DefectCreateManyTestExecutionInputEnvelope
    connect?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
  }

  export type EnumTestExecutionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TestExecutionStatus
  }

  export type TestPlanUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<TestPlanCreateWithoutExecutionsInput, TestPlanUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: TestPlanCreateOrConnectWithoutExecutionsInput
    upsert?: TestPlanUpsertWithoutExecutionsInput
    connect?: TestPlanWhereUniqueInput
    update?: XOR<XOR<TestPlanUpdateToOneWithWhereWithoutExecutionsInput, TestPlanUpdateWithoutExecutionsInput>, TestPlanUncheckedUpdateWithoutExecutionsInput>
  }

  export type TestCaseUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<TestCaseCreateWithoutExecutionsInput, TestCaseUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: TestCaseCreateOrConnectWithoutExecutionsInput
    upsert?: TestCaseUpsertWithoutExecutionsInput
    connect?: TestCaseWhereUniqueInput
    update?: XOR<XOR<TestCaseUpdateToOneWithWhereWithoutExecutionsInput, TestCaseUpdateWithoutExecutionsInput>, TestCaseUncheckedUpdateWithoutExecutionsInput>
  }

  export type UserUpdateOneRequiredWithoutTestExecutionsNestedInput = {
    create?: XOR<UserCreateWithoutTestExecutionsInput, UserUncheckedCreateWithoutTestExecutionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestExecutionsInput
    upsert?: UserUpsertWithoutTestExecutionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTestExecutionsInput, UserUpdateWithoutTestExecutionsInput>, UserUncheckedUpdateWithoutTestExecutionsInput>
  }

  export type DefectUpdateManyWithoutTestExecutionNestedInput = {
    create?: XOR<DefectCreateWithoutTestExecutionInput, DefectUncheckedCreateWithoutTestExecutionInput> | DefectCreateWithoutTestExecutionInput[] | DefectUncheckedCreateWithoutTestExecutionInput[]
    connectOrCreate?: DefectCreateOrConnectWithoutTestExecutionInput | DefectCreateOrConnectWithoutTestExecutionInput[]
    upsert?: DefectUpsertWithWhereUniqueWithoutTestExecutionInput | DefectUpsertWithWhereUniqueWithoutTestExecutionInput[]
    createMany?: DefectCreateManyTestExecutionInputEnvelope
    set?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
    disconnect?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
    delete?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
    connect?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
    update?: DefectUpdateWithWhereUniqueWithoutTestExecutionInput | DefectUpdateWithWhereUniqueWithoutTestExecutionInput[]
    updateMany?: DefectUpdateManyWithWhereWithoutTestExecutionInput | DefectUpdateManyWithWhereWithoutTestExecutionInput[]
    deleteMany?: DefectScalarWhereInput | DefectScalarWhereInput[]
  }

  export type DefectUncheckedUpdateManyWithoutTestExecutionNestedInput = {
    create?: XOR<DefectCreateWithoutTestExecutionInput, DefectUncheckedCreateWithoutTestExecutionInput> | DefectCreateWithoutTestExecutionInput[] | DefectUncheckedCreateWithoutTestExecutionInput[]
    connectOrCreate?: DefectCreateOrConnectWithoutTestExecutionInput | DefectCreateOrConnectWithoutTestExecutionInput[]
    upsert?: DefectUpsertWithWhereUniqueWithoutTestExecutionInput | DefectUpsertWithWhereUniqueWithoutTestExecutionInput[]
    createMany?: DefectCreateManyTestExecutionInputEnvelope
    set?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
    disconnect?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
    delete?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
    connect?: DefectWhereUniqueInput | DefectWhereUniqueInput[]
    update?: DefectUpdateWithWhereUniqueWithoutTestExecutionInput | DefectUpdateWithWhereUniqueWithoutTestExecutionInput[]
    updateMany?: DefectUpdateManyWithWhereWithoutTestExecutionInput | DefectUpdateManyWithWhereWithoutTestExecutionInput[]
    deleteMany?: DefectScalarWhereInput | DefectScalarWhereInput[]
  }

  export type TestExecutionCreateNestedOneWithoutDefectsInput = {
    create?: XOR<TestExecutionCreateWithoutDefectsInput, TestExecutionUncheckedCreateWithoutDefectsInput>
    connectOrCreate?: TestExecutionCreateOrConnectWithoutDefectsInput
    connect?: TestExecutionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReportedDefectsInput = {
    create?: XOR<UserCreateWithoutReportedDefectsInput, UserUncheckedCreateWithoutReportedDefectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportedDefectsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedDefectsInput = {
    create?: XOR<UserCreateWithoutAssignedDefectsInput, UserUncheckedCreateWithoutAssignedDefectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedDefectsInput
    connect?: UserWhereUniqueInput
  }

  export type DefectTestCaseCreateNestedManyWithoutDefectInput = {
    create?: XOR<DefectTestCaseCreateWithoutDefectInput, DefectTestCaseUncheckedCreateWithoutDefectInput> | DefectTestCaseCreateWithoutDefectInput[] | DefectTestCaseUncheckedCreateWithoutDefectInput[]
    connectOrCreate?: DefectTestCaseCreateOrConnectWithoutDefectInput | DefectTestCaseCreateOrConnectWithoutDefectInput[]
    createMany?: DefectTestCaseCreateManyDefectInputEnvelope
    connect?: DefectTestCaseWhereUniqueInput | DefectTestCaseWhereUniqueInput[]
  }

  export type DefectCommentCreateNestedManyWithoutDefectInput = {
    create?: XOR<DefectCommentCreateWithoutDefectInput, DefectCommentUncheckedCreateWithoutDefectInput> | DefectCommentCreateWithoutDefectInput[] | DefectCommentUncheckedCreateWithoutDefectInput[]
    connectOrCreate?: DefectCommentCreateOrConnectWithoutDefectInput | DefectCommentCreateOrConnectWithoutDefectInput[]
    createMany?: DefectCommentCreateManyDefectInputEnvelope
    connect?: DefectCommentWhereUniqueInput | DefectCommentWhereUniqueInput[]
  }

  export type DefectTestCaseUncheckedCreateNestedManyWithoutDefectInput = {
    create?: XOR<DefectTestCaseCreateWithoutDefectInput, DefectTestCaseUncheckedCreateWithoutDefectInput> | DefectTestCaseCreateWithoutDefectInput[] | DefectTestCaseUncheckedCreateWithoutDefectInput[]
    connectOrCreate?: DefectTestCaseCreateOrConnectWithoutDefectInput | DefectTestCaseCreateOrConnectWithoutDefectInput[]
    createMany?: DefectTestCaseCreateManyDefectInputEnvelope
    connect?: DefectTestCaseWhereUniqueInput | DefectTestCaseWhereUniqueInput[]
  }

  export type DefectCommentUncheckedCreateNestedManyWithoutDefectInput = {
    create?: XOR<DefectCommentCreateWithoutDefectInput, DefectCommentUncheckedCreateWithoutDefectInput> | DefectCommentCreateWithoutDefectInput[] | DefectCommentUncheckedCreateWithoutDefectInput[]
    connectOrCreate?: DefectCommentCreateOrConnectWithoutDefectInput | DefectCommentCreateOrConnectWithoutDefectInput[]
    createMany?: DefectCommentCreateManyDefectInputEnvelope
    connect?: DefectCommentWhereUniqueInput | DefectCommentWhereUniqueInput[]
  }

  export type EnumDefectSeverityFieldUpdateOperationsInput = {
    set?: $Enums.DefectSeverity
  }

  export type EnumDefectPriorityFieldUpdateOperationsInput = {
    set?: $Enums.DefectPriority
  }

  export type EnumDefectStatusFieldUpdateOperationsInput = {
    set?: $Enums.DefectStatus
  }

  export type TestExecutionUpdateOneWithoutDefectsNestedInput = {
    create?: XOR<TestExecutionCreateWithoutDefectsInput, TestExecutionUncheckedCreateWithoutDefectsInput>
    connectOrCreate?: TestExecutionCreateOrConnectWithoutDefectsInput
    upsert?: TestExecutionUpsertWithoutDefectsInput
    disconnect?: TestExecutionWhereInput | boolean
    delete?: TestExecutionWhereInput | boolean
    connect?: TestExecutionWhereUniqueInput
    update?: XOR<XOR<TestExecutionUpdateToOneWithWhereWithoutDefectsInput, TestExecutionUpdateWithoutDefectsInput>, TestExecutionUncheckedUpdateWithoutDefectsInput>
  }

  export type UserUpdateOneRequiredWithoutReportedDefectsNestedInput = {
    create?: XOR<UserCreateWithoutReportedDefectsInput, UserUncheckedCreateWithoutReportedDefectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportedDefectsInput
    upsert?: UserUpsertWithoutReportedDefectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportedDefectsInput, UserUpdateWithoutReportedDefectsInput>, UserUncheckedUpdateWithoutReportedDefectsInput>
  }

  export type UserUpdateOneWithoutAssignedDefectsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedDefectsInput, UserUncheckedCreateWithoutAssignedDefectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedDefectsInput
    upsert?: UserUpsertWithoutAssignedDefectsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedDefectsInput, UserUpdateWithoutAssignedDefectsInput>, UserUncheckedUpdateWithoutAssignedDefectsInput>
  }

  export type DefectTestCaseUpdateManyWithoutDefectNestedInput = {
    create?: XOR<DefectTestCaseCreateWithoutDefectInput, DefectTestCaseUncheckedCreateWithoutDefectInput> | DefectTestCaseCreateWithoutDefectInput[] | DefectTestCaseUncheckedCreateWithoutDefectInput[]
    connectOrCreate?: DefectTestCaseCreateOrConnectWithoutDefectInput | DefectTestCaseCreateOrConnectWithoutDefectInput[]
    upsert?: DefectTestCaseUpsertWithWhereUniqueWithoutDefectInput | DefectTestCaseUpsertWithWhereUniqueWithoutDefectInput[]
    createMany?: DefectTestCaseCreateManyDefectInputEnvelope
    set?: DefectTestCaseWhereUniqueInput | DefectTestCaseWhereUniqueInput[]
    disconnect?: DefectTestCaseWhereUniqueInput | DefectTestCaseWhereUniqueInput[]
    delete?: DefectTestCaseWhereUniqueInput | DefectTestCaseWhereUniqueInput[]
    connect?: DefectTestCaseWhereUniqueInput | DefectTestCaseWhereUniqueInput[]
    update?: DefectTestCaseUpdateWithWhereUniqueWithoutDefectInput | DefectTestCaseUpdateWithWhereUniqueWithoutDefectInput[]
    updateMany?: DefectTestCaseUpdateManyWithWhereWithoutDefectInput | DefectTestCaseUpdateManyWithWhereWithoutDefectInput[]
    deleteMany?: DefectTestCaseScalarWhereInput | DefectTestCaseScalarWhereInput[]
  }

  export type DefectCommentUpdateManyWithoutDefectNestedInput = {
    create?: XOR<DefectCommentCreateWithoutDefectInput, DefectCommentUncheckedCreateWithoutDefectInput> | DefectCommentCreateWithoutDefectInput[] | DefectCommentUncheckedCreateWithoutDefectInput[]
    connectOrCreate?: DefectCommentCreateOrConnectWithoutDefectInput | DefectCommentCreateOrConnectWithoutDefectInput[]
    upsert?: DefectCommentUpsertWithWhereUniqueWithoutDefectInput | DefectCommentUpsertWithWhereUniqueWithoutDefectInput[]
    createMany?: DefectCommentCreateManyDefectInputEnvelope
    set?: DefectCommentWhereUniqueInput | DefectCommentWhereUniqueInput[]
    disconnect?: DefectCommentWhereUniqueInput | DefectCommentWhereUniqueInput[]
    delete?: DefectCommentWhereUniqueInput | DefectCommentWhereUniqueInput[]
    connect?: DefectCommentWhereUniqueInput | DefectCommentWhereUniqueInput[]
    update?: DefectCommentUpdateWithWhereUniqueWithoutDefectInput | DefectCommentUpdateWithWhereUniqueWithoutDefectInput[]
    updateMany?: DefectCommentUpdateManyWithWhereWithoutDefectInput | DefectCommentUpdateManyWithWhereWithoutDefectInput[]
    deleteMany?: DefectCommentScalarWhereInput | DefectCommentScalarWhereInput[]
  }

  export type DefectTestCaseUncheckedUpdateManyWithoutDefectNestedInput = {
    create?: XOR<DefectTestCaseCreateWithoutDefectInput, DefectTestCaseUncheckedCreateWithoutDefectInput> | DefectTestCaseCreateWithoutDefectInput[] | DefectTestCaseUncheckedCreateWithoutDefectInput[]
    connectOrCreate?: DefectTestCaseCreateOrConnectWithoutDefectInput | DefectTestCaseCreateOrConnectWithoutDefectInput[]
    upsert?: DefectTestCaseUpsertWithWhereUniqueWithoutDefectInput | DefectTestCaseUpsertWithWhereUniqueWithoutDefectInput[]
    createMany?: DefectTestCaseCreateManyDefectInputEnvelope
    set?: DefectTestCaseWhereUniqueInput | DefectTestCaseWhereUniqueInput[]
    disconnect?: DefectTestCaseWhereUniqueInput | DefectTestCaseWhereUniqueInput[]
    delete?: DefectTestCaseWhereUniqueInput | DefectTestCaseWhereUniqueInput[]
    connect?: DefectTestCaseWhereUniqueInput | DefectTestCaseWhereUniqueInput[]
    update?: DefectTestCaseUpdateWithWhereUniqueWithoutDefectInput | DefectTestCaseUpdateWithWhereUniqueWithoutDefectInput[]
    updateMany?: DefectTestCaseUpdateManyWithWhereWithoutDefectInput | DefectTestCaseUpdateManyWithWhereWithoutDefectInput[]
    deleteMany?: DefectTestCaseScalarWhereInput | DefectTestCaseScalarWhereInput[]
  }

  export type DefectCommentUncheckedUpdateManyWithoutDefectNestedInput = {
    create?: XOR<DefectCommentCreateWithoutDefectInput, DefectCommentUncheckedCreateWithoutDefectInput> | DefectCommentCreateWithoutDefectInput[] | DefectCommentUncheckedCreateWithoutDefectInput[]
    connectOrCreate?: DefectCommentCreateOrConnectWithoutDefectInput | DefectCommentCreateOrConnectWithoutDefectInput[]
    upsert?: DefectCommentUpsertWithWhereUniqueWithoutDefectInput | DefectCommentUpsertWithWhereUniqueWithoutDefectInput[]
    createMany?: DefectCommentCreateManyDefectInputEnvelope
    set?: DefectCommentWhereUniqueInput | DefectCommentWhereUniqueInput[]
    disconnect?: DefectCommentWhereUniqueInput | DefectCommentWhereUniqueInput[]
    delete?: DefectCommentWhereUniqueInput | DefectCommentWhereUniqueInput[]
    connect?: DefectCommentWhereUniqueInput | DefectCommentWhereUniqueInput[]
    update?: DefectCommentUpdateWithWhereUniqueWithoutDefectInput | DefectCommentUpdateWithWhereUniqueWithoutDefectInput[]
    updateMany?: DefectCommentUpdateManyWithWhereWithoutDefectInput | DefectCommentUpdateManyWithWhereWithoutDefectInput[]
    deleteMany?: DefectCommentScalarWhereInput | DefectCommentScalarWhereInput[]
  }

  export type DefectCreateNestedOneWithoutTestCasesInput = {
    create?: XOR<DefectCreateWithoutTestCasesInput, DefectUncheckedCreateWithoutTestCasesInput>
    connectOrCreate?: DefectCreateOrConnectWithoutTestCasesInput
    connect?: DefectWhereUniqueInput
  }

  export type TestCaseCreateNestedOneWithoutDefectsInput = {
    create?: XOR<TestCaseCreateWithoutDefectsInput, TestCaseUncheckedCreateWithoutDefectsInput>
    connectOrCreate?: TestCaseCreateOrConnectWithoutDefectsInput
    connect?: TestCaseWhereUniqueInput
  }

  export type DefectUpdateOneRequiredWithoutTestCasesNestedInput = {
    create?: XOR<DefectCreateWithoutTestCasesInput, DefectUncheckedCreateWithoutTestCasesInput>
    connectOrCreate?: DefectCreateOrConnectWithoutTestCasesInput
    upsert?: DefectUpsertWithoutTestCasesInput
    connect?: DefectWhereUniqueInput
    update?: XOR<XOR<DefectUpdateToOneWithWhereWithoutTestCasesInput, DefectUpdateWithoutTestCasesInput>, DefectUncheckedUpdateWithoutTestCasesInput>
  }

  export type TestCaseUpdateOneRequiredWithoutDefectsNestedInput = {
    create?: XOR<TestCaseCreateWithoutDefectsInput, TestCaseUncheckedCreateWithoutDefectsInput>
    connectOrCreate?: TestCaseCreateOrConnectWithoutDefectsInput
    upsert?: TestCaseUpsertWithoutDefectsInput
    connect?: TestCaseWhereUniqueInput
    update?: XOR<XOR<TestCaseUpdateToOneWithWhereWithoutDefectsInput, TestCaseUpdateWithoutDefectsInput>, TestCaseUncheckedUpdateWithoutDefectsInput>
  }

  export type DefectCreateNestedOneWithoutCommentsInput = {
    create?: XOR<DefectCreateWithoutCommentsInput, DefectUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: DefectCreateOrConnectWithoutCommentsInput
    connect?: DefectWhereUniqueInput
  }

  export type DefectUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<DefectCreateWithoutCommentsInput, DefectUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: DefectCreateOrConnectWithoutCommentsInput
    upsert?: DefectUpsertWithoutCommentsInput
    connect?: DefectWhereUniqueInput
    update?: XOR<XOR<DefectUpdateToOneWithWhereWithoutCommentsInput, DefectUpdateWithoutCommentsInput>, DefectUncheckedUpdateWithoutCommentsInput>
  }

  export type TestPlanCreateNestedOneWithoutReviewsInput = {
    create?: XOR<TestPlanCreateWithoutReviewsInput, TestPlanUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: TestPlanCreateOrConnectWithoutReviewsInput
    connect?: TestPlanWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutQaReviewsInput = {
    create?: XOR<UserCreateWithoutQaReviewsInput, UserUncheckedCreateWithoutQaReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQaReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumQAReviewStatusFieldUpdateOperationsInput = {
    set?: $Enums.QAReviewStatus
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type TestPlanUpdateOneWithoutReviewsNestedInput = {
    create?: XOR<TestPlanCreateWithoutReviewsInput, TestPlanUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: TestPlanCreateOrConnectWithoutReviewsInput
    upsert?: TestPlanUpsertWithoutReviewsInput
    disconnect?: TestPlanWhereInput | boolean
    delete?: TestPlanWhereInput | boolean
    connect?: TestPlanWhereUniqueInput
    update?: XOR<XOR<TestPlanUpdateToOneWithWhereWithoutReviewsInput, TestPlanUpdateWithoutReviewsInput>, TestPlanUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutQaReviewsNestedInput = {
    create?: XOR<UserCreateWithoutQaReviewsInput, UserUncheckedCreateWithoutQaReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQaReviewsInput
    upsert?: UserUpsertWithoutQaReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQaReviewsInput, UserUpdateWithoutQaReviewsInput>, UserUncheckedUpdateWithoutQaReviewsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusFilter<$PrismaModel> | $Enums.AccountStatus
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountStatusFilter<$PrismaModel>
  }

  export type NestedEnumEnquiryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EnquiryStatus | EnumEnquiryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnquiryStatus[] | ListEnumEnquiryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnquiryStatus[] | ListEnumEnquiryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnquiryStatusFilter<$PrismaModel> | $Enums.EnquiryStatus
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumEnquiryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnquiryStatus | EnumEnquiryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnquiryStatus[] | ListEnumEnquiryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnquiryStatus[] | ListEnumEnquiryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnquiryStatusWithAggregatesFilter<$PrismaModel> | $Enums.EnquiryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnquiryStatusFilter<$PrismaModel>
    _max?: NestedEnumEnquiryStatusFilter<$PrismaModel>
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumProjectTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectType | EnumProjectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectType[] | ListEnumProjectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectType[] | ListEnumProjectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectTypeFilter<$PrismaModel> | $Enums.ProjectType
  }

  export type NestedEnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type NestedEnumProjectTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectType | EnumProjectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectType[] | ListEnumProjectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectType[] | ListEnumProjectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProjectType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectTypeFilter<$PrismaModel>
    _max?: NestedEnumProjectTypeFilter<$PrismaModel>
  }

  export type NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumCompletedProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CompletedProjectStatus | EnumCompletedProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CompletedProjectStatus[] | ListEnumCompletedProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompletedProjectStatus[] | ListEnumCompletedProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCompletedProjectStatusFilter<$PrismaModel> | $Enums.CompletedProjectStatus
  }

  export type NestedEnumCompletedProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompletedProjectStatus | EnumCompletedProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CompletedProjectStatus[] | ListEnumCompletedProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompletedProjectStatus[] | ListEnumCompletedProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCompletedProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.CompletedProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompletedProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumCompletedProjectStatusFilter<$PrismaModel>
  }

  export type NestedEnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type NestedEnumAppointmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentType | EnumAppointmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentTypeFilter<$PrismaModel> | $Enums.AppointmentType
  }

  export type NestedEnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type NestedEnumAppointmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentType | EnumAppointmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentTypeFilter<$PrismaModel>
    _max?: NestedEnumAppointmentTypeFilter<$PrismaModel>
  }

  export type NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumSnagStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SnagStatus | EnumSnagStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SnagStatus[] | ListEnumSnagStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SnagStatus[] | ListEnumSnagStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSnagStatusFilter<$PrismaModel> | $Enums.SnagStatus
  }

  export type NestedEnumSnagStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SnagStatus | EnumSnagStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SnagStatus[] | ListEnumSnagStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SnagStatus[] | ListEnumSnagStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSnagStatusWithAggregatesFilter<$PrismaModel> | $Enums.SnagStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSnagStatusFilter<$PrismaModel>
    _max?: NestedEnumSnagStatusFilter<$PrismaModel>
  }

  export type NestedEnumWorkflowTriggerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowTriggerType | EnumWorkflowTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowTriggerType[] | ListEnumWorkflowTriggerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowTriggerType[] | ListEnumWorkflowTriggerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowTriggerTypeFilter<$PrismaModel> | $Enums.WorkflowTriggerType
  }

  export type NestedEnumWorkflowTriggerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowTriggerType | EnumWorkflowTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowTriggerType[] | ListEnumWorkflowTriggerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowTriggerType[] | ListEnumWorkflowTriggerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowTriggerTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowTriggerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowTriggerTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkflowTriggerTypeFilter<$PrismaModel>
  }

  export type NestedEnumWorkflowStepTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStepType | EnumWorkflowStepTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStepType[] | ListEnumWorkflowStepTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStepType[] | ListEnumWorkflowStepTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStepTypeFilter<$PrismaModel> | $Enums.WorkflowStepType
  }

  export type NestedEnumWorkflowStepTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStepType | EnumWorkflowStepTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStepType[] | ListEnumWorkflowStepTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStepType[] | ListEnumWorkflowStepTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStepTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowStepType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowStepTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkflowStepTypeFilter<$PrismaModel>
  }

  export type NestedEnumApproverTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ApproverType | EnumApproverTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApproverType[] | ListEnumApproverTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApproverType[] | ListEnumApproverTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApproverTypeFilter<$PrismaModel> | $Enums.ApproverType
  }

  export type NestedEnumApproverTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApproverType | EnumApproverTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApproverType[] | ListEnumApproverTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApproverType[] | ListEnumApproverTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApproverTypeWithAggregatesFilter<$PrismaModel> | $Enums.ApproverType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApproverTypeFilter<$PrismaModel>
    _max?: NestedEnumApproverTypeFilter<$PrismaModel>
  }

  export type NestedEnumWorkflowStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusFilter<$PrismaModel> | $Enums.WorkflowStatus
  }

  export type NestedEnumWorkflowStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkflowStatusFilter<$PrismaModel>
  }

  export type NestedEnumWorkflowStepStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStepStatus | EnumWorkflowStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStepStatus[] | ListEnumWorkflowStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStepStatus[] | ListEnumWorkflowStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStepStatusFilter<$PrismaModel> | $Enums.WorkflowStepStatus
  }

  export type NestedEnumWorkflowStepStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStepStatus | EnumWorkflowStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStepStatus[] | ListEnumWorkflowStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStepStatus[] | ListEnumWorkflowStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStepStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowStepStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowStepStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkflowStepStatusFilter<$PrismaModel>
  }

  export type NestedEnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumAutomationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationStatus | EnumAutomationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationStatusFilter<$PrismaModel> | $Enums.AutomationStatus
  }

  export type NestedEnumAutomationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationStatus | EnumAutomationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationStatusWithAggregatesFilter<$PrismaModel> | $Enums.AutomationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutomationStatusFilter<$PrismaModel>
    _max?: NestedEnumAutomationStatusFilter<$PrismaModel>
  }

  export type NestedEnumTestPlanStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TestPlanStatus | EnumTestPlanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TestPlanStatus[] | ListEnumTestPlanStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestPlanStatus[] | ListEnumTestPlanStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTestPlanStatusFilter<$PrismaModel> | $Enums.TestPlanStatus
  }

  export type NestedEnumTestPlanStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TestPlanStatus | EnumTestPlanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TestPlanStatus[] | ListEnumTestPlanStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestPlanStatus[] | ListEnumTestPlanStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTestPlanStatusWithAggregatesFilter<$PrismaModel> | $Enums.TestPlanStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTestPlanStatusFilter<$PrismaModel>
    _max?: NestedEnumTestPlanStatusFilter<$PrismaModel>
  }

  export type NestedEnumTestCasePriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TestCasePriority | EnumTestCasePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TestCasePriority[] | ListEnumTestCasePriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestCasePriority[] | ListEnumTestCasePriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTestCasePriorityFilter<$PrismaModel> | $Enums.TestCasePriority
  }

  export type NestedEnumTestCaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TestCaseStatus | EnumTestCaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TestCaseStatus[] | ListEnumTestCaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestCaseStatus[] | ListEnumTestCaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTestCaseStatusFilter<$PrismaModel> | $Enums.TestCaseStatus
  }

  export type NestedEnumTestCasePriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TestCasePriority | EnumTestCasePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TestCasePriority[] | ListEnumTestCasePriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestCasePriority[] | ListEnumTestCasePriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTestCasePriorityWithAggregatesFilter<$PrismaModel> | $Enums.TestCasePriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTestCasePriorityFilter<$PrismaModel>
    _max?: NestedEnumTestCasePriorityFilter<$PrismaModel>
  }

  export type NestedEnumTestCaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TestCaseStatus | EnumTestCaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TestCaseStatus[] | ListEnumTestCaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestCaseStatus[] | ListEnumTestCaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTestCaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.TestCaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTestCaseStatusFilter<$PrismaModel>
    _max?: NestedEnumTestCaseStatusFilter<$PrismaModel>
  }

  export type NestedEnumTestExecutionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TestExecutionStatus | EnumTestExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TestExecutionStatus[] | ListEnumTestExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestExecutionStatus[] | ListEnumTestExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTestExecutionStatusFilter<$PrismaModel> | $Enums.TestExecutionStatus
  }

  export type NestedEnumTestExecutionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TestExecutionStatus | EnumTestExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TestExecutionStatus[] | ListEnumTestExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestExecutionStatus[] | ListEnumTestExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTestExecutionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TestExecutionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTestExecutionStatusFilter<$PrismaModel>
    _max?: NestedEnumTestExecutionStatusFilter<$PrismaModel>
  }

  export type NestedEnumDefectSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.DefectSeverity | EnumDefectSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.DefectSeverity[] | ListEnumDefectSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefectSeverity[] | ListEnumDefectSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumDefectSeverityFilter<$PrismaModel> | $Enums.DefectSeverity
  }

  export type NestedEnumDefectPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.DefectPriority | EnumDefectPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.DefectPriority[] | ListEnumDefectPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefectPriority[] | ListEnumDefectPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumDefectPriorityFilter<$PrismaModel> | $Enums.DefectPriority
  }

  export type NestedEnumDefectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DefectStatus | EnumDefectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DefectStatus[] | ListEnumDefectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefectStatus[] | ListEnumDefectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDefectStatusFilter<$PrismaModel> | $Enums.DefectStatus
  }

  export type NestedEnumDefectSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DefectSeverity | EnumDefectSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.DefectSeverity[] | ListEnumDefectSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefectSeverity[] | ListEnumDefectSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumDefectSeverityWithAggregatesFilter<$PrismaModel> | $Enums.DefectSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDefectSeverityFilter<$PrismaModel>
    _max?: NestedEnumDefectSeverityFilter<$PrismaModel>
  }

  export type NestedEnumDefectPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DefectPriority | EnumDefectPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.DefectPriority[] | ListEnumDefectPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefectPriority[] | ListEnumDefectPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumDefectPriorityWithAggregatesFilter<$PrismaModel> | $Enums.DefectPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDefectPriorityFilter<$PrismaModel>
    _max?: NestedEnumDefectPriorityFilter<$PrismaModel>
  }

  export type NestedEnumDefectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DefectStatus | EnumDefectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DefectStatus[] | ListEnumDefectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefectStatus[] | ListEnumDefectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDefectStatusWithAggregatesFilter<$PrismaModel> | $Enums.DefectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDefectStatusFilter<$PrismaModel>
    _max?: NestedEnumDefectStatusFilter<$PrismaModel>
  }

  export type NestedEnumQAReviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QAReviewStatus | EnumQAReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QAReviewStatus[] | ListEnumQAReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QAReviewStatus[] | ListEnumQAReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQAReviewStatusFilter<$PrismaModel> | $Enums.QAReviewStatus
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumQAReviewStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QAReviewStatus | EnumQAReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QAReviewStatus[] | ListEnumQAReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QAReviewStatus[] | ListEnumQAReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQAReviewStatusWithAggregatesFilter<$PrismaModel> | $Enums.QAReviewStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQAReviewStatusFilter<$PrismaModel>
    _max?: NestedEnumQAReviewStatusFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type AccountCreateWithoutOwnerInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityCreateNestedManyWithoutAccountInput
    appointments?: AppointmentCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectCreateNestedManyWithoutAccountInput
    contacts?: ContactCreateNestedManyWithoutAccountInput
    documents?: DocumentCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryCreateNestedManyWithoutAccountInput
    events?: EventLogCreateNestedManyWithoutAccountInput
    leads?: LeadCreateNestedManyWithoutAccountInput
    projects?: ProjectCreateNestedManyWithoutAccountInput
    snags?: SnagCreateNestedManyWithoutAccountInput
    tasks?: TaskCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutOwnerInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutAccountInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAccountInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutAccountInput
    events?: EventLogUncheckedCreateNestedManyWithoutAccountInput
    leads?: LeadUncheckedCreateNestedManyWithoutAccountInput
    projects?: ProjectUncheckedCreateNestedManyWithoutAccountInput
    snags?: SnagUncheckedCreateNestedManyWithoutAccountInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutOwnerInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutOwnerInput, AccountUncheckedCreateWithoutOwnerInput>
  }

  export type AccountCreateManyOwnerInputEnvelope = {
    data: AccountCreateManyOwnerInput | AccountCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutUserInput = {
    id?: string
    type: $Enums.ActivityType
    threadKey?: string | null
    summary?: string | null
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: Date | string
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutActivitiesInput
    enquiry?: EnquiryCreateNestedOneWithoutActivitiesInput
    lead?: LeadCreateNestedOneWithoutActivitiesInput
    project?: ProjectCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutUserInput = {
    id?: string
    accountId: string
    enquiryId?: string | null
    leadId?: string | null
    projectId?: string | null
    type: $Enums.ActivityType
    threadKey?: string | null
    summary?: string | null
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: Date | string
    createdAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutUserInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
  }

  export type ActivityCreateManyUserInputEnvelope = {
    data: ActivityCreateManyUserInput | ActivityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CompletedProjectCreateWithoutOwnerInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.CompletedProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutCompletedProjectsInput
    project?: ProjectCreateNestedOneWithoutCompletedProjectInput
  }

  export type CompletedProjectUncheckedCreateWithoutOwnerInput = {
    id?: string
    accountId: string
    projectId?: string | null
    title: string
    description?: string | null
    status?: $Enums.CompletedProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompletedProjectCreateOrConnectWithoutOwnerInput = {
    where: CompletedProjectWhereUniqueInput
    create: XOR<CompletedProjectCreateWithoutOwnerInput, CompletedProjectUncheckedCreateWithoutOwnerInput>
  }

  export type CompletedProjectCreateManyOwnerInputEnvelope = {
    data: CompletedProjectCreateManyOwnerInput | CompletedProjectCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type EnquiryCreateWithoutOwnerInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.EnquiryStatus
    priority?: $Enums.Priority
    source?: string | null
    campaign?: string | null
    medium?: string | null
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    contactMethod?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    company?: string | null
    message?: string | null
    leadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityCreateNestedManyWithoutEnquiryInput
    account?: AccountCreateNestedOneWithoutEnquiriesInput
    lead?: LeadCreateNestedOneWithoutEnquiryInput
    tasks?: TaskCreateNestedManyWithoutEnquiryInput
  }

  export type EnquiryUncheckedCreateWithoutOwnerInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.EnquiryStatus
    priority?: $Enums.Priority
    source?: string | null
    campaign?: string | null
    medium?: string | null
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    contactMethod?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    company?: string | null
    message?: string | null
    accountId?: string | null
    leadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutEnquiryInput
    lead?: LeadUncheckedCreateNestedOneWithoutEnquiryInput
    tasks?: TaskUncheckedCreateNestedManyWithoutEnquiryInput
  }

  export type EnquiryCreateOrConnectWithoutOwnerInput = {
    where: EnquiryWhereUniqueInput
    create: XOR<EnquiryCreateWithoutOwnerInput, EnquiryUncheckedCreateWithoutOwnerInput>
  }

  export type EnquiryCreateManyOwnerInputEnvelope = {
    data: EnquiryCreateManyOwnerInput | EnquiryCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type LeadCreateWithoutOwnerInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityCreateNestedManyWithoutLeadInput
    account: AccountCreateNestedOneWithoutLeadsInput
    enquiry?: EnquiryCreateNestedOneWithoutLeadInput
    project?: ProjectCreateNestedOneWithoutLeadInput
    tasks?: TaskCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutOwnerInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    accountId: string
    enquiryId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutLeadInput
    project?: ProjectUncheckedCreateNestedOneWithoutLeadInput
    tasks?: TaskUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutOwnerInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutOwnerInput, LeadUncheckedCreateWithoutOwnerInput>
  }

  export type LeadCreateManyOwnerInputEnvelope = {
    data: LeadCreateManyOwnerInput | LeadCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutOwnerInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    amountGrossIncVat: number
    vatRate?: number
    probability?: number
    source?: string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    completedProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutProjectInput
    appointments?: AppointmentCreateNestedManyWithoutProjectInput
    completedProject?: CompletedProjectCreateNestedOneWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    account: AccountCreateNestedOneWithoutProjectsInput
    lead?: LeadCreateNestedOneWithoutProjectInput
    snags?: SnagCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutOwnerInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    accountId: string
    amountGrossIncVat: number
    vatRate?: number
    probability?: number
    source?: string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    leadId?: string | null
    completedProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProjectInput
    completedProject?: CompletedProjectUncheckedCreateNestedOneWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    snags?: SnagUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutOwnerInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput>
  }

  export type ProjectCreateManyOwnerInputEnvelope = {
    data: ProjectCreateManyOwnerInput | ProjectCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutTasksInput
    enquiry?: EnquiryCreateNestedOneWithoutTasksInput
    lead?: LeadCreateNestedOneWithoutTasksInput
    project?: ProjectCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    accountId: string
    enquiryId?: string | null
    leadId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutAssigneeInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput>
  }

  export type TaskCreateManyAssigneeInputEnvelope = {
    data: TaskCreateManyAssigneeInput | TaskCreateManyAssigneeInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCreatedUsersInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedAccounts?: AccountCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutCreatedUsersInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownedAccounts?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceUncheckedCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverUncheckedCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanUncheckedCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanUncheckedCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionUncheckedCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectUncheckedCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectUncheckedCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutCreatedUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
  }

  export type UserCreateWithoutCreatedByInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedAccounts?: AccountCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutCreatedByInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: string | null
    ownedAccounts?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceUncheckedCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverUncheckedCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanUncheckedCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanUncheckedCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionUncheckedCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectUncheckedCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectUncheckedCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput>
  }

  export type UserCreateManyCreatedByInputEnvelope = {
    data: UserCreateManyCreatedByInput | UserCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutUpdatedUsersInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedAccounts?: AccountCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    createdWorkflows?: WorkflowDefinitionCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutUpdatedUsersInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownedAccounts?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdWorkflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceUncheckedCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverUncheckedCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanUncheckedCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanUncheckedCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionUncheckedCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectUncheckedCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectUncheckedCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutUpdatedUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedUsersInput, UserUncheckedCreateWithoutUpdatedUsersInput>
  }

  export type UserCreateWithoutUpdatedByInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedAccounts?: AccountCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    ownedAccounts?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceUncheckedCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverUncheckedCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanUncheckedCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanUncheckedCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionUncheckedCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectUncheckedCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectUncheckedCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutUpdatedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedByInput, UserUncheckedCreateWithoutUpdatedByInput>
  }

  export type UserCreateManyUpdatedByInputEnvelope = {
    data: UserCreateManyUpdatedByInput | UserCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowDefinitionCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    triggerType: $Enums.WorkflowTriggerType
    triggerConditions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutWorkflowsInput
    steps?: WorkflowStepCreateNestedManyWithoutWorkflowInput
    instances?: WorkflowInstanceCreateNestedManyWithoutWorkflowInput
    templates?: WorkflowTemplateCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowDefinitionUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    triggerType: $Enums.WorkflowTriggerType
    triggerConditions: JsonNullValueInput | InputJsonValue
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: WorkflowStepUncheckedCreateNestedManyWithoutWorkflowInput
    instances?: WorkflowInstanceUncheckedCreateNestedManyWithoutWorkflowInput
    templates?: WorkflowTemplateUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowDefinitionCreateOrConnectWithoutCreatedByInput = {
    where: WorkflowDefinitionWhereUniqueInput
    create: XOR<WorkflowDefinitionCreateWithoutCreatedByInput, WorkflowDefinitionUncheckedCreateWithoutCreatedByInput>
  }

  export type WorkflowDefinitionCreateManyCreatedByInputEnvelope = {
    data: WorkflowDefinitionCreateManyCreatedByInput | WorkflowDefinitionCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowInstanceCreateWithoutInitiatedByInput = {
    id?: string
    entityType: string
    entityId: string
    status: $Enums.WorkflowStatus
    currentStepId?: string | null
    priority?: $Enums.Priority
    startedAt?: Date | string
    completedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    workflow: WorkflowDefinitionCreateNestedOneWithoutInstancesInput
    account: AccountCreateNestedOneWithoutWorkflowInstancesInput
    executions?: WorkflowStepExecutionCreateNestedManyWithoutInstanceInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutInstanceInput
  }

  export type WorkflowInstanceUncheckedCreateWithoutInitiatedByInput = {
    id?: string
    workflowId: string
    entityType: string
    entityId: string
    status: $Enums.WorkflowStatus
    currentStepId?: string | null
    priority?: $Enums.Priority
    startedAt?: Date | string
    completedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId: string
    executions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutInstanceInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type WorkflowInstanceCreateOrConnectWithoutInitiatedByInput = {
    where: WorkflowInstanceWhereUniqueInput
    create: XOR<WorkflowInstanceCreateWithoutInitiatedByInput, WorkflowInstanceUncheckedCreateWithoutInitiatedByInput>
  }

  export type WorkflowInstanceCreateManyInitiatedByInputEnvelope = {
    data: WorkflowInstanceCreateManyInitiatedByInput | WorkflowInstanceCreateManyInitiatedByInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowStepExecutionCreateWithoutAssignedToInput = {
    id?: string
    status: $Enums.WorkflowStepStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    retryCount?: number
    isManual?: boolean
    instance: WorkflowInstanceCreateNestedOneWithoutExecutionsInput
    step: WorkflowStepCreateNestedOneWithoutExecutionsInput
  }

  export type WorkflowStepExecutionUncheckedCreateWithoutAssignedToInput = {
    id?: string
    instanceId: string
    stepId: string
    status: $Enums.WorkflowStepStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    retryCount?: number
    isManual?: boolean
  }

  export type WorkflowStepExecutionCreateOrConnectWithoutAssignedToInput = {
    where: WorkflowStepExecutionWhereUniqueInput
    create: XOR<WorkflowStepExecutionCreateWithoutAssignedToInput, WorkflowStepExecutionUncheckedCreateWithoutAssignedToInput>
  }

  export type WorkflowStepExecutionCreateManyAssignedToInputEnvelope = {
    data: WorkflowStepExecutionCreateManyAssignedToInput | WorkflowStepExecutionCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowStepApproverCreateWithoutUserInput = {
    id?: string
    approverType: $Enums.ApproverType
    isRequired?: boolean
    order?: number
    createdAt?: Date | string
    step: WorkflowStepCreateNestedOneWithoutApproversInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutStepApproverInput
  }

  export type WorkflowStepApproverUncheckedCreateWithoutUserInput = {
    id?: string
    stepId: string
    approverType: $Enums.ApproverType
    isRequired?: boolean
    order?: number
    createdAt?: Date | string
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutStepApproverInput
  }

  export type WorkflowStepApproverCreateOrConnectWithoutUserInput = {
    where: WorkflowStepApproverWhereUniqueInput
    create: XOR<WorkflowStepApproverCreateWithoutUserInput, WorkflowStepApproverUncheckedCreateWithoutUserInput>
  }

  export type WorkflowStepApproverCreateManyUserInputEnvelope = {
    data: WorkflowStepApproverCreateManyUserInput | WorkflowStepApproverCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowApprovalCreateWithoutApproverInput = {
    id?: string
    status: $Enums.ApprovalStatus
    comments?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestedAt?: Date | string
    remindersSent?: number
    lastReminderAt?: Date | string | null
    instance: WorkflowInstanceCreateNestedOneWithoutApprovalsInput
    stepApprover: WorkflowStepApproverCreateNestedOneWithoutApprovalsInput
  }

  export type WorkflowApprovalUncheckedCreateWithoutApproverInput = {
    id?: string
    instanceId: string
    stepApproverId: string
    status: $Enums.ApprovalStatus
    comments?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestedAt?: Date | string
    remindersSent?: number
    lastReminderAt?: Date | string | null
  }

  export type WorkflowApprovalCreateOrConnectWithoutApproverInput = {
    where: WorkflowApprovalWhereUniqueInput
    create: XOR<WorkflowApprovalCreateWithoutApproverInput, WorkflowApprovalUncheckedCreateWithoutApproverInput>
  }

  export type WorkflowApprovalCreateManyApproverInputEnvelope = {
    data: WorkflowApprovalCreateManyApproverInput | WorkflowApprovalCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowTemplateCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    industry?: string
    templateData: JsonNullValueInput | InputJsonValue
    isPublic?: boolean
    usageCount?: number
    rating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account?: AccountCreateNestedOneWithoutWorkflowTemplatesInput
    workflow?: WorkflowDefinitionCreateNestedOneWithoutTemplatesInput
  }

  export type WorkflowTemplateUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    industry?: string
    templateData: JsonNullValueInput | InputJsonValue
    isPublic?: boolean
    usageCount?: number
    rating?: number | null
    accountId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workflowId?: string | null
  }

  export type WorkflowTemplateCreateOrConnectWithoutCreatedByInput = {
    where: WorkflowTemplateWhereUniqueInput
    create: XOR<WorkflowTemplateCreateWithoutCreatedByInput, WorkflowTemplateUncheckedCreateWithoutCreatedByInput>
  }

  export type WorkflowTemplateCreateManyCreatedByInputEnvelope = {
    data: WorkflowTemplateCreateManyCreatedByInput | WorkflowTemplateCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AutomationRuleCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    triggerEvent: string
    conditions: JsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    priority?: number
    executionCount?: number
    lastExecutedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutAutomationRulesInput
    executions?: AutomationExecutionCreateNestedManyWithoutRuleInput
  }

  export type AutomationRuleUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    triggerEvent: string
    conditions: JsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    priority?: number
    executionCount?: number
    lastExecutedAt?: Date | string | null
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: AutomationExecutionUncheckedCreateNestedManyWithoutRuleInput
  }

  export type AutomationRuleCreateOrConnectWithoutCreatedByInput = {
    where: AutomationRuleWhereUniqueInput
    create: XOR<AutomationRuleCreateWithoutCreatedByInput, AutomationRuleUncheckedCreateWithoutCreatedByInput>
  }

  export type AutomationRuleCreateManyCreatedByInputEnvelope = {
    data: AutomationRuleCreateManyCreatedByInput | AutomationRuleCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type TestPlanCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    version?: string
    status?: $Enums.TestPlanStatus
    projectId?: string | null
    feature?: string | null
    environment?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedTestPlansInput
    testCases?: TestCaseCreateNestedManyWithoutTestPlanInput
    executions?: TestExecutionCreateNestedManyWithoutTestPlanInput
    reviews?: QAReviewCreateNestedManyWithoutTestPlanInput
  }

  export type TestPlanUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    version?: string
    status?: $Enums.TestPlanStatus
    projectId?: string | null
    feature?: string | null
    environment?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testCases?: TestCaseUncheckedCreateNestedManyWithoutTestPlanInput
    executions?: TestExecutionUncheckedCreateNestedManyWithoutTestPlanInput
    reviews?: QAReviewUncheckedCreateNestedManyWithoutTestPlanInput
  }

  export type TestPlanCreateOrConnectWithoutCreatedByInput = {
    where: TestPlanWhereUniqueInput
    create: XOR<TestPlanCreateWithoutCreatedByInput, TestPlanUncheckedCreateWithoutCreatedByInput>
  }

  export type TestPlanCreateManyCreatedByInputEnvelope = {
    data: TestPlanCreateManyCreatedByInput | TestPlanCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type TestPlanCreateWithoutAssignedToInput = {
    id?: string
    name: string
    description?: string | null
    version?: string
    status?: $Enums.TestPlanStatus
    projectId?: string | null
    feature?: string | null
    environment?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTestPlansInput
    testCases?: TestCaseCreateNestedManyWithoutTestPlanInput
    executions?: TestExecutionCreateNestedManyWithoutTestPlanInput
    reviews?: QAReviewCreateNestedManyWithoutTestPlanInput
  }

  export type TestPlanUncheckedCreateWithoutAssignedToInput = {
    id?: string
    name: string
    description?: string | null
    version?: string
    status?: $Enums.TestPlanStatus
    projectId?: string | null
    feature?: string | null
    environment?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    testCases?: TestCaseUncheckedCreateNestedManyWithoutTestPlanInput
    executions?: TestExecutionUncheckedCreateNestedManyWithoutTestPlanInput
    reviews?: QAReviewUncheckedCreateNestedManyWithoutTestPlanInput
  }

  export type TestPlanCreateOrConnectWithoutAssignedToInput = {
    where: TestPlanWhereUniqueInput
    create: XOR<TestPlanCreateWithoutAssignedToInput, TestPlanUncheckedCreateWithoutAssignedToInput>
  }

  export type TestPlanCreateManyAssignedToInputEnvelope = {
    data: TestPlanCreateManyAssignedToInput | TestPlanCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type TestCaseCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    preconditions?: string | null
    steps: JsonNullValueInput | InputJsonValue
    expectedResult?: string | null
    priority?: $Enums.TestCasePriority
    status?: $Enums.TestCaseStatus
    tags?: TestCaseCreatetagsInput | string[]
    automatable?: boolean
    estimatedTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testPlan: TestPlanCreateNestedOneWithoutTestCasesInput
    executions?: TestExecutionCreateNestedManyWithoutTestCaseInput
    defects?: DefectTestCaseCreateNestedManyWithoutTestCaseInput
  }

  export type TestCaseUncheckedCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    preconditions?: string | null
    steps: JsonNullValueInput | InputJsonValue
    expectedResult?: string | null
    priority?: $Enums.TestCasePriority
    status?: $Enums.TestCaseStatus
    tags?: TestCaseCreatetagsInput | string[]
    automatable?: boolean
    estimatedTime?: number | null
    testPlanId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: TestExecutionUncheckedCreateNestedManyWithoutTestCaseInput
    defects?: DefectTestCaseUncheckedCreateNestedManyWithoutTestCaseInput
  }

  export type TestCaseCreateOrConnectWithoutCreatedByInput = {
    where: TestCaseWhereUniqueInput
    create: XOR<TestCaseCreateWithoutCreatedByInput, TestCaseUncheckedCreateWithoutCreatedByInput>
  }

  export type TestCaseCreateManyCreatedByInputEnvelope = {
    data: TestCaseCreateManyCreatedByInput | TestCaseCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type TestExecutionCreateWithoutExecutedByInput = {
    id?: string
    status?: $Enums.TestExecutionStatus
    result?: string | null
    actualResult?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: number | null
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    notes?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testPlan: TestPlanCreateNestedOneWithoutExecutionsInput
    testCase: TestCaseCreateNestedOneWithoutExecutionsInput
    defects?: DefectCreateNestedManyWithoutTestExecutionInput
  }

  export type TestExecutionUncheckedCreateWithoutExecutedByInput = {
    id?: string
    testPlanId: string
    testCaseId: string
    status?: $Enums.TestExecutionStatus
    result?: string | null
    actualResult?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: number | null
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    notes?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defects?: DefectUncheckedCreateNestedManyWithoutTestExecutionInput
  }

  export type TestExecutionCreateOrConnectWithoutExecutedByInput = {
    where: TestExecutionWhereUniqueInput
    create: XOR<TestExecutionCreateWithoutExecutedByInput, TestExecutionUncheckedCreateWithoutExecutedByInput>
  }

  export type TestExecutionCreateManyExecutedByInputEnvelope = {
    data: TestExecutionCreateManyExecutedByInput | TestExecutionCreateManyExecutedByInput[]
    skipDuplicates?: boolean
  }

  export type DefectCreateWithoutReportedByInput = {
    id?: string
    title: string
    description: string
    steps?: string | null
    expectedBehavior?: string | null
    actualBehavior?: string | null
    severity?: $Enums.DefectSeverity
    priority?: $Enums.DefectPriority
    status?: $Enums.DefectStatus
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: boolean
    regression?: boolean
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testExecution?: TestExecutionCreateNestedOneWithoutDefectsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedDefectsInput
    testCases?: DefectTestCaseCreateNestedManyWithoutDefectInput
    comments?: DefectCommentCreateNestedManyWithoutDefectInput
  }

  export type DefectUncheckedCreateWithoutReportedByInput = {
    id?: string
    title: string
    description: string
    steps?: string | null
    expectedBehavior?: string | null
    actualBehavior?: string | null
    severity?: $Enums.DefectSeverity
    priority?: $Enums.DefectPriority
    status?: $Enums.DefectStatus
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: boolean
    regression?: boolean
    testExecutionId?: string | null
    assignedToId?: string | null
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testCases?: DefectTestCaseUncheckedCreateNestedManyWithoutDefectInput
    comments?: DefectCommentUncheckedCreateNestedManyWithoutDefectInput
  }

  export type DefectCreateOrConnectWithoutReportedByInput = {
    where: DefectWhereUniqueInput
    create: XOR<DefectCreateWithoutReportedByInput, DefectUncheckedCreateWithoutReportedByInput>
  }

  export type DefectCreateManyReportedByInputEnvelope = {
    data: DefectCreateManyReportedByInput | DefectCreateManyReportedByInput[]
    skipDuplicates?: boolean
  }

  export type DefectCreateWithoutAssignedToInput = {
    id?: string
    title: string
    description: string
    steps?: string | null
    expectedBehavior?: string | null
    actualBehavior?: string | null
    severity?: $Enums.DefectSeverity
    priority?: $Enums.DefectPriority
    status?: $Enums.DefectStatus
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: boolean
    regression?: boolean
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testExecution?: TestExecutionCreateNestedOneWithoutDefectsInput
    reportedBy: UserCreateNestedOneWithoutReportedDefectsInput
    testCases?: DefectTestCaseCreateNestedManyWithoutDefectInput
    comments?: DefectCommentCreateNestedManyWithoutDefectInput
  }

  export type DefectUncheckedCreateWithoutAssignedToInput = {
    id?: string
    title: string
    description: string
    steps?: string | null
    expectedBehavior?: string | null
    actualBehavior?: string | null
    severity?: $Enums.DefectSeverity
    priority?: $Enums.DefectPriority
    status?: $Enums.DefectStatus
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: boolean
    regression?: boolean
    testExecutionId?: string | null
    reportedById: string
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testCases?: DefectTestCaseUncheckedCreateNestedManyWithoutDefectInput
    comments?: DefectCommentUncheckedCreateNestedManyWithoutDefectInput
  }

  export type DefectCreateOrConnectWithoutAssignedToInput = {
    where: DefectWhereUniqueInput
    create: XOR<DefectCreateWithoutAssignedToInput, DefectUncheckedCreateWithoutAssignedToInput>
  }

  export type DefectCreateManyAssignedToInputEnvelope = {
    data: DefectCreateManyAssignedToInput | DefectCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type QAReviewCreateWithoutReviewerInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    entityId: string
    status?: $Enums.QAReviewStatus
    criteria?: NullableJsonNullValueInput | InputJsonValue
    findings?: string | null
    recommendations?: string | null
    approved?: boolean | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testPlan?: TestPlanCreateNestedOneWithoutReviewsInput
  }

  export type QAReviewUncheckedCreateWithoutReviewerInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    entityId: string
    status?: $Enums.QAReviewStatus
    criteria?: NullableJsonNullValueInput | InputJsonValue
    findings?: string | null
    recommendations?: string | null
    approved?: boolean | null
    testPlanId?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QAReviewCreateOrConnectWithoutReviewerInput = {
    where: QAReviewWhereUniqueInput
    create: XOR<QAReviewCreateWithoutReviewerInput, QAReviewUncheckedCreateWithoutReviewerInput>
  }

  export type QAReviewCreateManyReviewerInputEnvelope = {
    data: QAReviewCreateManyReviewerInput | QAReviewCreateManyReviewerInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutOwnerInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutOwnerInput, AccountUncheckedUpdateWithoutOwnerInput>
    create: XOR<AccountCreateWithoutOwnerInput, AccountUncheckedCreateWithoutOwnerInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutOwnerInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutOwnerInput, AccountUncheckedUpdateWithoutOwnerInput>
  }

  export type AccountUpdateManyWithWhereWithoutOwnerInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutOwnerInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    orgId?: StringNullableFilter<"Account"> | string | null
    name?: StringFilter<"Account"> | string
    legalName?: StringNullableFilter<"Account"> | string | null
    emails?: StringNullableListFilter<"Account">
    phones?: StringNullableListFilter<"Account">
    billingAddress?: JsonNullableFilter<"Account">
    siteAddresses?: JsonNullableFilter<"Account">
    ownerId?: StringFilter<"Account"> | string
    tags?: StringNullableListFilter<"Account">
    status?: EnumAccountStatusFilter<"Account"> | $Enums.AccountStatus
    portalToken?: StringFilter<"Account"> | string
    designFeePaid?: BoolFilter<"Account"> | boolean
    consentMarketing?: BoolFilter<"Account"> | boolean
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    createdById?: StringNullableFilter<"Account"> | string | null
    updatedById?: StringNullableFilter<"Account"> | string | null
  }

  export type ActivityUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutUserInput, ActivityUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutUserInput, ActivityUncheckedUpdateWithoutUserInput>
  }

  export type ActivityUpdateManyWithWhereWithoutUserInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutUserInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    OR?: ActivityScalarWhereInput[]
    NOT?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    id?: StringFilter<"Activity"> | string
    accountId?: StringFilter<"Activity"> | string
    enquiryId?: StringNullableFilter<"Activity"> | string | null
    leadId?: StringNullableFilter<"Activity"> | string | null
    projectId?: StringNullableFilter<"Activity"> | string | null
    userId?: StringNullableFilter<"Activity"> | string | null
    type?: EnumActivityTypeFilter<"Activity"> | $Enums.ActivityType
    threadKey?: StringNullableFilter<"Activity"> | string | null
    summary?: StringNullableFilter<"Activity"> | string | null
    body?: StringNullableFilter<"Activity"> | string | null
    attachments?: JsonNullableFilter<"Activity">
    durations?: JsonNullableFilter<"Activity">
    metadata?: JsonNullableFilter<"Activity">
    occurredAt?: DateTimeFilter<"Activity"> | Date | string
    createdAt?: DateTimeFilter<"Activity"> | Date | string
  }

  export type CompletedProjectUpsertWithWhereUniqueWithoutOwnerInput = {
    where: CompletedProjectWhereUniqueInput
    update: XOR<CompletedProjectUpdateWithoutOwnerInput, CompletedProjectUncheckedUpdateWithoutOwnerInput>
    create: XOR<CompletedProjectCreateWithoutOwnerInput, CompletedProjectUncheckedCreateWithoutOwnerInput>
  }

  export type CompletedProjectUpdateWithWhereUniqueWithoutOwnerInput = {
    where: CompletedProjectWhereUniqueInput
    data: XOR<CompletedProjectUpdateWithoutOwnerInput, CompletedProjectUncheckedUpdateWithoutOwnerInput>
  }

  export type CompletedProjectUpdateManyWithWhereWithoutOwnerInput = {
    where: CompletedProjectScalarWhereInput
    data: XOR<CompletedProjectUpdateManyMutationInput, CompletedProjectUncheckedUpdateManyWithoutOwnerInput>
  }

  export type CompletedProjectScalarWhereInput = {
    AND?: CompletedProjectScalarWhereInput | CompletedProjectScalarWhereInput[]
    OR?: CompletedProjectScalarWhereInput[]
    NOT?: CompletedProjectScalarWhereInput | CompletedProjectScalarWhereInput[]
    id?: StringFilter<"CompletedProject"> | string
    accountId?: StringFilter<"CompletedProject"> | string
    projectId?: StringNullableFilter<"CompletedProject"> | string | null
    ownerId?: StringFilter<"CompletedProject"> | string
    title?: StringFilter<"CompletedProject"> | string
    description?: StringNullableFilter<"CompletedProject"> | string | null
    status?: EnumCompletedProjectStatusFilter<"CompletedProject"> | $Enums.CompletedProjectStatus
    startDate?: DateTimeNullableFilter<"CompletedProject"> | Date | string | null
    endDate?: DateTimeNullableFilter<"CompletedProject"> | Date | string | null
    createdAt?: DateTimeFilter<"CompletedProject"> | Date | string
    updatedAt?: DateTimeFilter<"CompletedProject"> | Date | string
  }

  export type EnquiryUpsertWithWhereUniqueWithoutOwnerInput = {
    where: EnquiryWhereUniqueInput
    update: XOR<EnquiryUpdateWithoutOwnerInput, EnquiryUncheckedUpdateWithoutOwnerInput>
    create: XOR<EnquiryCreateWithoutOwnerInput, EnquiryUncheckedCreateWithoutOwnerInput>
  }

  export type EnquiryUpdateWithWhereUniqueWithoutOwnerInput = {
    where: EnquiryWhereUniqueInput
    data: XOR<EnquiryUpdateWithoutOwnerInput, EnquiryUncheckedUpdateWithoutOwnerInput>
  }

  export type EnquiryUpdateManyWithWhereWithoutOwnerInput = {
    where: EnquiryScalarWhereInput
    data: XOR<EnquiryUpdateManyMutationInput, EnquiryUncheckedUpdateManyWithoutOwnerInput>
  }

  export type EnquiryScalarWhereInput = {
    AND?: EnquiryScalarWhereInput | EnquiryScalarWhereInput[]
    OR?: EnquiryScalarWhereInput[]
    NOT?: EnquiryScalarWhereInput | EnquiryScalarWhereInput[]
    id?: StringFilter<"Enquiry"> | string
    title?: StringFilter<"Enquiry"> | string
    description?: StringNullableFilter<"Enquiry"> | string | null
    status?: EnumEnquiryStatusFilter<"Enquiry"> | $Enums.EnquiryStatus
    priority?: EnumPriorityFilter<"Enquiry"> | $Enums.Priority
    source?: StringNullableFilter<"Enquiry"> | string | null
    campaign?: StringNullableFilter<"Enquiry"> | string | null
    medium?: StringNullableFilter<"Enquiry"> | string | null
    estimatedValue?: DecimalNullableFilter<"Enquiry"> | Decimal | DecimalJsLike | number | string | null
    contactMethod?: StringNullableFilter<"Enquiry"> | string | null
    firstName?: StringFilter<"Enquiry"> | string
    lastName?: StringFilter<"Enquiry"> | string
    email?: StringNullableFilter<"Enquiry"> | string | null
    phone?: StringNullableFilter<"Enquiry"> | string | null
    mobile?: StringNullableFilter<"Enquiry"> | string | null
    company?: StringNullableFilter<"Enquiry"> | string | null
    message?: StringNullableFilter<"Enquiry"> | string | null
    accountId?: StringNullableFilter<"Enquiry"> | string | null
    ownerId?: StringFilter<"Enquiry"> | string
    leadId?: StringNullableFilter<"Enquiry"> | string | null
    createdAt?: DateTimeFilter<"Enquiry"> | Date | string
    updatedAt?: DateTimeFilter<"Enquiry"> | Date | string
    createdById?: StringNullableFilter<"Enquiry"> | string | null
    updatedById?: StringNullableFilter<"Enquiry"> | string | null
  }

  export type LeadUpsertWithWhereUniqueWithoutOwnerInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutOwnerInput, LeadUncheckedUpdateWithoutOwnerInput>
    create: XOR<LeadCreateWithoutOwnerInput, LeadUncheckedCreateWithoutOwnerInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutOwnerInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutOwnerInput, LeadUncheckedUpdateWithoutOwnerInput>
  }

  export type LeadUpdateManyWithWhereWithoutOwnerInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutOwnerInput>
  }

  export type LeadScalarWhereInput = {
    AND?: LeadScalarWhereInput | LeadScalarWhereInput[]
    OR?: LeadScalarWhereInput[]
    NOT?: LeadScalarWhereInput | LeadScalarWhereInput[]
    id?: StringFilter<"Lead"> | string
    title?: StringFilter<"Lead"> | string
    description?: StringNullableFilter<"Lead"> | string | null
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    priority?: EnumPriorityFilter<"Lead"> | $Enums.Priority
    estimatedValue?: DecimalNullableFilter<"Lead"> | Decimal | DecimalJsLike | number | string | null
    probability?: IntFilter<"Lead"> | number
    expectedCloseDate?: DateTimeNullableFilter<"Lead"> | Date | string | null
    source?: StringNullableFilter<"Lead"> | string | null
    campaign?: StringNullableFilter<"Lead"> | string | null
    medium?: StringNullableFilter<"Lead"> | string | null
    firstResponseAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    responseTime?: IntNullableFilter<"Lead"> | number | null
    accountId?: StringFilter<"Lead"> | string
    ownerId?: StringFilter<"Lead"> | string
    enquiryId?: StringNullableFilter<"Lead"> | string | null
    projectId?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    createdById?: StringNullableFilter<"Lead"> | string | null
    updatedById?: StringNullableFilter<"Lead"> | string | null
  }

  export type ProjectUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutOwnerInput, ProjectUncheckedUpdateWithoutOwnerInput>
    create: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutOwnerInput, ProjectUncheckedUpdateWithoutOwnerInput>
  }

  export type ProjectUpdateManyWithWhereWithoutOwnerInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    title?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    type?: EnumProjectTypeFilter<"Project"> | $Enums.ProjectType
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    accountId?: StringFilter<"Project"> | string
    ownerId?: StringFilter<"Project"> | string
    amountGrossIncVat?: IntFilter<"Project"> | number
    vatRate?: FloatFilter<"Project"> | number
    probability?: IntFilter<"Project"> | number
    source?: StringNullableFilter<"Project"> | string | null
    utm?: JsonNullableFilter<"Project">
    leadId?: StringNullableFilter<"Project"> | string | null
    completedProjectId?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutAssigneeInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutAssigneeInput, TaskUncheckedUpdateWithoutAssigneeInput>
    create: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutAssigneeInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutAssigneeInput, TaskUncheckedUpdateWithoutAssigneeInput>
  }

  export type TaskUpdateManyWithWhereWithoutAssigneeInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutAssigneeInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    priority?: EnumPriorityFilter<"Task"> | $Enums.Priority
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    assigneeId?: StringFilter<"Task"> | string
    accountId?: StringFilter<"Task"> | string
    enquiryId?: StringNullableFilter<"Task"> | string | null
    leadId?: StringNullableFilter<"Task"> | string | null
    projectId?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
  }

  export type UserUpsertWithoutCreatedUsersInput = {
    update: XOR<UserUpdateWithoutCreatedUsersInput, UserUncheckedUpdateWithoutCreatedUsersInput>
    create: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedUsersInput, UserUncheckedUpdateWithoutCreatedUsersInput>
  }

  export type UserUpdateWithoutCreatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedAccounts?: AccountUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedAccounts?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUncheckedUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUncheckedUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUncheckedUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUncheckedUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUncheckedUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCreatedByInput, UserUncheckedUpdateWithoutCreatedByInput>
    create: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCreatedByInput, UserUncheckedUpdateWithoutCreatedByInput>
  }

  export type UserUpdateManyWithWhereWithoutCreatedByInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    avatarUrl?: StringNullableFilter<"User"> | string | null
    timezone?: StringFilter<"User"> | string
    preferences?: JsonFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdById?: StringNullableFilter<"User"> | string | null
    updatedById?: StringNullableFilter<"User"> | string | null
  }

  export type UserUpsertWithoutUpdatedUsersInput = {
    update: XOR<UserUpdateWithoutUpdatedUsersInput, UserUncheckedUpdateWithoutUpdatedUsersInput>
    create: XOR<UserCreateWithoutUpdatedUsersInput, UserUncheckedCreateWithoutUpdatedUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedUsersInput, UserUncheckedUpdateWithoutUpdatedUsersInput>
  }

  export type UserUpdateWithoutUpdatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedAccounts?: AccountUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    createdWorkflows?: WorkflowDefinitionUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedAccounts?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUncheckedUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUncheckedUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUncheckedUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUncheckedUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUncheckedUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutUpdatedByInput, UserUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<UserCreateWithoutUpdatedByInput, UserUncheckedCreateWithoutUpdatedByInput>
  }

  export type UserUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutUpdatedByInput, UserUncheckedUpdateWithoutUpdatedByInput>
  }

  export type UserUpdateManyWithWhereWithoutUpdatedByInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type WorkflowDefinitionUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: WorkflowDefinitionWhereUniqueInput
    update: XOR<WorkflowDefinitionUpdateWithoutCreatedByInput, WorkflowDefinitionUncheckedUpdateWithoutCreatedByInput>
    create: XOR<WorkflowDefinitionCreateWithoutCreatedByInput, WorkflowDefinitionUncheckedCreateWithoutCreatedByInput>
  }

  export type WorkflowDefinitionUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: WorkflowDefinitionWhereUniqueInput
    data: XOR<WorkflowDefinitionUpdateWithoutCreatedByInput, WorkflowDefinitionUncheckedUpdateWithoutCreatedByInput>
  }

  export type WorkflowDefinitionUpdateManyWithWhereWithoutCreatedByInput = {
    where: WorkflowDefinitionScalarWhereInput
    data: XOR<WorkflowDefinitionUpdateManyMutationInput, WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type WorkflowDefinitionScalarWhereInput = {
    AND?: WorkflowDefinitionScalarWhereInput | WorkflowDefinitionScalarWhereInput[]
    OR?: WorkflowDefinitionScalarWhereInput[]
    NOT?: WorkflowDefinitionScalarWhereInput | WorkflowDefinitionScalarWhereInput[]
    id?: StringFilter<"WorkflowDefinition"> | string
    name?: StringFilter<"WorkflowDefinition"> | string
    description?: StringNullableFilter<"WorkflowDefinition"> | string | null
    version?: IntFilter<"WorkflowDefinition"> | number
    isActive?: BoolFilter<"WorkflowDefinition"> | boolean
    triggerType?: EnumWorkflowTriggerTypeFilter<"WorkflowDefinition"> | $Enums.WorkflowTriggerType
    triggerConditions?: JsonFilter<"WorkflowDefinition">
    accountId?: StringFilter<"WorkflowDefinition"> | string
    createdById?: StringFilter<"WorkflowDefinition"> | string
    createdAt?: DateTimeFilter<"WorkflowDefinition"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowDefinition"> | Date | string
  }

  export type WorkflowInstanceUpsertWithWhereUniqueWithoutInitiatedByInput = {
    where: WorkflowInstanceWhereUniqueInput
    update: XOR<WorkflowInstanceUpdateWithoutInitiatedByInput, WorkflowInstanceUncheckedUpdateWithoutInitiatedByInput>
    create: XOR<WorkflowInstanceCreateWithoutInitiatedByInput, WorkflowInstanceUncheckedCreateWithoutInitiatedByInput>
  }

  export type WorkflowInstanceUpdateWithWhereUniqueWithoutInitiatedByInput = {
    where: WorkflowInstanceWhereUniqueInput
    data: XOR<WorkflowInstanceUpdateWithoutInitiatedByInput, WorkflowInstanceUncheckedUpdateWithoutInitiatedByInput>
  }

  export type WorkflowInstanceUpdateManyWithWhereWithoutInitiatedByInput = {
    where: WorkflowInstanceScalarWhereInput
    data: XOR<WorkflowInstanceUpdateManyMutationInput, WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByInput>
  }

  export type WorkflowInstanceScalarWhereInput = {
    AND?: WorkflowInstanceScalarWhereInput | WorkflowInstanceScalarWhereInput[]
    OR?: WorkflowInstanceScalarWhereInput[]
    NOT?: WorkflowInstanceScalarWhereInput | WorkflowInstanceScalarWhereInput[]
    id?: StringFilter<"WorkflowInstance"> | string
    workflowId?: StringFilter<"WorkflowInstance"> | string
    entityType?: StringFilter<"WorkflowInstance"> | string
    entityId?: StringFilter<"WorkflowInstance"> | string
    status?: EnumWorkflowStatusFilter<"WorkflowInstance"> | $Enums.WorkflowStatus
    currentStepId?: StringNullableFilter<"WorkflowInstance"> | string | null
    priority?: EnumPriorityFilter<"WorkflowInstance"> | $Enums.Priority
    startedAt?: DateTimeFilter<"WorkflowInstance"> | Date | string
    completedAt?: DateTimeNullableFilter<"WorkflowInstance"> | Date | string | null
    errorMessage?: StringNullableFilter<"WorkflowInstance"> | string | null
    metadata?: JsonNullableFilter<"WorkflowInstance">
    accountId?: StringFilter<"WorkflowInstance"> | string
    initiatedById?: StringFilter<"WorkflowInstance"> | string
  }

  export type WorkflowStepExecutionUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: WorkflowStepExecutionWhereUniqueInput
    update: XOR<WorkflowStepExecutionUpdateWithoutAssignedToInput, WorkflowStepExecutionUncheckedUpdateWithoutAssignedToInput>
    create: XOR<WorkflowStepExecutionCreateWithoutAssignedToInput, WorkflowStepExecutionUncheckedCreateWithoutAssignedToInput>
  }

  export type WorkflowStepExecutionUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: WorkflowStepExecutionWhereUniqueInput
    data: XOR<WorkflowStepExecutionUpdateWithoutAssignedToInput, WorkflowStepExecutionUncheckedUpdateWithoutAssignedToInput>
  }

  export type WorkflowStepExecutionUpdateManyWithWhereWithoutAssignedToInput = {
    where: WorkflowStepExecutionScalarWhereInput
    data: XOR<WorkflowStepExecutionUpdateManyMutationInput, WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type WorkflowStepExecutionScalarWhereInput = {
    AND?: WorkflowStepExecutionScalarWhereInput | WorkflowStepExecutionScalarWhereInput[]
    OR?: WorkflowStepExecutionScalarWhereInput[]
    NOT?: WorkflowStepExecutionScalarWhereInput | WorkflowStepExecutionScalarWhereInput[]
    id?: StringFilter<"WorkflowStepExecution"> | string
    instanceId?: StringFilter<"WorkflowStepExecution"> | string
    stepId?: StringFilter<"WorkflowStepExecution"> | string
    status?: EnumWorkflowStepStatusFilter<"WorkflowStepExecution"> | $Enums.WorkflowStepStatus
    startedAt?: DateTimeFilter<"WorkflowStepExecution"> | Date | string
    completedAt?: DateTimeNullableFilter<"WorkflowStepExecution"> | Date | string | null
    assignedToId?: StringNullableFilter<"WorkflowStepExecution"> | string | null
    result?: JsonNullableFilter<"WorkflowStepExecution">
    errorMessage?: StringNullableFilter<"WorkflowStepExecution"> | string | null
    retryCount?: IntFilter<"WorkflowStepExecution"> | number
    isManual?: BoolFilter<"WorkflowStepExecution"> | boolean
  }

  export type WorkflowStepApproverUpsertWithWhereUniqueWithoutUserInput = {
    where: WorkflowStepApproverWhereUniqueInput
    update: XOR<WorkflowStepApproverUpdateWithoutUserInput, WorkflowStepApproverUncheckedUpdateWithoutUserInput>
    create: XOR<WorkflowStepApproverCreateWithoutUserInput, WorkflowStepApproverUncheckedCreateWithoutUserInput>
  }

  export type WorkflowStepApproverUpdateWithWhereUniqueWithoutUserInput = {
    where: WorkflowStepApproverWhereUniqueInput
    data: XOR<WorkflowStepApproverUpdateWithoutUserInput, WorkflowStepApproverUncheckedUpdateWithoutUserInput>
  }

  export type WorkflowStepApproverUpdateManyWithWhereWithoutUserInput = {
    where: WorkflowStepApproverScalarWhereInput
    data: XOR<WorkflowStepApproverUpdateManyMutationInput, WorkflowStepApproverUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkflowStepApproverScalarWhereInput = {
    AND?: WorkflowStepApproverScalarWhereInput | WorkflowStepApproverScalarWhereInput[]
    OR?: WorkflowStepApproverScalarWhereInput[]
    NOT?: WorkflowStepApproverScalarWhereInput | WorkflowStepApproverScalarWhereInput[]
    id?: StringFilter<"WorkflowStepApprover"> | string
    stepId?: StringFilter<"WorkflowStepApprover"> | string
    userId?: StringFilter<"WorkflowStepApprover"> | string
    approverType?: EnumApproverTypeFilter<"WorkflowStepApprover"> | $Enums.ApproverType
    isRequired?: BoolFilter<"WorkflowStepApprover"> | boolean
    order?: IntFilter<"WorkflowStepApprover"> | number
    createdAt?: DateTimeFilter<"WorkflowStepApprover"> | Date | string
  }

  export type WorkflowApprovalUpsertWithWhereUniqueWithoutApproverInput = {
    where: WorkflowApprovalWhereUniqueInput
    update: XOR<WorkflowApprovalUpdateWithoutApproverInput, WorkflowApprovalUncheckedUpdateWithoutApproverInput>
    create: XOR<WorkflowApprovalCreateWithoutApproverInput, WorkflowApprovalUncheckedCreateWithoutApproverInput>
  }

  export type WorkflowApprovalUpdateWithWhereUniqueWithoutApproverInput = {
    where: WorkflowApprovalWhereUniqueInput
    data: XOR<WorkflowApprovalUpdateWithoutApproverInput, WorkflowApprovalUncheckedUpdateWithoutApproverInput>
  }

  export type WorkflowApprovalUpdateManyWithWhereWithoutApproverInput = {
    where: WorkflowApprovalScalarWhereInput
    data: XOR<WorkflowApprovalUpdateManyMutationInput, WorkflowApprovalUncheckedUpdateManyWithoutApproverInput>
  }

  export type WorkflowApprovalScalarWhereInput = {
    AND?: WorkflowApprovalScalarWhereInput | WorkflowApprovalScalarWhereInput[]
    OR?: WorkflowApprovalScalarWhereInput[]
    NOT?: WorkflowApprovalScalarWhereInput | WorkflowApprovalScalarWhereInput[]
    id?: StringFilter<"WorkflowApproval"> | string
    instanceId?: StringFilter<"WorkflowApproval"> | string
    approverId?: StringFilter<"WorkflowApproval"> | string
    stepApproverId?: StringFilter<"WorkflowApproval"> | string
    status?: EnumApprovalStatusFilter<"WorkflowApproval"> | $Enums.ApprovalStatus
    comments?: StringNullableFilter<"WorkflowApproval"> | string | null
    approvedAt?: DateTimeNullableFilter<"WorkflowApproval"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"WorkflowApproval"> | Date | string | null
    requestedAt?: DateTimeFilter<"WorkflowApproval"> | Date | string
    remindersSent?: IntFilter<"WorkflowApproval"> | number
    lastReminderAt?: DateTimeNullableFilter<"WorkflowApproval"> | Date | string | null
  }

  export type WorkflowTemplateUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: WorkflowTemplateWhereUniqueInput
    update: XOR<WorkflowTemplateUpdateWithoutCreatedByInput, WorkflowTemplateUncheckedUpdateWithoutCreatedByInput>
    create: XOR<WorkflowTemplateCreateWithoutCreatedByInput, WorkflowTemplateUncheckedCreateWithoutCreatedByInput>
  }

  export type WorkflowTemplateUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: WorkflowTemplateWhereUniqueInput
    data: XOR<WorkflowTemplateUpdateWithoutCreatedByInput, WorkflowTemplateUncheckedUpdateWithoutCreatedByInput>
  }

  export type WorkflowTemplateUpdateManyWithWhereWithoutCreatedByInput = {
    where: WorkflowTemplateScalarWhereInput
    data: XOR<WorkflowTemplateUpdateManyMutationInput, WorkflowTemplateUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type WorkflowTemplateScalarWhereInput = {
    AND?: WorkflowTemplateScalarWhereInput | WorkflowTemplateScalarWhereInput[]
    OR?: WorkflowTemplateScalarWhereInput[]
    NOT?: WorkflowTemplateScalarWhereInput | WorkflowTemplateScalarWhereInput[]
    id?: StringFilter<"WorkflowTemplate"> | string
    name?: StringFilter<"WorkflowTemplate"> | string
    description?: StringNullableFilter<"WorkflowTemplate"> | string | null
    category?: StringFilter<"WorkflowTemplate"> | string
    industry?: StringFilter<"WorkflowTemplate"> | string
    templateData?: JsonFilter<"WorkflowTemplate">
    isPublic?: BoolFilter<"WorkflowTemplate"> | boolean
    usageCount?: IntFilter<"WorkflowTemplate"> | number
    rating?: FloatNullableFilter<"WorkflowTemplate"> | number | null
    accountId?: StringNullableFilter<"WorkflowTemplate"> | string | null
    createdById?: StringFilter<"WorkflowTemplate"> | string
    createdAt?: DateTimeFilter<"WorkflowTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowTemplate"> | Date | string
    workflowId?: StringNullableFilter<"WorkflowTemplate"> | string | null
  }

  export type AutomationRuleUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: AutomationRuleWhereUniqueInput
    update: XOR<AutomationRuleUpdateWithoutCreatedByInput, AutomationRuleUncheckedUpdateWithoutCreatedByInput>
    create: XOR<AutomationRuleCreateWithoutCreatedByInput, AutomationRuleUncheckedCreateWithoutCreatedByInput>
  }

  export type AutomationRuleUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: AutomationRuleWhereUniqueInput
    data: XOR<AutomationRuleUpdateWithoutCreatedByInput, AutomationRuleUncheckedUpdateWithoutCreatedByInput>
  }

  export type AutomationRuleUpdateManyWithWhereWithoutCreatedByInput = {
    where: AutomationRuleScalarWhereInput
    data: XOR<AutomationRuleUpdateManyMutationInput, AutomationRuleUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AutomationRuleScalarWhereInput = {
    AND?: AutomationRuleScalarWhereInput | AutomationRuleScalarWhereInput[]
    OR?: AutomationRuleScalarWhereInput[]
    NOT?: AutomationRuleScalarWhereInput | AutomationRuleScalarWhereInput[]
    id?: StringFilter<"AutomationRule"> | string
    name?: StringFilter<"AutomationRule"> | string
    description?: StringNullableFilter<"AutomationRule"> | string | null
    triggerEvent?: StringFilter<"AutomationRule"> | string
    conditions?: JsonFilter<"AutomationRule">
    actions?: JsonFilter<"AutomationRule">
    isActive?: BoolFilter<"AutomationRule"> | boolean
    priority?: IntFilter<"AutomationRule"> | number
    executionCount?: IntFilter<"AutomationRule"> | number
    lastExecutedAt?: DateTimeNullableFilter<"AutomationRule"> | Date | string | null
    accountId?: StringFilter<"AutomationRule"> | string
    createdById?: StringFilter<"AutomationRule"> | string
    createdAt?: DateTimeFilter<"AutomationRule"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationRule"> | Date | string
  }

  export type TestPlanUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: TestPlanWhereUniqueInput
    update: XOR<TestPlanUpdateWithoutCreatedByInput, TestPlanUncheckedUpdateWithoutCreatedByInput>
    create: XOR<TestPlanCreateWithoutCreatedByInput, TestPlanUncheckedCreateWithoutCreatedByInput>
  }

  export type TestPlanUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: TestPlanWhereUniqueInput
    data: XOR<TestPlanUpdateWithoutCreatedByInput, TestPlanUncheckedUpdateWithoutCreatedByInput>
  }

  export type TestPlanUpdateManyWithWhereWithoutCreatedByInput = {
    where: TestPlanScalarWhereInput
    data: XOR<TestPlanUpdateManyMutationInput, TestPlanUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type TestPlanScalarWhereInput = {
    AND?: TestPlanScalarWhereInput | TestPlanScalarWhereInput[]
    OR?: TestPlanScalarWhereInput[]
    NOT?: TestPlanScalarWhereInput | TestPlanScalarWhereInput[]
    id?: StringFilter<"TestPlan"> | string
    name?: StringFilter<"TestPlan"> | string
    description?: StringNullableFilter<"TestPlan"> | string | null
    version?: StringFilter<"TestPlan"> | string
    status?: EnumTestPlanStatusFilter<"TestPlan"> | $Enums.TestPlanStatus
    projectId?: StringNullableFilter<"TestPlan"> | string | null
    feature?: StringNullableFilter<"TestPlan"> | string | null
    environment?: StringNullableFilter<"TestPlan"> | string | null
    startDate?: DateTimeNullableFilter<"TestPlan"> | Date | string | null
    endDate?: DateTimeNullableFilter<"TestPlan"> | Date | string | null
    createdById?: StringFilter<"TestPlan"> | string
    assignedToId?: StringNullableFilter<"TestPlan"> | string | null
    createdAt?: DateTimeFilter<"TestPlan"> | Date | string
    updatedAt?: DateTimeFilter<"TestPlan"> | Date | string
  }

  export type TestPlanUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: TestPlanWhereUniqueInput
    update: XOR<TestPlanUpdateWithoutAssignedToInput, TestPlanUncheckedUpdateWithoutAssignedToInput>
    create: XOR<TestPlanCreateWithoutAssignedToInput, TestPlanUncheckedCreateWithoutAssignedToInput>
  }

  export type TestPlanUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: TestPlanWhereUniqueInput
    data: XOR<TestPlanUpdateWithoutAssignedToInput, TestPlanUncheckedUpdateWithoutAssignedToInput>
  }

  export type TestPlanUpdateManyWithWhereWithoutAssignedToInput = {
    where: TestPlanScalarWhereInput
    data: XOR<TestPlanUpdateManyMutationInput, TestPlanUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type TestCaseUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: TestCaseWhereUniqueInput
    update: XOR<TestCaseUpdateWithoutCreatedByInput, TestCaseUncheckedUpdateWithoutCreatedByInput>
    create: XOR<TestCaseCreateWithoutCreatedByInput, TestCaseUncheckedCreateWithoutCreatedByInput>
  }

  export type TestCaseUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: TestCaseWhereUniqueInput
    data: XOR<TestCaseUpdateWithoutCreatedByInput, TestCaseUncheckedUpdateWithoutCreatedByInput>
  }

  export type TestCaseUpdateManyWithWhereWithoutCreatedByInput = {
    where: TestCaseScalarWhereInput
    data: XOR<TestCaseUpdateManyMutationInput, TestCaseUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type TestCaseScalarWhereInput = {
    AND?: TestCaseScalarWhereInput | TestCaseScalarWhereInput[]
    OR?: TestCaseScalarWhereInput[]
    NOT?: TestCaseScalarWhereInput | TestCaseScalarWhereInput[]
    id?: StringFilter<"TestCase"> | string
    title?: StringFilter<"TestCase"> | string
    description?: StringNullableFilter<"TestCase"> | string | null
    preconditions?: StringNullableFilter<"TestCase"> | string | null
    steps?: JsonFilter<"TestCase">
    expectedResult?: StringNullableFilter<"TestCase"> | string | null
    priority?: EnumTestCasePriorityFilter<"TestCase"> | $Enums.TestCasePriority
    status?: EnumTestCaseStatusFilter<"TestCase"> | $Enums.TestCaseStatus
    tags?: StringNullableListFilter<"TestCase">
    automatable?: BoolFilter<"TestCase"> | boolean
    estimatedTime?: IntNullableFilter<"TestCase"> | number | null
    testPlanId?: StringFilter<"TestCase"> | string
    createdById?: StringFilter<"TestCase"> | string
    createdAt?: DateTimeFilter<"TestCase"> | Date | string
    updatedAt?: DateTimeFilter<"TestCase"> | Date | string
  }

  export type TestExecutionUpsertWithWhereUniqueWithoutExecutedByInput = {
    where: TestExecutionWhereUniqueInput
    update: XOR<TestExecutionUpdateWithoutExecutedByInput, TestExecutionUncheckedUpdateWithoutExecutedByInput>
    create: XOR<TestExecutionCreateWithoutExecutedByInput, TestExecutionUncheckedCreateWithoutExecutedByInput>
  }

  export type TestExecutionUpdateWithWhereUniqueWithoutExecutedByInput = {
    where: TestExecutionWhereUniqueInput
    data: XOR<TestExecutionUpdateWithoutExecutedByInput, TestExecutionUncheckedUpdateWithoutExecutedByInput>
  }

  export type TestExecutionUpdateManyWithWhereWithoutExecutedByInput = {
    where: TestExecutionScalarWhereInput
    data: XOR<TestExecutionUpdateManyMutationInput, TestExecutionUncheckedUpdateManyWithoutExecutedByInput>
  }

  export type TestExecutionScalarWhereInput = {
    AND?: TestExecutionScalarWhereInput | TestExecutionScalarWhereInput[]
    OR?: TestExecutionScalarWhereInput[]
    NOT?: TestExecutionScalarWhereInput | TestExecutionScalarWhereInput[]
    id?: StringFilter<"TestExecution"> | string
    testPlanId?: StringFilter<"TestExecution"> | string
    testCaseId?: StringFilter<"TestExecution"> | string
    status?: EnumTestExecutionStatusFilter<"TestExecution"> | $Enums.TestExecutionStatus
    result?: StringNullableFilter<"TestExecution"> | string | null
    actualResult?: StringNullableFilter<"TestExecution"> | string | null
    evidence?: JsonNullableFilter<"TestExecution">
    executionTime?: IntNullableFilter<"TestExecution"> | number | null
    environment?: StringNullableFilter<"TestExecution"> | string | null
    browserVersion?: StringNullableFilter<"TestExecution"> | string | null
    osVersion?: StringNullableFilter<"TestExecution"> | string | null
    notes?: StringNullableFilter<"TestExecution"> | string | null
    executedById?: StringFilter<"TestExecution"> | string
    startedAt?: DateTimeNullableFilter<"TestExecution"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"TestExecution"> | Date | string | null
    createdAt?: DateTimeFilter<"TestExecution"> | Date | string
    updatedAt?: DateTimeFilter<"TestExecution"> | Date | string
  }

  export type DefectUpsertWithWhereUniqueWithoutReportedByInput = {
    where: DefectWhereUniqueInput
    update: XOR<DefectUpdateWithoutReportedByInput, DefectUncheckedUpdateWithoutReportedByInput>
    create: XOR<DefectCreateWithoutReportedByInput, DefectUncheckedCreateWithoutReportedByInput>
  }

  export type DefectUpdateWithWhereUniqueWithoutReportedByInput = {
    where: DefectWhereUniqueInput
    data: XOR<DefectUpdateWithoutReportedByInput, DefectUncheckedUpdateWithoutReportedByInput>
  }

  export type DefectUpdateManyWithWhereWithoutReportedByInput = {
    where: DefectScalarWhereInput
    data: XOR<DefectUpdateManyMutationInput, DefectUncheckedUpdateManyWithoutReportedByInput>
  }

  export type DefectScalarWhereInput = {
    AND?: DefectScalarWhereInput | DefectScalarWhereInput[]
    OR?: DefectScalarWhereInput[]
    NOT?: DefectScalarWhereInput | DefectScalarWhereInput[]
    id?: StringFilter<"Defect"> | string
    title?: StringFilter<"Defect"> | string
    description?: StringFilter<"Defect"> | string
    steps?: StringNullableFilter<"Defect"> | string | null
    expectedBehavior?: StringNullableFilter<"Defect"> | string | null
    actualBehavior?: StringNullableFilter<"Defect"> | string | null
    severity?: EnumDefectSeverityFilter<"Defect"> | $Enums.DefectSeverity
    priority?: EnumDefectPriorityFilter<"Defect"> | $Enums.DefectPriority
    status?: EnumDefectStatusFilter<"Defect"> | $Enums.DefectStatus
    environment?: StringNullableFilter<"Defect"> | string | null
    browserVersion?: StringNullableFilter<"Defect"> | string | null
    osVersion?: StringNullableFilter<"Defect"> | string | null
    attachments?: JsonNullableFilter<"Defect">
    reproducible?: BoolFilter<"Defect"> | boolean
    regression?: BoolFilter<"Defect"> | boolean
    testExecutionId?: StringNullableFilter<"Defect"> | string | null
    reportedById?: StringFilter<"Defect"> | string
    assignedToId?: StringNullableFilter<"Defect"> | string | null
    reportedAt?: DateTimeFilter<"Defect"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Defect"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"Defect"> | Date | string | null
    createdAt?: DateTimeFilter<"Defect"> | Date | string
    updatedAt?: DateTimeFilter<"Defect"> | Date | string
  }

  export type DefectUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: DefectWhereUniqueInput
    update: XOR<DefectUpdateWithoutAssignedToInput, DefectUncheckedUpdateWithoutAssignedToInput>
    create: XOR<DefectCreateWithoutAssignedToInput, DefectUncheckedCreateWithoutAssignedToInput>
  }

  export type DefectUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: DefectWhereUniqueInput
    data: XOR<DefectUpdateWithoutAssignedToInput, DefectUncheckedUpdateWithoutAssignedToInput>
  }

  export type DefectUpdateManyWithWhereWithoutAssignedToInput = {
    where: DefectScalarWhereInput
    data: XOR<DefectUpdateManyMutationInput, DefectUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type QAReviewUpsertWithWhereUniqueWithoutReviewerInput = {
    where: QAReviewWhereUniqueInput
    update: XOR<QAReviewUpdateWithoutReviewerInput, QAReviewUncheckedUpdateWithoutReviewerInput>
    create: XOR<QAReviewCreateWithoutReviewerInput, QAReviewUncheckedCreateWithoutReviewerInput>
  }

  export type QAReviewUpdateWithWhereUniqueWithoutReviewerInput = {
    where: QAReviewWhereUniqueInput
    data: XOR<QAReviewUpdateWithoutReviewerInput, QAReviewUncheckedUpdateWithoutReviewerInput>
  }

  export type QAReviewUpdateManyWithWhereWithoutReviewerInput = {
    where: QAReviewScalarWhereInput
    data: XOR<QAReviewUpdateManyMutationInput, QAReviewUncheckedUpdateManyWithoutReviewerInput>
  }

  export type QAReviewScalarWhereInput = {
    AND?: QAReviewScalarWhereInput | QAReviewScalarWhereInput[]
    OR?: QAReviewScalarWhereInput[]
    NOT?: QAReviewScalarWhereInput | QAReviewScalarWhereInput[]
    id?: StringFilter<"QAReview"> | string
    title?: StringFilter<"QAReview"> | string
    description?: StringNullableFilter<"QAReview"> | string | null
    type?: StringFilter<"QAReview"> | string
    entityId?: StringFilter<"QAReview"> | string
    status?: EnumQAReviewStatusFilter<"QAReview"> | $Enums.QAReviewStatus
    criteria?: JsonNullableFilter<"QAReview">
    findings?: StringNullableFilter<"QAReview"> | string | null
    recommendations?: StringNullableFilter<"QAReview"> | string | null
    approved?: BoolNullableFilter<"QAReview"> | boolean | null
    testPlanId?: StringNullableFilter<"QAReview"> | string | null
    reviewerId?: StringFilter<"QAReview"> | string
    reviewedAt?: DateTimeNullableFilter<"QAReview"> | Date | string | null
    createdAt?: DateTimeFilter<"QAReview"> | Date | string
    updatedAt?: DateTimeFilter<"QAReview"> | Date | string
  }

  export type UserCreateWithoutOwnedAccountsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutOwnedAccountsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceUncheckedCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverUncheckedCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanUncheckedCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanUncheckedCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionUncheckedCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectUncheckedCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectUncheckedCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutOwnedAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedAccountsInput, UserUncheckedCreateWithoutOwnedAccountsInput>
  }

  export type ActivityCreateWithoutAccountInput = {
    id?: string
    type: $Enums.ActivityType
    threadKey?: string | null
    summary?: string | null
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: Date | string
    createdAt?: Date | string
    enquiry?: EnquiryCreateNestedOneWithoutActivitiesInput
    lead?: LeadCreateNestedOneWithoutActivitiesInput
    project?: ProjectCreateNestedOneWithoutActivitiesInput
    user?: UserCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutAccountInput = {
    id?: string
    enquiryId?: string | null
    leadId?: string | null
    projectId?: string | null
    userId?: string | null
    type: $Enums.ActivityType
    threadKey?: string | null
    summary?: string | null
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: Date | string
    createdAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutAccountInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutAccountInput, ActivityUncheckedCreateWithoutAccountInput>
  }

  export type ActivityCreateManyAccountInputEnvelope = {
    data: ActivityCreateManyAccountInput | ActivityCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutAccountInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.AppointmentType
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    status?: $Enums.AppointmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutAccountInput = {
    id?: string
    projectId?: string | null
    title: string
    description?: string | null
    type: $Enums.AppointmentType
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    status?: $Enums.AppointmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentCreateOrConnectWithoutAccountInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutAccountInput, AppointmentUncheckedCreateWithoutAccountInput>
  }

  export type AppointmentCreateManyAccountInputEnvelope = {
    data: AppointmentCreateManyAccountInput | AppointmentCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type CompletedProjectCreateWithoutAccountInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.CompletedProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedCompletedProjectsInput
    project?: ProjectCreateNestedOneWithoutCompletedProjectInput
  }

  export type CompletedProjectUncheckedCreateWithoutAccountInput = {
    id?: string
    projectId?: string | null
    ownerId: string
    title: string
    description?: string | null
    status?: $Enums.CompletedProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompletedProjectCreateOrConnectWithoutAccountInput = {
    where: CompletedProjectWhereUniqueInput
    create: XOR<CompletedProjectCreateWithoutAccountInput, CompletedProjectUncheckedCreateWithoutAccountInput>
  }

  export type CompletedProjectCreateManyAccountInputEnvelope = {
    data: CompletedProjectCreateManyAccountInput | CompletedProjectCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutAccountInput = {
    id?: string
    name: string
    role?: string | null
    email?: string | null
    phone?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUncheckedCreateWithoutAccountInput = {
    id?: string
    name: string
    role?: string | null
    email?: string | null
    phone?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateOrConnectWithoutAccountInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutAccountInput, ContactUncheckedCreateWithoutAccountInput>
  }

  export type ContactCreateManyAccountInputEnvelope = {
    data: ContactCreateManyAccountInput | ContactCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutAccountInput = {
    id?: string
    filename: string
    fileUrl: string
    fileSize?: number | null
    mimeType?: string | null
    type?: $Enums.DocumentType
    uploadedBy?: string | null
    createdAt?: Date | string
    project?: ProjectCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutAccountInput = {
    id?: string
    projectId?: string | null
    filename: string
    fileUrl: string
    fileSize?: number | null
    mimeType?: string | null
    type?: $Enums.DocumentType
    uploadedBy?: string | null
    createdAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutAccountInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutAccountInput, DocumentUncheckedCreateWithoutAccountInput>
  }

  export type DocumentCreateManyAccountInputEnvelope = {
    data: DocumentCreateManyAccountInput | DocumentCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type EnquiryCreateWithoutAccountInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.EnquiryStatus
    priority?: $Enums.Priority
    source?: string | null
    campaign?: string | null
    medium?: string | null
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    contactMethod?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    company?: string | null
    message?: string | null
    leadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityCreateNestedManyWithoutEnquiryInput
    owner: UserCreateNestedOneWithoutOwnedEnquiriesInput
    lead?: LeadCreateNestedOneWithoutEnquiryInput
    tasks?: TaskCreateNestedManyWithoutEnquiryInput
  }

  export type EnquiryUncheckedCreateWithoutAccountInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.EnquiryStatus
    priority?: $Enums.Priority
    source?: string | null
    campaign?: string | null
    medium?: string | null
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    contactMethod?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    company?: string | null
    message?: string | null
    ownerId: string
    leadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutEnquiryInput
    lead?: LeadUncheckedCreateNestedOneWithoutEnquiryInput
    tasks?: TaskUncheckedCreateNestedManyWithoutEnquiryInput
  }

  export type EnquiryCreateOrConnectWithoutAccountInput = {
    where: EnquiryWhereUniqueInput
    create: XOR<EnquiryCreateWithoutAccountInput, EnquiryUncheckedCreateWithoutAccountInput>
  }

  export type EnquiryCreateManyAccountInputEnvelope = {
    data: EnquiryCreateManyAccountInput | EnquiryCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type EventLogCreateWithoutAccountInput = {
    id?: string
    actorId?: string | null
    entity: string
    entityId: string
    action: string
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EventLogUncheckedCreateWithoutAccountInput = {
    id?: string
    actorId?: string | null
    entity: string
    entityId: string
    action: string
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EventLogCreateOrConnectWithoutAccountInput = {
    where: EventLogWhereUniqueInput
    create: XOR<EventLogCreateWithoutAccountInput, EventLogUncheckedCreateWithoutAccountInput>
  }

  export type EventLogCreateManyAccountInputEnvelope = {
    data: EventLogCreateManyAccountInput | EventLogCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type LeadCreateWithoutAccountInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityCreateNestedManyWithoutLeadInput
    enquiry?: EnquiryCreateNestedOneWithoutLeadInput
    owner: UserCreateNestedOneWithoutOwnedLeadsInput
    project?: ProjectCreateNestedOneWithoutLeadInput
    tasks?: TaskCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutAccountInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    ownerId: string
    enquiryId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutLeadInput
    project?: ProjectUncheckedCreateNestedOneWithoutLeadInput
    tasks?: TaskUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutAccountInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutAccountInput, LeadUncheckedCreateWithoutAccountInput>
  }

  export type LeadCreateManyAccountInputEnvelope = {
    data: LeadCreateManyAccountInput | LeadCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutAccountInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    amountGrossIncVat: number
    vatRate?: number
    probability?: number
    source?: string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    completedProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutProjectInput
    appointments?: AppointmentCreateNestedManyWithoutProjectInput
    completedProject?: CompletedProjectCreateNestedOneWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    lead?: LeadCreateNestedOneWithoutProjectInput
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    snags?: SnagCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutAccountInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    ownerId: string
    amountGrossIncVat: number
    vatRate?: number
    probability?: number
    source?: string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    leadId?: string | null
    completedProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProjectInput
    completedProject?: CompletedProjectUncheckedCreateNestedOneWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    snags?: SnagUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutAccountInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutAccountInput, ProjectUncheckedCreateWithoutAccountInput>
  }

  export type ProjectCreateManyAccountInputEnvelope = {
    data: ProjectCreateManyAccountInput | ProjectCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type SnagCreateWithoutAccountInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SnagStatus
    priority?: $Enums.Priority
    assigneeId?: string | null
    dueAt?: Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSnagsInput
  }

  export type SnagUncheckedCreateWithoutAccountInput = {
    id?: string
    projectId: string
    title: string
    description: string
    status?: $Enums.SnagStatus
    priority?: $Enums.Priority
    assigneeId?: string | null
    dueAt?: Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SnagCreateOrConnectWithoutAccountInput = {
    where: SnagWhereUniqueInput
    create: XOR<SnagCreateWithoutAccountInput, SnagUncheckedCreateWithoutAccountInput>
  }

  export type SnagCreateManyAccountInputEnvelope = {
    data: SnagCreateManyAccountInput | SnagCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutAccountInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignee: UserCreateNestedOneWithoutAssignedTasksInput
    enquiry?: EnquiryCreateNestedOneWithoutTasksInput
    lead?: LeadCreateNestedOneWithoutTasksInput
    project?: ProjectCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutAccountInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    assigneeId: string
    enquiryId?: string | null
    leadId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutAccountInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAccountInput, TaskUncheckedCreateWithoutAccountInput>
  }

  export type TaskCreateManyAccountInputEnvelope = {
    data: TaskCreateManyAccountInput | TaskCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowDefinitionCreateWithoutAccountInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    triggerType: $Enums.WorkflowTriggerType
    triggerConditions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedWorkflowsInput
    steps?: WorkflowStepCreateNestedManyWithoutWorkflowInput
    instances?: WorkflowInstanceCreateNestedManyWithoutWorkflowInput
    templates?: WorkflowTemplateCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowDefinitionUncheckedCreateWithoutAccountInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    triggerType: $Enums.WorkflowTriggerType
    triggerConditions: JsonNullValueInput | InputJsonValue
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: WorkflowStepUncheckedCreateNestedManyWithoutWorkflowInput
    instances?: WorkflowInstanceUncheckedCreateNestedManyWithoutWorkflowInput
    templates?: WorkflowTemplateUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowDefinitionCreateOrConnectWithoutAccountInput = {
    where: WorkflowDefinitionWhereUniqueInput
    create: XOR<WorkflowDefinitionCreateWithoutAccountInput, WorkflowDefinitionUncheckedCreateWithoutAccountInput>
  }

  export type WorkflowDefinitionCreateManyAccountInputEnvelope = {
    data: WorkflowDefinitionCreateManyAccountInput | WorkflowDefinitionCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowInstanceCreateWithoutAccountInput = {
    id?: string
    entityType: string
    entityId: string
    status: $Enums.WorkflowStatus
    currentStepId?: string | null
    priority?: $Enums.Priority
    startedAt?: Date | string
    completedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    workflow: WorkflowDefinitionCreateNestedOneWithoutInstancesInput
    initiatedBy: UserCreateNestedOneWithoutInitiatedWorkflowsInput
    executions?: WorkflowStepExecutionCreateNestedManyWithoutInstanceInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutInstanceInput
  }

  export type WorkflowInstanceUncheckedCreateWithoutAccountInput = {
    id?: string
    workflowId: string
    entityType: string
    entityId: string
    status: $Enums.WorkflowStatus
    currentStepId?: string | null
    priority?: $Enums.Priority
    startedAt?: Date | string
    completedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedById: string
    executions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutInstanceInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type WorkflowInstanceCreateOrConnectWithoutAccountInput = {
    where: WorkflowInstanceWhereUniqueInput
    create: XOR<WorkflowInstanceCreateWithoutAccountInput, WorkflowInstanceUncheckedCreateWithoutAccountInput>
  }

  export type WorkflowInstanceCreateManyAccountInputEnvelope = {
    data: WorkflowInstanceCreateManyAccountInput | WorkflowInstanceCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowTemplateCreateWithoutAccountInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    industry?: string
    templateData: JsonNullValueInput | InputJsonValue
    isPublic?: boolean
    usageCount?: number
    rating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTemplatesInput
    workflow?: WorkflowDefinitionCreateNestedOneWithoutTemplatesInput
  }

  export type WorkflowTemplateUncheckedCreateWithoutAccountInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    industry?: string
    templateData: JsonNullValueInput | InputJsonValue
    isPublic?: boolean
    usageCount?: number
    rating?: number | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workflowId?: string | null
  }

  export type WorkflowTemplateCreateOrConnectWithoutAccountInput = {
    where: WorkflowTemplateWhereUniqueInput
    create: XOR<WorkflowTemplateCreateWithoutAccountInput, WorkflowTemplateUncheckedCreateWithoutAccountInput>
  }

  export type WorkflowTemplateCreateManyAccountInputEnvelope = {
    data: WorkflowTemplateCreateManyAccountInput | WorkflowTemplateCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type AutomationRuleCreateWithoutAccountInput = {
    id?: string
    name: string
    description?: string | null
    triggerEvent: string
    conditions: JsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    priority?: number
    executionCount?: number
    lastExecutedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedRulesInput
    executions?: AutomationExecutionCreateNestedManyWithoutRuleInput
  }

  export type AutomationRuleUncheckedCreateWithoutAccountInput = {
    id?: string
    name: string
    description?: string | null
    triggerEvent: string
    conditions: JsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    priority?: number
    executionCount?: number
    lastExecutedAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: AutomationExecutionUncheckedCreateNestedManyWithoutRuleInput
  }

  export type AutomationRuleCreateOrConnectWithoutAccountInput = {
    where: AutomationRuleWhereUniqueInput
    create: XOR<AutomationRuleCreateWithoutAccountInput, AutomationRuleUncheckedCreateWithoutAccountInput>
  }

  export type AutomationRuleCreateManyAccountInputEnvelope = {
    data: AutomationRuleCreateManyAccountInput | AutomationRuleCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOwnedAccountsInput = {
    update: XOR<UserUpdateWithoutOwnedAccountsInput, UserUncheckedUpdateWithoutOwnedAccountsInput>
    create: XOR<UserCreateWithoutOwnedAccountsInput, UserUncheckedCreateWithoutOwnedAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedAccountsInput, UserUncheckedUpdateWithoutOwnedAccountsInput>
  }

  export type UserUpdateWithoutOwnedAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUncheckedUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUncheckedUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUncheckedUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUncheckedUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUncheckedUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type ActivityUpsertWithWhereUniqueWithoutAccountInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutAccountInput, ActivityUncheckedUpdateWithoutAccountInput>
    create: XOR<ActivityCreateWithoutAccountInput, ActivityUncheckedCreateWithoutAccountInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutAccountInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutAccountInput, ActivityUncheckedUpdateWithoutAccountInput>
  }

  export type ActivityUpdateManyWithWhereWithoutAccountInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutAccountInput>
  }

  export type AppointmentUpsertWithWhereUniqueWithoutAccountInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutAccountInput, AppointmentUncheckedUpdateWithoutAccountInput>
    create: XOR<AppointmentCreateWithoutAccountInput, AppointmentUncheckedCreateWithoutAccountInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutAccountInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutAccountInput, AppointmentUncheckedUpdateWithoutAccountInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutAccountInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutAccountInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: StringFilter<"Appointment"> | string
    accountId?: StringFilter<"Appointment"> | string
    projectId?: StringNullableFilter<"Appointment"> | string | null
    title?: StringFilter<"Appointment"> | string
    description?: StringNullableFilter<"Appointment"> | string | null
    type?: EnumAppointmentTypeFilter<"Appointment"> | $Enums.AppointmentType
    startTime?: DateTimeFilter<"Appointment"> | Date | string
    endTime?: DateTimeFilter<"Appointment"> | Date | string
    location?: StringNullableFilter<"Appointment"> | string | null
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
  }

  export type CompletedProjectUpsertWithWhereUniqueWithoutAccountInput = {
    where: CompletedProjectWhereUniqueInput
    update: XOR<CompletedProjectUpdateWithoutAccountInput, CompletedProjectUncheckedUpdateWithoutAccountInput>
    create: XOR<CompletedProjectCreateWithoutAccountInput, CompletedProjectUncheckedCreateWithoutAccountInput>
  }

  export type CompletedProjectUpdateWithWhereUniqueWithoutAccountInput = {
    where: CompletedProjectWhereUniqueInput
    data: XOR<CompletedProjectUpdateWithoutAccountInput, CompletedProjectUncheckedUpdateWithoutAccountInput>
  }

  export type CompletedProjectUpdateManyWithWhereWithoutAccountInput = {
    where: CompletedProjectScalarWhereInput
    data: XOR<CompletedProjectUpdateManyMutationInput, CompletedProjectUncheckedUpdateManyWithoutAccountInput>
  }

  export type ContactUpsertWithWhereUniqueWithoutAccountInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutAccountInput, ContactUncheckedUpdateWithoutAccountInput>
    create: XOR<ContactCreateWithoutAccountInput, ContactUncheckedCreateWithoutAccountInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutAccountInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutAccountInput, ContactUncheckedUpdateWithoutAccountInput>
  }

  export type ContactUpdateManyWithWhereWithoutAccountInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutAccountInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: StringFilter<"Contact"> | string
    accountId?: StringFilter<"Contact"> | string
    name?: StringFilter<"Contact"> | string
    role?: StringNullableFilter<"Contact"> | string | null
    email?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    isPrimary?: BoolFilter<"Contact"> | boolean
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutAccountInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutAccountInput, DocumentUncheckedUpdateWithoutAccountInput>
    create: XOR<DocumentCreateWithoutAccountInput, DocumentUncheckedCreateWithoutAccountInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutAccountInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutAccountInput, DocumentUncheckedUpdateWithoutAccountInput>
  }

  export type DocumentUpdateManyWithWhereWithoutAccountInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutAccountInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    accountId?: StringFilter<"Document"> | string
    projectId?: StringNullableFilter<"Document"> | string | null
    filename?: StringFilter<"Document"> | string
    fileUrl?: StringFilter<"Document"> | string
    fileSize?: IntNullableFilter<"Document"> | number | null
    mimeType?: StringNullableFilter<"Document"> | string | null
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    uploadedBy?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type EnquiryUpsertWithWhereUniqueWithoutAccountInput = {
    where: EnquiryWhereUniqueInput
    update: XOR<EnquiryUpdateWithoutAccountInput, EnquiryUncheckedUpdateWithoutAccountInput>
    create: XOR<EnquiryCreateWithoutAccountInput, EnquiryUncheckedCreateWithoutAccountInput>
  }

  export type EnquiryUpdateWithWhereUniqueWithoutAccountInput = {
    where: EnquiryWhereUniqueInput
    data: XOR<EnquiryUpdateWithoutAccountInput, EnquiryUncheckedUpdateWithoutAccountInput>
  }

  export type EnquiryUpdateManyWithWhereWithoutAccountInput = {
    where: EnquiryScalarWhereInput
    data: XOR<EnquiryUpdateManyMutationInput, EnquiryUncheckedUpdateManyWithoutAccountInput>
  }

  export type EventLogUpsertWithWhereUniqueWithoutAccountInput = {
    where: EventLogWhereUniqueInput
    update: XOR<EventLogUpdateWithoutAccountInput, EventLogUncheckedUpdateWithoutAccountInput>
    create: XOR<EventLogCreateWithoutAccountInput, EventLogUncheckedCreateWithoutAccountInput>
  }

  export type EventLogUpdateWithWhereUniqueWithoutAccountInput = {
    where: EventLogWhereUniqueInput
    data: XOR<EventLogUpdateWithoutAccountInput, EventLogUncheckedUpdateWithoutAccountInput>
  }

  export type EventLogUpdateManyWithWhereWithoutAccountInput = {
    where: EventLogScalarWhereInput
    data: XOR<EventLogUpdateManyMutationInput, EventLogUncheckedUpdateManyWithoutAccountInput>
  }

  export type EventLogScalarWhereInput = {
    AND?: EventLogScalarWhereInput | EventLogScalarWhereInput[]
    OR?: EventLogScalarWhereInput[]
    NOT?: EventLogScalarWhereInput | EventLogScalarWhereInput[]
    id?: StringFilter<"EventLog"> | string
    accountId?: StringNullableFilter<"EventLog"> | string | null
    actorId?: StringNullableFilter<"EventLog"> | string | null
    entity?: StringFilter<"EventLog"> | string
    entityId?: StringFilter<"EventLog"> | string
    action?: StringFilter<"EventLog"> | string
    before?: JsonNullableFilter<"EventLog">
    after?: JsonNullableFilter<"EventLog">
    createdAt?: DateTimeFilter<"EventLog"> | Date | string
  }

  export type LeadUpsertWithWhereUniqueWithoutAccountInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutAccountInput, LeadUncheckedUpdateWithoutAccountInput>
    create: XOR<LeadCreateWithoutAccountInput, LeadUncheckedCreateWithoutAccountInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutAccountInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutAccountInput, LeadUncheckedUpdateWithoutAccountInput>
  }

  export type LeadUpdateManyWithWhereWithoutAccountInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutAccountInput>
  }

  export type ProjectUpsertWithWhereUniqueWithoutAccountInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutAccountInput, ProjectUncheckedUpdateWithoutAccountInput>
    create: XOR<ProjectCreateWithoutAccountInput, ProjectUncheckedCreateWithoutAccountInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutAccountInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutAccountInput, ProjectUncheckedUpdateWithoutAccountInput>
  }

  export type ProjectUpdateManyWithWhereWithoutAccountInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutAccountInput>
  }

  export type SnagUpsertWithWhereUniqueWithoutAccountInput = {
    where: SnagWhereUniqueInput
    update: XOR<SnagUpdateWithoutAccountInput, SnagUncheckedUpdateWithoutAccountInput>
    create: XOR<SnagCreateWithoutAccountInput, SnagUncheckedCreateWithoutAccountInput>
  }

  export type SnagUpdateWithWhereUniqueWithoutAccountInput = {
    where: SnagWhereUniqueInput
    data: XOR<SnagUpdateWithoutAccountInput, SnagUncheckedUpdateWithoutAccountInput>
  }

  export type SnagUpdateManyWithWhereWithoutAccountInput = {
    where: SnagScalarWhereInput
    data: XOR<SnagUpdateManyMutationInput, SnagUncheckedUpdateManyWithoutAccountInput>
  }

  export type SnagScalarWhereInput = {
    AND?: SnagScalarWhereInput | SnagScalarWhereInput[]
    OR?: SnagScalarWhereInput[]
    NOT?: SnagScalarWhereInput | SnagScalarWhereInput[]
    id?: StringFilter<"Snag"> | string
    accountId?: StringFilter<"Snag"> | string
    projectId?: StringFilter<"Snag"> | string
    title?: StringFilter<"Snag"> | string
    description?: StringFilter<"Snag"> | string
    status?: EnumSnagStatusFilter<"Snag"> | $Enums.SnagStatus
    priority?: EnumPriorityFilter<"Snag"> | $Enums.Priority
    assigneeId?: StringNullableFilter<"Snag"> | string | null
    dueAt?: DateTimeNullableFilter<"Snag"> | Date | string | null
    photos?: JsonNullableFilter<"Snag">
    createdAt?: DateTimeFilter<"Snag"> | Date | string
    updatedAt?: DateTimeFilter<"Snag"> | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutAccountInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutAccountInput, TaskUncheckedUpdateWithoutAccountInput>
    create: XOR<TaskCreateWithoutAccountInput, TaskUncheckedCreateWithoutAccountInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutAccountInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutAccountInput, TaskUncheckedUpdateWithoutAccountInput>
  }

  export type TaskUpdateManyWithWhereWithoutAccountInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutAccountInput>
  }

  export type WorkflowDefinitionUpsertWithWhereUniqueWithoutAccountInput = {
    where: WorkflowDefinitionWhereUniqueInput
    update: XOR<WorkflowDefinitionUpdateWithoutAccountInput, WorkflowDefinitionUncheckedUpdateWithoutAccountInput>
    create: XOR<WorkflowDefinitionCreateWithoutAccountInput, WorkflowDefinitionUncheckedCreateWithoutAccountInput>
  }

  export type WorkflowDefinitionUpdateWithWhereUniqueWithoutAccountInput = {
    where: WorkflowDefinitionWhereUniqueInput
    data: XOR<WorkflowDefinitionUpdateWithoutAccountInput, WorkflowDefinitionUncheckedUpdateWithoutAccountInput>
  }

  export type WorkflowDefinitionUpdateManyWithWhereWithoutAccountInput = {
    where: WorkflowDefinitionScalarWhereInput
    data: XOR<WorkflowDefinitionUpdateManyMutationInput, WorkflowDefinitionUncheckedUpdateManyWithoutAccountInput>
  }

  export type WorkflowInstanceUpsertWithWhereUniqueWithoutAccountInput = {
    where: WorkflowInstanceWhereUniqueInput
    update: XOR<WorkflowInstanceUpdateWithoutAccountInput, WorkflowInstanceUncheckedUpdateWithoutAccountInput>
    create: XOR<WorkflowInstanceCreateWithoutAccountInput, WorkflowInstanceUncheckedCreateWithoutAccountInput>
  }

  export type WorkflowInstanceUpdateWithWhereUniqueWithoutAccountInput = {
    where: WorkflowInstanceWhereUniqueInput
    data: XOR<WorkflowInstanceUpdateWithoutAccountInput, WorkflowInstanceUncheckedUpdateWithoutAccountInput>
  }

  export type WorkflowInstanceUpdateManyWithWhereWithoutAccountInput = {
    where: WorkflowInstanceScalarWhereInput
    data: XOR<WorkflowInstanceUpdateManyMutationInput, WorkflowInstanceUncheckedUpdateManyWithoutAccountInput>
  }

  export type WorkflowTemplateUpsertWithWhereUniqueWithoutAccountInput = {
    where: WorkflowTemplateWhereUniqueInput
    update: XOR<WorkflowTemplateUpdateWithoutAccountInput, WorkflowTemplateUncheckedUpdateWithoutAccountInput>
    create: XOR<WorkflowTemplateCreateWithoutAccountInput, WorkflowTemplateUncheckedCreateWithoutAccountInput>
  }

  export type WorkflowTemplateUpdateWithWhereUniqueWithoutAccountInput = {
    where: WorkflowTemplateWhereUniqueInput
    data: XOR<WorkflowTemplateUpdateWithoutAccountInput, WorkflowTemplateUncheckedUpdateWithoutAccountInput>
  }

  export type WorkflowTemplateUpdateManyWithWhereWithoutAccountInput = {
    where: WorkflowTemplateScalarWhereInput
    data: XOR<WorkflowTemplateUpdateManyMutationInput, WorkflowTemplateUncheckedUpdateManyWithoutAccountInput>
  }

  export type AutomationRuleUpsertWithWhereUniqueWithoutAccountInput = {
    where: AutomationRuleWhereUniqueInput
    update: XOR<AutomationRuleUpdateWithoutAccountInput, AutomationRuleUncheckedUpdateWithoutAccountInput>
    create: XOR<AutomationRuleCreateWithoutAccountInput, AutomationRuleUncheckedCreateWithoutAccountInput>
  }

  export type AutomationRuleUpdateWithWhereUniqueWithoutAccountInput = {
    where: AutomationRuleWhereUniqueInput
    data: XOR<AutomationRuleUpdateWithoutAccountInput, AutomationRuleUncheckedUpdateWithoutAccountInput>
  }

  export type AutomationRuleUpdateManyWithWhereWithoutAccountInput = {
    where: AutomationRuleScalarWhereInput
    data: XOR<AutomationRuleUpdateManyMutationInput, AutomationRuleUncheckedUpdateManyWithoutAccountInput>
  }

  export type ActivityCreateWithoutEnquiryInput = {
    id?: string
    type: $Enums.ActivityType
    threadKey?: string | null
    summary?: string | null
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: Date | string
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutActivitiesInput
    lead?: LeadCreateNestedOneWithoutActivitiesInput
    project?: ProjectCreateNestedOneWithoutActivitiesInput
    user?: UserCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutEnquiryInput = {
    id?: string
    accountId: string
    leadId?: string | null
    projectId?: string | null
    userId?: string | null
    type: $Enums.ActivityType
    threadKey?: string | null
    summary?: string | null
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: Date | string
    createdAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutEnquiryInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutEnquiryInput, ActivityUncheckedCreateWithoutEnquiryInput>
  }

  export type ActivityCreateManyEnquiryInputEnvelope = {
    data: ActivityCreateManyEnquiryInput | ActivityCreateManyEnquiryInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutEnquiriesInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    owner: UserCreateNestedOneWithoutOwnedAccountsInput
    activities?: ActivityCreateNestedManyWithoutAccountInput
    appointments?: AppointmentCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectCreateNestedManyWithoutAccountInput
    contacts?: ContactCreateNestedManyWithoutAccountInput
    documents?: DocumentCreateNestedManyWithoutAccountInput
    events?: EventLogCreateNestedManyWithoutAccountInput
    leads?: LeadCreateNestedManyWithoutAccountInput
    projects?: ProjectCreateNestedManyWithoutAccountInput
    snags?: SnagCreateNestedManyWithoutAccountInput
    tasks?: TaskCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutEnquiriesInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutAccountInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAccountInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAccountInput
    events?: EventLogUncheckedCreateNestedManyWithoutAccountInput
    leads?: LeadUncheckedCreateNestedManyWithoutAccountInput
    projects?: ProjectUncheckedCreateNestedManyWithoutAccountInput
    snags?: SnagUncheckedCreateNestedManyWithoutAccountInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutEnquiriesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutEnquiriesInput, AccountUncheckedCreateWithoutEnquiriesInput>
  }

  export type UserCreateWithoutOwnedEnquiriesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedAccounts?: AccountCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutOwnedEnquiriesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownedAccounts?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceUncheckedCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverUncheckedCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanUncheckedCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanUncheckedCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionUncheckedCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectUncheckedCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectUncheckedCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutOwnedEnquiriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedEnquiriesInput, UserUncheckedCreateWithoutOwnedEnquiriesInput>
  }

  export type LeadCreateWithoutEnquiryInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityCreateNestedManyWithoutLeadInput
    account: AccountCreateNestedOneWithoutLeadsInput
    owner: UserCreateNestedOneWithoutOwnedLeadsInput
    project?: ProjectCreateNestedOneWithoutLeadInput
    tasks?: TaskCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutEnquiryInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    accountId: string
    ownerId: string
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutLeadInput
    project?: ProjectUncheckedCreateNestedOneWithoutLeadInput
    tasks?: TaskUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutEnquiryInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutEnquiryInput, LeadUncheckedCreateWithoutEnquiryInput>
  }

  export type TaskCreateWithoutEnquiryInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutTasksInput
    assignee: UserCreateNestedOneWithoutAssignedTasksInput
    lead?: LeadCreateNestedOneWithoutTasksInput
    project?: ProjectCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutEnquiryInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    assigneeId: string
    accountId: string
    leadId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutEnquiryInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutEnquiryInput, TaskUncheckedCreateWithoutEnquiryInput>
  }

  export type TaskCreateManyEnquiryInputEnvelope = {
    data: TaskCreateManyEnquiryInput | TaskCreateManyEnquiryInput[]
    skipDuplicates?: boolean
  }

  export type ActivityUpsertWithWhereUniqueWithoutEnquiryInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutEnquiryInput, ActivityUncheckedUpdateWithoutEnquiryInput>
    create: XOR<ActivityCreateWithoutEnquiryInput, ActivityUncheckedCreateWithoutEnquiryInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutEnquiryInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutEnquiryInput, ActivityUncheckedUpdateWithoutEnquiryInput>
  }

  export type ActivityUpdateManyWithWhereWithoutEnquiryInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutEnquiryInput>
  }

  export type AccountUpsertWithoutEnquiriesInput = {
    update: XOR<AccountUpdateWithoutEnquiriesInput, AccountUncheckedUpdateWithoutEnquiriesInput>
    create: XOR<AccountCreateWithoutEnquiriesInput, AccountUncheckedCreateWithoutEnquiriesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutEnquiriesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutEnquiriesInput, AccountUncheckedUpdateWithoutEnquiriesInput>
  }

  export type AccountUpdateWithoutEnquiriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: UserUpdateOneRequiredWithoutOwnedAccountsNestedInput
    activities?: ActivityUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUpdateManyWithoutAccountNestedInput
    contacts?: ContactUpdateManyWithoutAccountNestedInput
    documents?: DocumentUpdateManyWithoutAccountNestedInput
    events?: EventLogUpdateManyWithoutAccountNestedInput
    leads?: LeadUpdateManyWithoutAccountNestedInput
    projects?: ProjectUpdateManyWithoutAccountNestedInput
    snags?: SnagUpdateManyWithoutAccountNestedInput
    tasks?: TaskUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutEnquiriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUncheckedUpdateManyWithoutAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAccountNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAccountNestedInput
    events?: EventLogUncheckedUpdateManyWithoutAccountNestedInput
    leads?: LeadUncheckedUpdateManyWithoutAccountNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutAccountNestedInput
    snags?: SnagUncheckedUpdateManyWithoutAccountNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUncheckedUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type UserUpsertWithoutOwnedEnquiriesInput = {
    update: XOR<UserUpdateWithoutOwnedEnquiriesInput, UserUncheckedUpdateWithoutOwnedEnquiriesInput>
    create: XOR<UserCreateWithoutOwnedEnquiriesInput, UserUncheckedCreateWithoutOwnedEnquiriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedEnquiriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedEnquiriesInput, UserUncheckedUpdateWithoutOwnedEnquiriesInput>
  }

  export type UserUpdateWithoutOwnedEnquiriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedAccounts?: AccountUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedEnquiriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedAccounts?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUncheckedUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUncheckedUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUncheckedUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUncheckedUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type LeadUpsertWithoutEnquiryInput = {
    update: XOR<LeadUpdateWithoutEnquiryInput, LeadUncheckedUpdateWithoutEnquiryInput>
    create: XOR<LeadCreateWithoutEnquiryInput, LeadUncheckedCreateWithoutEnquiryInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutEnquiryInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutEnquiryInput, LeadUncheckedUpdateWithoutEnquiryInput>
  }

  export type LeadUpdateWithoutEnquiryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutLeadNestedInput
    account?: AccountUpdateOneRequiredWithoutLeadsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedLeadsNestedInput
    project?: ProjectUpdateOneWithoutLeadNestedInput
    tasks?: TaskUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutEnquiryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutLeadNestedInput
    project?: ProjectUncheckedUpdateOneWithoutLeadNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutEnquiryInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutEnquiryInput, TaskUncheckedUpdateWithoutEnquiryInput>
    create: XOR<TaskCreateWithoutEnquiryInput, TaskUncheckedCreateWithoutEnquiryInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutEnquiryInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutEnquiryInput, TaskUncheckedUpdateWithoutEnquiryInput>
  }

  export type TaskUpdateManyWithWhereWithoutEnquiryInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutEnquiryInput>
  }

  export type AccountCreateWithoutContactsInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    owner: UserCreateNestedOneWithoutOwnedAccountsInput
    activities?: ActivityCreateNestedManyWithoutAccountInput
    appointments?: AppointmentCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectCreateNestedManyWithoutAccountInput
    documents?: DocumentCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryCreateNestedManyWithoutAccountInput
    events?: EventLogCreateNestedManyWithoutAccountInput
    leads?: LeadCreateNestedManyWithoutAccountInput
    projects?: ProjectCreateNestedManyWithoutAccountInput
    snags?: SnagCreateNestedManyWithoutAccountInput
    tasks?: TaskCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutContactsInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutAccountInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutAccountInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutAccountInput
    events?: EventLogUncheckedCreateNestedManyWithoutAccountInput
    leads?: LeadUncheckedCreateNestedManyWithoutAccountInput
    projects?: ProjectUncheckedCreateNestedManyWithoutAccountInput
    snags?: SnagUncheckedCreateNestedManyWithoutAccountInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutContactsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutContactsInput, AccountUncheckedCreateWithoutContactsInput>
  }

  export type AccountUpsertWithoutContactsInput = {
    update: XOR<AccountUpdateWithoutContactsInput, AccountUncheckedUpdateWithoutContactsInput>
    create: XOR<AccountCreateWithoutContactsInput, AccountUncheckedCreateWithoutContactsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutContactsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutContactsInput, AccountUncheckedUpdateWithoutContactsInput>
  }

  export type AccountUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: UserUpdateOneRequiredWithoutOwnedAccountsNestedInput
    activities?: ActivityUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUpdateManyWithoutAccountNestedInput
    documents?: DocumentUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUpdateManyWithoutAccountNestedInput
    events?: EventLogUpdateManyWithoutAccountNestedInput
    leads?: LeadUpdateManyWithoutAccountNestedInput
    projects?: ProjectUpdateManyWithoutAccountNestedInput
    snags?: SnagUpdateManyWithoutAccountNestedInput
    tasks?: TaskUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUncheckedUpdateManyWithoutAccountNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutAccountNestedInput
    events?: EventLogUncheckedUpdateManyWithoutAccountNestedInput
    leads?: LeadUncheckedUpdateManyWithoutAccountNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutAccountNestedInput
    snags?: SnagUncheckedUpdateManyWithoutAccountNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUncheckedUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type ActivityCreateWithoutLeadInput = {
    id?: string
    type: $Enums.ActivityType
    threadKey?: string | null
    summary?: string | null
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: Date | string
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutActivitiesInput
    enquiry?: EnquiryCreateNestedOneWithoutActivitiesInput
    project?: ProjectCreateNestedOneWithoutActivitiesInput
    user?: UserCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutLeadInput = {
    id?: string
    accountId: string
    enquiryId?: string | null
    projectId?: string | null
    userId?: string | null
    type: $Enums.ActivityType
    threadKey?: string | null
    summary?: string | null
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: Date | string
    createdAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutLeadInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutLeadInput, ActivityUncheckedCreateWithoutLeadInput>
  }

  export type ActivityCreateManyLeadInputEnvelope = {
    data: ActivityCreateManyLeadInput | ActivityCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutLeadsInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    owner: UserCreateNestedOneWithoutOwnedAccountsInput
    activities?: ActivityCreateNestedManyWithoutAccountInput
    appointments?: AppointmentCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectCreateNestedManyWithoutAccountInput
    contacts?: ContactCreateNestedManyWithoutAccountInput
    documents?: DocumentCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryCreateNestedManyWithoutAccountInput
    events?: EventLogCreateNestedManyWithoutAccountInput
    projects?: ProjectCreateNestedManyWithoutAccountInput
    snags?: SnagCreateNestedManyWithoutAccountInput
    tasks?: TaskCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutLeadsInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutAccountInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAccountInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutAccountInput
    events?: EventLogUncheckedCreateNestedManyWithoutAccountInput
    projects?: ProjectUncheckedCreateNestedManyWithoutAccountInput
    snags?: SnagUncheckedCreateNestedManyWithoutAccountInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutLeadsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutLeadsInput, AccountUncheckedCreateWithoutLeadsInput>
  }

  export type EnquiryCreateWithoutLeadInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.EnquiryStatus
    priority?: $Enums.Priority
    source?: string | null
    campaign?: string | null
    medium?: string | null
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    contactMethod?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    company?: string | null
    message?: string | null
    leadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityCreateNestedManyWithoutEnquiryInput
    account?: AccountCreateNestedOneWithoutEnquiriesInput
    owner: UserCreateNestedOneWithoutOwnedEnquiriesInput
    tasks?: TaskCreateNestedManyWithoutEnquiryInput
  }

  export type EnquiryUncheckedCreateWithoutLeadInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.EnquiryStatus
    priority?: $Enums.Priority
    source?: string | null
    campaign?: string | null
    medium?: string | null
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    contactMethod?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    company?: string | null
    message?: string | null
    accountId?: string | null
    ownerId: string
    leadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutEnquiryInput
    tasks?: TaskUncheckedCreateNestedManyWithoutEnquiryInput
  }

  export type EnquiryCreateOrConnectWithoutLeadInput = {
    where: EnquiryWhereUniqueInput
    create: XOR<EnquiryCreateWithoutLeadInput, EnquiryUncheckedCreateWithoutLeadInput>
  }

  export type UserCreateWithoutOwnedLeadsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedAccounts?: AccountCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutOwnedLeadsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownedAccounts?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryUncheckedCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceUncheckedCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverUncheckedCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanUncheckedCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanUncheckedCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionUncheckedCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectUncheckedCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectUncheckedCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutOwnedLeadsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedLeadsInput, UserUncheckedCreateWithoutOwnedLeadsInput>
  }

  export type ProjectCreateWithoutLeadInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    amountGrossIncVat: number
    vatRate?: number
    probability?: number
    source?: string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    completedProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutProjectInput
    appointments?: AppointmentCreateNestedManyWithoutProjectInput
    completedProject?: CompletedProjectCreateNestedOneWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    account: AccountCreateNestedOneWithoutProjectsInput
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    snags?: SnagCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutLeadInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    accountId: string
    ownerId: string
    amountGrossIncVat: number
    vatRate?: number
    probability?: number
    source?: string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    completedProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProjectInput
    completedProject?: CompletedProjectUncheckedCreateNestedOneWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    snags?: SnagUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutLeadInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutLeadInput, ProjectUncheckedCreateWithoutLeadInput>
  }

  export type TaskCreateWithoutLeadInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutTasksInput
    assignee: UserCreateNestedOneWithoutAssignedTasksInput
    enquiry?: EnquiryCreateNestedOneWithoutTasksInput
    project?: ProjectCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutLeadInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    assigneeId: string
    accountId: string
    enquiryId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutLeadInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutLeadInput, TaskUncheckedCreateWithoutLeadInput>
  }

  export type TaskCreateManyLeadInputEnvelope = {
    data: TaskCreateManyLeadInput | TaskCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type ActivityUpsertWithWhereUniqueWithoutLeadInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutLeadInput, ActivityUncheckedUpdateWithoutLeadInput>
    create: XOR<ActivityCreateWithoutLeadInput, ActivityUncheckedCreateWithoutLeadInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutLeadInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutLeadInput, ActivityUncheckedUpdateWithoutLeadInput>
  }

  export type ActivityUpdateManyWithWhereWithoutLeadInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutLeadInput>
  }

  export type AccountUpsertWithoutLeadsInput = {
    update: XOR<AccountUpdateWithoutLeadsInput, AccountUncheckedUpdateWithoutLeadsInput>
    create: XOR<AccountCreateWithoutLeadsInput, AccountUncheckedCreateWithoutLeadsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutLeadsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutLeadsInput, AccountUncheckedUpdateWithoutLeadsInput>
  }

  export type AccountUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: UserUpdateOneRequiredWithoutOwnedAccountsNestedInput
    activities?: ActivityUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUpdateManyWithoutAccountNestedInput
    contacts?: ContactUpdateManyWithoutAccountNestedInput
    documents?: DocumentUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUpdateManyWithoutAccountNestedInput
    events?: EventLogUpdateManyWithoutAccountNestedInput
    projects?: ProjectUpdateManyWithoutAccountNestedInput
    snags?: SnagUpdateManyWithoutAccountNestedInput
    tasks?: TaskUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUncheckedUpdateManyWithoutAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAccountNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutAccountNestedInput
    events?: EventLogUncheckedUpdateManyWithoutAccountNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutAccountNestedInput
    snags?: SnagUncheckedUpdateManyWithoutAccountNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUncheckedUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type EnquiryUpsertWithoutLeadInput = {
    update: XOR<EnquiryUpdateWithoutLeadInput, EnquiryUncheckedUpdateWithoutLeadInput>
    create: XOR<EnquiryCreateWithoutLeadInput, EnquiryUncheckedCreateWithoutLeadInput>
    where?: EnquiryWhereInput
  }

  export type EnquiryUpdateToOneWithWhereWithoutLeadInput = {
    where?: EnquiryWhereInput
    data: XOR<EnquiryUpdateWithoutLeadInput, EnquiryUncheckedUpdateWithoutLeadInput>
  }

  export type EnquiryUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnquiryStatusFieldUpdateOperationsInput | $Enums.EnquiryStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutEnquiryNestedInput
    account?: AccountUpdateOneWithoutEnquiriesNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedEnquiriesNestedInput
    tasks?: TaskUpdateManyWithoutEnquiryNestedInput
  }

  export type EnquiryUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnquiryStatusFieldUpdateOperationsInput | $Enums.EnquiryStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutEnquiryNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutEnquiryNestedInput
  }

  export type UserUpsertWithoutOwnedLeadsInput = {
    update: XOR<UserUpdateWithoutOwnedLeadsInput, UserUncheckedUpdateWithoutOwnedLeadsInput>
    create: XOR<UserCreateWithoutOwnedLeadsInput, UserUncheckedCreateWithoutOwnedLeadsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedLeadsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedLeadsInput, UserUncheckedUpdateWithoutOwnedLeadsInput>
  }

  export type UserUpdateWithoutOwnedLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedAccounts?: AccountUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedAccounts?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUncheckedUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUncheckedUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUncheckedUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUncheckedUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUncheckedUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUncheckedUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type ProjectUpsertWithoutLeadInput = {
    update: XOR<ProjectUpdateWithoutLeadInput, ProjectUncheckedUpdateWithoutLeadInput>
    create: XOR<ProjectCreateWithoutLeadInput, ProjectUncheckedCreateWithoutLeadInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutLeadInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutLeadInput, ProjectUncheckedUpdateWithoutLeadInput>
  }

  export type ProjectUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    amountGrossIncVat?: IntFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    completedProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    appointments?: AppointmentUpdateManyWithoutProjectNestedInput
    completedProject?: CompletedProjectUpdateOneWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    account?: AccountUpdateOneRequiredWithoutProjectsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    snags?: SnagUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    accountId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    amountGrossIncVat?: IntFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    completedProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutProjectNestedInput
    completedProject?: CompletedProjectUncheckedUpdateOneWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    snags?: SnagUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutLeadInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutLeadInput, TaskUncheckedUpdateWithoutLeadInput>
    create: XOR<TaskCreateWithoutLeadInput, TaskUncheckedCreateWithoutLeadInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutLeadInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutLeadInput, TaskUncheckedUpdateWithoutLeadInput>
  }

  export type TaskUpdateManyWithWhereWithoutLeadInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutLeadInput>
  }

  export type ActivityCreateWithoutProjectInput = {
    id?: string
    type: $Enums.ActivityType
    threadKey?: string | null
    summary?: string | null
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: Date | string
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutActivitiesInput
    enquiry?: EnquiryCreateNestedOneWithoutActivitiesInput
    lead?: LeadCreateNestedOneWithoutActivitiesInput
    user?: UserCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutProjectInput = {
    id?: string
    accountId: string
    enquiryId?: string | null
    leadId?: string | null
    userId?: string | null
    type: $Enums.ActivityType
    threadKey?: string | null
    summary?: string | null
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: Date | string
    createdAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutProjectInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutProjectInput, ActivityUncheckedCreateWithoutProjectInput>
  }

  export type ActivityCreateManyProjectInputEnvelope = {
    data: ActivityCreateManyProjectInput | ActivityCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.AppointmentType
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    status?: $Enums.AppointmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutProjectInput = {
    id?: string
    accountId: string
    title: string
    description?: string | null
    type: $Enums.AppointmentType
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    status?: $Enums.AppointmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentCreateOrConnectWithoutProjectInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutProjectInput, AppointmentUncheckedCreateWithoutProjectInput>
  }

  export type AppointmentCreateManyProjectInputEnvelope = {
    data: AppointmentCreateManyProjectInput | AppointmentCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type CompletedProjectCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.CompletedProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutCompletedProjectsInput
    owner: UserCreateNestedOneWithoutOwnedCompletedProjectsInput
  }

  export type CompletedProjectUncheckedCreateWithoutProjectInput = {
    id?: string
    accountId: string
    ownerId: string
    title: string
    description?: string | null
    status?: $Enums.CompletedProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompletedProjectCreateOrConnectWithoutProjectInput = {
    where: CompletedProjectWhereUniqueInput
    create: XOR<CompletedProjectCreateWithoutProjectInput, CompletedProjectUncheckedCreateWithoutProjectInput>
  }

  export type DocumentCreateWithoutProjectInput = {
    id?: string
    filename: string
    fileUrl: string
    fileSize?: number | null
    mimeType?: string | null
    type?: $Enums.DocumentType
    uploadedBy?: string | null
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutProjectInput = {
    id?: string
    accountId: string
    filename: string
    fileUrl: string
    fileSize?: number | null
    mimeType?: string | null
    type?: $Enums.DocumentType
    uploadedBy?: string | null
    createdAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutProjectInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput>
  }

  export type DocumentCreateManyProjectInputEnvelope = {
    data: DocumentCreateManyProjectInput | DocumentCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutProjectsInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    owner: UserCreateNestedOneWithoutOwnedAccountsInput
    activities?: ActivityCreateNestedManyWithoutAccountInput
    appointments?: AppointmentCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectCreateNestedManyWithoutAccountInput
    contacts?: ContactCreateNestedManyWithoutAccountInput
    documents?: DocumentCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryCreateNestedManyWithoutAccountInput
    events?: EventLogCreateNestedManyWithoutAccountInput
    leads?: LeadCreateNestedManyWithoutAccountInput
    snags?: SnagCreateNestedManyWithoutAccountInput
    tasks?: TaskCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutProjectsInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutAccountInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAccountInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutAccountInput
    events?: EventLogUncheckedCreateNestedManyWithoutAccountInput
    leads?: LeadUncheckedCreateNestedManyWithoutAccountInput
    snags?: SnagUncheckedCreateNestedManyWithoutAccountInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutProjectsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutProjectsInput, AccountUncheckedCreateWithoutProjectsInput>
  }

  export type LeadCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityCreateNestedManyWithoutLeadInput
    account: AccountCreateNestedOneWithoutLeadsInput
    enquiry?: EnquiryCreateNestedOneWithoutLeadInput
    owner: UserCreateNestedOneWithoutOwnedLeadsInput
    tasks?: TaskCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    accountId: string
    ownerId: string
    enquiryId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutLeadInput
    tasks?: TaskUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutProjectInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutProjectInput, LeadUncheckedCreateWithoutProjectInput>
  }

  export type UserCreateWithoutOwnedProjectsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedAccounts?: AccountCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutOwnedProjectsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownedAccounts?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceUncheckedCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverUncheckedCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanUncheckedCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanUncheckedCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionUncheckedCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectUncheckedCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectUncheckedCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutOwnedProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedProjectsInput, UserUncheckedCreateWithoutOwnedProjectsInput>
  }

  export type SnagCreateWithoutProjectInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SnagStatus
    priority?: $Enums.Priority
    assigneeId?: string | null
    dueAt?: Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutSnagsInput
  }

  export type SnagUncheckedCreateWithoutProjectInput = {
    id?: string
    accountId: string
    title: string
    description: string
    status?: $Enums.SnagStatus
    priority?: $Enums.Priority
    assigneeId?: string | null
    dueAt?: Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SnagCreateOrConnectWithoutProjectInput = {
    where: SnagWhereUniqueInput
    create: XOR<SnagCreateWithoutProjectInput, SnagUncheckedCreateWithoutProjectInput>
  }

  export type SnagCreateManyProjectInputEnvelope = {
    data: SnagCreateManyProjectInput | SnagCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutTasksInput
    assignee: UserCreateNestedOneWithoutAssignedTasksInput
    enquiry?: EnquiryCreateNestedOneWithoutTasksInput
    lead?: LeadCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    assigneeId: string
    accountId: string
    enquiryId?: string | null
    leadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutProjectInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskCreateManyProjectInputEnvelope = {
    data: TaskCreateManyProjectInput | TaskCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ActivityUpsertWithWhereUniqueWithoutProjectInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutProjectInput, ActivityUncheckedUpdateWithoutProjectInput>
    create: XOR<ActivityCreateWithoutProjectInput, ActivityUncheckedCreateWithoutProjectInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutProjectInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutProjectInput, ActivityUncheckedUpdateWithoutProjectInput>
  }

  export type ActivityUpdateManyWithWhereWithoutProjectInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutProjectInput>
  }

  export type AppointmentUpsertWithWhereUniqueWithoutProjectInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutProjectInput, AppointmentUncheckedUpdateWithoutProjectInput>
    create: XOR<AppointmentCreateWithoutProjectInput, AppointmentUncheckedCreateWithoutProjectInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutProjectInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutProjectInput, AppointmentUncheckedUpdateWithoutProjectInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutProjectInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutProjectInput>
  }

  export type CompletedProjectUpsertWithoutProjectInput = {
    update: XOR<CompletedProjectUpdateWithoutProjectInput, CompletedProjectUncheckedUpdateWithoutProjectInput>
    create: XOR<CompletedProjectCreateWithoutProjectInput, CompletedProjectUncheckedCreateWithoutProjectInput>
    where?: CompletedProjectWhereInput
  }

  export type CompletedProjectUpdateToOneWithWhereWithoutProjectInput = {
    where?: CompletedProjectWhereInput
    data: XOR<CompletedProjectUpdateWithoutProjectInput, CompletedProjectUncheckedUpdateWithoutProjectInput>
  }

  export type CompletedProjectUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompletedProjectStatusFieldUpdateOperationsInput | $Enums.CompletedProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutCompletedProjectsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedCompletedProjectsNestedInput
  }

  export type CompletedProjectUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompletedProjectStatusFieldUpdateOperationsInput | $Enums.CompletedProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutProjectInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutProjectInput, DocumentUncheckedUpdateWithoutProjectInput>
    create: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutProjectInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutProjectInput, DocumentUncheckedUpdateWithoutProjectInput>
  }

  export type DocumentUpdateManyWithWhereWithoutProjectInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutProjectInput>
  }

  export type AccountUpsertWithoutProjectsInput = {
    update: XOR<AccountUpdateWithoutProjectsInput, AccountUncheckedUpdateWithoutProjectsInput>
    create: XOR<AccountCreateWithoutProjectsInput, AccountUncheckedCreateWithoutProjectsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutProjectsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutProjectsInput, AccountUncheckedUpdateWithoutProjectsInput>
  }

  export type AccountUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: UserUpdateOneRequiredWithoutOwnedAccountsNestedInput
    activities?: ActivityUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUpdateManyWithoutAccountNestedInput
    contacts?: ContactUpdateManyWithoutAccountNestedInput
    documents?: DocumentUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUpdateManyWithoutAccountNestedInput
    events?: EventLogUpdateManyWithoutAccountNestedInput
    leads?: LeadUpdateManyWithoutAccountNestedInput
    snags?: SnagUpdateManyWithoutAccountNestedInput
    tasks?: TaskUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUncheckedUpdateManyWithoutAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAccountNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutAccountNestedInput
    events?: EventLogUncheckedUpdateManyWithoutAccountNestedInput
    leads?: LeadUncheckedUpdateManyWithoutAccountNestedInput
    snags?: SnagUncheckedUpdateManyWithoutAccountNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUncheckedUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type LeadUpsertWithoutProjectInput = {
    update: XOR<LeadUpdateWithoutProjectInput, LeadUncheckedUpdateWithoutProjectInput>
    create: XOR<LeadCreateWithoutProjectInput, LeadUncheckedCreateWithoutProjectInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutProjectInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutProjectInput, LeadUncheckedUpdateWithoutProjectInput>
  }

  export type LeadUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutLeadNestedInput
    account?: AccountUpdateOneRequiredWithoutLeadsNestedInput
    enquiry?: EnquiryUpdateOneWithoutLeadNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedLeadsNestedInput
    tasks?: TaskUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutLeadNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type UserUpsertWithoutOwnedProjectsInput = {
    update: XOR<UserUpdateWithoutOwnedProjectsInput, UserUncheckedUpdateWithoutOwnedProjectsInput>
    create: XOR<UserCreateWithoutOwnedProjectsInput, UserUncheckedCreateWithoutOwnedProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedProjectsInput, UserUncheckedUpdateWithoutOwnedProjectsInput>
  }

  export type UserUpdateWithoutOwnedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedAccounts?: AccountUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedAccounts?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUncheckedUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUncheckedUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUncheckedUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUncheckedUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUncheckedUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type SnagUpsertWithWhereUniqueWithoutProjectInput = {
    where: SnagWhereUniqueInput
    update: XOR<SnagUpdateWithoutProjectInput, SnagUncheckedUpdateWithoutProjectInput>
    create: XOR<SnagCreateWithoutProjectInput, SnagUncheckedCreateWithoutProjectInput>
  }

  export type SnagUpdateWithWhereUniqueWithoutProjectInput = {
    where: SnagWhereUniqueInput
    data: XOR<SnagUpdateWithoutProjectInput, SnagUncheckedUpdateWithoutProjectInput>
  }

  export type SnagUpdateManyWithWhereWithoutProjectInput = {
    where: SnagScalarWhereInput
    data: XOR<SnagUpdateManyMutationInput, SnagUncheckedUpdateManyWithoutProjectInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
  }

  export type TaskUpdateManyWithWhereWithoutProjectInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutProjectInput>
  }

  export type AccountCreateWithoutCompletedProjectsInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    owner: UserCreateNestedOneWithoutOwnedAccountsInput
    activities?: ActivityCreateNestedManyWithoutAccountInput
    appointments?: AppointmentCreateNestedManyWithoutAccountInput
    contacts?: ContactCreateNestedManyWithoutAccountInput
    documents?: DocumentCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryCreateNestedManyWithoutAccountInput
    events?: EventLogCreateNestedManyWithoutAccountInput
    leads?: LeadCreateNestedManyWithoutAccountInput
    projects?: ProjectCreateNestedManyWithoutAccountInput
    snags?: SnagCreateNestedManyWithoutAccountInput
    tasks?: TaskCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutCompletedProjectsInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutAccountInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAccountInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutAccountInput
    events?: EventLogUncheckedCreateNestedManyWithoutAccountInput
    leads?: LeadUncheckedCreateNestedManyWithoutAccountInput
    projects?: ProjectUncheckedCreateNestedManyWithoutAccountInput
    snags?: SnagUncheckedCreateNestedManyWithoutAccountInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutCompletedProjectsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutCompletedProjectsInput, AccountUncheckedCreateWithoutCompletedProjectsInput>
  }

  export type UserCreateWithoutOwnedCompletedProjectsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedAccounts?: AccountCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedEnquiries?: EnquiryCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutOwnedCompletedProjectsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownedAccounts?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedEnquiries?: EnquiryUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceUncheckedCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverUncheckedCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanUncheckedCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanUncheckedCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionUncheckedCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectUncheckedCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectUncheckedCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutOwnedCompletedProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedCompletedProjectsInput, UserUncheckedCreateWithoutOwnedCompletedProjectsInput>
  }

  export type ProjectCreateWithoutCompletedProjectInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    amountGrossIncVat: number
    vatRate?: number
    probability?: number
    source?: string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    completedProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutProjectInput
    appointments?: AppointmentCreateNestedManyWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    account: AccountCreateNestedOneWithoutProjectsInput
    lead?: LeadCreateNestedOneWithoutProjectInput
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    snags?: SnagCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCompletedProjectInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    accountId: string
    ownerId: string
    amountGrossIncVat: number
    vatRate?: number
    probability?: number
    source?: string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    leadId?: string | null
    completedProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    snags?: SnagUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCompletedProjectInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCompletedProjectInput, ProjectUncheckedCreateWithoutCompletedProjectInput>
  }

  export type AccountUpsertWithoutCompletedProjectsInput = {
    update: XOR<AccountUpdateWithoutCompletedProjectsInput, AccountUncheckedUpdateWithoutCompletedProjectsInput>
    create: XOR<AccountCreateWithoutCompletedProjectsInput, AccountUncheckedCreateWithoutCompletedProjectsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutCompletedProjectsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutCompletedProjectsInput, AccountUncheckedUpdateWithoutCompletedProjectsInput>
  }

  export type AccountUpdateWithoutCompletedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: UserUpdateOneRequiredWithoutOwnedAccountsNestedInput
    activities?: ActivityUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUpdateManyWithoutAccountNestedInput
    contacts?: ContactUpdateManyWithoutAccountNestedInput
    documents?: DocumentUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUpdateManyWithoutAccountNestedInput
    events?: EventLogUpdateManyWithoutAccountNestedInput
    leads?: LeadUpdateManyWithoutAccountNestedInput
    projects?: ProjectUpdateManyWithoutAccountNestedInput
    snags?: SnagUpdateManyWithoutAccountNestedInput
    tasks?: TaskUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutCompletedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAccountNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutAccountNestedInput
    events?: EventLogUncheckedUpdateManyWithoutAccountNestedInput
    leads?: LeadUncheckedUpdateManyWithoutAccountNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutAccountNestedInput
    snags?: SnagUncheckedUpdateManyWithoutAccountNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUncheckedUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type UserUpsertWithoutOwnedCompletedProjectsInput = {
    update: XOR<UserUpdateWithoutOwnedCompletedProjectsInput, UserUncheckedUpdateWithoutOwnedCompletedProjectsInput>
    create: XOR<UserCreateWithoutOwnedCompletedProjectsInput, UserUncheckedCreateWithoutOwnedCompletedProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedCompletedProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedCompletedProjectsInput, UserUncheckedUpdateWithoutOwnedCompletedProjectsInput>
  }

  export type UserUpdateWithoutOwnedCompletedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedAccounts?: AccountUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedEnquiries?: EnquiryUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedCompletedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedAccounts?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedEnquiries?: EnquiryUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUncheckedUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUncheckedUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUncheckedUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUncheckedUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type ProjectUpsertWithoutCompletedProjectInput = {
    update: XOR<ProjectUpdateWithoutCompletedProjectInput, ProjectUncheckedUpdateWithoutCompletedProjectInput>
    create: XOR<ProjectCreateWithoutCompletedProjectInput, ProjectUncheckedCreateWithoutCompletedProjectInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutCompletedProjectInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutCompletedProjectInput, ProjectUncheckedUpdateWithoutCompletedProjectInput>
  }

  export type ProjectUpdateWithoutCompletedProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    amountGrossIncVat?: IntFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    completedProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    appointments?: AppointmentUpdateManyWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    account?: AccountUpdateOneRequiredWithoutProjectsNestedInput
    lead?: LeadUpdateOneWithoutProjectNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    snags?: SnagUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCompletedProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    accountId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    amountGrossIncVat?: IntFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    completedProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    snags?: SnagUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type AccountCreateWithoutActivitiesInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    owner: UserCreateNestedOneWithoutOwnedAccountsInput
    appointments?: AppointmentCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectCreateNestedManyWithoutAccountInput
    contacts?: ContactCreateNestedManyWithoutAccountInput
    documents?: DocumentCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryCreateNestedManyWithoutAccountInput
    events?: EventLogCreateNestedManyWithoutAccountInput
    leads?: LeadCreateNestedManyWithoutAccountInput
    projects?: ProjectCreateNestedManyWithoutAccountInput
    snags?: SnagCreateNestedManyWithoutAccountInput
    tasks?: TaskCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutActivitiesInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAccountInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutAccountInput
    events?: EventLogUncheckedCreateNestedManyWithoutAccountInput
    leads?: LeadUncheckedCreateNestedManyWithoutAccountInput
    projects?: ProjectUncheckedCreateNestedManyWithoutAccountInput
    snags?: SnagUncheckedCreateNestedManyWithoutAccountInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutActivitiesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutActivitiesInput, AccountUncheckedCreateWithoutActivitiesInput>
  }

  export type EnquiryCreateWithoutActivitiesInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.EnquiryStatus
    priority?: $Enums.Priority
    source?: string | null
    campaign?: string | null
    medium?: string | null
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    contactMethod?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    company?: string | null
    message?: string | null
    leadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    account?: AccountCreateNestedOneWithoutEnquiriesInput
    owner: UserCreateNestedOneWithoutOwnedEnquiriesInput
    lead?: LeadCreateNestedOneWithoutEnquiryInput
    tasks?: TaskCreateNestedManyWithoutEnquiryInput
  }

  export type EnquiryUncheckedCreateWithoutActivitiesInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.EnquiryStatus
    priority?: $Enums.Priority
    source?: string | null
    campaign?: string | null
    medium?: string | null
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    contactMethod?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    company?: string | null
    message?: string | null
    accountId?: string | null
    ownerId: string
    leadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    lead?: LeadUncheckedCreateNestedOneWithoutEnquiryInput
    tasks?: TaskUncheckedCreateNestedManyWithoutEnquiryInput
  }

  export type EnquiryCreateOrConnectWithoutActivitiesInput = {
    where: EnquiryWhereUniqueInput
    create: XOR<EnquiryCreateWithoutActivitiesInput, EnquiryUncheckedCreateWithoutActivitiesInput>
  }

  export type LeadCreateWithoutActivitiesInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    account: AccountCreateNestedOneWithoutLeadsInput
    enquiry?: EnquiryCreateNestedOneWithoutLeadInput
    owner: UserCreateNestedOneWithoutOwnedLeadsInput
    project?: ProjectCreateNestedOneWithoutLeadInput
    tasks?: TaskCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutActivitiesInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    accountId: string
    ownerId: string
    enquiryId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    project?: ProjectUncheckedCreateNestedOneWithoutLeadInput
    tasks?: TaskUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutActivitiesInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutActivitiesInput, LeadUncheckedCreateWithoutActivitiesInput>
  }

  export type ProjectCreateWithoutActivitiesInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    amountGrossIncVat: number
    vatRate?: number
    probability?: number
    source?: string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    completedProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutProjectInput
    completedProject?: CompletedProjectCreateNestedOneWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    account: AccountCreateNestedOneWithoutProjectsInput
    lead?: LeadCreateNestedOneWithoutProjectInput
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    snags?: SnagCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutActivitiesInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    accountId: string
    ownerId: string
    amountGrossIncVat: number
    vatRate?: number
    probability?: number
    source?: string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    leadId?: string | null
    completedProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProjectInput
    completedProject?: CompletedProjectUncheckedCreateNestedOneWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    snags?: SnagUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutActivitiesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutActivitiesInput, ProjectUncheckedCreateWithoutActivitiesInput>
  }

  export type UserCreateWithoutActivitiesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedAccounts?: AccountCreateNestedManyWithoutOwnerInput
    ownedCompletedProjects?: CompletedProjectCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutActivitiesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownedAccounts?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    ownedCompletedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceUncheckedCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverUncheckedCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanUncheckedCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanUncheckedCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionUncheckedCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectUncheckedCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectUncheckedCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
  }

  export type AccountUpsertWithoutActivitiesInput = {
    update: XOR<AccountUpdateWithoutActivitiesInput, AccountUncheckedUpdateWithoutActivitiesInput>
    create: XOR<AccountCreateWithoutActivitiesInput, AccountUncheckedCreateWithoutActivitiesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutActivitiesInput, AccountUncheckedUpdateWithoutActivitiesInput>
  }

  export type AccountUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: UserUpdateOneRequiredWithoutOwnedAccountsNestedInput
    appointments?: AppointmentUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUpdateManyWithoutAccountNestedInput
    contacts?: ContactUpdateManyWithoutAccountNestedInput
    documents?: DocumentUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUpdateManyWithoutAccountNestedInput
    events?: EventLogUpdateManyWithoutAccountNestedInput
    leads?: LeadUpdateManyWithoutAccountNestedInput
    projects?: ProjectUpdateManyWithoutAccountNestedInput
    snags?: SnagUpdateManyWithoutAccountNestedInput
    tasks?: TaskUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUncheckedUpdateManyWithoutAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAccountNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutAccountNestedInput
    events?: EventLogUncheckedUpdateManyWithoutAccountNestedInput
    leads?: LeadUncheckedUpdateManyWithoutAccountNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutAccountNestedInput
    snags?: SnagUncheckedUpdateManyWithoutAccountNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUncheckedUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type EnquiryUpsertWithoutActivitiesInput = {
    update: XOR<EnquiryUpdateWithoutActivitiesInput, EnquiryUncheckedUpdateWithoutActivitiesInput>
    create: XOR<EnquiryCreateWithoutActivitiesInput, EnquiryUncheckedCreateWithoutActivitiesInput>
    where?: EnquiryWhereInput
  }

  export type EnquiryUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: EnquiryWhereInput
    data: XOR<EnquiryUpdateWithoutActivitiesInput, EnquiryUncheckedUpdateWithoutActivitiesInput>
  }

  export type EnquiryUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnquiryStatusFieldUpdateOperationsInput | $Enums.EnquiryStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneWithoutEnquiriesNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedEnquiriesNestedInput
    lead?: LeadUpdateOneWithoutEnquiryNestedInput
    tasks?: TaskUpdateManyWithoutEnquiryNestedInput
  }

  export type EnquiryUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnquiryStatusFieldUpdateOperationsInput | $Enums.EnquiryStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    lead?: LeadUncheckedUpdateOneWithoutEnquiryNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutEnquiryNestedInput
  }

  export type LeadUpsertWithoutActivitiesInput = {
    update: XOR<LeadUpdateWithoutActivitiesInput, LeadUncheckedUpdateWithoutActivitiesInput>
    create: XOR<LeadCreateWithoutActivitiesInput, LeadUncheckedCreateWithoutActivitiesInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutActivitiesInput, LeadUncheckedUpdateWithoutActivitiesInput>
  }

  export type LeadUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneRequiredWithoutLeadsNestedInput
    enquiry?: EnquiryUpdateOneWithoutLeadNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedLeadsNestedInput
    project?: ProjectUpdateOneWithoutLeadNestedInput
    tasks?: TaskUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUncheckedUpdateOneWithoutLeadNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type ProjectUpsertWithoutActivitiesInput = {
    update: XOR<ProjectUpdateWithoutActivitiesInput, ProjectUncheckedUpdateWithoutActivitiesInput>
    create: XOR<ProjectCreateWithoutActivitiesInput, ProjectUncheckedCreateWithoutActivitiesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutActivitiesInput, ProjectUncheckedUpdateWithoutActivitiesInput>
  }

  export type ProjectUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    amountGrossIncVat?: IntFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    completedProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutProjectNestedInput
    completedProject?: CompletedProjectUpdateOneWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    account?: AccountUpdateOneRequiredWithoutProjectsNestedInput
    lead?: LeadUpdateOneWithoutProjectNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    snags?: SnagUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    accountId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    amountGrossIncVat?: IntFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    completedProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutProjectNestedInput
    completedProject?: CompletedProjectUncheckedUpdateOneWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    snags?: SnagUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutActivitiesInput = {
    update: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedAccounts?: AccountUpdateManyWithoutOwnerNestedInput
    ownedCompletedProjects?: CompletedProjectUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedAccounts?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    ownedCompletedProjects?: CompletedProjectUncheckedUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUncheckedUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUncheckedUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUncheckedUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUncheckedUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type AccountCreateWithoutTasksInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    owner: UserCreateNestedOneWithoutOwnedAccountsInput
    activities?: ActivityCreateNestedManyWithoutAccountInput
    appointments?: AppointmentCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectCreateNestedManyWithoutAccountInput
    contacts?: ContactCreateNestedManyWithoutAccountInput
    documents?: DocumentCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryCreateNestedManyWithoutAccountInput
    events?: EventLogCreateNestedManyWithoutAccountInput
    leads?: LeadCreateNestedManyWithoutAccountInput
    projects?: ProjectCreateNestedManyWithoutAccountInput
    snags?: SnagCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutTasksInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutAccountInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAccountInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutAccountInput
    events?: EventLogUncheckedCreateNestedManyWithoutAccountInput
    leads?: LeadUncheckedCreateNestedManyWithoutAccountInput
    projects?: ProjectUncheckedCreateNestedManyWithoutAccountInput
    snags?: SnagUncheckedCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutTasksInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutTasksInput, AccountUncheckedCreateWithoutTasksInput>
  }

  export type UserCreateWithoutAssignedTasksInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedAccounts?: AccountCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutAssignedTasksInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownedAccounts?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceUncheckedCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverUncheckedCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanUncheckedCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanUncheckedCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionUncheckedCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectUncheckedCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectUncheckedCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutAssignedTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
  }

  export type EnquiryCreateWithoutTasksInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.EnquiryStatus
    priority?: $Enums.Priority
    source?: string | null
    campaign?: string | null
    medium?: string | null
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    contactMethod?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    company?: string | null
    message?: string | null
    leadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityCreateNestedManyWithoutEnquiryInput
    account?: AccountCreateNestedOneWithoutEnquiriesInput
    owner: UserCreateNestedOneWithoutOwnedEnquiriesInput
    lead?: LeadCreateNestedOneWithoutEnquiryInput
  }

  export type EnquiryUncheckedCreateWithoutTasksInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.EnquiryStatus
    priority?: $Enums.Priority
    source?: string | null
    campaign?: string | null
    medium?: string | null
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    contactMethod?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    company?: string | null
    message?: string | null
    accountId?: string | null
    ownerId: string
    leadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutEnquiryInput
    lead?: LeadUncheckedCreateNestedOneWithoutEnquiryInput
  }

  export type EnquiryCreateOrConnectWithoutTasksInput = {
    where: EnquiryWhereUniqueInput
    create: XOR<EnquiryCreateWithoutTasksInput, EnquiryUncheckedCreateWithoutTasksInput>
  }

  export type LeadCreateWithoutTasksInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityCreateNestedManyWithoutLeadInput
    account: AccountCreateNestedOneWithoutLeadsInput
    enquiry?: EnquiryCreateNestedOneWithoutLeadInput
    owner: UserCreateNestedOneWithoutOwnedLeadsInput
    project?: ProjectCreateNestedOneWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutTasksInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    accountId: string
    ownerId: string
    enquiryId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutLeadInput
    project?: ProjectUncheckedCreateNestedOneWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutTasksInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutTasksInput, LeadUncheckedCreateWithoutTasksInput>
  }

  export type ProjectCreateWithoutTasksInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    amountGrossIncVat: number
    vatRate?: number
    probability?: number
    source?: string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    completedProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutProjectInput
    appointments?: AppointmentCreateNestedManyWithoutProjectInput
    completedProject?: CompletedProjectCreateNestedOneWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    account: AccountCreateNestedOneWithoutProjectsInput
    lead?: LeadCreateNestedOneWithoutProjectInput
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    snags?: SnagCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTasksInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    accountId: string
    ownerId: string
    amountGrossIncVat: number
    vatRate?: number
    probability?: number
    source?: string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    leadId?: string | null
    completedProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProjectInput
    completedProject?: CompletedProjectUncheckedCreateNestedOneWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    snags?: SnagUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTasksInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
  }

  export type AccountUpsertWithoutTasksInput = {
    update: XOR<AccountUpdateWithoutTasksInput, AccountUncheckedUpdateWithoutTasksInput>
    create: XOR<AccountCreateWithoutTasksInput, AccountUncheckedCreateWithoutTasksInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutTasksInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutTasksInput, AccountUncheckedUpdateWithoutTasksInput>
  }

  export type AccountUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: UserUpdateOneRequiredWithoutOwnedAccountsNestedInput
    activities?: ActivityUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUpdateManyWithoutAccountNestedInput
    contacts?: ContactUpdateManyWithoutAccountNestedInput
    documents?: DocumentUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUpdateManyWithoutAccountNestedInput
    events?: EventLogUpdateManyWithoutAccountNestedInput
    leads?: LeadUpdateManyWithoutAccountNestedInput
    projects?: ProjectUpdateManyWithoutAccountNestedInput
    snags?: SnagUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUncheckedUpdateManyWithoutAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAccountNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutAccountNestedInput
    events?: EventLogUncheckedUpdateManyWithoutAccountNestedInput
    leads?: LeadUncheckedUpdateManyWithoutAccountNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutAccountNestedInput
    snags?: SnagUncheckedUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUncheckedUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type UserUpsertWithoutAssignedTasksInput = {
    update: XOR<UserUpdateWithoutAssignedTasksInput, UserUncheckedUpdateWithoutAssignedTasksInput>
    create: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedTasksInput, UserUncheckedUpdateWithoutAssignedTasksInput>
  }

  export type UserUpdateWithoutAssignedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedAccounts?: AccountUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedAccounts?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUncheckedUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUncheckedUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUncheckedUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUncheckedUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUncheckedUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type EnquiryUpsertWithoutTasksInput = {
    update: XOR<EnquiryUpdateWithoutTasksInput, EnquiryUncheckedUpdateWithoutTasksInput>
    create: XOR<EnquiryCreateWithoutTasksInput, EnquiryUncheckedCreateWithoutTasksInput>
    where?: EnquiryWhereInput
  }

  export type EnquiryUpdateToOneWithWhereWithoutTasksInput = {
    where?: EnquiryWhereInput
    data: XOR<EnquiryUpdateWithoutTasksInput, EnquiryUncheckedUpdateWithoutTasksInput>
  }

  export type EnquiryUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnquiryStatusFieldUpdateOperationsInput | $Enums.EnquiryStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutEnquiryNestedInput
    account?: AccountUpdateOneWithoutEnquiriesNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedEnquiriesNestedInput
    lead?: LeadUpdateOneWithoutEnquiryNestedInput
  }

  export type EnquiryUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnquiryStatusFieldUpdateOperationsInput | $Enums.EnquiryStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutEnquiryNestedInput
    lead?: LeadUncheckedUpdateOneWithoutEnquiryNestedInput
  }

  export type LeadUpsertWithoutTasksInput = {
    update: XOR<LeadUpdateWithoutTasksInput, LeadUncheckedUpdateWithoutTasksInput>
    create: XOR<LeadCreateWithoutTasksInput, LeadUncheckedCreateWithoutTasksInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutTasksInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutTasksInput, LeadUncheckedUpdateWithoutTasksInput>
  }

  export type LeadUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutLeadNestedInput
    account?: AccountUpdateOneRequiredWithoutLeadsNestedInput
    enquiry?: EnquiryUpdateOneWithoutLeadNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedLeadsNestedInput
    project?: ProjectUpdateOneWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutLeadNestedInput
    project?: ProjectUncheckedUpdateOneWithoutLeadNestedInput
  }

  export type ProjectUpsertWithoutTasksInput = {
    update: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTasksInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
  }

  export type ProjectUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    amountGrossIncVat?: IntFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    completedProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    appointments?: AppointmentUpdateManyWithoutProjectNestedInput
    completedProject?: CompletedProjectUpdateOneWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    account?: AccountUpdateOneRequiredWithoutProjectsNestedInput
    lead?: LeadUpdateOneWithoutProjectNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    snags?: SnagUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    accountId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    amountGrossIncVat?: IntFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    completedProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutProjectNestedInput
    completedProject?: CompletedProjectUncheckedUpdateOneWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    snags?: SnagUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type AccountCreateWithoutAppointmentsInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    owner: UserCreateNestedOneWithoutOwnedAccountsInput
    activities?: ActivityCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectCreateNestedManyWithoutAccountInput
    contacts?: ContactCreateNestedManyWithoutAccountInput
    documents?: DocumentCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryCreateNestedManyWithoutAccountInput
    events?: EventLogCreateNestedManyWithoutAccountInput
    leads?: LeadCreateNestedManyWithoutAccountInput
    projects?: ProjectCreateNestedManyWithoutAccountInput
    snags?: SnagCreateNestedManyWithoutAccountInput
    tasks?: TaskCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAccountInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutAccountInput
    events?: EventLogUncheckedCreateNestedManyWithoutAccountInput
    leads?: LeadUncheckedCreateNestedManyWithoutAccountInput
    projects?: ProjectUncheckedCreateNestedManyWithoutAccountInput
    snags?: SnagUncheckedCreateNestedManyWithoutAccountInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutAppointmentsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutAppointmentsInput, AccountUncheckedCreateWithoutAppointmentsInput>
  }

  export type ProjectCreateWithoutAppointmentsInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    amountGrossIncVat: number
    vatRate?: number
    probability?: number
    source?: string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    completedProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutProjectInput
    completedProject?: CompletedProjectCreateNestedOneWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    account: AccountCreateNestedOneWithoutProjectsInput
    lead?: LeadCreateNestedOneWithoutProjectInput
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    snags?: SnagCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    accountId: string
    ownerId: string
    amountGrossIncVat: number
    vatRate?: number
    probability?: number
    source?: string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    leadId?: string | null
    completedProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    completedProject?: CompletedProjectUncheckedCreateNestedOneWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    snags?: SnagUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutAppointmentsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutAppointmentsInput, ProjectUncheckedCreateWithoutAppointmentsInput>
  }

  export type AccountUpsertWithoutAppointmentsInput = {
    update: XOR<AccountUpdateWithoutAppointmentsInput, AccountUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<AccountCreateWithoutAppointmentsInput, AccountUncheckedCreateWithoutAppointmentsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutAppointmentsInput, AccountUncheckedUpdateWithoutAppointmentsInput>
  }

  export type AccountUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: UserUpdateOneRequiredWithoutOwnedAccountsNestedInput
    activities?: ActivityUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUpdateManyWithoutAccountNestedInput
    contacts?: ContactUpdateManyWithoutAccountNestedInput
    documents?: DocumentUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUpdateManyWithoutAccountNestedInput
    events?: EventLogUpdateManyWithoutAccountNestedInput
    leads?: LeadUpdateManyWithoutAccountNestedInput
    projects?: ProjectUpdateManyWithoutAccountNestedInput
    snags?: SnagUpdateManyWithoutAccountNestedInput
    tasks?: TaskUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUncheckedUpdateManyWithoutAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAccountNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutAccountNestedInput
    events?: EventLogUncheckedUpdateManyWithoutAccountNestedInput
    leads?: LeadUncheckedUpdateManyWithoutAccountNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutAccountNestedInput
    snags?: SnagUncheckedUpdateManyWithoutAccountNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUncheckedUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type ProjectUpsertWithoutAppointmentsInput = {
    update: XOR<ProjectUpdateWithoutAppointmentsInput, ProjectUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<ProjectCreateWithoutAppointmentsInput, ProjectUncheckedCreateWithoutAppointmentsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutAppointmentsInput, ProjectUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ProjectUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    amountGrossIncVat?: IntFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    completedProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    completedProject?: CompletedProjectUpdateOneWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    account?: AccountUpdateOneRequiredWithoutProjectsNestedInput
    lead?: LeadUpdateOneWithoutProjectNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    snags?: SnagUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    accountId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    amountGrossIncVat?: IntFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    completedProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    completedProject?: CompletedProjectUncheckedUpdateOneWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    snags?: SnagUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type AccountCreateWithoutDocumentsInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    owner: UserCreateNestedOneWithoutOwnedAccountsInput
    activities?: ActivityCreateNestedManyWithoutAccountInput
    appointments?: AppointmentCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectCreateNestedManyWithoutAccountInput
    contacts?: ContactCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryCreateNestedManyWithoutAccountInput
    events?: EventLogCreateNestedManyWithoutAccountInput
    leads?: LeadCreateNestedManyWithoutAccountInput
    projects?: ProjectCreateNestedManyWithoutAccountInput
    snags?: SnagCreateNestedManyWithoutAccountInput
    tasks?: TaskCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutDocumentsInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutAccountInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutAccountInput
    events?: EventLogUncheckedCreateNestedManyWithoutAccountInput
    leads?: LeadUncheckedCreateNestedManyWithoutAccountInput
    projects?: ProjectUncheckedCreateNestedManyWithoutAccountInput
    snags?: SnagUncheckedCreateNestedManyWithoutAccountInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutDocumentsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutDocumentsInput, AccountUncheckedCreateWithoutDocumentsInput>
  }

  export type ProjectCreateWithoutDocumentsInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    amountGrossIncVat: number
    vatRate?: number
    probability?: number
    source?: string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    completedProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutProjectInput
    appointments?: AppointmentCreateNestedManyWithoutProjectInput
    completedProject?: CompletedProjectCreateNestedOneWithoutProjectInput
    account: AccountCreateNestedOneWithoutProjectsInput
    lead?: LeadCreateNestedOneWithoutProjectInput
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    snags?: SnagCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutDocumentsInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    accountId: string
    ownerId: string
    amountGrossIncVat: number
    vatRate?: number
    probability?: number
    source?: string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    leadId?: string | null
    completedProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProjectInput
    completedProject?: CompletedProjectUncheckedCreateNestedOneWithoutProjectInput
    snags?: SnagUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutDocumentsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
  }

  export type AccountUpsertWithoutDocumentsInput = {
    update: XOR<AccountUpdateWithoutDocumentsInput, AccountUncheckedUpdateWithoutDocumentsInput>
    create: XOR<AccountCreateWithoutDocumentsInput, AccountUncheckedCreateWithoutDocumentsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutDocumentsInput, AccountUncheckedUpdateWithoutDocumentsInput>
  }

  export type AccountUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: UserUpdateOneRequiredWithoutOwnedAccountsNestedInput
    activities?: ActivityUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUpdateManyWithoutAccountNestedInput
    contacts?: ContactUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUpdateManyWithoutAccountNestedInput
    events?: EventLogUpdateManyWithoutAccountNestedInput
    leads?: LeadUpdateManyWithoutAccountNestedInput
    projects?: ProjectUpdateManyWithoutAccountNestedInput
    snags?: SnagUpdateManyWithoutAccountNestedInput
    tasks?: TaskUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUncheckedUpdateManyWithoutAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutAccountNestedInput
    events?: EventLogUncheckedUpdateManyWithoutAccountNestedInput
    leads?: LeadUncheckedUpdateManyWithoutAccountNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutAccountNestedInput
    snags?: SnagUncheckedUpdateManyWithoutAccountNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUncheckedUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type ProjectUpsertWithoutDocumentsInput = {
    update: XOR<ProjectUpdateWithoutDocumentsInput, ProjectUncheckedUpdateWithoutDocumentsInput>
    create: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutDocumentsInput, ProjectUncheckedUpdateWithoutDocumentsInput>
  }

  export type ProjectUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    amountGrossIncVat?: IntFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    completedProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    appointments?: AppointmentUpdateManyWithoutProjectNestedInput
    completedProject?: CompletedProjectUpdateOneWithoutProjectNestedInput
    account?: AccountUpdateOneRequiredWithoutProjectsNestedInput
    lead?: LeadUpdateOneWithoutProjectNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    snags?: SnagUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    accountId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    amountGrossIncVat?: IntFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    completedProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutProjectNestedInput
    completedProject?: CompletedProjectUncheckedUpdateOneWithoutProjectNestedInput
    snags?: SnagUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type AccountCreateWithoutSnagsInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    owner: UserCreateNestedOneWithoutOwnedAccountsInput
    activities?: ActivityCreateNestedManyWithoutAccountInput
    appointments?: AppointmentCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectCreateNestedManyWithoutAccountInput
    contacts?: ContactCreateNestedManyWithoutAccountInput
    documents?: DocumentCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryCreateNestedManyWithoutAccountInput
    events?: EventLogCreateNestedManyWithoutAccountInput
    leads?: LeadCreateNestedManyWithoutAccountInput
    projects?: ProjectCreateNestedManyWithoutAccountInput
    tasks?: TaskCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutSnagsInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutAccountInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAccountInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutAccountInput
    events?: EventLogUncheckedCreateNestedManyWithoutAccountInput
    leads?: LeadUncheckedCreateNestedManyWithoutAccountInput
    projects?: ProjectUncheckedCreateNestedManyWithoutAccountInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutSnagsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutSnagsInput, AccountUncheckedCreateWithoutSnagsInput>
  }

  export type ProjectCreateWithoutSnagsInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    amountGrossIncVat: number
    vatRate?: number
    probability?: number
    source?: string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    completedProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutProjectInput
    appointments?: AppointmentCreateNestedManyWithoutProjectInput
    completedProject?: CompletedProjectCreateNestedOneWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    account: AccountCreateNestedOneWithoutProjectsInput
    lead?: LeadCreateNestedOneWithoutProjectInput
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSnagsInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    accountId: string
    ownerId: string
    amountGrossIncVat: number
    vatRate?: number
    probability?: number
    source?: string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    leadId?: string | null
    completedProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProjectInput
    completedProject?: CompletedProjectUncheckedCreateNestedOneWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSnagsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSnagsInput, ProjectUncheckedCreateWithoutSnagsInput>
  }

  export type AccountUpsertWithoutSnagsInput = {
    update: XOR<AccountUpdateWithoutSnagsInput, AccountUncheckedUpdateWithoutSnagsInput>
    create: XOR<AccountCreateWithoutSnagsInput, AccountUncheckedCreateWithoutSnagsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutSnagsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutSnagsInput, AccountUncheckedUpdateWithoutSnagsInput>
  }

  export type AccountUpdateWithoutSnagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: UserUpdateOneRequiredWithoutOwnedAccountsNestedInput
    activities?: ActivityUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUpdateManyWithoutAccountNestedInput
    contacts?: ContactUpdateManyWithoutAccountNestedInput
    documents?: DocumentUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUpdateManyWithoutAccountNestedInput
    events?: EventLogUpdateManyWithoutAccountNestedInput
    leads?: LeadUpdateManyWithoutAccountNestedInput
    projects?: ProjectUpdateManyWithoutAccountNestedInput
    tasks?: TaskUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutSnagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUncheckedUpdateManyWithoutAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAccountNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutAccountNestedInput
    events?: EventLogUncheckedUpdateManyWithoutAccountNestedInput
    leads?: LeadUncheckedUpdateManyWithoutAccountNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutAccountNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUncheckedUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type ProjectUpsertWithoutSnagsInput = {
    update: XOR<ProjectUpdateWithoutSnagsInput, ProjectUncheckedUpdateWithoutSnagsInput>
    create: XOR<ProjectCreateWithoutSnagsInput, ProjectUncheckedCreateWithoutSnagsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSnagsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSnagsInput, ProjectUncheckedUpdateWithoutSnagsInput>
  }

  export type ProjectUpdateWithoutSnagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    amountGrossIncVat?: IntFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    completedProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    appointments?: AppointmentUpdateManyWithoutProjectNestedInput
    completedProject?: CompletedProjectUpdateOneWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    account?: AccountUpdateOneRequiredWithoutProjectsNestedInput
    lead?: LeadUpdateOneWithoutProjectNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSnagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    accountId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    amountGrossIncVat?: IntFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    completedProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutProjectNestedInput
    completedProject?: CompletedProjectUncheckedUpdateOneWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type AccountCreateWithoutEventsInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    owner: UserCreateNestedOneWithoutOwnedAccountsInput
    activities?: ActivityCreateNestedManyWithoutAccountInput
    appointments?: AppointmentCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectCreateNestedManyWithoutAccountInput
    contacts?: ContactCreateNestedManyWithoutAccountInput
    documents?: DocumentCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryCreateNestedManyWithoutAccountInput
    leads?: LeadCreateNestedManyWithoutAccountInput
    projects?: ProjectCreateNestedManyWithoutAccountInput
    snags?: SnagCreateNestedManyWithoutAccountInput
    tasks?: TaskCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutEventsInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutAccountInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAccountInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutAccountInput
    leads?: LeadUncheckedCreateNestedManyWithoutAccountInput
    projects?: ProjectUncheckedCreateNestedManyWithoutAccountInput
    snags?: SnagUncheckedCreateNestedManyWithoutAccountInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutEventsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutEventsInput, AccountUncheckedCreateWithoutEventsInput>
  }

  export type AccountUpsertWithoutEventsInput = {
    update: XOR<AccountUpdateWithoutEventsInput, AccountUncheckedUpdateWithoutEventsInput>
    create: XOR<AccountCreateWithoutEventsInput, AccountUncheckedCreateWithoutEventsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutEventsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutEventsInput, AccountUncheckedUpdateWithoutEventsInput>
  }

  export type AccountUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: UserUpdateOneRequiredWithoutOwnedAccountsNestedInput
    activities?: ActivityUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUpdateManyWithoutAccountNestedInput
    contacts?: ContactUpdateManyWithoutAccountNestedInput
    documents?: DocumentUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUpdateManyWithoutAccountNestedInput
    leads?: LeadUpdateManyWithoutAccountNestedInput
    projects?: ProjectUpdateManyWithoutAccountNestedInput
    snags?: SnagUpdateManyWithoutAccountNestedInput
    tasks?: TaskUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUncheckedUpdateManyWithoutAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAccountNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutAccountNestedInput
    leads?: LeadUncheckedUpdateManyWithoutAccountNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutAccountNestedInput
    snags?: SnagUncheckedUpdateManyWithoutAccountNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUncheckedUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountCreateWithoutWorkflowsInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    owner: UserCreateNestedOneWithoutOwnedAccountsInput
    activities?: ActivityCreateNestedManyWithoutAccountInput
    appointments?: AppointmentCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectCreateNestedManyWithoutAccountInput
    contacts?: ContactCreateNestedManyWithoutAccountInput
    documents?: DocumentCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryCreateNestedManyWithoutAccountInput
    events?: EventLogCreateNestedManyWithoutAccountInput
    leads?: LeadCreateNestedManyWithoutAccountInput
    projects?: ProjectCreateNestedManyWithoutAccountInput
    snags?: SnagCreateNestedManyWithoutAccountInput
    tasks?: TaskCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutWorkflowsInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutAccountInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAccountInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutAccountInput
    events?: EventLogUncheckedCreateNestedManyWithoutAccountInput
    leads?: LeadUncheckedCreateNestedManyWithoutAccountInput
    projects?: ProjectUncheckedCreateNestedManyWithoutAccountInput
    snags?: SnagUncheckedCreateNestedManyWithoutAccountInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutWorkflowsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutWorkflowsInput, AccountUncheckedCreateWithoutWorkflowsInput>
  }

  export type UserCreateWithoutCreatedWorkflowsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedAccounts?: AccountCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    initiatedWorkflows?: WorkflowInstanceCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutCreatedWorkflowsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownedAccounts?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    initiatedWorkflows?: WorkflowInstanceUncheckedCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverUncheckedCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanUncheckedCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanUncheckedCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionUncheckedCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectUncheckedCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectUncheckedCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutCreatedWorkflowsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedWorkflowsInput, UserUncheckedCreateWithoutCreatedWorkflowsInput>
  }

  export type WorkflowStepCreateWithoutWorkflowInput = {
    id?: string
    name: string
    description?: string | null
    stepType: $Enums.WorkflowStepType
    position: number
    configuration: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    timeoutMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: WorkflowStepExecutionCreateNestedManyWithoutStepInput
    approvers?: WorkflowStepApproverCreateNestedManyWithoutStepInput
  }

  export type WorkflowStepUncheckedCreateWithoutWorkflowInput = {
    id?: string
    name: string
    description?: string | null
    stepType: $Enums.WorkflowStepType
    position: number
    configuration: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    timeoutMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutStepInput
    approvers?: WorkflowStepApproverUncheckedCreateNestedManyWithoutStepInput
  }

  export type WorkflowStepCreateOrConnectWithoutWorkflowInput = {
    where: WorkflowStepWhereUniqueInput
    create: XOR<WorkflowStepCreateWithoutWorkflowInput, WorkflowStepUncheckedCreateWithoutWorkflowInput>
  }

  export type WorkflowStepCreateManyWorkflowInputEnvelope = {
    data: WorkflowStepCreateManyWorkflowInput | WorkflowStepCreateManyWorkflowInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowInstanceCreateWithoutWorkflowInput = {
    id?: string
    entityType: string
    entityId: string
    status: $Enums.WorkflowStatus
    currentStepId?: string | null
    priority?: $Enums.Priority
    startedAt?: Date | string
    completedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    account: AccountCreateNestedOneWithoutWorkflowInstancesInput
    initiatedBy: UserCreateNestedOneWithoutInitiatedWorkflowsInput
    executions?: WorkflowStepExecutionCreateNestedManyWithoutInstanceInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutInstanceInput
  }

  export type WorkflowInstanceUncheckedCreateWithoutWorkflowInput = {
    id?: string
    entityType: string
    entityId: string
    status: $Enums.WorkflowStatus
    currentStepId?: string | null
    priority?: $Enums.Priority
    startedAt?: Date | string
    completedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId: string
    initiatedById: string
    executions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutInstanceInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type WorkflowInstanceCreateOrConnectWithoutWorkflowInput = {
    where: WorkflowInstanceWhereUniqueInput
    create: XOR<WorkflowInstanceCreateWithoutWorkflowInput, WorkflowInstanceUncheckedCreateWithoutWorkflowInput>
  }

  export type WorkflowInstanceCreateManyWorkflowInputEnvelope = {
    data: WorkflowInstanceCreateManyWorkflowInput | WorkflowInstanceCreateManyWorkflowInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowTemplateCreateWithoutWorkflowInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    industry?: string
    templateData: JsonNullValueInput | InputJsonValue
    isPublic?: boolean
    usageCount?: number
    rating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account?: AccountCreateNestedOneWithoutWorkflowTemplatesInput
    createdBy: UserCreateNestedOneWithoutCreatedTemplatesInput
  }

  export type WorkflowTemplateUncheckedCreateWithoutWorkflowInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    industry?: string
    templateData: JsonNullValueInput | InputJsonValue
    isPublic?: boolean
    usageCount?: number
    rating?: number | null
    accountId?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowTemplateCreateOrConnectWithoutWorkflowInput = {
    where: WorkflowTemplateWhereUniqueInput
    create: XOR<WorkflowTemplateCreateWithoutWorkflowInput, WorkflowTemplateUncheckedCreateWithoutWorkflowInput>
  }

  export type WorkflowTemplateCreateManyWorkflowInputEnvelope = {
    data: WorkflowTemplateCreateManyWorkflowInput | WorkflowTemplateCreateManyWorkflowInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutWorkflowsInput = {
    update: XOR<AccountUpdateWithoutWorkflowsInput, AccountUncheckedUpdateWithoutWorkflowsInput>
    create: XOR<AccountCreateWithoutWorkflowsInput, AccountUncheckedCreateWithoutWorkflowsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutWorkflowsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutWorkflowsInput, AccountUncheckedUpdateWithoutWorkflowsInput>
  }

  export type AccountUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: UserUpdateOneRequiredWithoutOwnedAccountsNestedInput
    activities?: ActivityUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUpdateManyWithoutAccountNestedInput
    contacts?: ContactUpdateManyWithoutAccountNestedInput
    documents?: DocumentUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUpdateManyWithoutAccountNestedInput
    events?: EventLogUpdateManyWithoutAccountNestedInput
    leads?: LeadUpdateManyWithoutAccountNestedInput
    projects?: ProjectUpdateManyWithoutAccountNestedInput
    snags?: SnagUpdateManyWithoutAccountNestedInput
    tasks?: TaskUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUncheckedUpdateManyWithoutAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAccountNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutAccountNestedInput
    events?: EventLogUncheckedUpdateManyWithoutAccountNestedInput
    leads?: LeadUncheckedUpdateManyWithoutAccountNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutAccountNestedInput
    snags?: SnagUncheckedUpdateManyWithoutAccountNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type UserUpsertWithoutCreatedWorkflowsInput = {
    update: XOR<UserUpdateWithoutCreatedWorkflowsInput, UserUncheckedUpdateWithoutCreatedWorkflowsInput>
    create: XOR<UserCreateWithoutCreatedWorkflowsInput, UserUncheckedCreateWithoutCreatedWorkflowsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedWorkflowsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedWorkflowsInput, UserUncheckedUpdateWithoutCreatedWorkflowsInput>
  }

  export type UserUpdateWithoutCreatedWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedAccounts?: AccountUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedAccounts?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUncheckedUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUncheckedUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUncheckedUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUncheckedUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUncheckedUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type WorkflowStepUpsertWithWhereUniqueWithoutWorkflowInput = {
    where: WorkflowStepWhereUniqueInput
    update: XOR<WorkflowStepUpdateWithoutWorkflowInput, WorkflowStepUncheckedUpdateWithoutWorkflowInput>
    create: XOR<WorkflowStepCreateWithoutWorkflowInput, WorkflowStepUncheckedCreateWithoutWorkflowInput>
  }

  export type WorkflowStepUpdateWithWhereUniqueWithoutWorkflowInput = {
    where: WorkflowStepWhereUniqueInput
    data: XOR<WorkflowStepUpdateWithoutWorkflowInput, WorkflowStepUncheckedUpdateWithoutWorkflowInput>
  }

  export type WorkflowStepUpdateManyWithWhereWithoutWorkflowInput = {
    where: WorkflowStepScalarWhereInput
    data: XOR<WorkflowStepUpdateManyMutationInput, WorkflowStepUncheckedUpdateManyWithoutWorkflowInput>
  }

  export type WorkflowStepScalarWhereInput = {
    AND?: WorkflowStepScalarWhereInput | WorkflowStepScalarWhereInput[]
    OR?: WorkflowStepScalarWhereInput[]
    NOT?: WorkflowStepScalarWhereInput | WorkflowStepScalarWhereInput[]
    id?: StringFilter<"WorkflowStep"> | string
    workflowId?: StringFilter<"WorkflowStep"> | string
    name?: StringFilter<"WorkflowStep"> | string
    description?: StringNullableFilter<"WorkflowStep"> | string | null
    stepType?: EnumWorkflowStepTypeFilter<"WorkflowStep"> | $Enums.WorkflowStepType
    position?: IntFilter<"WorkflowStep"> | number
    configuration?: JsonFilter<"WorkflowStep">
    conditions?: JsonNullableFilter<"WorkflowStep">
    isRequired?: BoolFilter<"WorkflowStep"> | boolean
    timeoutMinutes?: IntNullableFilter<"WorkflowStep"> | number | null
    createdAt?: DateTimeFilter<"WorkflowStep"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowStep"> | Date | string
  }

  export type WorkflowInstanceUpsertWithWhereUniqueWithoutWorkflowInput = {
    where: WorkflowInstanceWhereUniqueInput
    update: XOR<WorkflowInstanceUpdateWithoutWorkflowInput, WorkflowInstanceUncheckedUpdateWithoutWorkflowInput>
    create: XOR<WorkflowInstanceCreateWithoutWorkflowInput, WorkflowInstanceUncheckedCreateWithoutWorkflowInput>
  }

  export type WorkflowInstanceUpdateWithWhereUniqueWithoutWorkflowInput = {
    where: WorkflowInstanceWhereUniqueInput
    data: XOR<WorkflowInstanceUpdateWithoutWorkflowInput, WorkflowInstanceUncheckedUpdateWithoutWorkflowInput>
  }

  export type WorkflowInstanceUpdateManyWithWhereWithoutWorkflowInput = {
    where: WorkflowInstanceScalarWhereInput
    data: XOR<WorkflowInstanceUpdateManyMutationInput, WorkflowInstanceUncheckedUpdateManyWithoutWorkflowInput>
  }

  export type WorkflowTemplateUpsertWithWhereUniqueWithoutWorkflowInput = {
    where: WorkflowTemplateWhereUniqueInput
    update: XOR<WorkflowTemplateUpdateWithoutWorkflowInput, WorkflowTemplateUncheckedUpdateWithoutWorkflowInput>
    create: XOR<WorkflowTemplateCreateWithoutWorkflowInput, WorkflowTemplateUncheckedCreateWithoutWorkflowInput>
  }

  export type WorkflowTemplateUpdateWithWhereUniqueWithoutWorkflowInput = {
    where: WorkflowTemplateWhereUniqueInput
    data: XOR<WorkflowTemplateUpdateWithoutWorkflowInput, WorkflowTemplateUncheckedUpdateWithoutWorkflowInput>
  }

  export type WorkflowTemplateUpdateManyWithWhereWithoutWorkflowInput = {
    where: WorkflowTemplateScalarWhereInput
    data: XOR<WorkflowTemplateUpdateManyMutationInput, WorkflowTemplateUncheckedUpdateManyWithoutWorkflowInput>
  }

  export type WorkflowDefinitionCreateWithoutStepsInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    triggerType: $Enums.WorkflowTriggerType
    triggerConditions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutWorkflowsInput
    createdBy: UserCreateNestedOneWithoutCreatedWorkflowsInput
    instances?: WorkflowInstanceCreateNestedManyWithoutWorkflowInput
    templates?: WorkflowTemplateCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowDefinitionUncheckedCreateWithoutStepsInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    triggerType: $Enums.WorkflowTriggerType
    triggerConditions: JsonNullValueInput | InputJsonValue
    accountId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    instances?: WorkflowInstanceUncheckedCreateNestedManyWithoutWorkflowInput
    templates?: WorkflowTemplateUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowDefinitionCreateOrConnectWithoutStepsInput = {
    where: WorkflowDefinitionWhereUniqueInput
    create: XOR<WorkflowDefinitionCreateWithoutStepsInput, WorkflowDefinitionUncheckedCreateWithoutStepsInput>
  }

  export type WorkflowStepExecutionCreateWithoutStepInput = {
    id?: string
    status: $Enums.WorkflowStepStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    retryCount?: number
    isManual?: boolean
    instance: WorkflowInstanceCreateNestedOneWithoutExecutionsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedStepsInput
  }

  export type WorkflowStepExecutionUncheckedCreateWithoutStepInput = {
    id?: string
    instanceId: string
    status: $Enums.WorkflowStepStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    assignedToId?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    retryCount?: number
    isManual?: boolean
  }

  export type WorkflowStepExecutionCreateOrConnectWithoutStepInput = {
    where: WorkflowStepExecutionWhereUniqueInput
    create: XOR<WorkflowStepExecutionCreateWithoutStepInput, WorkflowStepExecutionUncheckedCreateWithoutStepInput>
  }

  export type WorkflowStepExecutionCreateManyStepInputEnvelope = {
    data: WorkflowStepExecutionCreateManyStepInput | WorkflowStepExecutionCreateManyStepInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowStepApproverCreateWithoutStepInput = {
    id?: string
    approverType: $Enums.ApproverType
    isRequired?: boolean
    order?: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutApproverStepsInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutStepApproverInput
  }

  export type WorkflowStepApproverUncheckedCreateWithoutStepInput = {
    id?: string
    userId: string
    approverType: $Enums.ApproverType
    isRequired?: boolean
    order?: number
    createdAt?: Date | string
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutStepApproverInput
  }

  export type WorkflowStepApproverCreateOrConnectWithoutStepInput = {
    where: WorkflowStepApproverWhereUniqueInput
    create: XOR<WorkflowStepApproverCreateWithoutStepInput, WorkflowStepApproverUncheckedCreateWithoutStepInput>
  }

  export type WorkflowStepApproverCreateManyStepInputEnvelope = {
    data: WorkflowStepApproverCreateManyStepInput | WorkflowStepApproverCreateManyStepInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowDefinitionUpsertWithoutStepsInput = {
    update: XOR<WorkflowDefinitionUpdateWithoutStepsInput, WorkflowDefinitionUncheckedUpdateWithoutStepsInput>
    create: XOR<WorkflowDefinitionCreateWithoutStepsInput, WorkflowDefinitionUncheckedCreateWithoutStepsInput>
    where?: WorkflowDefinitionWhereInput
  }

  export type WorkflowDefinitionUpdateToOneWithWhereWithoutStepsInput = {
    where?: WorkflowDefinitionWhereInput
    data: XOR<WorkflowDefinitionUpdateWithoutStepsInput, WorkflowDefinitionUncheckedUpdateWithoutStepsInput>
  }

  export type WorkflowDefinitionUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    triggerType?: EnumWorkflowTriggerTypeFieldUpdateOperationsInput | $Enums.WorkflowTriggerType
    triggerConditions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutWorkflowsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedWorkflowsNestedInput
    instances?: WorkflowInstanceUpdateManyWithoutWorkflowNestedInput
    templates?: WorkflowTemplateUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowDefinitionUncheckedUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    triggerType?: EnumWorkflowTriggerTypeFieldUpdateOperationsInput | $Enums.WorkflowTriggerType
    triggerConditions?: JsonNullValueInput | InputJsonValue
    accountId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instances?: WorkflowInstanceUncheckedUpdateManyWithoutWorkflowNestedInput
    templates?: WorkflowTemplateUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowStepExecutionUpsertWithWhereUniqueWithoutStepInput = {
    where: WorkflowStepExecutionWhereUniqueInput
    update: XOR<WorkflowStepExecutionUpdateWithoutStepInput, WorkflowStepExecutionUncheckedUpdateWithoutStepInput>
    create: XOR<WorkflowStepExecutionCreateWithoutStepInput, WorkflowStepExecutionUncheckedCreateWithoutStepInput>
  }

  export type WorkflowStepExecutionUpdateWithWhereUniqueWithoutStepInput = {
    where: WorkflowStepExecutionWhereUniqueInput
    data: XOR<WorkflowStepExecutionUpdateWithoutStepInput, WorkflowStepExecutionUncheckedUpdateWithoutStepInput>
  }

  export type WorkflowStepExecutionUpdateManyWithWhereWithoutStepInput = {
    where: WorkflowStepExecutionScalarWhereInput
    data: XOR<WorkflowStepExecutionUpdateManyMutationInput, WorkflowStepExecutionUncheckedUpdateManyWithoutStepInput>
  }

  export type WorkflowStepApproverUpsertWithWhereUniqueWithoutStepInput = {
    where: WorkflowStepApproverWhereUniqueInput
    update: XOR<WorkflowStepApproverUpdateWithoutStepInput, WorkflowStepApproverUncheckedUpdateWithoutStepInput>
    create: XOR<WorkflowStepApproverCreateWithoutStepInput, WorkflowStepApproverUncheckedCreateWithoutStepInput>
  }

  export type WorkflowStepApproverUpdateWithWhereUniqueWithoutStepInput = {
    where: WorkflowStepApproverWhereUniqueInput
    data: XOR<WorkflowStepApproverUpdateWithoutStepInput, WorkflowStepApproverUncheckedUpdateWithoutStepInput>
  }

  export type WorkflowStepApproverUpdateManyWithWhereWithoutStepInput = {
    where: WorkflowStepApproverScalarWhereInput
    data: XOR<WorkflowStepApproverUpdateManyMutationInput, WorkflowStepApproverUncheckedUpdateManyWithoutStepInput>
  }

  export type WorkflowStepCreateWithoutApproversInput = {
    id?: string
    name: string
    description?: string | null
    stepType: $Enums.WorkflowStepType
    position: number
    configuration: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    timeoutMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workflow: WorkflowDefinitionCreateNestedOneWithoutStepsInput
    executions?: WorkflowStepExecutionCreateNestedManyWithoutStepInput
  }

  export type WorkflowStepUncheckedCreateWithoutApproversInput = {
    id?: string
    workflowId: string
    name: string
    description?: string | null
    stepType: $Enums.WorkflowStepType
    position: number
    configuration: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    timeoutMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutStepInput
  }

  export type WorkflowStepCreateOrConnectWithoutApproversInput = {
    where: WorkflowStepWhereUniqueInput
    create: XOR<WorkflowStepCreateWithoutApproversInput, WorkflowStepUncheckedCreateWithoutApproversInput>
  }

  export type UserCreateWithoutApproverStepsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedAccounts?: AccountCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionCreateNestedManyWithoutAssignedToInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutApproverStepsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownedAccounts?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceUncheckedCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutAssignedToInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanUncheckedCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanUncheckedCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionUncheckedCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectUncheckedCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectUncheckedCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutApproverStepsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApproverStepsInput, UserUncheckedCreateWithoutApproverStepsInput>
  }

  export type WorkflowApprovalCreateWithoutStepApproverInput = {
    id?: string
    status: $Enums.ApprovalStatus
    comments?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestedAt?: Date | string
    remindersSent?: number
    lastReminderAt?: Date | string | null
    instance: WorkflowInstanceCreateNestedOneWithoutApprovalsInput
    approver: UserCreateNestedOneWithoutApprovalsInput
  }

  export type WorkflowApprovalUncheckedCreateWithoutStepApproverInput = {
    id?: string
    instanceId: string
    approverId: string
    status: $Enums.ApprovalStatus
    comments?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestedAt?: Date | string
    remindersSent?: number
    lastReminderAt?: Date | string | null
  }

  export type WorkflowApprovalCreateOrConnectWithoutStepApproverInput = {
    where: WorkflowApprovalWhereUniqueInput
    create: XOR<WorkflowApprovalCreateWithoutStepApproverInput, WorkflowApprovalUncheckedCreateWithoutStepApproverInput>
  }

  export type WorkflowApprovalCreateManyStepApproverInputEnvelope = {
    data: WorkflowApprovalCreateManyStepApproverInput | WorkflowApprovalCreateManyStepApproverInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowStepUpsertWithoutApproversInput = {
    update: XOR<WorkflowStepUpdateWithoutApproversInput, WorkflowStepUncheckedUpdateWithoutApproversInput>
    create: XOR<WorkflowStepCreateWithoutApproversInput, WorkflowStepUncheckedCreateWithoutApproversInput>
    where?: WorkflowStepWhereInput
  }

  export type WorkflowStepUpdateToOneWithWhereWithoutApproversInput = {
    where?: WorkflowStepWhereInput
    data: XOR<WorkflowStepUpdateWithoutApproversInput, WorkflowStepUncheckedUpdateWithoutApproversInput>
  }

  export type WorkflowStepUpdateWithoutApproversInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    position?: IntFieldUpdateOperationsInput | number
    configuration?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    timeoutMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflow?: WorkflowDefinitionUpdateOneRequiredWithoutStepsNestedInput
    executions?: WorkflowStepExecutionUpdateManyWithoutStepNestedInput
  }

  export type WorkflowStepUncheckedUpdateWithoutApproversInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    position?: IntFieldUpdateOperationsInput | number
    configuration?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    timeoutMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: WorkflowStepExecutionUncheckedUpdateManyWithoutStepNestedInput
  }

  export type UserUpsertWithoutApproverStepsInput = {
    update: XOR<UserUpdateWithoutApproverStepsInput, UserUncheckedUpdateWithoutApproverStepsInput>
    create: XOR<UserCreateWithoutApproverStepsInput, UserUncheckedCreateWithoutApproverStepsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApproverStepsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApproverStepsInput, UserUncheckedUpdateWithoutApproverStepsInput>
  }

  export type UserUpdateWithoutApproverStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedAccounts?: AccountUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUpdateManyWithoutAssignedToNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutApproverStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedAccounts?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUncheckedUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUncheckedUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUncheckedUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUncheckedUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type WorkflowApprovalUpsertWithWhereUniqueWithoutStepApproverInput = {
    where: WorkflowApprovalWhereUniqueInput
    update: XOR<WorkflowApprovalUpdateWithoutStepApproverInput, WorkflowApprovalUncheckedUpdateWithoutStepApproverInput>
    create: XOR<WorkflowApprovalCreateWithoutStepApproverInput, WorkflowApprovalUncheckedCreateWithoutStepApproverInput>
  }

  export type WorkflowApprovalUpdateWithWhereUniqueWithoutStepApproverInput = {
    where: WorkflowApprovalWhereUniqueInput
    data: XOR<WorkflowApprovalUpdateWithoutStepApproverInput, WorkflowApprovalUncheckedUpdateWithoutStepApproverInput>
  }

  export type WorkflowApprovalUpdateManyWithWhereWithoutStepApproverInput = {
    where: WorkflowApprovalScalarWhereInput
    data: XOR<WorkflowApprovalUpdateManyMutationInput, WorkflowApprovalUncheckedUpdateManyWithoutStepApproverInput>
  }

  export type WorkflowDefinitionCreateWithoutInstancesInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    triggerType: $Enums.WorkflowTriggerType
    triggerConditions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutWorkflowsInput
    createdBy: UserCreateNestedOneWithoutCreatedWorkflowsInput
    steps?: WorkflowStepCreateNestedManyWithoutWorkflowInput
    templates?: WorkflowTemplateCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowDefinitionUncheckedCreateWithoutInstancesInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    triggerType: $Enums.WorkflowTriggerType
    triggerConditions: JsonNullValueInput | InputJsonValue
    accountId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: WorkflowStepUncheckedCreateNestedManyWithoutWorkflowInput
    templates?: WorkflowTemplateUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowDefinitionCreateOrConnectWithoutInstancesInput = {
    where: WorkflowDefinitionWhereUniqueInput
    create: XOR<WorkflowDefinitionCreateWithoutInstancesInput, WorkflowDefinitionUncheckedCreateWithoutInstancesInput>
  }

  export type AccountCreateWithoutWorkflowInstancesInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    owner: UserCreateNestedOneWithoutOwnedAccountsInput
    activities?: ActivityCreateNestedManyWithoutAccountInput
    appointments?: AppointmentCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectCreateNestedManyWithoutAccountInput
    contacts?: ContactCreateNestedManyWithoutAccountInput
    documents?: DocumentCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryCreateNestedManyWithoutAccountInput
    events?: EventLogCreateNestedManyWithoutAccountInput
    leads?: LeadCreateNestedManyWithoutAccountInput
    projects?: ProjectCreateNestedManyWithoutAccountInput
    snags?: SnagCreateNestedManyWithoutAccountInput
    tasks?: TaskCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutWorkflowInstancesInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutAccountInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAccountInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutAccountInput
    events?: EventLogUncheckedCreateNestedManyWithoutAccountInput
    leads?: LeadUncheckedCreateNestedManyWithoutAccountInput
    projects?: ProjectUncheckedCreateNestedManyWithoutAccountInput
    snags?: SnagUncheckedCreateNestedManyWithoutAccountInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutWorkflowInstancesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutWorkflowInstancesInput, AccountUncheckedCreateWithoutWorkflowInstancesInput>
  }

  export type UserCreateWithoutInitiatedWorkflowsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedAccounts?: AccountCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionCreateNestedManyWithoutCreatedByInput
    assignedSteps?: WorkflowStepExecutionCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutInitiatedWorkflowsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownedAccounts?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    assignedSteps?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverUncheckedCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanUncheckedCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanUncheckedCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionUncheckedCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectUncheckedCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectUncheckedCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutInitiatedWorkflowsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInitiatedWorkflowsInput, UserUncheckedCreateWithoutInitiatedWorkflowsInput>
  }

  export type WorkflowStepExecutionCreateWithoutInstanceInput = {
    id?: string
    status: $Enums.WorkflowStepStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    retryCount?: number
    isManual?: boolean
    step: WorkflowStepCreateNestedOneWithoutExecutionsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedStepsInput
  }

  export type WorkflowStepExecutionUncheckedCreateWithoutInstanceInput = {
    id?: string
    stepId: string
    status: $Enums.WorkflowStepStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    assignedToId?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    retryCount?: number
    isManual?: boolean
  }

  export type WorkflowStepExecutionCreateOrConnectWithoutInstanceInput = {
    where: WorkflowStepExecutionWhereUniqueInput
    create: XOR<WorkflowStepExecutionCreateWithoutInstanceInput, WorkflowStepExecutionUncheckedCreateWithoutInstanceInput>
  }

  export type WorkflowStepExecutionCreateManyInstanceInputEnvelope = {
    data: WorkflowStepExecutionCreateManyInstanceInput | WorkflowStepExecutionCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowApprovalCreateWithoutInstanceInput = {
    id?: string
    status: $Enums.ApprovalStatus
    comments?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestedAt?: Date | string
    remindersSent?: number
    lastReminderAt?: Date | string | null
    approver: UserCreateNestedOneWithoutApprovalsInput
    stepApprover: WorkflowStepApproverCreateNestedOneWithoutApprovalsInput
  }

  export type WorkflowApprovalUncheckedCreateWithoutInstanceInput = {
    id?: string
    approverId: string
    stepApproverId: string
    status: $Enums.ApprovalStatus
    comments?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestedAt?: Date | string
    remindersSent?: number
    lastReminderAt?: Date | string | null
  }

  export type WorkflowApprovalCreateOrConnectWithoutInstanceInput = {
    where: WorkflowApprovalWhereUniqueInput
    create: XOR<WorkflowApprovalCreateWithoutInstanceInput, WorkflowApprovalUncheckedCreateWithoutInstanceInput>
  }

  export type WorkflowApprovalCreateManyInstanceInputEnvelope = {
    data: WorkflowApprovalCreateManyInstanceInput | WorkflowApprovalCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowDefinitionUpsertWithoutInstancesInput = {
    update: XOR<WorkflowDefinitionUpdateWithoutInstancesInput, WorkflowDefinitionUncheckedUpdateWithoutInstancesInput>
    create: XOR<WorkflowDefinitionCreateWithoutInstancesInput, WorkflowDefinitionUncheckedCreateWithoutInstancesInput>
    where?: WorkflowDefinitionWhereInput
  }

  export type WorkflowDefinitionUpdateToOneWithWhereWithoutInstancesInput = {
    where?: WorkflowDefinitionWhereInput
    data: XOR<WorkflowDefinitionUpdateWithoutInstancesInput, WorkflowDefinitionUncheckedUpdateWithoutInstancesInput>
  }

  export type WorkflowDefinitionUpdateWithoutInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    triggerType?: EnumWorkflowTriggerTypeFieldUpdateOperationsInput | $Enums.WorkflowTriggerType
    triggerConditions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutWorkflowsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedWorkflowsNestedInput
    steps?: WorkflowStepUpdateManyWithoutWorkflowNestedInput
    templates?: WorkflowTemplateUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowDefinitionUncheckedUpdateWithoutInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    triggerType?: EnumWorkflowTriggerTypeFieldUpdateOperationsInput | $Enums.WorkflowTriggerType
    triggerConditions?: JsonNullValueInput | InputJsonValue
    accountId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: WorkflowStepUncheckedUpdateManyWithoutWorkflowNestedInput
    templates?: WorkflowTemplateUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type AccountUpsertWithoutWorkflowInstancesInput = {
    update: XOR<AccountUpdateWithoutWorkflowInstancesInput, AccountUncheckedUpdateWithoutWorkflowInstancesInput>
    create: XOR<AccountCreateWithoutWorkflowInstancesInput, AccountUncheckedCreateWithoutWorkflowInstancesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutWorkflowInstancesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutWorkflowInstancesInput, AccountUncheckedUpdateWithoutWorkflowInstancesInput>
  }

  export type AccountUpdateWithoutWorkflowInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: UserUpdateOneRequiredWithoutOwnedAccountsNestedInput
    activities?: ActivityUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUpdateManyWithoutAccountNestedInput
    contacts?: ContactUpdateManyWithoutAccountNestedInput
    documents?: DocumentUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUpdateManyWithoutAccountNestedInput
    events?: EventLogUpdateManyWithoutAccountNestedInput
    leads?: LeadUpdateManyWithoutAccountNestedInput
    projects?: ProjectUpdateManyWithoutAccountNestedInput
    snags?: SnagUpdateManyWithoutAccountNestedInput
    tasks?: TaskUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutWorkflowInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUncheckedUpdateManyWithoutAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAccountNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutAccountNestedInput
    events?: EventLogUncheckedUpdateManyWithoutAccountNestedInput
    leads?: LeadUncheckedUpdateManyWithoutAccountNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutAccountNestedInput
    snags?: SnagUncheckedUpdateManyWithoutAccountNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUncheckedUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type UserUpsertWithoutInitiatedWorkflowsInput = {
    update: XOR<UserUpdateWithoutInitiatedWorkflowsInput, UserUncheckedUpdateWithoutInitiatedWorkflowsInput>
    create: XOR<UserCreateWithoutInitiatedWorkflowsInput, UserUncheckedCreateWithoutInitiatedWorkflowsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInitiatedWorkflowsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInitiatedWorkflowsInput, UserUncheckedUpdateWithoutInitiatedWorkflowsInput>
  }

  export type UserUpdateWithoutInitiatedWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedAccounts?: AccountUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUpdateManyWithoutCreatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutInitiatedWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedAccounts?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUncheckedUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUncheckedUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUncheckedUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUncheckedUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUncheckedUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type WorkflowStepExecutionUpsertWithWhereUniqueWithoutInstanceInput = {
    where: WorkflowStepExecutionWhereUniqueInput
    update: XOR<WorkflowStepExecutionUpdateWithoutInstanceInput, WorkflowStepExecutionUncheckedUpdateWithoutInstanceInput>
    create: XOR<WorkflowStepExecutionCreateWithoutInstanceInput, WorkflowStepExecutionUncheckedCreateWithoutInstanceInput>
  }

  export type WorkflowStepExecutionUpdateWithWhereUniqueWithoutInstanceInput = {
    where: WorkflowStepExecutionWhereUniqueInput
    data: XOR<WorkflowStepExecutionUpdateWithoutInstanceInput, WorkflowStepExecutionUncheckedUpdateWithoutInstanceInput>
  }

  export type WorkflowStepExecutionUpdateManyWithWhereWithoutInstanceInput = {
    where: WorkflowStepExecutionScalarWhereInput
    data: XOR<WorkflowStepExecutionUpdateManyMutationInput, WorkflowStepExecutionUncheckedUpdateManyWithoutInstanceInput>
  }

  export type WorkflowApprovalUpsertWithWhereUniqueWithoutInstanceInput = {
    where: WorkflowApprovalWhereUniqueInput
    update: XOR<WorkflowApprovalUpdateWithoutInstanceInput, WorkflowApprovalUncheckedUpdateWithoutInstanceInput>
    create: XOR<WorkflowApprovalCreateWithoutInstanceInput, WorkflowApprovalUncheckedCreateWithoutInstanceInput>
  }

  export type WorkflowApprovalUpdateWithWhereUniqueWithoutInstanceInput = {
    where: WorkflowApprovalWhereUniqueInput
    data: XOR<WorkflowApprovalUpdateWithoutInstanceInput, WorkflowApprovalUncheckedUpdateWithoutInstanceInput>
  }

  export type WorkflowApprovalUpdateManyWithWhereWithoutInstanceInput = {
    where: WorkflowApprovalScalarWhereInput
    data: XOR<WorkflowApprovalUpdateManyMutationInput, WorkflowApprovalUncheckedUpdateManyWithoutInstanceInput>
  }

  export type WorkflowInstanceCreateWithoutExecutionsInput = {
    id?: string
    entityType: string
    entityId: string
    status: $Enums.WorkflowStatus
    currentStepId?: string | null
    priority?: $Enums.Priority
    startedAt?: Date | string
    completedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    workflow: WorkflowDefinitionCreateNestedOneWithoutInstancesInput
    account: AccountCreateNestedOneWithoutWorkflowInstancesInput
    initiatedBy: UserCreateNestedOneWithoutInitiatedWorkflowsInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutInstanceInput
  }

  export type WorkflowInstanceUncheckedCreateWithoutExecutionsInput = {
    id?: string
    workflowId: string
    entityType: string
    entityId: string
    status: $Enums.WorkflowStatus
    currentStepId?: string | null
    priority?: $Enums.Priority
    startedAt?: Date | string
    completedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId: string
    initiatedById: string
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type WorkflowInstanceCreateOrConnectWithoutExecutionsInput = {
    where: WorkflowInstanceWhereUniqueInput
    create: XOR<WorkflowInstanceCreateWithoutExecutionsInput, WorkflowInstanceUncheckedCreateWithoutExecutionsInput>
  }

  export type WorkflowStepCreateWithoutExecutionsInput = {
    id?: string
    name: string
    description?: string | null
    stepType: $Enums.WorkflowStepType
    position: number
    configuration: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    timeoutMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workflow: WorkflowDefinitionCreateNestedOneWithoutStepsInput
    approvers?: WorkflowStepApproverCreateNestedManyWithoutStepInput
  }

  export type WorkflowStepUncheckedCreateWithoutExecutionsInput = {
    id?: string
    workflowId: string
    name: string
    description?: string | null
    stepType: $Enums.WorkflowStepType
    position: number
    configuration: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    timeoutMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvers?: WorkflowStepApproverUncheckedCreateNestedManyWithoutStepInput
  }

  export type WorkflowStepCreateOrConnectWithoutExecutionsInput = {
    where: WorkflowStepWhereUniqueInput
    create: XOR<WorkflowStepCreateWithoutExecutionsInput, WorkflowStepUncheckedCreateWithoutExecutionsInput>
  }

  export type UserCreateWithoutAssignedStepsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedAccounts?: AccountCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceCreateNestedManyWithoutInitiatedByInput
    approverSteps?: WorkflowStepApproverCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutAssignedStepsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownedAccounts?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceUncheckedCreateNestedManyWithoutInitiatedByInput
    approverSteps?: WorkflowStepApproverUncheckedCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanUncheckedCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanUncheckedCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionUncheckedCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectUncheckedCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectUncheckedCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutAssignedStepsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedStepsInput, UserUncheckedCreateWithoutAssignedStepsInput>
  }

  export type WorkflowInstanceUpsertWithoutExecutionsInput = {
    update: XOR<WorkflowInstanceUpdateWithoutExecutionsInput, WorkflowInstanceUncheckedUpdateWithoutExecutionsInput>
    create: XOR<WorkflowInstanceCreateWithoutExecutionsInput, WorkflowInstanceUncheckedCreateWithoutExecutionsInput>
    where?: WorkflowInstanceWhereInput
  }

  export type WorkflowInstanceUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: WorkflowInstanceWhereInput
    data: XOR<WorkflowInstanceUpdateWithoutExecutionsInput, WorkflowInstanceUncheckedUpdateWithoutExecutionsInput>
  }

  export type WorkflowInstanceUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    workflow?: WorkflowDefinitionUpdateOneRequiredWithoutInstancesNestedInput
    account?: AccountUpdateOneRequiredWithoutWorkflowInstancesNestedInput
    initiatedBy?: UserUpdateOneRequiredWithoutInitiatedWorkflowsNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutInstanceNestedInput
  }

  export type WorkflowInstanceUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId?: StringFieldUpdateOperationsInput | string
    initiatedById?: StringFieldUpdateOperationsInput | string
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type WorkflowStepUpsertWithoutExecutionsInput = {
    update: XOR<WorkflowStepUpdateWithoutExecutionsInput, WorkflowStepUncheckedUpdateWithoutExecutionsInput>
    create: XOR<WorkflowStepCreateWithoutExecutionsInput, WorkflowStepUncheckedCreateWithoutExecutionsInput>
    where?: WorkflowStepWhereInput
  }

  export type WorkflowStepUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: WorkflowStepWhereInput
    data: XOR<WorkflowStepUpdateWithoutExecutionsInput, WorkflowStepUncheckedUpdateWithoutExecutionsInput>
  }

  export type WorkflowStepUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    position?: IntFieldUpdateOperationsInput | number
    configuration?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    timeoutMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflow?: WorkflowDefinitionUpdateOneRequiredWithoutStepsNestedInput
    approvers?: WorkflowStepApproverUpdateManyWithoutStepNestedInput
  }

  export type WorkflowStepUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    position?: IntFieldUpdateOperationsInput | number
    configuration?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    timeoutMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvers?: WorkflowStepApproverUncheckedUpdateManyWithoutStepNestedInput
  }

  export type UserUpsertWithoutAssignedStepsInput = {
    update: XOR<UserUpdateWithoutAssignedStepsInput, UserUncheckedUpdateWithoutAssignedStepsInput>
    create: XOR<UserCreateWithoutAssignedStepsInput, UserUncheckedCreateWithoutAssignedStepsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedStepsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedStepsInput, UserUncheckedUpdateWithoutAssignedStepsInput>
  }

  export type UserUpdateWithoutAssignedStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedAccounts?: AccountUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUpdateManyWithoutInitiatedByNestedInput
    approverSteps?: WorkflowStepApproverUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedAccounts?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUncheckedUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByNestedInput
    approverSteps?: WorkflowStepApproverUncheckedUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUncheckedUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUncheckedUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUncheckedUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type WorkflowInstanceCreateWithoutApprovalsInput = {
    id?: string
    entityType: string
    entityId: string
    status: $Enums.WorkflowStatus
    currentStepId?: string | null
    priority?: $Enums.Priority
    startedAt?: Date | string
    completedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    workflow: WorkflowDefinitionCreateNestedOneWithoutInstancesInput
    account: AccountCreateNestedOneWithoutWorkflowInstancesInput
    initiatedBy: UserCreateNestedOneWithoutInitiatedWorkflowsInput
    executions?: WorkflowStepExecutionCreateNestedManyWithoutInstanceInput
  }

  export type WorkflowInstanceUncheckedCreateWithoutApprovalsInput = {
    id?: string
    workflowId: string
    entityType: string
    entityId: string
    status: $Enums.WorkflowStatus
    currentStepId?: string | null
    priority?: $Enums.Priority
    startedAt?: Date | string
    completedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId: string
    initiatedById: string
    executions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type WorkflowInstanceCreateOrConnectWithoutApprovalsInput = {
    where: WorkflowInstanceWhereUniqueInput
    create: XOR<WorkflowInstanceCreateWithoutApprovalsInput, WorkflowInstanceUncheckedCreateWithoutApprovalsInput>
  }

  export type UserCreateWithoutApprovalsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedAccounts?: AccountCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverCreateNestedManyWithoutUserInput
    createdTemplates?: WorkflowTemplateCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutApprovalsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownedAccounts?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceUncheckedCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverUncheckedCreateNestedManyWithoutUserInput
    createdTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanUncheckedCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanUncheckedCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionUncheckedCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectUncheckedCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectUncheckedCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutApprovalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovalsInput, UserUncheckedCreateWithoutApprovalsInput>
  }

  export type WorkflowStepApproverCreateWithoutApprovalsInput = {
    id?: string
    approverType: $Enums.ApproverType
    isRequired?: boolean
    order?: number
    createdAt?: Date | string
    step: WorkflowStepCreateNestedOneWithoutApproversInput
    user: UserCreateNestedOneWithoutApproverStepsInput
  }

  export type WorkflowStepApproverUncheckedCreateWithoutApprovalsInput = {
    id?: string
    stepId: string
    userId: string
    approverType: $Enums.ApproverType
    isRequired?: boolean
    order?: number
    createdAt?: Date | string
  }

  export type WorkflowStepApproverCreateOrConnectWithoutApprovalsInput = {
    where: WorkflowStepApproverWhereUniqueInput
    create: XOR<WorkflowStepApproverCreateWithoutApprovalsInput, WorkflowStepApproverUncheckedCreateWithoutApprovalsInput>
  }

  export type WorkflowInstanceUpsertWithoutApprovalsInput = {
    update: XOR<WorkflowInstanceUpdateWithoutApprovalsInput, WorkflowInstanceUncheckedUpdateWithoutApprovalsInput>
    create: XOR<WorkflowInstanceCreateWithoutApprovalsInput, WorkflowInstanceUncheckedCreateWithoutApprovalsInput>
    where?: WorkflowInstanceWhereInput
  }

  export type WorkflowInstanceUpdateToOneWithWhereWithoutApprovalsInput = {
    where?: WorkflowInstanceWhereInput
    data: XOR<WorkflowInstanceUpdateWithoutApprovalsInput, WorkflowInstanceUncheckedUpdateWithoutApprovalsInput>
  }

  export type WorkflowInstanceUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    workflow?: WorkflowDefinitionUpdateOneRequiredWithoutInstancesNestedInput
    account?: AccountUpdateOneRequiredWithoutWorkflowInstancesNestedInput
    initiatedBy?: UserUpdateOneRequiredWithoutInitiatedWorkflowsNestedInput
    executions?: WorkflowStepExecutionUpdateManyWithoutInstanceNestedInput
  }

  export type WorkflowInstanceUncheckedUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId?: StringFieldUpdateOperationsInput | string
    initiatedById?: StringFieldUpdateOperationsInput | string
    executions?: WorkflowStepExecutionUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type UserUpsertWithoutApprovalsInput = {
    update: XOR<UserUpdateWithoutApprovalsInput, UserUncheckedUpdateWithoutApprovalsInput>
    create: XOR<UserCreateWithoutApprovalsInput, UserUncheckedCreateWithoutApprovalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovalsInput, UserUncheckedUpdateWithoutApprovalsInput>
  }

  export type UserUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedAccounts?: AccountUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUpdateManyWithoutUserNestedInput
    createdTemplates?: WorkflowTemplateUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedAccounts?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUncheckedUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUncheckedUpdateManyWithoutUserNestedInput
    createdTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUncheckedUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUncheckedUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUncheckedUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type WorkflowStepApproverUpsertWithoutApprovalsInput = {
    update: XOR<WorkflowStepApproverUpdateWithoutApprovalsInput, WorkflowStepApproverUncheckedUpdateWithoutApprovalsInput>
    create: XOR<WorkflowStepApproverCreateWithoutApprovalsInput, WorkflowStepApproverUncheckedCreateWithoutApprovalsInput>
    where?: WorkflowStepApproverWhereInput
  }

  export type WorkflowStepApproverUpdateToOneWithWhereWithoutApprovalsInput = {
    where?: WorkflowStepApproverWhereInput
    data: XOR<WorkflowStepApproverUpdateWithoutApprovalsInput, WorkflowStepApproverUncheckedUpdateWithoutApprovalsInput>
  }

  export type WorkflowStepApproverUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    approverType?: EnumApproverTypeFieldUpdateOperationsInput | $Enums.ApproverType
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    step?: WorkflowStepUpdateOneRequiredWithoutApproversNestedInput
    user?: UserUpdateOneRequiredWithoutApproverStepsNestedInput
  }

  export type WorkflowStepApproverUncheckedUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    approverType?: EnumApproverTypeFieldUpdateOperationsInput | $Enums.ApproverType
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateWithoutWorkflowTemplatesInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    owner: UserCreateNestedOneWithoutOwnedAccountsInput
    activities?: ActivityCreateNestedManyWithoutAccountInput
    appointments?: AppointmentCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectCreateNestedManyWithoutAccountInput
    contacts?: ContactCreateNestedManyWithoutAccountInput
    documents?: DocumentCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryCreateNestedManyWithoutAccountInput
    events?: EventLogCreateNestedManyWithoutAccountInput
    leads?: LeadCreateNestedManyWithoutAccountInput
    projects?: ProjectCreateNestedManyWithoutAccountInput
    snags?: SnagCreateNestedManyWithoutAccountInput
    tasks?: TaskCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutWorkflowTemplatesInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutAccountInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAccountInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutAccountInput
    events?: EventLogUncheckedCreateNestedManyWithoutAccountInput
    leads?: LeadUncheckedCreateNestedManyWithoutAccountInput
    projects?: ProjectUncheckedCreateNestedManyWithoutAccountInput
    snags?: SnagUncheckedCreateNestedManyWithoutAccountInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutAccountInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutWorkflowTemplatesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutWorkflowTemplatesInput, AccountUncheckedCreateWithoutWorkflowTemplatesInput>
  }

  export type UserCreateWithoutCreatedTemplatesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedAccounts?: AccountCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutApproverInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutCreatedTemplatesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownedAccounts?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceUncheckedCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverUncheckedCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanUncheckedCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanUncheckedCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionUncheckedCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectUncheckedCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectUncheckedCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutCreatedTemplatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTemplatesInput, UserUncheckedCreateWithoutCreatedTemplatesInput>
  }

  export type WorkflowDefinitionCreateWithoutTemplatesInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    triggerType: $Enums.WorkflowTriggerType
    triggerConditions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutWorkflowsInput
    createdBy: UserCreateNestedOneWithoutCreatedWorkflowsInput
    steps?: WorkflowStepCreateNestedManyWithoutWorkflowInput
    instances?: WorkflowInstanceCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowDefinitionUncheckedCreateWithoutTemplatesInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    triggerType: $Enums.WorkflowTriggerType
    triggerConditions: JsonNullValueInput | InputJsonValue
    accountId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: WorkflowStepUncheckedCreateNestedManyWithoutWorkflowInput
    instances?: WorkflowInstanceUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowDefinitionCreateOrConnectWithoutTemplatesInput = {
    where: WorkflowDefinitionWhereUniqueInput
    create: XOR<WorkflowDefinitionCreateWithoutTemplatesInput, WorkflowDefinitionUncheckedCreateWithoutTemplatesInput>
  }

  export type AccountUpsertWithoutWorkflowTemplatesInput = {
    update: XOR<AccountUpdateWithoutWorkflowTemplatesInput, AccountUncheckedUpdateWithoutWorkflowTemplatesInput>
    create: XOR<AccountCreateWithoutWorkflowTemplatesInput, AccountUncheckedCreateWithoutWorkflowTemplatesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutWorkflowTemplatesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutWorkflowTemplatesInput, AccountUncheckedUpdateWithoutWorkflowTemplatesInput>
  }

  export type AccountUpdateWithoutWorkflowTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: UserUpdateOneRequiredWithoutOwnedAccountsNestedInput
    activities?: ActivityUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUpdateManyWithoutAccountNestedInput
    contacts?: ContactUpdateManyWithoutAccountNestedInput
    documents?: DocumentUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUpdateManyWithoutAccountNestedInput
    events?: EventLogUpdateManyWithoutAccountNestedInput
    leads?: LeadUpdateManyWithoutAccountNestedInput
    projects?: ProjectUpdateManyWithoutAccountNestedInput
    snags?: SnagUpdateManyWithoutAccountNestedInput
    tasks?: TaskUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutWorkflowTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUncheckedUpdateManyWithoutAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAccountNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutAccountNestedInput
    events?: EventLogUncheckedUpdateManyWithoutAccountNestedInput
    leads?: LeadUncheckedUpdateManyWithoutAccountNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutAccountNestedInput
    snags?: SnagUncheckedUpdateManyWithoutAccountNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUncheckedUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type UserUpsertWithoutCreatedTemplatesInput = {
    update: XOR<UserUpdateWithoutCreatedTemplatesInput, UserUncheckedUpdateWithoutCreatedTemplatesInput>
    create: XOR<UserCreateWithoutCreatedTemplatesInput, UserUncheckedCreateWithoutCreatedTemplatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedTemplatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedTemplatesInput, UserUncheckedUpdateWithoutCreatedTemplatesInput>
  }

  export type UserUpdateWithoutCreatedTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedAccounts?: AccountUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutApproverNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedAccounts?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUncheckedUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUncheckedUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUncheckedUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUncheckedUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUncheckedUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type WorkflowDefinitionUpsertWithoutTemplatesInput = {
    update: XOR<WorkflowDefinitionUpdateWithoutTemplatesInput, WorkflowDefinitionUncheckedUpdateWithoutTemplatesInput>
    create: XOR<WorkflowDefinitionCreateWithoutTemplatesInput, WorkflowDefinitionUncheckedCreateWithoutTemplatesInput>
    where?: WorkflowDefinitionWhereInput
  }

  export type WorkflowDefinitionUpdateToOneWithWhereWithoutTemplatesInput = {
    where?: WorkflowDefinitionWhereInput
    data: XOR<WorkflowDefinitionUpdateWithoutTemplatesInput, WorkflowDefinitionUncheckedUpdateWithoutTemplatesInput>
  }

  export type WorkflowDefinitionUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    triggerType?: EnumWorkflowTriggerTypeFieldUpdateOperationsInput | $Enums.WorkflowTriggerType
    triggerConditions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutWorkflowsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedWorkflowsNestedInput
    steps?: WorkflowStepUpdateManyWithoutWorkflowNestedInput
    instances?: WorkflowInstanceUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowDefinitionUncheckedUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    triggerType?: EnumWorkflowTriggerTypeFieldUpdateOperationsInput | $Enums.WorkflowTriggerType
    triggerConditions?: JsonNullValueInput | InputJsonValue
    accountId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: WorkflowStepUncheckedUpdateManyWithoutWorkflowNestedInput
    instances?: WorkflowInstanceUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type AccountCreateWithoutAutomationRulesInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    owner: UserCreateNestedOneWithoutOwnedAccountsInput
    activities?: ActivityCreateNestedManyWithoutAccountInput
    appointments?: AppointmentCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectCreateNestedManyWithoutAccountInput
    contacts?: ContactCreateNestedManyWithoutAccountInput
    documents?: DocumentCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryCreateNestedManyWithoutAccountInput
    events?: EventLogCreateNestedManyWithoutAccountInput
    leads?: LeadCreateNestedManyWithoutAccountInput
    projects?: ProjectCreateNestedManyWithoutAccountInput
    snags?: SnagCreateNestedManyWithoutAccountInput
    tasks?: TaskCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutAutomationRulesInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutAccountInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAccountInput
    completedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAccountInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAccountInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutAccountInput
    events?: EventLogUncheckedCreateNestedManyWithoutAccountInput
    leads?: LeadUncheckedCreateNestedManyWithoutAccountInput
    projects?: ProjectUncheckedCreateNestedManyWithoutAccountInput
    snags?: SnagUncheckedCreateNestedManyWithoutAccountInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAccountInput
    workflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutAccountInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutAccountInput
    workflowTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutAutomationRulesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutAutomationRulesInput, AccountUncheckedCreateWithoutAutomationRulesInput>
  }

  export type UserCreateWithoutCreatedRulesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedAccounts?: AccountCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutCreatedRulesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownedAccounts?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceUncheckedCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverUncheckedCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanUncheckedCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanUncheckedCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionUncheckedCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectUncheckedCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectUncheckedCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutCreatedRulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedRulesInput, UserUncheckedCreateWithoutCreatedRulesInput>
  }

  export type AutomationExecutionCreateWithoutRuleInput = {
    id?: string
    triggerData: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.AutomationStatus
    errorMessage?: string | null
    executedAt?: Date | string
    durationMs?: number | null
  }

  export type AutomationExecutionUncheckedCreateWithoutRuleInput = {
    id?: string
    triggerData: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.AutomationStatus
    errorMessage?: string | null
    executedAt?: Date | string
    durationMs?: number | null
  }

  export type AutomationExecutionCreateOrConnectWithoutRuleInput = {
    where: AutomationExecutionWhereUniqueInput
    create: XOR<AutomationExecutionCreateWithoutRuleInput, AutomationExecutionUncheckedCreateWithoutRuleInput>
  }

  export type AutomationExecutionCreateManyRuleInputEnvelope = {
    data: AutomationExecutionCreateManyRuleInput | AutomationExecutionCreateManyRuleInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutAutomationRulesInput = {
    update: XOR<AccountUpdateWithoutAutomationRulesInput, AccountUncheckedUpdateWithoutAutomationRulesInput>
    create: XOR<AccountCreateWithoutAutomationRulesInput, AccountUncheckedCreateWithoutAutomationRulesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutAutomationRulesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutAutomationRulesInput, AccountUncheckedUpdateWithoutAutomationRulesInput>
  }

  export type AccountUpdateWithoutAutomationRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: UserUpdateOneRequiredWithoutOwnedAccountsNestedInput
    activities?: ActivityUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUpdateManyWithoutAccountNestedInput
    contacts?: ContactUpdateManyWithoutAccountNestedInput
    documents?: DocumentUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUpdateManyWithoutAccountNestedInput
    events?: EventLogUpdateManyWithoutAccountNestedInput
    leads?: LeadUpdateManyWithoutAccountNestedInput
    projects?: ProjectUpdateManyWithoutAccountNestedInput
    snags?: SnagUpdateManyWithoutAccountNestedInput
    tasks?: TaskUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutAutomationRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUncheckedUpdateManyWithoutAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAccountNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutAccountNestedInput
    events?: EventLogUncheckedUpdateManyWithoutAccountNestedInput
    leads?: LeadUncheckedUpdateManyWithoutAccountNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutAccountNestedInput
    snags?: SnagUncheckedUpdateManyWithoutAccountNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUncheckedUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type UserUpsertWithoutCreatedRulesInput = {
    update: XOR<UserUpdateWithoutCreatedRulesInput, UserUncheckedUpdateWithoutCreatedRulesInput>
    create: XOR<UserCreateWithoutCreatedRulesInput, UserUncheckedCreateWithoutCreatedRulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedRulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedRulesInput, UserUncheckedUpdateWithoutCreatedRulesInput>
  }

  export type UserUpdateWithoutCreatedRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedAccounts?: AccountUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedAccounts?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUncheckedUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUncheckedUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUncheckedUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUncheckedUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUncheckedUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type AutomationExecutionUpsertWithWhereUniqueWithoutRuleInput = {
    where: AutomationExecutionWhereUniqueInput
    update: XOR<AutomationExecutionUpdateWithoutRuleInput, AutomationExecutionUncheckedUpdateWithoutRuleInput>
    create: XOR<AutomationExecutionCreateWithoutRuleInput, AutomationExecutionUncheckedCreateWithoutRuleInput>
  }

  export type AutomationExecutionUpdateWithWhereUniqueWithoutRuleInput = {
    where: AutomationExecutionWhereUniqueInput
    data: XOR<AutomationExecutionUpdateWithoutRuleInput, AutomationExecutionUncheckedUpdateWithoutRuleInput>
  }

  export type AutomationExecutionUpdateManyWithWhereWithoutRuleInput = {
    where: AutomationExecutionScalarWhereInput
    data: XOR<AutomationExecutionUpdateManyMutationInput, AutomationExecutionUncheckedUpdateManyWithoutRuleInput>
  }

  export type AutomationExecutionScalarWhereInput = {
    AND?: AutomationExecutionScalarWhereInput | AutomationExecutionScalarWhereInput[]
    OR?: AutomationExecutionScalarWhereInput[]
    NOT?: AutomationExecutionScalarWhereInput | AutomationExecutionScalarWhereInput[]
    id?: StringFilter<"AutomationExecution"> | string
    ruleId?: StringFilter<"AutomationExecution"> | string
    triggerData?: JsonFilter<"AutomationExecution">
    result?: JsonNullableFilter<"AutomationExecution">
    status?: EnumAutomationStatusFilter<"AutomationExecution"> | $Enums.AutomationStatus
    errorMessage?: StringNullableFilter<"AutomationExecution"> | string | null
    executedAt?: DateTimeFilter<"AutomationExecution"> | Date | string
    durationMs?: IntNullableFilter<"AutomationExecution"> | number | null
  }

  export type AutomationRuleCreateWithoutExecutionsInput = {
    id?: string
    name: string
    description?: string | null
    triggerEvent: string
    conditions: JsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    priority?: number
    executionCount?: number
    lastExecutedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutAutomationRulesInput
    createdBy: UserCreateNestedOneWithoutCreatedRulesInput
  }

  export type AutomationRuleUncheckedCreateWithoutExecutionsInput = {
    id?: string
    name: string
    description?: string | null
    triggerEvent: string
    conditions: JsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    priority?: number
    executionCount?: number
    lastExecutedAt?: Date | string | null
    accountId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationRuleCreateOrConnectWithoutExecutionsInput = {
    where: AutomationRuleWhereUniqueInput
    create: XOR<AutomationRuleCreateWithoutExecutionsInput, AutomationRuleUncheckedCreateWithoutExecutionsInput>
  }

  export type AutomationRuleUpsertWithoutExecutionsInput = {
    update: XOR<AutomationRuleUpdateWithoutExecutionsInput, AutomationRuleUncheckedUpdateWithoutExecutionsInput>
    create: XOR<AutomationRuleCreateWithoutExecutionsInput, AutomationRuleUncheckedCreateWithoutExecutionsInput>
    where?: AutomationRuleWhereInput
  }

  export type AutomationRuleUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: AutomationRuleWhereInput
    data: XOR<AutomationRuleUpdateWithoutExecutionsInput, AutomationRuleUncheckedUpdateWithoutExecutionsInput>
  }

  export type AutomationRuleUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerEvent?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    executionCount?: IntFieldUpdateOperationsInput | number
    lastExecutedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutAutomationRulesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedRulesNestedInput
  }

  export type AutomationRuleUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerEvent?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    executionCount?: IntFieldUpdateOperationsInput | number
    lastExecutedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutCreatedTestPlansInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedAccounts?: AccountCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutCreatedTestPlansInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownedAccounts?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceUncheckedCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverUncheckedCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanUncheckedCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionUncheckedCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectUncheckedCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectUncheckedCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutCreatedTestPlansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTestPlansInput, UserUncheckedCreateWithoutCreatedTestPlansInput>
  }

  export type UserCreateWithoutAssignedTestPlansInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedAccounts?: AccountCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanCreateNestedManyWithoutCreatedByInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutAssignedTestPlansInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownedAccounts?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceUncheckedCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverUncheckedCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanUncheckedCreateNestedManyWithoutCreatedByInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionUncheckedCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectUncheckedCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectUncheckedCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutAssignedTestPlansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedTestPlansInput, UserUncheckedCreateWithoutAssignedTestPlansInput>
  }

  export type TestCaseCreateWithoutTestPlanInput = {
    id?: string
    title: string
    description?: string | null
    preconditions?: string | null
    steps: JsonNullValueInput | InputJsonValue
    expectedResult?: string | null
    priority?: $Enums.TestCasePriority
    status?: $Enums.TestCaseStatus
    tags?: TestCaseCreatetagsInput | string[]
    automatable?: boolean
    estimatedTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTestCasesInput
    executions?: TestExecutionCreateNestedManyWithoutTestCaseInput
    defects?: DefectTestCaseCreateNestedManyWithoutTestCaseInput
  }

  export type TestCaseUncheckedCreateWithoutTestPlanInput = {
    id?: string
    title: string
    description?: string | null
    preconditions?: string | null
    steps: JsonNullValueInput | InputJsonValue
    expectedResult?: string | null
    priority?: $Enums.TestCasePriority
    status?: $Enums.TestCaseStatus
    tags?: TestCaseCreatetagsInput | string[]
    automatable?: boolean
    estimatedTime?: number | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: TestExecutionUncheckedCreateNestedManyWithoutTestCaseInput
    defects?: DefectTestCaseUncheckedCreateNestedManyWithoutTestCaseInput
  }

  export type TestCaseCreateOrConnectWithoutTestPlanInput = {
    where: TestCaseWhereUniqueInput
    create: XOR<TestCaseCreateWithoutTestPlanInput, TestCaseUncheckedCreateWithoutTestPlanInput>
  }

  export type TestCaseCreateManyTestPlanInputEnvelope = {
    data: TestCaseCreateManyTestPlanInput | TestCaseCreateManyTestPlanInput[]
    skipDuplicates?: boolean
  }

  export type TestExecutionCreateWithoutTestPlanInput = {
    id?: string
    status?: $Enums.TestExecutionStatus
    result?: string | null
    actualResult?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: number | null
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    notes?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testCase: TestCaseCreateNestedOneWithoutExecutionsInput
    executedBy: UserCreateNestedOneWithoutTestExecutionsInput
    defects?: DefectCreateNestedManyWithoutTestExecutionInput
  }

  export type TestExecutionUncheckedCreateWithoutTestPlanInput = {
    id?: string
    testCaseId: string
    status?: $Enums.TestExecutionStatus
    result?: string | null
    actualResult?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: number | null
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    notes?: string | null
    executedById: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defects?: DefectUncheckedCreateNestedManyWithoutTestExecutionInput
  }

  export type TestExecutionCreateOrConnectWithoutTestPlanInput = {
    where: TestExecutionWhereUniqueInput
    create: XOR<TestExecutionCreateWithoutTestPlanInput, TestExecutionUncheckedCreateWithoutTestPlanInput>
  }

  export type TestExecutionCreateManyTestPlanInputEnvelope = {
    data: TestExecutionCreateManyTestPlanInput | TestExecutionCreateManyTestPlanInput[]
    skipDuplicates?: boolean
  }

  export type QAReviewCreateWithoutTestPlanInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    entityId: string
    status?: $Enums.QAReviewStatus
    criteria?: NullableJsonNullValueInput | InputJsonValue
    findings?: string | null
    recommendations?: string | null
    approved?: boolean | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewer: UserCreateNestedOneWithoutQaReviewsInput
  }

  export type QAReviewUncheckedCreateWithoutTestPlanInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    entityId: string
    status?: $Enums.QAReviewStatus
    criteria?: NullableJsonNullValueInput | InputJsonValue
    findings?: string | null
    recommendations?: string | null
    approved?: boolean | null
    reviewerId: string
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QAReviewCreateOrConnectWithoutTestPlanInput = {
    where: QAReviewWhereUniqueInput
    create: XOR<QAReviewCreateWithoutTestPlanInput, QAReviewUncheckedCreateWithoutTestPlanInput>
  }

  export type QAReviewCreateManyTestPlanInputEnvelope = {
    data: QAReviewCreateManyTestPlanInput | QAReviewCreateManyTestPlanInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedTestPlansInput = {
    update: XOR<UserUpdateWithoutCreatedTestPlansInput, UserUncheckedUpdateWithoutCreatedTestPlansInput>
    create: XOR<UserCreateWithoutCreatedTestPlansInput, UserUncheckedCreateWithoutCreatedTestPlansInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedTestPlansInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedTestPlansInput, UserUncheckedUpdateWithoutCreatedTestPlansInput>
  }

  export type UserUpdateWithoutCreatedTestPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedAccounts?: AccountUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTestPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedAccounts?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUncheckedUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUncheckedUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUncheckedUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUncheckedUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUncheckedUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type UserUpsertWithoutAssignedTestPlansInput = {
    update: XOR<UserUpdateWithoutAssignedTestPlansInput, UserUncheckedUpdateWithoutAssignedTestPlansInput>
    create: XOR<UserCreateWithoutAssignedTestPlansInput, UserUncheckedCreateWithoutAssignedTestPlansInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedTestPlansInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedTestPlansInput, UserUncheckedUpdateWithoutAssignedTestPlansInput>
  }

  export type UserUpdateWithoutAssignedTestPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedAccounts?: AccountUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUpdateManyWithoutCreatedByNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedTestPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedAccounts?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUncheckedUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUncheckedUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUncheckedUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUncheckedUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUncheckedUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type TestCaseUpsertWithWhereUniqueWithoutTestPlanInput = {
    where: TestCaseWhereUniqueInput
    update: XOR<TestCaseUpdateWithoutTestPlanInput, TestCaseUncheckedUpdateWithoutTestPlanInput>
    create: XOR<TestCaseCreateWithoutTestPlanInput, TestCaseUncheckedCreateWithoutTestPlanInput>
  }

  export type TestCaseUpdateWithWhereUniqueWithoutTestPlanInput = {
    where: TestCaseWhereUniqueInput
    data: XOR<TestCaseUpdateWithoutTestPlanInput, TestCaseUncheckedUpdateWithoutTestPlanInput>
  }

  export type TestCaseUpdateManyWithWhereWithoutTestPlanInput = {
    where: TestCaseScalarWhereInput
    data: XOR<TestCaseUpdateManyMutationInput, TestCaseUncheckedUpdateManyWithoutTestPlanInput>
  }

  export type TestExecutionUpsertWithWhereUniqueWithoutTestPlanInput = {
    where: TestExecutionWhereUniqueInput
    update: XOR<TestExecutionUpdateWithoutTestPlanInput, TestExecutionUncheckedUpdateWithoutTestPlanInput>
    create: XOR<TestExecutionCreateWithoutTestPlanInput, TestExecutionUncheckedCreateWithoutTestPlanInput>
  }

  export type TestExecutionUpdateWithWhereUniqueWithoutTestPlanInput = {
    where: TestExecutionWhereUniqueInput
    data: XOR<TestExecutionUpdateWithoutTestPlanInput, TestExecutionUncheckedUpdateWithoutTestPlanInput>
  }

  export type TestExecutionUpdateManyWithWhereWithoutTestPlanInput = {
    where: TestExecutionScalarWhereInput
    data: XOR<TestExecutionUpdateManyMutationInput, TestExecutionUncheckedUpdateManyWithoutTestPlanInput>
  }

  export type QAReviewUpsertWithWhereUniqueWithoutTestPlanInput = {
    where: QAReviewWhereUniqueInput
    update: XOR<QAReviewUpdateWithoutTestPlanInput, QAReviewUncheckedUpdateWithoutTestPlanInput>
    create: XOR<QAReviewCreateWithoutTestPlanInput, QAReviewUncheckedCreateWithoutTestPlanInput>
  }

  export type QAReviewUpdateWithWhereUniqueWithoutTestPlanInput = {
    where: QAReviewWhereUniqueInput
    data: XOR<QAReviewUpdateWithoutTestPlanInput, QAReviewUncheckedUpdateWithoutTestPlanInput>
  }

  export type QAReviewUpdateManyWithWhereWithoutTestPlanInput = {
    where: QAReviewScalarWhereInput
    data: XOR<QAReviewUpdateManyMutationInput, QAReviewUncheckedUpdateManyWithoutTestPlanInput>
  }

  export type TestPlanCreateWithoutTestCasesInput = {
    id?: string
    name: string
    description?: string | null
    version?: string
    status?: $Enums.TestPlanStatus
    projectId?: string | null
    feature?: string | null
    environment?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTestPlansInput
    assignedTo?: UserCreateNestedOneWithoutAssignedTestPlansInput
    executions?: TestExecutionCreateNestedManyWithoutTestPlanInput
    reviews?: QAReviewCreateNestedManyWithoutTestPlanInput
  }

  export type TestPlanUncheckedCreateWithoutTestCasesInput = {
    id?: string
    name: string
    description?: string | null
    version?: string
    status?: $Enums.TestPlanStatus
    projectId?: string | null
    feature?: string | null
    environment?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: TestExecutionUncheckedCreateNestedManyWithoutTestPlanInput
    reviews?: QAReviewUncheckedCreateNestedManyWithoutTestPlanInput
  }

  export type TestPlanCreateOrConnectWithoutTestCasesInput = {
    where: TestPlanWhereUniqueInput
    create: XOR<TestPlanCreateWithoutTestCasesInput, TestPlanUncheckedCreateWithoutTestCasesInput>
  }

  export type UserCreateWithoutCreatedTestCasesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedAccounts?: AccountCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanCreateNestedManyWithoutAssignedToInput
    testExecutions?: TestExecutionCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutCreatedTestCasesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownedAccounts?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceUncheckedCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverUncheckedCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanUncheckedCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanUncheckedCreateNestedManyWithoutAssignedToInput
    testExecutions?: TestExecutionUncheckedCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectUncheckedCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectUncheckedCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutCreatedTestCasesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTestCasesInput, UserUncheckedCreateWithoutCreatedTestCasesInput>
  }

  export type TestExecutionCreateWithoutTestCaseInput = {
    id?: string
    status?: $Enums.TestExecutionStatus
    result?: string | null
    actualResult?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: number | null
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    notes?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testPlan: TestPlanCreateNestedOneWithoutExecutionsInput
    executedBy: UserCreateNestedOneWithoutTestExecutionsInput
    defects?: DefectCreateNestedManyWithoutTestExecutionInput
  }

  export type TestExecutionUncheckedCreateWithoutTestCaseInput = {
    id?: string
    testPlanId: string
    status?: $Enums.TestExecutionStatus
    result?: string | null
    actualResult?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: number | null
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    notes?: string | null
    executedById: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defects?: DefectUncheckedCreateNestedManyWithoutTestExecutionInput
  }

  export type TestExecutionCreateOrConnectWithoutTestCaseInput = {
    where: TestExecutionWhereUniqueInput
    create: XOR<TestExecutionCreateWithoutTestCaseInput, TestExecutionUncheckedCreateWithoutTestCaseInput>
  }

  export type TestExecutionCreateManyTestCaseInputEnvelope = {
    data: TestExecutionCreateManyTestCaseInput | TestExecutionCreateManyTestCaseInput[]
    skipDuplicates?: boolean
  }

  export type DefectTestCaseCreateWithoutTestCaseInput = {
    id?: string
    createdAt?: Date | string
    defect: DefectCreateNestedOneWithoutTestCasesInput
  }

  export type DefectTestCaseUncheckedCreateWithoutTestCaseInput = {
    id?: string
    defectId: string
    createdAt?: Date | string
  }

  export type DefectTestCaseCreateOrConnectWithoutTestCaseInput = {
    where: DefectTestCaseWhereUniqueInput
    create: XOR<DefectTestCaseCreateWithoutTestCaseInput, DefectTestCaseUncheckedCreateWithoutTestCaseInput>
  }

  export type DefectTestCaseCreateManyTestCaseInputEnvelope = {
    data: DefectTestCaseCreateManyTestCaseInput | DefectTestCaseCreateManyTestCaseInput[]
    skipDuplicates?: boolean
  }

  export type TestPlanUpsertWithoutTestCasesInput = {
    update: XOR<TestPlanUpdateWithoutTestCasesInput, TestPlanUncheckedUpdateWithoutTestCasesInput>
    create: XOR<TestPlanCreateWithoutTestCasesInput, TestPlanUncheckedCreateWithoutTestCasesInput>
    where?: TestPlanWhereInput
  }

  export type TestPlanUpdateToOneWithWhereWithoutTestCasesInput = {
    where?: TestPlanWhereInput
    data: XOR<TestPlanUpdateWithoutTestCasesInput, TestPlanUncheckedUpdateWithoutTestCasesInput>
  }

  export type TestPlanUpdateWithoutTestCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumTestPlanStatusFieldUpdateOperationsInput | $Enums.TestPlanStatus
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTestPlansNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedTestPlansNestedInput
    executions?: TestExecutionUpdateManyWithoutTestPlanNestedInput
    reviews?: QAReviewUpdateManyWithoutTestPlanNestedInput
  }

  export type TestPlanUncheckedUpdateWithoutTestCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumTestPlanStatusFieldUpdateOperationsInput | $Enums.TestPlanStatus
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: TestExecutionUncheckedUpdateManyWithoutTestPlanNestedInput
    reviews?: QAReviewUncheckedUpdateManyWithoutTestPlanNestedInput
  }

  export type UserUpsertWithoutCreatedTestCasesInput = {
    update: XOR<UserUpdateWithoutCreatedTestCasesInput, UserUncheckedUpdateWithoutCreatedTestCasesInput>
    create: XOR<UserCreateWithoutCreatedTestCasesInput, UserUncheckedCreateWithoutCreatedTestCasesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedTestCasesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedTestCasesInput, UserUncheckedUpdateWithoutCreatedTestCasesInput>
  }

  export type UserUpdateWithoutCreatedTestCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedAccounts?: AccountUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUpdateManyWithoutAssignedToNestedInput
    testExecutions?: TestExecutionUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTestCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedAccounts?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUncheckedUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUncheckedUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUncheckedUpdateManyWithoutAssignedToNestedInput
    testExecutions?: TestExecutionUncheckedUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUncheckedUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUncheckedUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type TestExecutionUpsertWithWhereUniqueWithoutTestCaseInput = {
    where: TestExecutionWhereUniqueInput
    update: XOR<TestExecutionUpdateWithoutTestCaseInput, TestExecutionUncheckedUpdateWithoutTestCaseInput>
    create: XOR<TestExecutionCreateWithoutTestCaseInput, TestExecutionUncheckedCreateWithoutTestCaseInput>
  }

  export type TestExecutionUpdateWithWhereUniqueWithoutTestCaseInput = {
    where: TestExecutionWhereUniqueInput
    data: XOR<TestExecutionUpdateWithoutTestCaseInput, TestExecutionUncheckedUpdateWithoutTestCaseInput>
  }

  export type TestExecutionUpdateManyWithWhereWithoutTestCaseInput = {
    where: TestExecutionScalarWhereInput
    data: XOR<TestExecutionUpdateManyMutationInput, TestExecutionUncheckedUpdateManyWithoutTestCaseInput>
  }

  export type DefectTestCaseUpsertWithWhereUniqueWithoutTestCaseInput = {
    where: DefectTestCaseWhereUniqueInput
    update: XOR<DefectTestCaseUpdateWithoutTestCaseInput, DefectTestCaseUncheckedUpdateWithoutTestCaseInput>
    create: XOR<DefectTestCaseCreateWithoutTestCaseInput, DefectTestCaseUncheckedCreateWithoutTestCaseInput>
  }

  export type DefectTestCaseUpdateWithWhereUniqueWithoutTestCaseInput = {
    where: DefectTestCaseWhereUniqueInput
    data: XOR<DefectTestCaseUpdateWithoutTestCaseInput, DefectTestCaseUncheckedUpdateWithoutTestCaseInput>
  }

  export type DefectTestCaseUpdateManyWithWhereWithoutTestCaseInput = {
    where: DefectTestCaseScalarWhereInput
    data: XOR<DefectTestCaseUpdateManyMutationInput, DefectTestCaseUncheckedUpdateManyWithoutTestCaseInput>
  }

  export type DefectTestCaseScalarWhereInput = {
    AND?: DefectTestCaseScalarWhereInput | DefectTestCaseScalarWhereInput[]
    OR?: DefectTestCaseScalarWhereInput[]
    NOT?: DefectTestCaseScalarWhereInput | DefectTestCaseScalarWhereInput[]
    id?: StringFilter<"DefectTestCase"> | string
    defectId?: StringFilter<"DefectTestCase"> | string
    testCaseId?: StringFilter<"DefectTestCase"> | string
    createdAt?: DateTimeFilter<"DefectTestCase"> | Date | string
  }

  export type TestPlanCreateWithoutExecutionsInput = {
    id?: string
    name: string
    description?: string | null
    version?: string
    status?: $Enums.TestPlanStatus
    projectId?: string | null
    feature?: string | null
    environment?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTestPlansInput
    assignedTo?: UserCreateNestedOneWithoutAssignedTestPlansInput
    testCases?: TestCaseCreateNestedManyWithoutTestPlanInput
    reviews?: QAReviewCreateNestedManyWithoutTestPlanInput
  }

  export type TestPlanUncheckedCreateWithoutExecutionsInput = {
    id?: string
    name: string
    description?: string | null
    version?: string
    status?: $Enums.TestPlanStatus
    projectId?: string | null
    feature?: string | null
    environment?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testCases?: TestCaseUncheckedCreateNestedManyWithoutTestPlanInput
    reviews?: QAReviewUncheckedCreateNestedManyWithoutTestPlanInput
  }

  export type TestPlanCreateOrConnectWithoutExecutionsInput = {
    where: TestPlanWhereUniqueInput
    create: XOR<TestPlanCreateWithoutExecutionsInput, TestPlanUncheckedCreateWithoutExecutionsInput>
  }

  export type TestCaseCreateWithoutExecutionsInput = {
    id?: string
    title: string
    description?: string | null
    preconditions?: string | null
    steps: JsonNullValueInput | InputJsonValue
    expectedResult?: string | null
    priority?: $Enums.TestCasePriority
    status?: $Enums.TestCaseStatus
    tags?: TestCaseCreatetagsInput | string[]
    automatable?: boolean
    estimatedTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testPlan: TestPlanCreateNestedOneWithoutTestCasesInput
    createdBy: UserCreateNestedOneWithoutCreatedTestCasesInput
    defects?: DefectTestCaseCreateNestedManyWithoutTestCaseInput
  }

  export type TestCaseUncheckedCreateWithoutExecutionsInput = {
    id?: string
    title: string
    description?: string | null
    preconditions?: string | null
    steps: JsonNullValueInput | InputJsonValue
    expectedResult?: string | null
    priority?: $Enums.TestCasePriority
    status?: $Enums.TestCaseStatus
    tags?: TestCaseCreatetagsInput | string[]
    automatable?: boolean
    estimatedTime?: number | null
    testPlanId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    defects?: DefectTestCaseUncheckedCreateNestedManyWithoutTestCaseInput
  }

  export type TestCaseCreateOrConnectWithoutExecutionsInput = {
    where: TestCaseWhereUniqueInput
    create: XOR<TestCaseCreateWithoutExecutionsInput, TestCaseUncheckedCreateWithoutExecutionsInput>
  }

  export type UserCreateWithoutTestExecutionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedAccounts?: AccountCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatedByInput
    reportedDefects?: DefectCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutTestExecutionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownedAccounts?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceUncheckedCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverUncheckedCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanUncheckedCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanUncheckedCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatedByInput
    reportedDefects?: DefectUncheckedCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectUncheckedCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutTestExecutionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTestExecutionsInput, UserUncheckedCreateWithoutTestExecutionsInput>
  }

  export type DefectCreateWithoutTestExecutionInput = {
    id?: string
    title: string
    description: string
    steps?: string | null
    expectedBehavior?: string | null
    actualBehavior?: string | null
    severity?: $Enums.DefectSeverity
    priority?: $Enums.DefectPriority
    status?: $Enums.DefectStatus
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: boolean
    regression?: boolean
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reportedBy: UserCreateNestedOneWithoutReportedDefectsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedDefectsInput
    testCases?: DefectTestCaseCreateNestedManyWithoutDefectInput
    comments?: DefectCommentCreateNestedManyWithoutDefectInput
  }

  export type DefectUncheckedCreateWithoutTestExecutionInput = {
    id?: string
    title: string
    description: string
    steps?: string | null
    expectedBehavior?: string | null
    actualBehavior?: string | null
    severity?: $Enums.DefectSeverity
    priority?: $Enums.DefectPriority
    status?: $Enums.DefectStatus
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: boolean
    regression?: boolean
    reportedById: string
    assignedToId?: string | null
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testCases?: DefectTestCaseUncheckedCreateNestedManyWithoutDefectInput
    comments?: DefectCommentUncheckedCreateNestedManyWithoutDefectInput
  }

  export type DefectCreateOrConnectWithoutTestExecutionInput = {
    where: DefectWhereUniqueInput
    create: XOR<DefectCreateWithoutTestExecutionInput, DefectUncheckedCreateWithoutTestExecutionInput>
  }

  export type DefectCreateManyTestExecutionInputEnvelope = {
    data: DefectCreateManyTestExecutionInput | DefectCreateManyTestExecutionInput[]
    skipDuplicates?: boolean
  }

  export type TestPlanUpsertWithoutExecutionsInput = {
    update: XOR<TestPlanUpdateWithoutExecutionsInput, TestPlanUncheckedUpdateWithoutExecutionsInput>
    create: XOR<TestPlanCreateWithoutExecutionsInput, TestPlanUncheckedCreateWithoutExecutionsInput>
    where?: TestPlanWhereInput
  }

  export type TestPlanUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: TestPlanWhereInput
    data: XOR<TestPlanUpdateWithoutExecutionsInput, TestPlanUncheckedUpdateWithoutExecutionsInput>
  }

  export type TestPlanUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumTestPlanStatusFieldUpdateOperationsInput | $Enums.TestPlanStatus
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTestPlansNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedTestPlansNestedInput
    testCases?: TestCaseUpdateManyWithoutTestPlanNestedInput
    reviews?: QAReviewUpdateManyWithoutTestPlanNestedInput
  }

  export type TestPlanUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumTestPlanStatusFieldUpdateOperationsInput | $Enums.TestPlanStatus
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testCases?: TestCaseUncheckedUpdateManyWithoutTestPlanNestedInput
    reviews?: QAReviewUncheckedUpdateManyWithoutTestPlanNestedInput
  }

  export type TestCaseUpsertWithoutExecutionsInput = {
    update: XOR<TestCaseUpdateWithoutExecutionsInput, TestCaseUncheckedUpdateWithoutExecutionsInput>
    create: XOR<TestCaseCreateWithoutExecutionsInput, TestCaseUncheckedCreateWithoutExecutionsInput>
    where?: TestCaseWhereInput
  }

  export type TestCaseUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: TestCaseWhereInput
    data: XOR<TestCaseUpdateWithoutExecutionsInput, TestCaseUncheckedUpdateWithoutExecutionsInput>
  }

  export type TestCaseUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    steps?: JsonNullValueInput | InputJsonValue
    expectedResult?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTestCasePriorityFieldUpdateOperationsInput | $Enums.TestCasePriority
    status?: EnumTestCaseStatusFieldUpdateOperationsInput | $Enums.TestCaseStatus
    tags?: TestCaseUpdatetagsInput | string[]
    automatable?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testPlan?: TestPlanUpdateOneRequiredWithoutTestCasesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTestCasesNestedInput
    defects?: DefectTestCaseUpdateManyWithoutTestCaseNestedInput
  }

  export type TestCaseUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    steps?: JsonNullValueInput | InputJsonValue
    expectedResult?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTestCasePriorityFieldUpdateOperationsInput | $Enums.TestCasePriority
    status?: EnumTestCaseStatusFieldUpdateOperationsInput | $Enums.TestCaseStatus
    tags?: TestCaseUpdatetagsInput | string[]
    automatable?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: NullableIntFieldUpdateOperationsInput | number | null
    testPlanId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defects?: DefectTestCaseUncheckedUpdateManyWithoutTestCaseNestedInput
  }

  export type UserUpsertWithoutTestExecutionsInput = {
    update: XOR<UserUpdateWithoutTestExecutionsInput, UserUncheckedUpdateWithoutTestExecutionsInput>
    create: XOR<UserCreateWithoutTestExecutionsInput, UserUncheckedCreateWithoutTestExecutionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTestExecutionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTestExecutionsInput, UserUncheckedUpdateWithoutTestExecutionsInput>
  }

  export type UserUpdateWithoutTestExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedAccounts?: AccountUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatedByNestedInput
    reportedDefects?: DefectUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutTestExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedAccounts?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUncheckedUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUncheckedUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    reportedDefects?: DefectUncheckedUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUncheckedUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type DefectUpsertWithWhereUniqueWithoutTestExecutionInput = {
    where: DefectWhereUniqueInput
    update: XOR<DefectUpdateWithoutTestExecutionInput, DefectUncheckedUpdateWithoutTestExecutionInput>
    create: XOR<DefectCreateWithoutTestExecutionInput, DefectUncheckedCreateWithoutTestExecutionInput>
  }

  export type DefectUpdateWithWhereUniqueWithoutTestExecutionInput = {
    where: DefectWhereUniqueInput
    data: XOR<DefectUpdateWithoutTestExecutionInput, DefectUncheckedUpdateWithoutTestExecutionInput>
  }

  export type DefectUpdateManyWithWhereWithoutTestExecutionInput = {
    where: DefectScalarWhereInput
    data: XOR<DefectUpdateManyMutationInput, DefectUncheckedUpdateManyWithoutTestExecutionInput>
  }

  export type TestExecutionCreateWithoutDefectsInput = {
    id?: string
    status?: $Enums.TestExecutionStatus
    result?: string | null
    actualResult?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: number | null
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    notes?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testPlan: TestPlanCreateNestedOneWithoutExecutionsInput
    testCase: TestCaseCreateNestedOneWithoutExecutionsInput
    executedBy: UserCreateNestedOneWithoutTestExecutionsInput
  }

  export type TestExecutionUncheckedCreateWithoutDefectsInput = {
    id?: string
    testPlanId: string
    testCaseId: string
    status?: $Enums.TestExecutionStatus
    result?: string | null
    actualResult?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: number | null
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    notes?: string | null
    executedById: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestExecutionCreateOrConnectWithoutDefectsInput = {
    where: TestExecutionWhereUniqueInput
    create: XOR<TestExecutionCreateWithoutDefectsInput, TestExecutionUncheckedCreateWithoutDefectsInput>
  }

  export type UserCreateWithoutReportedDefectsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedAccounts?: AccountCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionCreateNestedManyWithoutExecutedByInput
    assignedDefects?: DefectCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutReportedDefectsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownedAccounts?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceUncheckedCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverUncheckedCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanUncheckedCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanUncheckedCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionUncheckedCreateNestedManyWithoutExecutedByInput
    assignedDefects?: DefectUncheckedCreateNestedManyWithoutAssignedToInput
    qaReviews?: QAReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutReportedDefectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportedDefectsInput, UserUncheckedCreateWithoutReportedDefectsInput>
  }

  export type UserCreateWithoutAssignedDefectsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedAccounts?: AccountCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectCreateNestedManyWithoutReportedByInput
    qaReviews?: QAReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutAssignedDefectsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownedAccounts?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceUncheckedCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverUncheckedCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanUncheckedCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanUncheckedCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionUncheckedCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectUncheckedCreateNestedManyWithoutReportedByInput
    qaReviews?: QAReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutAssignedDefectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedDefectsInput, UserUncheckedCreateWithoutAssignedDefectsInput>
  }

  export type DefectTestCaseCreateWithoutDefectInput = {
    id?: string
    createdAt?: Date | string
    testCase: TestCaseCreateNestedOneWithoutDefectsInput
  }

  export type DefectTestCaseUncheckedCreateWithoutDefectInput = {
    id?: string
    testCaseId: string
    createdAt?: Date | string
  }

  export type DefectTestCaseCreateOrConnectWithoutDefectInput = {
    where: DefectTestCaseWhereUniqueInput
    create: XOR<DefectTestCaseCreateWithoutDefectInput, DefectTestCaseUncheckedCreateWithoutDefectInput>
  }

  export type DefectTestCaseCreateManyDefectInputEnvelope = {
    data: DefectTestCaseCreateManyDefectInput | DefectTestCaseCreateManyDefectInput[]
    skipDuplicates?: boolean
  }

  export type DefectCommentCreateWithoutDefectInput = {
    id?: string
    content: string
    authorId: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DefectCommentUncheckedCreateWithoutDefectInput = {
    id?: string
    content: string
    authorId: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DefectCommentCreateOrConnectWithoutDefectInput = {
    where: DefectCommentWhereUniqueInput
    create: XOR<DefectCommentCreateWithoutDefectInput, DefectCommentUncheckedCreateWithoutDefectInput>
  }

  export type DefectCommentCreateManyDefectInputEnvelope = {
    data: DefectCommentCreateManyDefectInput | DefectCommentCreateManyDefectInput[]
    skipDuplicates?: boolean
  }

  export type TestExecutionUpsertWithoutDefectsInput = {
    update: XOR<TestExecutionUpdateWithoutDefectsInput, TestExecutionUncheckedUpdateWithoutDefectsInput>
    create: XOR<TestExecutionCreateWithoutDefectsInput, TestExecutionUncheckedCreateWithoutDefectsInput>
    where?: TestExecutionWhereInput
  }

  export type TestExecutionUpdateToOneWithWhereWithoutDefectsInput = {
    where?: TestExecutionWhereInput
    data: XOR<TestExecutionUpdateWithoutDefectsInput, TestExecutionUncheckedUpdateWithoutDefectsInput>
  }

  export type TestExecutionUpdateWithoutDefectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTestExecutionStatusFieldUpdateOperationsInput | $Enums.TestExecutionStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    actualResult?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testPlan?: TestPlanUpdateOneRequiredWithoutExecutionsNestedInput
    testCase?: TestCaseUpdateOneRequiredWithoutExecutionsNestedInput
    executedBy?: UserUpdateOneRequiredWithoutTestExecutionsNestedInput
  }

  export type TestExecutionUncheckedUpdateWithoutDefectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    testPlanId?: StringFieldUpdateOperationsInput | string
    testCaseId?: StringFieldUpdateOperationsInput | string
    status?: EnumTestExecutionStatusFieldUpdateOperationsInput | $Enums.TestExecutionStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    actualResult?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    executedById?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutReportedDefectsInput = {
    update: XOR<UserUpdateWithoutReportedDefectsInput, UserUncheckedUpdateWithoutReportedDefectsInput>
    create: XOR<UserCreateWithoutReportedDefectsInput, UserUncheckedCreateWithoutReportedDefectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportedDefectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportedDefectsInput, UserUncheckedUpdateWithoutReportedDefectsInput>
  }

  export type UserUpdateWithoutReportedDefectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedAccounts?: AccountUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUpdateManyWithoutExecutedByNestedInput
    assignedDefects?: DefectUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutReportedDefectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedAccounts?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUncheckedUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUncheckedUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUncheckedUpdateManyWithoutExecutedByNestedInput
    assignedDefects?: DefectUncheckedUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type UserUpsertWithoutAssignedDefectsInput = {
    update: XOR<UserUpdateWithoutAssignedDefectsInput, UserUncheckedUpdateWithoutAssignedDefectsInput>
    create: XOR<UserCreateWithoutAssignedDefectsInput, UserUncheckedCreateWithoutAssignedDefectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedDefectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedDefectsInput, UserUncheckedUpdateWithoutAssignedDefectsInput>
  }

  export type UserUpdateWithoutAssignedDefectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedAccounts?: AccountUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUpdateManyWithoutReportedByNestedInput
    qaReviews?: QAReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedDefectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedAccounts?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUncheckedUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUncheckedUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUncheckedUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUncheckedUpdateManyWithoutReportedByNestedInput
    qaReviews?: QAReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type DefectTestCaseUpsertWithWhereUniqueWithoutDefectInput = {
    where: DefectTestCaseWhereUniqueInput
    update: XOR<DefectTestCaseUpdateWithoutDefectInput, DefectTestCaseUncheckedUpdateWithoutDefectInput>
    create: XOR<DefectTestCaseCreateWithoutDefectInput, DefectTestCaseUncheckedCreateWithoutDefectInput>
  }

  export type DefectTestCaseUpdateWithWhereUniqueWithoutDefectInput = {
    where: DefectTestCaseWhereUniqueInput
    data: XOR<DefectTestCaseUpdateWithoutDefectInput, DefectTestCaseUncheckedUpdateWithoutDefectInput>
  }

  export type DefectTestCaseUpdateManyWithWhereWithoutDefectInput = {
    where: DefectTestCaseScalarWhereInput
    data: XOR<DefectTestCaseUpdateManyMutationInput, DefectTestCaseUncheckedUpdateManyWithoutDefectInput>
  }

  export type DefectCommentUpsertWithWhereUniqueWithoutDefectInput = {
    where: DefectCommentWhereUniqueInput
    update: XOR<DefectCommentUpdateWithoutDefectInput, DefectCommentUncheckedUpdateWithoutDefectInput>
    create: XOR<DefectCommentCreateWithoutDefectInput, DefectCommentUncheckedCreateWithoutDefectInput>
  }

  export type DefectCommentUpdateWithWhereUniqueWithoutDefectInput = {
    where: DefectCommentWhereUniqueInput
    data: XOR<DefectCommentUpdateWithoutDefectInput, DefectCommentUncheckedUpdateWithoutDefectInput>
  }

  export type DefectCommentUpdateManyWithWhereWithoutDefectInput = {
    where: DefectCommentScalarWhereInput
    data: XOR<DefectCommentUpdateManyMutationInput, DefectCommentUncheckedUpdateManyWithoutDefectInput>
  }

  export type DefectCommentScalarWhereInput = {
    AND?: DefectCommentScalarWhereInput | DefectCommentScalarWhereInput[]
    OR?: DefectCommentScalarWhereInput[]
    NOT?: DefectCommentScalarWhereInput | DefectCommentScalarWhereInput[]
    id?: StringFilter<"DefectComment"> | string
    content?: StringFilter<"DefectComment"> | string
    defectId?: StringFilter<"DefectComment"> | string
    authorId?: StringFilter<"DefectComment"> | string
    isInternal?: BoolFilter<"DefectComment"> | boolean
    createdAt?: DateTimeFilter<"DefectComment"> | Date | string
    updatedAt?: DateTimeFilter<"DefectComment"> | Date | string
  }

  export type DefectCreateWithoutTestCasesInput = {
    id?: string
    title: string
    description: string
    steps?: string | null
    expectedBehavior?: string | null
    actualBehavior?: string | null
    severity?: $Enums.DefectSeverity
    priority?: $Enums.DefectPriority
    status?: $Enums.DefectStatus
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: boolean
    regression?: boolean
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testExecution?: TestExecutionCreateNestedOneWithoutDefectsInput
    reportedBy: UserCreateNestedOneWithoutReportedDefectsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedDefectsInput
    comments?: DefectCommentCreateNestedManyWithoutDefectInput
  }

  export type DefectUncheckedCreateWithoutTestCasesInput = {
    id?: string
    title: string
    description: string
    steps?: string | null
    expectedBehavior?: string | null
    actualBehavior?: string | null
    severity?: $Enums.DefectSeverity
    priority?: $Enums.DefectPriority
    status?: $Enums.DefectStatus
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: boolean
    regression?: boolean
    testExecutionId?: string | null
    reportedById: string
    assignedToId?: string | null
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: DefectCommentUncheckedCreateNestedManyWithoutDefectInput
  }

  export type DefectCreateOrConnectWithoutTestCasesInput = {
    where: DefectWhereUniqueInput
    create: XOR<DefectCreateWithoutTestCasesInput, DefectUncheckedCreateWithoutTestCasesInput>
  }

  export type TestCaseCreateWithoutDefectsInput = {
    id?: string
    title: string
    description?: string | null
    preconditions?: string | null
    steps: JsonNullValueInput | InputJsonValue
    expectedResult?: string | null
    priority?: $Enums.TestCasePriority
    status?: $Enums.TestCaseStatus
    tags?: TestCaseCreatetagsInput | string[]
    automatable?: boolean
    estimatedTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testPlan: TestPlanCreateNestedOneWithoutTestCasesInput
    createdBy: UserCreateNestedOneWithoutCreatedTestCasesInput
    executions?: TestExecutionCreateNestedManyWithoutTestCaseInput
  }

  export type TestCaseUncheckedCreateWithoutDefectsInput = {
    id?: string
    title: string
    description?: string | null
    preconditions?: string | null
    steps: JsonNullValueInput | InputJsonValue
    expectedResult?: string | null
    priority?: $Enums.TestCasePriority
    status?: $Enums.TestCaseStatus
    tags?: TestCaseCreatetagsInput | string[]
    automatable?: boolean
    estimatedTime?: number | null
    testPlanId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: TestExecutionUncheckedCreateNestedManyWithoutTestCaseInput
  }

  export type TestCaseCreateOrConnectWithoutDefectsInput = {
    where: TestCaseWhereUniqueInput
    create: XOR<TestCaseCreateWithoutDefectsInput, TestCaseUncheckedCreateWithoutDefectsInput>
  }

  export type DefectUpsertWithoutTestCasesInput = {
    update: XOR<DefectUpdateWithoutTestCasesInput, DefectUncheckedUpdateWithoutTestCasesInput>
    create: XOR<DefectCreateWithoutTestCasesInput, DefectUncheckedCreateWithoutTestCasesInput>
    where?: DefectWhereInput
  }

  export type DefectUpdateToOneWithWhereWithoutTestCasesInput = {
    where?: DefectWhereInput
    data: XOR<DefectUpdateWithoutTestCasesInput, DefectUncheckedUpdateWithoutTestCasesInput>
  }

  export type DefectUpdateWithoutTestCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    expectedBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    actualBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    priority?: EnumDefectPriorityFieldUpdateOperationsInput | $Enums.DefectPriority
    status?: EnumDefectStatusFieldUpdateOperationsInput | $Enums.DefectStatus
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: BoolFieldUpdateOperationsInput | boolean
    regression?: BoolFieldUpdateOperationsInput | boolean
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testExecution?: TestExecutionUpdateOneWithoutDefectsNestedInput
    reportedBy?: UserUpdateOneRequiredWithoutReportedDefectsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedDefectsNestedInput
    comments?: DefectCommentUpdateManyWithoutDefectNestedInput
  }

  export type DefectUncheckedUpdateWithoutTestCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    expectedBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    actualBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    priority?: EnumDefectPriorityFieldUpdateOperationsInput | $Enums.DefectPriority
    status?: EnumDefectStatusFieldUpdateOperationsInput | $Enums.DefectStatus
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: BoolFieldUpdateOperationsInput | boolean
    regression?: BoolFieldUpdateOperationsInput | boolean
    testExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedById?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: DefectCommentUncheckedUpdateManyWithoutDefectNestedInput
  }

  export type TestCaseUpsertWithoutDefectsInput = {
    update: XOR<TestCaseUpdateWithoutDefectsInput, TestCaseUncheckedUpdateWithoutDefectsInput>
    create: XOR<TestCaseCreateWithoutDefectsInput, TestCaseUncheckedCreateWithoutDefectsInput>
    where?: TestCaseWhereInput
  }

  export type TestCaseUpdateToOneWithWhereWithoutDefectsInput = {
    where?: TestCaseWhereInput
    data: XOR<TestCaseUpdateWithoutDefectsInput, TestCaseUncheckedUpdateWithoutDefectsInput>
  }

  export type TestCaseUpdateWithoutDefectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    steps?: JsonNullValueInput | InputJsonValue
    expectedResult?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTestCasePriorityFieldUpdateOperationsInput | $Enums.TestCasePriority
    status?: EnumTestCaseStatusFieldUpdateOperationsInput | $Enums.TestCaseStatus
    tags?: TestCaseUpdatetagsInput | string[]
    automatable?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testPlan?: TestPlanUpdateOneRequiredWithoutTestCasesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTestCasesNestedInput
    executions?: TestExecutionUpdateManyWithoutTestCaseNestedInput
  }

  export type TestCaseUncheckedUpdateWithoutDefectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    steps?: JsonNullValueInput | InputJsonValue
    expectedResult?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTestCasePriorityFieldUpdateOperationsInput | $Enums.TestCasePriority
    status?: EnumTestCaseStatusFieldUpdateOperationsInput | $Enums.TestCaseStatus
    tags?: TestCaseUpdatetagsInput | string[]
    automatable?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: NullableIntFieldUpdateOperationsInput | number | null
    testPlanId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: TestExecutionUncheckedUpdateManyWithoutTestCaseNestedInput
  }

  export type DefectCreateWithoutCommentsInput = {
    id?: string
    title: string
    description: string
    steps?: string | null
    expectedBehavior?: string | null
    actualBehavior?: string | null
    severity?: $Enums.DefectSeverity
    priority?: $Enums.DefectPriority
    status?: $Enums.DefectStatus
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: boolean
    regression?: boolean
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testExecution?: TestExecutionCreateNestedOneWithoutDefectsInput
    reportedBy: UserCreateNestedOneWithoutReportedDefectsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedDefectsInput
    testCases?: DefectTestCaseCreateNestedManyWithoutDefectInput
  }

  export type DefectUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    description: string
    steps?: string | null
    expectedBehavior?: string | null
    actualBehavior?: string | null
    severity?: $Enums.DefectSeverity
    priority?: $Enums.DefectPriority
    status?: $Enums.DefectStatus
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: boolean
    regression?: boolean
    testExecutionId?: string | null
    reportedById: string
    assignedToId?: string | null
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testCases?: DefectTestCaseUncheckedCreateNestedManyWithoutDefectInput
  }

  export type DefectCreateOrConnectWithoutCommentsInput = {
    where: DefectWhereUniqueInput
    create: XOR<DefectCreateWithoutCommentsInput, DefectUncheckedCreateWithoutCommentsInput>
  }

  export type DefectUpsertWithoutCommentsInput = {
    update: XOR<DefectUpdateWithoutCommentsInput, DefectUncheckedUpdateWithoutCommentsInput>
    create: XOR<DefectCreateWithoutCommentsInput, DefectUncheckedCreateWithoutCommentsInput>
    where?: DefectWhereInput
  }

  export type DefectUpdateToOneWithWhereWithoutCommentsInput = {
    where?: DefectWhereInput
    data: XOR<DefectUpdateWithoutCommentsInput, DefectUncheckedUpdateWithoutCommentsInput>
  }

  export type DefectUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    expectedBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    actualBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    priority?: EnumDefectPriorityFieldUpdateOperationsInput | $Enums.DefectPriority
    status?: EnumDefectStatusFieldUpdateOperationsInput | $Enums.DefectStatus
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: BoolFieldUpdateOperationsInput | boolean
    regression?: BoolFieldUpdateOperationsInput | boolean
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testExecution?: TestExecutionUpdateOneWithoutDefectsNestedInput
    reportedBy?: UserUpdateOneRequiredWithoutReportedDefectsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedDefectsNestedInput
    testCases?: DefectTestCaseUpdateManyWithoutDefectNestedInput
  }

  export type DefectUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    expectedBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    actualBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    priority?: EnumDefectPriorityFieldUpdateOperationsInput | $Enums.DefectPriority
    status?: EnumDefectStatusFieldUpdateOperationsInput | $Enums.DefectStatus
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: BoolFieldUpdateOperationsInput | boolean
    regression?: BoolFieldUpdateOperationsInput | boolean
    testExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedById?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testCases?: DefectTestCaseUncheckedUpdateManyWithoutDefectNestedInput
  }

  export type TestPlanCreateWithoutReviewsInput = {
    id?: string
    name: string
    description?: string | null
    version?: string
    status?: $Enums.TestPlanStatus
    projectId?: string | null
    feature?: string | null
    environment?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTestPlansInput
    assignedTo?: UserCreateNestedOneWithoutAssignedTestPlansInput
    testCases?: TestCaseCreateNestedManyWithoutTestPlanInput
    executions?: TestExecutionCreateNestedManyWithoutTestPlanInput
  }

  export type TestPlanUncheckedCreateWithoutReviewsInput = {
    id?: string
    name: string
    description?: string | null
    version?: string
    status?: $Enums.TestPlanStatus
    projectId?: string | null
    feature?: string | null
    environment?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testCases?: TestCaseUncheckedCreateNestedManyWithoutTestPlanInput
    executions?: TestExecutionUncheckedCreateNestedManyWithoutTestPlanInput
  }

  export type TestPlanCreateOrConnectWithoutReviewsInput = {
    where: TestPlanWhereUniqueInput
    create: XOR<TestPlanCreateWithoutReviewsInput, TestPlanUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutQaReviewsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedAccounts?: AccountCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedUsersInput
    updatedUsers?: UserCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectCreateNestedManyWithoutAssignedToInput
  }

  export type UserUncheckedCreateWithoutQaReviewsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    ownedAccounts?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedCompletedProjects?: CompletedProjectUncheckedCreateNestedManyWithoutOwnerInput
    ownedEnquiries?: EnquiryUncheckedCreateNestedManyWithoutOwnerInput
    ownedLeads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    updatedUsers?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    createdWorkflows?: WorkflowDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    initiatedWorkflows?: WorkflowInstanceUncheckedCreateNestedManyWithoutInitiatedByInput
    assignedSteps?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutAssignedToInput
    approverSteps?: WorkflowStepApproverUncheckedCreateNestedManyWithoutUserInput
    approvals?: WorkflowApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdTemplates?: WorkflowTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatedByInput
    createdTestPlans?: TestPlanUncheckedCreateNestedManyWithoutCreatedByInput
    assignedTestPlans?: TestPlanUncheckedCreateNestedManyWithoutAssignedToInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatedByInput
    testExecutions?: TestExecutionUncheckedCreateNestedManyWithoutExecutedByInput
    reportedDefects?: DefectUncheckedCreateNestedManyWithoutReportedByInput
    assignedDefects?: DefectUncheckedCreateNestedManyWithoutAssignedToInput
  }

  export type UserCreateOrConnectWithoutQaReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQaReviewsInput, UserUncheckedCreateWithoutQaReviewsInput>
  }

  export type TestPlanUpsertWithoutReviewsInput = {
    update: XOR<TestPlanUpdateWithoutReviewsInput, TestPlanUncheckedUpdateWithoutReviewsInput>
    create: XOR<TestPlanCreateWithoutReviewsInput, TestPlanUncheckedCreateWithoutReviewsInput>
    where?: TestPlanWhereInput
  }

  export type TestPlanUpdateToOneWithWhereWithoutReviewsInput = {
    where?: TestPlanWhereInput
    data: XOR<TestPlanUpdateWithoutReviewsInput, TestPlanUncheckedUpdateWithoutReviewsInput>
  }

  export type TestPlanUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumTestPlanStatusFieldUpdateOperationsInput | $Enums.TestPlanStatus
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTestPlansNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedTestPlansNestedInput
    testCases?: TestCaseUpdateManyWithoutTestPlanNestedInput
    executions?: TestExecutionUpdateManyWithoutTestPlanNestedInput
  }

  export type TestPlanUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumTestPlanStatusFieldUpdateOperationsInput | $Enums.TestPlanStatus
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testCases?: TestCaseUncheckedUpdateManyWithoutTestPlanNestedInput
    executions?: TestExecutionUncheckedUpdateManyWithoutTestPlanNestedInput
  }

  export type UserUpsertWithoutQaReviewsInput = {
    update: XOR<UserUpdateWithoutQaReviewsInput, UserUncheckedUpdateWithoutQaReviewsInput>
    create: XOR<UserCreateWithoutQaReviewsInput, UserUncheckedCreateWithoutQaReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQaReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQaReviewsInput, UserUncheckedUpdateWithoutQaReviewsInput>
  }

  export type UserUpdateWithoutQaReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedAccounts?: AccountUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUpdateManyWithoutAssignedToNestedInput
  }

  export type UserUncheckedUpdateWithoutQaReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedAccounts?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUncheckedUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUncheckedUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUncheckedUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUncheckedUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUncheckedUpdateManyWithoutAssignedToNestedInput
  }

  export type AccountCreateManyOwnerInput = {
    id?: string
    orgId?: string | null
    name: string
    legalName?: string | null
    emails?: AccountCreateemailsInput | string[]
    phones?: AccountCreatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountCreatetagsInput | string[]
    status?: $Enums.AccountStatus
    portalToken?: string
    designFeePaid?: boolean
    consentMarketing?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
  }

  export type ActivityCreateManyUserInput = {
    id?: string
    accountId: string
    enquiryId?: string | null
    leadId?: string | null
    projectId?: string | null
    type: $Enums.ActivityType
    threadKey?: string | null
    summary?: string | null
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: Date | string
    createdAt?: Date | string
  }

  export type CompletedProjectCreateManyOwnerInput = {
    id?: string
    accountId: string
    projectId?: string | null
    title: string
    description?: string | null
    status?: $Enums.CompletedProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnquiryCreateManyOwnerInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.EnquiryStatus
    priority?: $Enums.Priority
    source?: string | null
    campaign?: string | null
    medium?: string | null
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    contactMethod?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    company?: string | null
    message?: string | null
    accountId?: string | null
    leadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
  }

  export type LeadCreateManyOwnerInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    accountId: string
    enquiryId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
  }

  export type ProjectCreateManyOwnerInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    accountId: string
    amountGrossIncVat: number
    vatRate?: number
    probability?: number
    source?: string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    leadId?: string | null
    completedProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateManyAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    accountId: string
    enquiryId?: string | null
    leadId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyCreatedByInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: string | null
  }

  export type UserCreateManyUpdatedByInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    avatarUrl?: string | null
    timezone?: string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type WorkflowDefinitionCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    triggerType: $Enums.WorkflowTriggerType
    triggerConditions: JsonNullValueInput | InputJsonValue
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowInstanceCreateManyInitiatedByInput = {
    id?: string
    workflowId: string
    entityType: string
    entityId: string
    status: $Enums.WorkflowStatus
    currentStepId?: string | null
    priority?: $Enums.Priority
    startedAt?: Date | string
    completedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId: string
  }

  export type WorkflowStepExecutionCreateManyAssignedToInput = {
    id?: string
    instanceId: string
    stepId: string
    status: $Enums.WorkflowStepStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    retryCount?: number
    isManual?: boolean
  }

  export type WorkflowStepApproverCreateManyUserInput = {
    id?: string
    stepId: string
    approverType: $Enums.ApproverType
    isRequired?: boolean
    order?: number
    createdAt?: Date | string
  }

  export type WorkflowApprovalCreateManyApproverInput = {
    id?: string
    instanceId: string
    stepApproverId: string
    status: $Enums.ApprovalStatus
    comments?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestedAt?: Date | string
    remindersSent?: number
    lastReminderAt?: Date | string | null
  }

  export type WorkflowTemplateCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    industry?: string
    templateData: JsonNullValueInput | InputJsonValue
    isPublic?: boolean
    usageCount?: number
    rating?: number | null
    accountId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workflowId?: string | null
  }

  export type AutomationRuleCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    triggerEvent: string
    conditions: JsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    priority?: number
    executionCount?: number
    lastExecutedAt?: Date | string | null
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestPlanCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    version?: string
    status?: $Enums.TestPlanStatus
    projectId?: string | null
    feature?: string | null
    environment?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestPlanCreateManyAssignedToInput = {
    id?: string
    name: string
    description?: string | null
    version?: string
    status?: $Enums.TestPlanStatus
    projectId?: string | null
    feature?: string | null
    environment?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestCaseCreateManyCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    preconditions?: string | null
    steps: JsonNullValueInput | InputJsonValue
    expectedResult?: string | null
    priority?: $Enums.TestCasePriority
    status?: $Enums.TestCaseStatus
    tags?: TestCaseCreatetagsInput | string[]
    automatable?: boolean
    estimatedTime?: number | null
    testPlanId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestExecutionCreateManyExecutedByInput = {
    id?: string
    testPlanId: string
    testCaseId: string
    status?: $Enums.TestExecutionStatus
    result?: string | null
    actualResult?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: number | null
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    notes?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DefectCreateManyReportedByInput = {
    id?: string
    title: string
    description: string
    steps?: string | null
    expectedBehavior?: string | null
    actualBehavior?: string | null
    severity?: $Enums.DefectSeverity
    priority?: $Enums.DefectPriority
    status?: $Enums.DefectStatus
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: boolean
    regression?: boolean
    testExecutionId?: string | null
    assignedToId?: string | null
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DefectCreateManyAssignedToInput = {
    id?: string
    title: string
    description: string
    steps?: string | null
    expectedBehavior?: string | null
    actualBehavior?: string | null
    severity?: $Enums.DefectSeverity
    priority?: $Enums.DefectPriority
    status?: $Enums.DefectStatus
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: boolean
    regression?: boolean
    testExecutionId?: string | null
    reportedById: string
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QAReviewCreateManyReviewerInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    entityId: string
    status?: $Enums.QAReviewStatus
    criteria?: NullableJsonNullValueInput | InputJsonValue
    findings?: string | null
    recommendations?: string | null
    approved?: boolean | null
    testPlanId?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUpdateManyWithoutAccountNestedInput
    contacts?: ContactUpdateManyWithoutAccountNestedInput
    documents?: DocumentUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUpdateManyWithoutAccountNestedInput
    events?: EventLogUpdateManyWithoutAccountNestedInput
    leads?: LeadUpdateManyWithoutAccountNestedInput
    projects?: ProjectUpdateManyWithoutAccountNestedInput
    snags?: SnagUpdateManyWithoutAccountNestedInput
    tasks?: TaskUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutAccountNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAccountNestedInput
    completedProjects?: CompletedProjectUncheckedUpdateManyWithoutAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAccountNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAccountNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutAccountNestedInput
    events?: EventLogUncheckedUpdateManyWithoutAccountNestedInput
    leads?: LeadUncheckedUpdateManyWithoutAccountNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutAccountNestedInput
    snags?: SnagUncheckedUpdateManyWithoutAccountNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAccountNestedInput
    workflows?: WorkflowDefinitionUncheckedUpdateManyWithoutAccountNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutAccountNestedInput
    workflowTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutAccountNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: AccountUpdateemailsInput | string[]
    phones?: AccountUpdatephonesInput | string[]
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    siteAddresses?: NullableJsonNullValueInput | InputJsonValue
    tags?: AccountUpdatetagsInput | string[]
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    portalToken?: StringFieldUpdateOperationsInput | string
    designFeePaid?: BoolFieldUpdateOperationsInput | boolean
    consentMarketing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    threadKey?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutActivitiesNestedInput
    enquiry?: EnquiryUpdateOneWithoutActivitiesNestedInput
    lead?: LeadUpdateOneWithoutActivitiesNestedInput
    project?: ProjectUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    threadKey?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    threadKey?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompletedProjectUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompletedProjectStatusFieldUpdateOperationsInput | $Enums.CompletedProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutCompletedProjectsNestedInput
    project?: ProjectUpdateOneWithoutCompletedProjectNestedInput
  }

  export type CompletedProjectUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompletedProjectStatusFieldUpdateOperationsInput | $Enums.CompletedProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompletedProjectUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompletedProjectStatusFieldUpdateOperationsInput | $Enums.CompletedProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnquiryUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnquiryStatusFieldUpdateOperationsInput | $Enums.EnquiryStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutEnquiryNestedInput
    account?: AccountUpdateOneWithoutEnquiriesNestedInput
    lead?: LeadUpdateOneWithoutEnquiryNestedInput
    tasks?: TaskUpdateManyWithoutEnquiryNestedInput
  }

  export type EnquiryUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnquiryStatusFieldUpdateOperationsInput | $Enums.EnquiryStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutEnquiryNestedInput
    lead?: LeadUncheckedUpdateOneWithoutEnquiryNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutEnquiryNestedInput
  }

  export type EnquiryUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnquiryStatusFieldUpdateOperationsInput | $Enums.EnquiryStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeadUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutLeadNestedInput
    account?: AccountUpdateOneRequiredWithoutLeadsNestedInput
    enquiry?: EnquiryUpdateOneWithoutLeadNestedInput
    project?: ProjectUpdateOneWithoutLeadNestedInput
    tasks?: TaskUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutLeadNestedInput
    project?: ProjectUncheckedUpdateOneWithoutLeadNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    amountGrossIncVat?: IntFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    completedProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    appointments?: AppointmentUpdateManyWithoutProjectNestedInput
    completedProject?: CompletedProjectUpdateOneWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    account?: AccountUpdateOneRequiredWithoutProjectsNestedInput
    lead?: LeadUpdateOneWithoutProjectNestedInput
    snags?: SnagUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    accountId?: StringFieldUpdateOperationsInput | string
    amountGrossIncVat?: IntFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    completedProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutProjectNestedInput
    completedProject?: CompletedProjectUncheckedUpdateOneWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    snags?: SnagUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    accountId?: StringFieldUpdateOperationsInput | string
    amountGrossIncVat?: IntFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    completedProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutTasksNestedInput
    enquiry?: EnquiryUpdateOneWithoutTasksNestedInput
    lead?: LeadUpdateOneWithoutTasksNestedInput
    project?: ProjectUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedAccounts?: AccountUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedUsersNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedAccounts?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUncheckedUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUncheckedUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUncheckedUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUncheckedUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUncheckedUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedAccounts?: AccountUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedAccounts?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedCompletedProjects?: CompletedProjectUncheckedUpdateManyWithoutOwnerNestedInput
    ownedEnquiries?: EnquiryUncheckedUpdateManyWithoutOwnerNestedInput
    ownedLeads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedUsers?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdWorkflows?: WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatedWorkflows?: WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByNestedInput
    assignedSteps?: WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToNestedInput
    approverSteps?: WorkflowStepApproverUncheckedUpdateManyWithoutUserNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdTemplates?: WorkflowTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTestPlans?: TestPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedTestPlans?: TestPlanUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    testExecutions?: TestExecutionUncheckedUpdateManyWithoutExecutedByNestedInput
    reportedDefects?: DefectUncheckedUpdateManyWithoutReportedByNestedInput
    assignedDefects?: DefectUncheckedUpdateManyWithoutAssignedToNestedInput
    qaReviews?: QAReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkflowDefinitionUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    triggerType?: EnumWorkflowTriggerTypeFieldUpdateOperationsInput | $Enums.WorkflowTriggerType
    triggerConditions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutWorkflowsNestedInput
    steps?: WorkflowStepUpdateManyWithoutWorkflowNestedInput
    instances?: WorkflowInstanceUpdateManyWithoutWorkflowNestedInput
    templates?: WorkflowTemplateUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowDefinitionUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    triggerType?: EnumWorkflowTriggerTypeFieldUpdateOperationsInput | $Enums.WorkflowTriggerType
    triggerConditions?: JsonNullValueInput | InputJsonValue
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: WorkflowStepUncheckedUpdateManyWithoutWorkflowNestedInput
    instances?: WorkflowInstanceUncheckedUpdateManyWithoutWorkflowNestedInput
    templates?: WorkflowTemplateUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowDefinitionUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    triggerType?: EnumWorkflowTriggerTypeFieldUpdateOperationsInput | $Enums.WorkflowTriggerType
    triggerConditions?: JsonNullValueInput | InputJsonValue
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowInstanceUpdateWithoutInitiatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    workflow?: WorkflowDefinitionUpdateOneRequiredWithoutInstancesNestedInput
    account?: AccountUpdateOneRequiredWithoutWorkflowInstancesNestedInput
    executions?: WorkflowStepExecutionUpdateManyWithoutInstanceNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutInstanceNestedInput
  }

  export type WorkflowInstanceUncheckedUpdateWithoutInitiatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId?: StringFieldUpdateOperationsInput | string
    executions?: WorkflowStepExecutionUncheckedUpdateManyWithoutInstanceNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type WorkflowInstanceUncheckedUpdateManyWithoutInitiatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkflowStepExecutionUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStepStatusFieldUpdateOperationsInput | $Enums.WorkflowStepStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    isManual?: BoolFieldUpdateOperationsInput | boolean
    instance?: WorkflowInstanceUpdateOneRequiredWithoutExecutionsNestedInput
    step?: WorkflowStepUpdateOneRequiredWithoutExecutionsNestedInput
  }

  export type WorkflowStepExecutionUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStepStatusFieldUpdateOperationsInput | $Enums.WorkflowStepStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    isManual?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkflowStepExecutionUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStepStatusFieldUpdateOperationsInput | $Enums.WorkflowStepStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    isManual?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkflowStepApproverUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    approverType?: EnumApproverTypeFieldUpdateOperationsInput | $Enums.ApproverType
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    step?: WorkflowStepUpdateOneRequiredWithoutApproversNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutStepApproverNestedInput
  }

  export type WorkflowStepApproverUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    approverType?: EnumApproverTypeFieldUpdateOperationsInput | $Enums.ApproverType
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutStepApproverNestedInput
  }

  export type WorkflowStepApproverUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    approverType?: EnumApproverTypeFieldUpdateOperationsInput | $Enums.ApproverType
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowApprovalUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remindersSent?: IntFieldUpdateOperationsInput | number
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: WorkflowInstanceUpdateOneRequiredWithoutApprovalsNestedInput
    stepApprover?: WorkflowStepApproverUpdateOneRequiredWithoutApprovalsNestedInput
  }

  export type WorkflowApprovalUncheckedUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    stepApproverId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remindersSent?: IntFieldUpdateOperationsInput | number
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkflowApprovalUncheckedUpdateManyWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    stepApproverId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remindersSent?: IntFieldUpdateOperationsInput | number
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkflowTemplateUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    templateData?: JsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutWorkflowTemplatesNestedInput
    workflow?: WorkflowDefinitionUpdateOneWithoutTemplatesNestedInput
  }

  export type WorkflowTemplateUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    templateData?: JsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkflowTemplateUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    templateData?: JsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AutomationRuleUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerEvent?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    executionCount?: IntFieldUpdateOperationsInput | number
    lastExecutedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutAutomationRulesNestedInput
    executions?: AutomationExecutionUpdateManyWithoutRuleNestedInput
  }

  export type AutomationRuleUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerEvent?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    executionCount?: IntFieldUpdateOperationsInput | number
    lastExecutedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: AutomationExecutionUncheckedUpdateManyWithoutRuleNestedInput
  }

  export type AutomationRuleUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerEvent?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    executionCount?: IntFieldUpdateOperationsInput | number
    lastExecutedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestPlanUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumTestPlanStatusFieldUpdateOperationsInput | $Enums.TestPlanStatus
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedTestPlansNestedInput
    testCases?: TestCaseUpdateManyWithoutTestPlanNestedInput
    executions?: TestExecutionUpdateManyWithoutTestPlanNestedInput
    reviews?: QAReviewUpdateManyWithoutTestPlanNestedInput
  }

  export type TestPlanUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumTestPlanStatusFieldUpdateOperationsInput | $Enums.TestPlanStatus
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testCases?: TestCaseUncheckedUpdateManyWithoutTestPlanNestedInput
    executions?: TestExecutionUncheckedUpdateManyWithoutTestPlanNestedInput
    reviews?: QAReviewUncheckedUpdateManyWithoutTestPlanNestedInput
  }

  export type TestPlanUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumTestPlanStatusFieldUpdateOperationsInput | $Enums.TestPlanStatus
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestPlanUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumTestPlanStatusFieldUpdateOperationsInput | $Enums.TestPlanStatus
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTestPlansNestedInput
    testCases?: TestCaseUpdateManyWithoutTestPlanNestedInput
    executions?: TestExecutionUpdateManyWithoutTestPlanNestedInput
    reviews?: QAReviewUpdateManyWithoutTestPlanNestedInput
  }

  export type TestPlanUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumTestPlanStatusFieldUpdateOperationsInput | $Enums.TestPlanStatus
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testCases?: TestCaseUncheckedUpdateManyWithoutTestPlanNestedInput
    executions?: TestExecutionUncheckedUpdateManyWithoutTestPlanNestedInput
    reviews?: QAReviewUncheckedUpdateManyWithoutTestPlanNestedInput
  }

  export type TestPlanUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumTestPlanStatusFieldUpdateOperationsInput | $Enums.TestPlanStatus
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestCaseUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    steps?: JsonNullValueInput | InputJsonValue
    expectedResult?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTestCasePriorityFieldUpdateOperationsInput | $Enums.TestCasePriority
    status?: EnumTestCaseStatusFieldUpdateOperationsInput | $Enums.TestCaseStatus
    tags?: TestCaseUpdatetagsInput | string[]
    automatable?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testPlan?: TestPlanUpdateOneRequiredWithoutTestCasesNestedInput
    executions?: TestExecutionUpdateManyWithoutTestCaseNestedInput
    defects?: DefectTestCaseUpdateManyWithoutTestCaseNestedInput
  }

  export type TestCaseUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    steps?: JsonNullValueInput | InputJsonValue
    expectedResult?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTestCasePriorityFieldUpdateOperationsInput | $Enums.TestCasePriority
    status?: EnumTestCaseStatusFieldUpdateOperationsInput | $Enums.TestCaseStatus
    tags?: TestCaseUpdatetagsInput | string[]
    automatable?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: NullableIntFieldUpdateOperationsInput | number | null
    testPlanId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: TestExecutionUncheckedUpdateManyWithoutTestCaseNestedInput
    defects?: DefectTestCaseUncheckedUpdateManyWithoutTestCaseNestedInput
  }

  export type TestCaseUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    steps?: JsonNullValueInput | InputJsonValue
    expectedResult?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTestCasePriorityFieldUpdateOperationsInput | $Enums.TestCasePriority
    status?: EnumTestCaseStatusFieldUpdateOperationsInput | $Enums.TestCaseStatus
    tags?: TestCaseUpdatetagsInput | string[]
    automatable?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: NullableIntFieldUpdateOperationsInput | number | null
    testPlanId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestExecutionUpdateWithoutExecutedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTestExecutionStatusFieldUpdateOperationsInput | $Enums.TestExecutionStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    actualResult?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testPlan?: TestPlanUpdateOneRequiredWithoutExecutionsNestedInput
    testCase?: TestCaseUpdateOneRequiredWithoutExecutionsNestedInput
    defects?: DefectUpdateManyWithoutTestExecutionNestedInput
  }

  export type TestExecutionUncheckedUpdateWithoutExecutedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    testPlanId?: StringFieldUpdateOperationsInput | string
    testCaseId?: StringFieldUpdateOperationsInput | string
    status?: EnumTestExecutionStatusFieldUpdateOperationsInput | $Enums.TestExecutionStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    actualResult?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defects?: DefectUncheckedUpdateManyWithoutTestExecutionNestedInput
  }

  export type TestExecutionUncheckedUpdateManyWithoutExecutedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    testPlanId?: StringFieldUpdateOperationsInput | string
    testCaseId?: StringFieldUpdateOperationsInput | string
    status?: EnumTestExecutionStatusFieldUpdateOperationsInput | $Enums.TestExecutionStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    actualResult?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectUpdateWithoutReportedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    expectedBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    actualBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    priority?: EnumDefectPriorityFieldUpdateOperationsInput | $Enums.DefectPriority
    status?: EnumDefectStatusFieldUpdateOperationsInput | $Enums.DefectStatus
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: BoolFieldUpdateOperationsInput | boolean
    regression?: BoolFieldUpdateOperationsInput | boolean
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testExecution?: TestExecutionUpdateOneWithoutDefectsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedDefectsNestedInput
    testCases?: DefectTestCaseUpdateManyWithoutDefectNestedInput
    comments?: DefectCommentUpdateManyWithoutDefectNestedInput
  }

  export type DefectUncheckedUpdateWithoutReportedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    expectedBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    actualBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    priority?: EnumDefectPriorityFieldUpdateOperationsInput | $Enums.DefectPriority
    status?: EnumDefectStatusFieldUpdateOperationsInput | $Enums.DefectStatus
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: BoolFieldUpdateOperationsInput | boolean
    regression?: BoolFieldUpdateOperationsInput | boolean
    testExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testCases?: DefectTestCaseUncheckedUpdateManyWithoutDefectNestedInput
    comments?: DefectCommentUncheckedUpdateManyWithoutDefectNestedInput
  }

  export type DefectUncheckedUpdateManyWithoutReportedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    expectedBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    actualBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    priority?: EnumDefectPriorityFieldUpdateOperationsInput | $Enums.DefectPriority
    status?: EnumDefectStatusFieldUpdateOperationsInput | $Enums.DefectStatus
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: BoolFieldUpdateOperationsInput | boolean
    regression?: BoolFieldUpdateOperationsInput | boolean
    testExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    expectedBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    actualBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    priority?: EnumDefectPriorityFieldUpdateOperationsInput | $Enums.DefectPriority
    status?: EnumDefectStatusFieldUpdateOperationsInput | $Enums.DefectStatus
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: BoolFieldUpdateOperationsInput | boolean
    regression?: BoolFieldUpdateOperationsInput | boolean
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testExecution?: TestExecutionUpdateOneWithoutDefectsNestedInput
    reportedBy?: UserUpdateOneRequiredWithoutReportedDefectsNestedInput
    testCases?: DefectTestCaseUpdateManyWithoutDefectNestedInput
    comments?: DefectCommentUpdateManyWithoutDefectNestedInput
  }

  export type DefectUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    expectedBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    actualBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    priority?: EnumDefectPriorityFieldUpdateOperationsInput | $Enums.DefectPriority
    status?: EnumDefectStatusFieldUpdateOperationsInput | $Enums.DefectStatus
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: BoolFieldUpdateOperationsInput | boolean
    regression?: BoolFieldUpdateOperationsInput | boolean
    testExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedById?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testCases?: DefectTestCaseUncheckedUpdateManyWithoutDefectNestedInput
    comments?: DefectCommentUncheckedUpdateManyWithoutDefectNestedInput
  }

  export type DefectUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    expectedBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    actualBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    priority?: EnumDefectPriorityFieldUpdateOperationsInput | $Enums.DefectPriority
    status?: EnumDefectStatusFieldUpdateOperationsInput | $Enums.DefectStatus
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: BoolFieldUpdateOperationsInput | boolean
    regression?: BoolFieldUpdateOperationsInput | boolean
    testExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedById?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QAReviewUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumQAReviewStatusFieldUpdateOperationsInput | $Enums.QAReviewStatus
    criteria?: NullableJsonNullValueInput | InputJsonValue
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testPlan?: TestPlanUpdateOneWithoutReviewsNestedInput
  }

  export type QAReviewUncheckedUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumQAReviewStatusFieldUpdateOperationsInput | $Enums.QAReviewStatus
    criteria?: NullableJsonNullValueInput | InputJsonValue
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    testPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QAReviewUncheckedUpdateManyWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumQAReviewStatusFieldUpdateOperationsInput | $Enums.QAReviewStatus
    criteria?: NullableJsonNullValueInput | InputJsonValue
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    testPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyAccountInput = {
    id?: string
    enquiryId?: string | null
    leadId?: string | null
    projectId?: string | null
    userId?: string | null
    type: $Enums.ActivityType
    threadKey?: string | null
    summary?: string | null
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: Date | string
    createdAt?: Date | string
  }

  export type AppointmentCreateManyAccountInput = {
    id?: string
    projectId?: string | null
    title: string
    description?: string | null
    type: $Enums.AppointmentType
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    status?: $Enums.AppointmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompletedProjectCreateManyAccountInput = {
    id?: string
    projectId?: string | null
    ownerId: string
    title: string
    description?: string | null
    status?: $Enums.CompletedProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateManyAccountInput = {
    id?: string
    name: string
    role?: string | null
    email?: string | null
    phone?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyAccountInput = {
    id?: string
    projectId?: string | null
    filename: string
    fileUrl: string
    fileSize?: number | null
    mimeType?: string | null
    type?: $Enums.DocumentType
    uploadedBy?: string | null
    createdAt?: Date | string
  }

  export type EnquiryCreateManyAccountInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.EnquiryStatus
    priority?: $Enums.Priority
    source?: string | null
    campaign?: string | null
    medium?: string | null
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    contactMethod?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    mobile?: string | null
    company?: string | null
    message?: string | null
    ownerId: string
    leadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
  }

  export type EventLogCreateManyAccountInput = {
    id?: string
    actorId?: string | null
    entity: string
    entityId: string
    action: string
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LeadCreateManyAccountInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.LeadStatus
    priority?: $Enums.Priority
    estimatedValue?: Decimal | DecimalJsLike | number | string | null
    probability?: number
    expectedCloseDate?: Date | string | null
    source?: string | null
    campaign?: string | null
    medium?: string | null
    firstResponseAt?: Date | string | null
    responseTime?: number | null
    ownerId: string
    enquiryId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
  }

  export type ProjectCreateManyAccountInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    ownerId: string
    amountGrossIncVat: number
    vatRate?: number
    probability?: number
    source?: string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    leadId?: string | null
    completedProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SnagCreateManyAccountInput = {
    id?: string
    projectId: string
    title: string
    description: string
    status?: $Enums.SnagStatus
    priority?: $Enums.Priority
    assigneeId?: string | null
    dueAt?: Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateManyAccountInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    assigneeId: string
    enquiryId?: string | null
    leadId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowDefinitionCreateManyAccountInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    triggerType: $Enums.WorkflowTriggerType
    triggerConditions: JsonNullValueInput | InputJsonValue
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowInstanceCreateManyAccountInput = {
    id?: string
    workflowId: string
    entityType: string
    entityId: string
    status: $Enums.WorkflowStatus
    currentStepId?: string | null
    priority?: $Enums.Priority
    startedAt?: Date | string
    completedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedById: string
  }

  export type WorkflowTemplateCreateManyAccountInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    industry?: string
    templateData: JsonNullValueInput | InputJsonValue
    isPublic?: boolean
    usageCount?: number
    rating?: number | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workflowId?: string | null
  }

  export type AutomationRuleCreateManyAccountInput = {
    id?: string
    name: string
    description?: string | null
    triggerEvent: string
    conditions: JsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    priority?: number
    executionCount?: number
    lastExecutedAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    threadKey?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enquiry?: EnquiryUpdateOneWithoutActivitiesNestedInput
    lead?: LeadUpdateOneWithoutActivitiesNestedInput
    project?: ProjectUpdateOneWithoutActivitiesNestedInput
    user?: UserUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    threadKey?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    threadKey?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompletedProjectUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompletedProjectStatusFieldUpdateOperationsInput | $Enums.CompletedProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedCompletedProjectsNestedInput
    project?: ProjectUpdateOneWithoutCompletedProjectNestedInput
  }

  export type CompletedProjectUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompletedProjectStatusFieldUpdateOperationsInput | $Enums.CompletedProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompletedProjectUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompletedProjectStatusFieldUpdateOperationsInput | $Enums.CompletedProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnquiryUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnquiryStatusFieldUpdateOperationsInput | $Enums.EnquiryStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutEnquiryNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedEnquiriesNestedInput
    lead?: LeadUpdateOneWithoutEnquiryNestedInput
    tasks?: TaskUpdateManyWithoutEnquiryNestedInput
  }

  export type EnquiryUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnquiryStatusFieldUpdateOperationsInput | $Enums.EnquiryStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutEnquiryNestedInput
    lead?: LeadUncheckedUpdateOneWithoutEnquiryNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutEnquiryNestedInput
  }

  export type EnquiryUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnquiryStatusFieldUpdateOperationsInput | $Enums.EnquiryStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventLogUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventLogUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventLogUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutLeadNestedInput
    enquiry?: EnquiryUpdateOneWithoutLeadNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedLeadsNestedInput
    project?: ProjectUpdateOneWithoutLeadNestedInput
    tasks?: TaskUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutLeadNestedInput
    project?: ProjectUncheckedUpdateOneWithoutLeadNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    estimatedValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    amountGrossIncVat?: IntFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    completedProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    appointments?: AppointmentUpdateManyWithoutProjectNestedInput
    completedProject?: CompletedProjectUpdateOneWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    lead?: LeadUpdateOneWithoutProjectNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    snags?: SnagUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    ownerId?: StringFieldUpdateOperationsInput | string
    amountGrossIncVat?: IntFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    completedProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutProjectNestedInput
    completedProject?: CompletedProjectUncheckedUpdateOneWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    snags?: SnagUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    ownerId?: StringFieldUpdateOperationsInput | string
    amountGrossIncVat?: IntFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    probability?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utm?: NullableJsonNullValueInput | InputJsonValue
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    completedProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnagUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSnagStatusFieldUpdateOperationsInput | $Enums.SnagStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSnagsNestedInput
  }

  export type SnagUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSnagStatusFieldUpdateOperationsInput | $Enums.SnagStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnagUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSnagStatusFieldUpdateOperationsInput | $Enums.SnagStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignee?: UserUpdateOneRequiredWithoutAssignedTasksNestedInput
    enquiry?: EnquiryUpdateOneWithoutTasksNestedInput
    lead?: LeadUpdateOneWithoutTasksNestedInput
    project?: ProjectUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowDefinitionUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    triggerType?: EnumWorkflowTriggerTypeFieldUpdateOperationsInput | $Enums.WorkflowTriggerType
    triggerConditions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedWorkflowsNestedInput
    steps?: WorkflowStepUpdateManyWithoutWorkflowNestedInput
    instances?: WorkflowInstanceUpdateManyWithoutWorkflowNestedInput
    templates?: WorkflowTemplateUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowDefinitionUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    triggerType?: EnumWorkflowTriggerTypeFieldUpdateOperationsInput | $Enums.WorkflowTriggerType
    triggerConditions?: JsonNullValueInput | InputJsonValue
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: WorkflowStepUncheckedUpdateManyWithoutWorkflowNestedInput
    instances?: WorkflowInstanceUncheckedUpdateManyWithoutWorkflowNestedInput
    templates?: WorkflowTemplateUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowDefinitionUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    triggerType?: EnumWorkflowTriggerTypeFieldUpdateOperationsInput | $Enums.WorkflowTriggerType
    triggerConditions?: JsonNullValueInput | InputJsonValue
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowInstanceUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    workflow?: WorkflowDefinitionUpdateOneRequiredWithoutInstancesNestedInput
    initiatedBy?: UserUpdateOneRequiredWithoutInitiatedWorkflowsNestedInput
    executions?: WorkflowStepExecutionUpdateManyWithoutInstanceNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutInstanceNestedInput
  }

  export type WorkflowInstanceUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedById?: StringFieldUpdateOperationsInput | string
    executions?: WorkflowStepExecutionUncheckedUpdateManyWithoutInstanceNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type WorkflowInstanceUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedById?: StringFieldUpdateOperationsInput | string
  }

  export type WorkflowTemplateUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    templateData?: JsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTemplatesNestedInput
    workflow?: WorkflowDefinitionUpdateOneWithoutTemplatesNestedInput
  }

  export type WorkflowTemplateUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    templateData?: JsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkflowTemplateUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    templateData?: JsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AutomationRuleUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerEvent?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    executionCount?: IntFieldUpdateOperationsInput | number
    lastExecutedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedRulesNestedInput
    executions?: AutomationExecutionUpdateManyWithoutRuleNestedInput
  }

  export type AutomationRuleUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerEvent?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    executionCount?: IntFieldUpdateOperationsInput | number
    lastExecutedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: AutomationExecutionUncheckedUpdateManyWithoutRuleNestedInput
  }

  export type AutomationRuleUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerEvent?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    executionCount?: IntFieldUpdateOperationsInput | number
    lastExecutedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyEnquiryInput = {
    id?: string
    accountId: string
    leadId?: string | null
    projectId?: string | null
    userId?: string | null
    type: $Enums.ActivityType
    threadKey?: string | null
    summary?: string | null
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: Date | string
    createdAt?: Date | string
  }

  export type TaskCreateManyEnquiryInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    assigneeId: string
    accountId: string
    leadId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateWithoutEnquiryInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    threadKey?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutActivitiesNestedInput
    lead?: LeadUpdateOneWithoutActivitiesNestedInput
    project?: ProjectUpdateOneWithoutActivitiesNestedInput
    user?: UserUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutEnquiryInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    threadKey?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutEnquiryInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    threadKey?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutEnquiryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutTasksNestedInput
    assignee?: UserUpdateOneRequiredWithoutAssignedTasksNestedInput
    lead?: LeadUpdateOneWithoutTasksNestedInput
    project?: ProjectUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutEnquiryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutEnquiryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyLeadInput = {
    id?: string
    accountId: string
    enquiryId?: string | null
    projectId?: string | null
    userId?: string | null
    type: $Enums.ActivityType
    threadKey?: string | null
    summary?: string | null
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: Date | string
    createdAt?: Date | string
  }

  export type TaskCreateManyLeadInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    assigneeId: string
    accountId: string
    enquiryId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    threadKey?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutActivitiesNestedInput
    enquiry?: EnquiryUpdateOneWithoutActivitiesNestedInput
    project?: ProjectUpdateOneWithoutActivitiesNestedInput
    user?: UserUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    threadKey?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    threadKey?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutTasksNestedInput
    assignee?: UserUpdateOneRequiredWithoutAssignedTasksNestedInput
    enquiry?: EnquiryUpdateOneWithoutTasksNestedInput
    project?: ProjectUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyProjectInput = {
    id?: string
    accountId: string
    enquiryId?: string | null
    leadId?: string | null
    userId?: string | null
    type: $Enums.ActivityType
    threadKey?: string | null
    summary?: string | null
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: Date | string
    createdAt?: Date | string
  }

  export type AppointmentCreateManyProjectInput = {
    id?: string
    accountId: string
    title: string
    description?: string | null
    type: $Enums.AppointmentType
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    status?: $Enums.AppointmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyProjectInput = {
    id?: string
    accountId: string
    filename: string
    fileUrl: string
    fileSize?: number | null
    mimeType?: string | null
    type?: $Enums.DocumentType
    uploadedBy?: string | null
    createdAt?: Date | string
  }

  export type SnagCreateManyProjectInput = {
    id?: string
    accountId: string
    title: string
    description: string
    status?: $Enums.SnagStatus
    priority?: $Enums.Priority
    assigneeId?: string | null
    dueAt?: Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateManyProjectInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    assigneeId: string
    accountId: string
    enquiryId?: string | null
    leadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    threadKey?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutActivitiesNestedInput
    enquiry?: EnquiryUpdateOneWithoutActivitiesNestedInput
    lead?: LeadUpdateOneWithoutActivitiesNestedInput
    user?: UserUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    threadKey?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    threadKey?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    durations?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnagUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSnagStatusFieldUpdateOperationsInput | $Enums.SnagStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutSnagsNestedInput
  }

  export type SnagUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSnagStatusFieldUpdateOperationsInput | $Enums.SnagStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnagUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSnagStatusFieldUpdateOperationsInput | $Enums.SnagStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutTasksNestedInput
    assignee?: UserUpdateOneRequiredWithoutAssignedTasksNestedInput
    enquiry?: EnquiryUpdateOneWithoutTasksNestedInput
    lead?: LeadUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowStepCreateManyWorkflowInput = {
    id?: string
    name: string
    description?: string | null
    stepType: $Enums.WorkflowStepType
    position: number
    configuration: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    timeoutMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowInstanceCreateManyWorkflowInput = {
    id?: string
    entityType: string
    entityId: string
    status: $Enums.WorkflowStatus
    currentStepId?: string | null
    priority?: $Enums.Priority
    startedAt?: Date | string
    completedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId: string
    initiatedById: string
  }

  export type WorkflowTemplateCreateManyWorkflowInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    industry?: string
    templateData: JsonNullValueInput | InputJsonValue
    isPublic?: boolean
    usageCount?: number
    rating?: number | null
    accountId?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowStepUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    position?: IntFieldUpdateOperationsInput | number
    configuration?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    timeoutMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: WorkflowStepExecutionUpdateManyWithoutStepNestedInput
    approvers?: WorkflowStepApproverUpdateManyWithoutStepNestedInput
  }

  export type WorkflowStepUncheckedUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    position?: IntFieldUpdateOperationsInput | number
    configuration?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    timeoutMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: WorkflowStepExecutionUncheckedUpdateManyWithoutStepNestedInput
    approvers?: WorkflowStepApproverUncheckedUpdateManyWithoutStepNestedInput
  }

  export type WorkflowStepUncheckedUpdateManyWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    position?: IntFieldUpdateOperationsInput | number
    configuration?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    timeoutMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowInstanceUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    account?: AccountUpdateOneRequiredWithoutWorkflowInstancesNestedInput
    initiatedBy?: UserUpdateOneRequiredWithoutInitiatedWorkflowsNestedInput
    executions?: WorkflowStepExecutionUpdateManyWithoutInstanceNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutInstanceNestedInput
  }

  export type WorkflowInstanceUncheckedUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId?: StringFieldUpdateOperationsInput | string
    initiatedById?: StringFieldUpdateOperationsInput | string
    executions?: WorkflowStepExecutionUncheckedUpdateManyWithoutInstanceNestedInput
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type WorkflowInstanceUncheckedUpdateManyWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId?: StringFieldUpdateOperationsInput | string
    initiatedById?: StringFieldUpdateOperationsInput | string
  }

  export type WorkflowTemplateUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    templateData?: JsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutWorkflowTemplatesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTemplatesNestedInput
  }

  export type WorkflowTemplateUncheckedUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    templateData?: JsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowTemplateUncheckedUpdateManyWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    templateData?: JsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowStepExecutionCreateManyStepInput = {
    id?: string
    instanceId: string
    status: $Enums.WorkflowStepStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    assignedToId?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    retryCount?: number
    isManual?: boolean
  }

  export type WorkflowStepApproverCreateManyStepInput = {
    id?: string
    userId: string
    approverType: $Enums.ApproverType
    isRequired?: boolean
    order?: number
    createdAt?: Date | string
  }

  export type WorkflowStepExecutionUpdateWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStepStatusFieldUpdateOperationsInput | $Enums.WorkflowStepStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    isManual?: BoolFieldUpdateOperationsInput | boolean
    instance?: WorkflowInstanceUpdateOneRequiredWithoutExecutionsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedStepsNestedInput
  }

  export type WorkflowStepExecutionUncheckedUpdateWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStepStatusFieldUpdateOperationsInput | $Enums.WorkflowStepStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    isManual?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkflowStepExecutionUncheckedUpdateManyWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStepStatusFieldUpdateOperationsInput | $Enums.WorkflowStepStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    isManual?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkflowStepApproverUpdateWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    approverType?: EnumApproverTypeFieldUpdateOperationsInput | $Enums.ApproverType
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutApproverStepsNestedInput
    approvals?: WorkflowApprovalUpdateManyWithoutStepApproverNestedInput
  }

  export type WorkflowStepApproverUncheckedUpdateWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    approverType?: EnumApproverTypeFieldUpdateOperationsInput | $Enums.ApproverType
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvals?: WorkflowApprovalUncheckedUpdateManyWithoutStepApproverNestedInput
  }

  export type WorkflowStepApproverUncheckedUpdateManyWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    approverType?: EnumApproverTypeFieldUpdateOperationsInput | $Enums.ApproverType
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowApprovalCreateManyStepApproverInput = {
    id?: string
    instanceId: string
    approverId: string
    status: $Enums.ApprovalStatus
    comments?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestedAt?: Date | string
    remindersSent?: number
    lastReminderAt?: Date | string | null
  }

  export type WorkflowApprovalUpdateWithoutStepApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remindersSent?: IntFieldUpdateOperationsInput | number
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: WorkflowInstanceUpdateOneRequiredWithoutApprovalsNestedInput
    approver?: UserUpdateOneRequiredWithoutApprovalsNestedInput
  }

  export type WorkflowApprovalUncheckedUpdateWithoutStepApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remindersSent?: IntFieldUpdateOperationsInput | number
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkflowApprovalUncheckedUpdateManyWithoutStepApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remindersSent?: IntFieldUpdateOperationsInput | number
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkflowStepExecutionCreateManyInstanceInput = {
    id?: string
    stepId: string
    status: $Enums.WorkflowStepStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    assignedToId?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    retryCount?: number
    isManual?: boolean
  }

  export type WorkflowApprovalCreateManyInstanceInput = {
    id?: string
    approverId: string
    stepApproverId: string
    status: $Enums.ApprovalStatus
    comments?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestedAt?: Date | string
    remindersSent?: number
    lastReminderAt?: Date | string | null
  }

  export type WorkflowStepExecutionUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStepStatusFieldUpdateOperationsInput | $Enums.WorkflowStepStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    isManual?: BoolFieldUpdateOperationsInput | boolean
    step?: WorkflowStepUpdateOneRequiredWithoutExecutionsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedStepsNestedInput
  }

  export type WorkflowStepExecutionUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStepStatusFieldUpdateOperationsInput | $Enums.WorkflowStepStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    isManual?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkflowStepExecutionUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStepStatusFieldUpdateOperationsInput | $Enums.WorkflowStepStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    isManual?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkflowApprovalUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remindersSent?: IntFieldUpdateOperationsInput | number
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approver?: UserUpdateOneRequiredWithoutApprovalsNestedInput
    stepApprover?: WorkflowStepApproverUpdateOneRequiredWithoutApprovalsNestedInput
  }

  export type WorkflowApprovalUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    stepApproverId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remindersSent?: IntFieldUpdateOperationsInput | number
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkflowApprovalUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    stepApproverId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remindersSent?: IntFieldUpdateOperationsInput | number
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AutomationExecutionCreateManyRuleInput = {
    id?: string
    triggerData: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.AutomationStatus
    errorMessage?: string | null
    executedAt?: Date | string
    durationMs?: number | null
  }

  export type AutomationExecutionUpdateWithoutRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    triggerData?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AutomationExecutionUncheckedUpdateWithoutRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    triggerData?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AutomationExecutionUncheckedUpdateManyWithoutRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    triggerData?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TestCaseCreateManyTestPlanInput = {
    id?: string
    title: string
    description?: string | null
    preconditions?: string | null
    steps: JsonNullValueInput | InputJsonValue
    expectedResult?: string | null
    priority?: $Enums.TestCasePriority
    status?: $Enums.TestCaseStatus
    tags?: TestCaseCreatetagsInput | string[]
    automatable?: boolean
    estimatedTime?: number | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestExecutionCreateManyTestPlanInput = {
    id?: string
    testCaseId: string
    status?: $Enums.TestExecutionStatus
    result?: string | null
    actualResult?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: number | null
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    notes?: string | null
    executedById: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QAReviewCreateManyTestPlanInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    entityId: string
    status?: $Enums.QAReviewStatus
    criteria?: NullableJsonNullValueInput | InputJsonValue
    findings?: string | null
    recommendations?: string | null
    approved?: boolean | null
    reviewerId: string
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestCaseUpdateWithoutTestPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    steps?: JsonNullValueInput | InputJsonValue
    expectedResult?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTestCasePriorityFieldUpdateOperationsInput | $Enums.TestCasePriority
    status?: EnumTestCaseStatusFieldUpdateOperationsInput | $Enums.TestCaseStatus
    tags?: TestCaseUpdatetagsInput | string[]
    automatable?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTestCasesNestedInput
    executions?: TestExecutionUpdateManyWithoutTestCaseNestedInput
    defects?: DefectTestCaseUpdateManyWithoutTestCaseNestedInput
  }

  export type TestCaseUncheckedUpdateWithoutTestPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    steps?: JsonNullValueInput | InputJsonValue
    expectedResult?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTestCasePriorityFieldUpdateOperationsInput | $Enums.TestCasePriority
    status?: EnumTestCaseStatusFieldUpdateOperationsInput | $Enums.TestCaseStatus
    tags?: TestCaseUpdatetagsInput | string[]
    automatable?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: TestExecutionUncheckedUpdateManyWithoutTestCaseNestedInput
    defects?: DefectTestCaseUncheckedUpdateManyWithoutTestCaseNestedInput
  }

  export type TestCaseUncheckedUpdateManyWithoutTestPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    steps?: JsonNullValueInput | InputJsonValue
    expectedResult?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTestCasePriorityFieldUpdateOperationsInput | $Enums.TestCasePriority
    status?: EnumTestCaseStatusFieldUpdateOperationsInput | $Enums.TestCaseStatus
    tags?: TestCaseUpdatetagsInput | string[]
    automatable?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestExecutionUpdateWithoutTestPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTestExecutionStatusFieldUpdateOperationsInput | $Enums.TestExecutionStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    actualResult?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testCase?: TestCaseUpdateOneRequiredWithoutExecutionsNestedInput
    executedBy?: UserUpdateOneRequiredWithoutTestExecutionsNestedInput
    defects?: DefectUpdateManyWithoutTestExecutionNestedInput
  }

  export type TestExecutionUncheckedUpdateWithoutTestPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    testCaseId?: StringFieldUpdateOperationsInput | string
    status?: EnumTestExecutionStatusFieldUpdateOperationsInput | $Enums.TestExecutionStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    actualResult?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    executedById?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defects?: DefectUncheckedUpdateManyWithoutTestExecutionNestedInput
  }

  export type TestExecutionUncheckedUpdateManyWithoutTestPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    testCaseId?: StringFieldUpdateOperationsInput | string
    status?: EnumTestExecutionStatusFieldUpdateOperationsInput | $Enums.TestExecutionStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    actualResult?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    executedById?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QAReviewUpdateWithoutTestPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumQAReviewStatusFieldUpdateOperationsInput | $Enums.QAReviewStatus
    criteria?: NullableJsonNullValueInput | InputJsonValue
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewer?: UserUpdateOneRequiredWithoutQaReviewsNestedInput
  }

  export type QAReviewUncheckedUpdateWithoutTestPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumQAReviewStatusFieldUpdateOperationsInput | $Enums.QAReviewStatus
    criteria?: NullableJsonNullValueInput | InputJsonValue
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reviewerId?: StringFieldUpdateOperationsInput | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QAReviewUncheckedUpdateManyWithoutTestPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumQAReviewStatusFieldUpdateOperationsInput | $Enums.QAReviewStatus
    criteria?: NullableJsonNullValueInput | InputJsonValue
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reviewerId?: StringFieldUpdateOperationsInput | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestExecutionCreateManyTestCaseInput = {
    id?: string
    testPlanId: string
    status?: $Enums.TestExecutionStatus
    result?: string | null
    actualResult?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: number | null
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    notes?: string | null
    executedById: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DefectTestCaseCreateManyTestCaseInput = {
    id?: string
    defectId: string
    createdAt?: Date | string
  }

  export type TestExecutionUpdateWithoutTestCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTestExecutionStatusFieldUpdateOperationsInput | $Enums.TestExecutionStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    actualResult?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testPlan?: TestPlanUpdateOneRequiredWithoutExecutionsNestedInput
    executedBy?: UserUpdateOneRequiredWithoutTestExecutionsNestedInput
    defects?: DefectUpdateManyWithoutTestExecutionNestedInput
  }

  export type TestExecutionUncheckedUpdateWithoutTestCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    testPlanId?: StringFieldUpdateOperationsInput | string
    status?: EnumTestExecutionStatusFieldUpdateOperationsInput | $Enums.TestExecutionStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    actualResult?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    executedById?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defects?: DefectUncheckedUpdateManyWithoutTestExecutionNestedInput
  }

  export type TestExecutionUncheckedUpdateManyWithoutTestCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    testPlanId?: StringFieldUpdateOperationsInput | string
    status?: EnumTestExecutionStatusFieldUpdateOperationsInput | $Enums.TestExecutionStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    actualResult?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    executedById?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectTestCaseUpdateWithoutTestCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defect?: DefectUpdateOneRequiredWithoutTestCasesNestedInput
  }

  export type DefectTestCaseUncheckedUpdateWithoutTestCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    defectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectTestCaseUncheckedUpdateManyWithoutTestCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    defectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectCreateManyTestExecutionInput = {
    id?: string
    title: string
    description: string
    steps?: string | null
    expectedBehavior?: string | null
    actualBehavior?: string | null
    severity?: $Enums.DefectSeverity
    priority?: $Enums.DefectPriority
    status?: $Enums.DefectStatus
    environment?: string | null
    browserVersion?: string | null
    osVersion?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: boolean
    regression?: boolean
    reportedById: string
    assignedToId?: string | null
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DefectUpdateWithoutTestExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    expectedBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    actualBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    priority?: EnumDefectPriorityFieldUpdateOperationsInput | $Enums.DefectPriority
    status?: EnumDefectStatusFieldUpdateOperationsInput | $Enums.DefectStatus
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: BoolFieldUpdateOperationsInput | boolean
    regression?: BoolFieldUpdateOperationsInput | boolean
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedBy?: UserUpdateOneRequiredWithoutReportedDefectsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedDefectsNestedInput
    testCases?: DefectTestCaseUpdateManyWithoutDefectNestedInput
    comments?: DefectCommentUpdateManyWithoutDefectNestedInput
  }

  export type DefectUncheckedUpdateWithoutTestExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    expectedBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    actualBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    priority?: EnumDefectPriorityFieldUpdateOperationsInput | $Enums.DefectPriority
    status?: EnumDefectStatusFieldUpdateOperationsInput | $Enums.DefectStatus
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: BoolFieldUpdateOperationsInput | boolean
    regression?: BoolFieldUpdateOperationsInput | boolean
    reportedById?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testCases?: DefectTestCaseUncheckedUpdateManyWithoutDefectNestedInput
    comments?: DefectCommentUncheckedUpdateManyWithoutDefectNestedInput
  }

  export type DefectUncheckedUpdateManyWithoutTestExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    expectedBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    actualBehavior?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    priority?: EnumDefectPriorityFieldUpdateOperationsInput | $Enums.DefectPriority
    status?: EnumDefectStatusFieldUpdateOperationsInput | $Enums.DefectStatus
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reproducible?: BoolFieldUpdateOperationsInput | boolean
    regression?: BoolFieldUpdateOperationsInput | boolean
    reportedById?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectTestCaseCreateManyDefectInput = {
    id?: string
    testCaseId: string
    createdAt?: Date | string
  }

  export type DefectCommentCreateManyDefectInput = {
    id?: string
    content: string
    authorId: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DefectTestCaseUpdateWithoutDefectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testCase?: TestCaseUpdateOneRequiredWithoutDefectsNestedInput
  }

  export type DefectTestCaseUncheckedUpdateWithoutDefectInput = {
    id?: StringFieldUpdateOperationsInput | string
    testCaseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectTestCaseUncheckedUpdateManyWithoutDefectInput = {
    id?: StringFieldUpdateOperationsInput | string
    testCaseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectCommentUpdateWithoutDefectInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectCommentUncheckedUpdateWithoutDefectInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectCommentUncheckedUpdateManyWithoutDefectInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountCountOutputTypeDefaultArgs instead
     */
    export type AccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EnquiryCountOutputTypeDefaultArgs instead
     */
    export type EnquiryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EnquiryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeadCountOutputTypeDefaultArgs instead
     */
    export type LeadCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeadCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectCountOutputTypeDefaultArgs instead
     */
    export type ProjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowDefinitionCountOutputTypeDefaultArgs instead
     */
    export type WorkflowDefinitionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowDefinitionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowStepCountOutputTypeDefaultArgs instead
     */
    export type WorkflowStepCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowStepCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowStepApproverCountOutputTypeDefaultArgs instead
     */
    export type WorkflowStepApproverCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowStepApproverCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowInstanceCountOutputTypeDefaultArgs instead
     */
    export type WorkflowInstanceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowInstanceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AutomationRuleCountOutputTypeDefaultArgs instead
     */
    export type AutomationRuleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AutomationRuleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestPlanCountOutputTypeDefaultArgs instead
     */
    export type TestPlanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestPlanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestCaseCountOutputTypeDefaultArgs instead
     */
    export type TestCaseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestCaseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestExecutionCountOutputTypeDefaultArgs instead
     */
    export type TestExecutionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestExecutionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DefectCountOutputTypeDefaultArgs instead
     */
    export type DefectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DefectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EnquiryDefaultArgs instead
     */
    export type EnquiryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EnquiryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactDefaultArgs instead
     */
    export type ContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeadDefaultArgs instead
     */
    export type LeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDefaultArgs instead
     */
    export type ProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompletedProjectDefaultArgs instead
     */
    export type CompletedProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompletedProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivityDefaultArgs instead
     */
    export type ActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskDefaultArgs instead
     */
    export type TaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AppointmentDefaultArgs instead
     */
    export type AppointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppointmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentDefaultArgs instead
     */
    export type DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SnagDefaultArgs instead
     */
    export type SnagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SnagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventLogDefaultArgs instead
     */
    export type EventLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowDefinitionDefaultArgs instead
     */
    export type WorkflowDefinitionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowDefinitionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowStepDefaultArgs instead
     */
    export type WorkflowStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowStepDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowStepApproverDefaultArgs instead
     */
    export type WorkflowStepApproverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowStepApproverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowInstanceDefaultArgs instead
     */
    export type WorkflowInstanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowInstanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowStepExecutionDefaultArgs instead
     */
    export type WorkflowStepExecutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowStepExecutionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowApprovalDefaultArgs instead
     */
    export type WorkflowApprovalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowApprovalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowTemplateDefaultArgs instead
     */
    export type WorkflowTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AutomationRuleDefaultArgs instead
     */
    export type AutomationRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AutomationRuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AutomationExecutionDefaultArgs instead
     */
    export type AutomationExecutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AutomationExecutionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestPlanDefaultArgs instead
     */
    export type TestPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestCaseDefaultArgs instead
     */
    export type TestCaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestCaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestExecutionDefaultArgs instead
     */
    export type TestExecutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestExecutionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DefectDefaultArgs instead
     */
    export type DefectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DefectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DefectTestCaseDefaultArgs instead
     */
    export type DefectTestCaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DefectTestCaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DefectCommentDefaultArgs instead
     */
    export type DefectCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DefectCommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QAReviewDefaultArgs instead
     */
    export type QAReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QAReviewDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}